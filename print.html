<!DOCTYPE HTML>
<html lang="cs" class="sidebar-visible no-js rust">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Úvod do programování</title>
        
        <meta name="robots" content="noindex" />
        
        


        <!-- Custom HTML head -->
        <style>
.xterm {
  margin-top: 10px;
}
.content {
  overflow-y: visible !important;
}
video {
    max-width: 100%;
}
</style>


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="favicon.svg">
        
        
        <link rel="shortcut icon" href="favicon.png">
        
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        
        <link rel="stylesheet" href="theme/css/tufte.css">
        
        <link rel="stylesheet" href="theme/asciinema-player.css">
        
        <link rel="stylesheet" href="src/wasm/xterm.min.css">
        

        
        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "rust" : "rust";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('rust')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item "><a href="uvod/uvod.html"><strong aria-hidden="true">1.</strong> Úvod</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="uvod/programovani.html"><strong aria-hidden="true">1.1.</strong> Programování</a></li><li class="chapter-item "><a href="uvod/programovaci_jazyky.html"><strong aria-hidden="true">1.2.</strong> Programovací jazyky</a></li><li class="chapter-item "><a href="uvod/jazyk_c.html"><strong aria-hidden="true">1.3.</strong> Jazyk C</a></li><li class="chapter-item "><a href="uvod/pamet.html"><strong aria-hidden="true">1.4.</strong> Paměť</a></li></ol></li><li class="chapter-item "><a href="prostredi/nastaveni_prostredi.html"><strong aria-hidden="true">2.</strong> Nastavení prostředí</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="prostredi/os/os.html"><strong aria-hidden="true">2.1.</strong> Operační systém</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="prostredi/os/linux.html"><strong aria-hidden="true">2.1.1.</strong> Linux</a></li><li class="chapter-item "><a href="prostredi/os/macos.html"><strong aria-hidden="true">2.1.2.</strong> macOS</a></li></ol></li><li class="chapter-item "><a href="prostredi/editor/editor.html"><strong aria-hidden="true">2.2.</strong> Editor</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="prostredi/editor/vscode.html"><strong aria-hidden="true">2.2.1.</strong> VS Code</a></li><li class="chapter-item "><a href="prostredi/editor/clion.html"><strong aria-hidden="true">2.2.2.</strong> CLion</a></li></ol></li><li class="chapter-item "><a href="prostredi/preklad_programu.html"><strong aria-hidden="true">2.3.</strong> Překlad</a></li><li class="chapter-item "><a href="prostredi/ladeni.html"><strong aria-hidden="true">2.4.</strong> Ladění</a></li></ol></li><li class="chapter-item "><a href="ai.html"><strong aria-hidden="true">3.</strong> Použití AI</a></li><li class="chapter-item "><a href="c/programovani.html"><strong aria-hidden="true">4.</strong> Programování v C</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="c/syntaxe.html"><strong aria-hidden="true">4.1.</strong> Syntaxe</a></li><li class="chapter-item "><a href="c/prikazy_vyrazy.html"><strong aria-hidden="true">4.2.</strong> Příkazy a výrazy</a></li><li class="chapter-item "><a href="c/promenne/promenne.html"><strong aria-hidden="true">4.3.</strong> Proměnné</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="c/promenne/globalni_promenne.html"><strong aria-hidden="true">4.3.1.</strong> Globální proměnné</a></li><li class="chapter-item "><a href="c/promenne/konstanty.html"><strong aria-hidden="true">4.3.2.</strong> Konstanty</a></li><li class="chapter-item "><a href="c/promenne/slozeny_zapis.html"><strong aria-hidden="true">4.3.3.</strong> Složený zápis</a></li><li class="chapter-item "><a href="c/promenne/pojmenovavani.html"><strong aria-hidden="true">4.3.4.</strong> Pojmenovávání proměnných</a></li></ol></li><li class="chapter-item "><a href="c/datove_typy/datove_typy.html"><strong aria-hidden="true">4.4.</strong> Datové typy</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="c/datove_typy/celociselne_typy.html"><strong aria-hidden="true">4.4.1.</strong> Celočíselné typy</a></li><li class="chapter-item "><a href="c/datove_typy/desetinne_typy.html"><strong aria-hidden="true">4.4.2.</strong> Desetinné číselné typy</a></li><li class="chapter-item "><a href="c/datove_typy/pravdivostni_typy.html"><strong aria-hidden="true">4.4.3.</strong> Pravdivostní typy</a></li><li class="chapter-item "><a href="c/datove_typy/konverze.html"><strong aria-hidden="true">4.4.4.</strong> Konverze</a></li></ol></li><li class="chapter-item "><a href="c/rizeni_toku/rizeni_toku.html"><strong aria-hidden="true">4.5.</strong> Řízení toku</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="c/rizeni_toku/podminky.html"><strong aria-hidden="true">4.5.1.</strong> Podmínky</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="c/rizeni_toku/if.html"><strong aria-hidden="true">4.5.1.1.</strong> Příkaz if</a></li><li class="chapter-item "><a href="c/rizeni_toku/switch.html"><strong aria-hidden="true">4.5.1.2.</strong> Příkaz switch</a></li><li class="chapter-item "><a href="c/rizeni_toku/ternarni_operator.html"><strong aria-hidden="true">4.5.1.3.</strong> Ternární operátor</a></li></ol></li><li class="chapter-item "><a href="c/rizeni_toku/cykly.html"><strong aria-hidden="true">4.5.2.</strong> Cykly</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="c/rizeni_toku/while.html"><strong aria-hidden="true">4.5.2.1.</strong> Cyklus while</a></li><li class="chapter-item "><a href="c/rizeni_toku/for.html"><strong aria-hidden="true">4.5.2.2.</strong> Cyklus for</a></li></ol></li></ol></li><li class="chapter-item "><a href="c/funkce/funkce.html"><strong aria-hidden="true">4.6.</strong> Funkce</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="c/funkce/rekurze.html"><strong aria-hidden="true">4.6.1.</strong> Rekurze</a></li><li class="chapter-item "><a href="c/funkce/stdlib.html"><strong aria-hidden="true">4.6.2.</strong> Funkce standardní knihovny</a></li></ol></li><li class="chapter-item "><a href="c/preprocesor/preprocesor.html"><strong aria-hidden="true">4.7.</strong> Preprocesor</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="c/preprocesor/vkladani_souboru.html"><strong aria-hidden="true">4.7.1.</strong> Vkládání souborů</a></li><li class="chapter-item "><a href="c/preprocesor/makra.html"><strong aria-hidden="true">4.7.2.</strong> Makra</a></li></ol></li><li class="chapter-item "><a href="c/prace_s_pameti/prace_s_pameti.html"><strong aria-hidden="true">4.8.</strong> Práce s pamětí</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="c/prace_s_pameti/automaticka_pamet.html"><strong aria-hidden="true">4.8.1.</strong> Automatická paměť</a></li><li class="chapter-item "><a href="c/prace_s_pameti/ukazatele.html"><strong aria-hidden="true">4.8.2.</strong> Ukazatele</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="c/prace_s_pameti/ukazatele_na_funkce.html"><strong aria-hidden="true">4.8.2.1.</strong> Ukazatele na funkce</a></li></ol></li><li class="chapter-item "><a href="c/prace_s_pameti/dynamicka_pamet.html"><strong aria-hidden="true">4.8.3.</strong> Dynamická paměť</a></li><li class="chapter-item "><a href="c/prace_s_pameti/globalni_pamet.html"><strong aria-hidden="true">4.8.4.</strong> Globální paměť</a></li></ol></li><li class="chapter-item "><a href="c/pole/pole.html"><strong aria-hidden="true">4.9.</strong> Pole</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="c/pole/staticka_pole.html"><strong aria-hidden="true">4.9.1.</strong> Statické pole</a></li><li class="chapter-item "><a href="c/pole/dynamicka_pole.html"><strong aria-hidden="true">4.9.2.</strong> Dynamické pole</a></li><li class="chapter-item "><a href="c/pole/vicerozmerna_pole.html"><strong aria-hidden="true">4.9.3.</strong> Vícerozměrné pole</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="c/pole/zubata_pole.html"><strong aria-hidden="true">4.9.3.1.</strong> Zubatá pole</a></li></ol></li></ol></li><li class="chapter-item "><a href="c/text/text.html"><strong aria-hidden="true">4.10.</strong> Text</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="c/text/znaky.html"><strong aria-hidden="true">4.10.1.</strong> Znaky</a></li><li class="chapter-item "><a href="c/text/retezce.html"><strong aria-hidden="true">4.10.2.</strong> Řetězce</a></li><li class="chapter-item "><a href="c/text/vstupavystup.html"><strong aria-hidden="true">4.10.3.</strong> Vstup a výstup</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="c/text/vstup.html"><strong aria-hidden="true">4.10.3.1.</strong> Vstup</a></li><li class="chapter-item "><a href="c/text/vystup.html"><strong aria-hidden="true">4.10.3.2.</strong> Výstup</a></li></ol></li></ol></li><li class="chapter-item "><a href="c/struktury/vlastni_datove_typy.html"><strong aria-hidden="true">4.11.</strong> Vlastní datové typy</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="c/struktury/struktury.html"><strong aria-hidden="true">4.11.1.</strong> Struktury</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="c/struktury/pametova_reprezentace.html"><strong aria-hidden="true">4.11.1.1.</strong> Reprezentace v paměti</a></li></ol></li><li class="chapter-item "><a href="c/struktury/struktury_funkce.html"><strong aria-hidden="true">4.11.2.</strong> Struktury a funkce</a></li></ol></li><li class="chapter-item "><a href="c/soubory/soubory.html"><strong aria-hidden="true">4.12.</strong> Soubory</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="c/soubory/otevirani_souboru.html"><strong aria-hidden="true">4.12.1.</strong> Otevření souborů</a></li><li class="chapter-item "><a href="c/soubory/prace_se_soubory.html"><strong aria-hidden="true">4.12.2.</strong> Práce se soubory</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="c/soubory/zapis_do_souboru.html"><strong aria-hidden="true">4.12.2.1.</strong> Zápis do souboru</a></li><li class="chapter-item "><a href="c/soubory/cteni_ze_souboru.html"><strong aria-hidden="true">4.12.2.2.</strong> Čtení ze souboru</a></li></ol></li></ol></li><li class="chapter-item "><a href="c/modularizace/modularizace.html"><strong aria-hidden="true">4.13.</strong> Modularizace</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="c/modularizace/linker.html"><strong aria-hidden="true">4.13.1.</strong> Linker</a></li><li class="chapter-item "><a href="c/modularizace/pouzivani_kodu_z_jinych_souboru.html"><strong aria-hidden="true">4.13.2.</strong> Používání kódu z jiných souborů</a></li><li class="chapter-item "><a href="c/modularizace/hlavickove_soubory.html"><strong aria-hidden="true">4.13.3.</strong> Hlavičkové soubory</a></li><li class="chapter-item "><a href="c/modularizace/knihovny.html"><strong aria-hidden="true">4.13.4.</strong> Knihovny</a></li></ol></li><li class="chapter-item "><a href="c/automatizace_prekladu.html"><strong aria-hidden="true">4.14.</strong> Automatizace překladu</a></li><li class="chapter-item "><a href="c/aplikovane_ulohy/ulohy.html"><strong aria-hidden="true">4.15.</strong> Aplikované úlohy</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="c/aplikovane_ulohy/tga.html"><strong aria-hidden="true">4.15.1.</strong> TGA</a></li><li class="chapter-item "><a href="c/aplikovane_ulohy/gif.html"><strong aria-hidden="true">4.15.2.</strong> GIF</a></li><li class="chapter-item "><a href="c/aplikovane_ulohy/sdl.html"><strong aria-hidden="true">4.15.3.</strong> SDL</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="c/aplikovane_ulohy/sdl/herni_smycka.html"><strong aria-hidden="true">4.15.3.1.</strong> Herní smyčka</a></li><li class="chapter-item "><a href="c/aplikovane_ulohy/sdl/kresleni.html"><strong aria-hidden="true">4.15.3.2.</strong> Kreslení</a></li><li class="chapter-item "><a href="c/aplikovane_ulohy/sdl/vstup.html"><strong aria-hidden="true">4.15.3.3.</strong> Vstup</a></li></ol></li><li class="chapter-item "><a href="c/aplikovane_ulohy/chipmunk.html"><strong aria-hidden="true">4.15.4.</strong> Chipmunk</a></li></ol></li><li class="chapter-item "><a href="c/co_dal.html"><strong aria-hidden="true">4.16.</strong> Co dál?</a></li></ol></li><li class="chapter-item "><a href="ruzne/ruzne.html"><strong aria-hidden="true">5.</strong> Různé</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="ruzne/rozklad_problemu.html"><strong aria-hidden="true">5.1.</strong> Rozklad problému</a></li><li class="chapter-item "><a href="ruzne/vyhodnocovani_vyrazu.html"><strong aria-hidden="true">5.2.</strong> Vyhodnocování výrazů</a></li><li class="chapter-item "><a href="ruzne/nahodna_cisla.html"><strong aria-hidden="true">5.3.</strong> Generování náhodných čísel</a></li><li class="chapter-item "><a href="ruzne/dynamicky_rostouci_pole.html"><strong aria-hidden="true">5.4.</strong> Dynamicky rostoucí pole</a></li><li class="chapter-item "><a href="ruzne/funkce_main.html"><strong aria-hidden="true">5.5.</strong> Funkce main</a></li><li class="chapter-item "><a href="ruzne/parametry_prekladace.html"><strong aria-hidden="true">5.6.</strong> Parametry překladače</a></li><li class="chapter-item "><a href="ruzne/nedefinovane_chovani.html"><strong aria-hidden="true">5.7.</strong> Nedefinované chování</a></li><li class="chapter-item "><a href="ruzne/tahak.html"><strong aria-hidden="true">5.8.</strong> Tahák</a></li></ol></li><li class="chapter-item "><a href="ulohy/ulohy.html"><strong aria-hidden="true">6.</strong> Úlohy</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="ulohy/promenne.html"><strong aria-hidden="true">6.1.</strong> Proměnné</a></li><li class="chapter-item "><a href="ulohy/podminky_a_cykly.html"><strong aria-hidden="true">6.2.</strong> Podmínky a cykly</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="ulohy/kulicka.html"><strong aria-hidden="true">6.2.1.</strong> Odrážející se kulička</a></li><li class="chapter-item "><a href="ulohy/grafy.html"><strong aria-hidden="true">6.2.2.</strong> Vykreslování grafů funkcí</a></li></ol></li><li class="chapter-item "><a href="ulohy/funkce.html"><strong aria-hidden="true">6.3.</strong> Funkce</a></li><li class="chapter-item "><a href="ulohy/ukazatele.html"><strong aria-hidden="true">6.4.</strong> Ukazatele</a></li><li class="chapter-item "><a href="ulohy/pole.html"><strong aria-hidden="true">6.5.</strong> Pole</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="ulohy/pvp.html"><strong aria-hidden="true">6.5.1.</strong> PvP bitevní hra</a></li><li class="chapter-item "><a href="ulohy/dvourozmerne_pole.html"><strong aria-hidden="true">6.5.2.</strong> Dvourozměrné pole</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="ulohy/digitalni_hodiny.html"><strong aria-hidden="true">6.5.2.1.</strong> Digitální hodiny</a></li></ol></li></ol></li><li class="chapter-item "><a href="ulohy/text.html"><strong aria-hidden="true">6.6.</strong> Text</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="ulohy/kalkulacka.html"><strong aria-hidden="true">6.6.1.</strong> Kalkulačka</a></li><li class="chapter-item "><a href="ulohy/strelba_na_terc.html"><strong aria-hidden="true">6.6.2.</strong> Střelba na terč</a></li><li class="chapter-item "><a href="ulohy/cisteni_chatu.html"><strong aria-hidden="true">6.6.3.</strong> Čištění chatu</a></li><li class="chapter-item "><a href="ulohy/brainfuck.html"><strong aria-hidden="true">6.6.4.</strong> Překladač jazyka Brainfuck</a></li></ol></li><li class="chapter-item "><a href="ulohy/struktury.html"><strong aria-hidden="true">6.7.</strong> Struktury</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="ulohy/tga_watch.html"><strong aria-hidden="true">6.7.1.</strong> TGA hodiny</a></li><li class="chapter-item "><a href="ulohy/letters.html"><strong aria-hidden="true">6.7.2.</strong> Létající písmenka</a></li></ol></li><li class="chapter-item "><a href="ulohy/soubory.html"><strong aria-hidden="true">6.8.</strong> Soubory</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="ulohy/meme.html"><strong aria-hidden="true">6.8.1.</strong> Meme generátor</a></li></ol></li><li class="chapter-item "><a href="ulohy/sdl.html"><strong aria-hidden="true">6.9.</strong> SDL</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="ulohy/snake/snake.html"><strong aria-hidden="true">6.9.1.</strong> Had</a></li></ol></li></ol></li><li class="chapter-item "><a href="caste_chyby/caste_chyby.html"><strong aria-hidden="true">7.</strong> Časté chyby</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="caste_chyby/pametove_chyby.html"><strong aria-hidden="true">7.1.</strong> Paměťové chyby</a></li></ol></li><li class="chapter-item "><a href="galerie_projektu/galerie_projektu.html"><strong aria-hidden="true">8.</strong> Galerie projektů</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="galerie_projektu/2020.html"><strong aria-hidden="true">8.1.</strong> 2020/2021</a></li><li class="chapter-item "><a href="galerie_projektu/2023.html"><strong aria-hidden="true">8.2.</strong> 2023/2024</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">Úvod do programování</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        <a href="https://github.com/mrlvsb/upr-skripta" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#Úvod" id="Úvod">Úvod</a></h1>
<p>Tento text vznikl pro potřeby výuky předmětu <a href="https://github.com/geordi/upr-course">Úvod do programování</a> na FEI VŠB-TUO.
Slouží k získání přehledu o základních konceptech programovacího jazyka C.
Není však plnohodnotnou náhradou za poslechy přednášek a návštěvy cvičení a programovat vás (stejně
jako žádný jiný text) nenaučí, toho lze dosáhnout pouze opakovaným zkoušením a řešením různých úloh.
Studentům tedy silně doporučujeme, aby přednášky a cvičení navštěvovali a hlavně aby se věnovali programování
doma, alespoň hodinu denně.</p>
<p>V tomto textu naleznete stručný úvod o programování, překladu a ladění programů, nastavení prostředí
k editaci zdrojového kódu, a zejména popis základních konstrukcí jazyka <em>C</em> (proměnné, podmínky,
cykly, funkce, ukazatele, pole, řetězce, struktury atd.) spolu se sadou úloh k procvičení jednotlivých
témat. Pomocí ikony <i class="fa fa-search"></i> vlevo nahoře můžete v textu rychle vyhledávat, pokud
potřebujete najít informace o konkrétním tématu.</p>
<p>Několik poznámek k textu:</p>
<ul>
<li>Tento text neslouží jako kompletní průvodce jazyka C. Pro takovýto účel lze doporučit některý
knižní titul, např. Učebnice jazyka <em>C</em> od Pavla Herouta nebo přímo standard jazyka <a href="http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1256.pdf">C99</a>.</li>
<li>Jelikož je předmět UPR zaměřen na vývoj v operačním systému Linux, tak ukázky kódu a příkazů v terminálu
předpokládají použití tohoto operačního systému (konkrétně distribuce <code>Ubuntu</code>).</li>
<li>Tento text je psán česky, nicméně primárním jazykem programování (celosvětově) je angličtina. Přeložené pojmy,
které mají zavedené anglické názvy, budou v tomto textu uvedeny v závorce <em>kurzívou</em>.</li>
<li>V tomto textu naleznete různé ukázky <em>C</em> kódu. Některé z nich můžete sami upravovat a dokonce
i spustit rovnou v prohlížeči pomocí ikony <i class="fa fa-play"></i> v pravém horním rohu kódu.
Ukázky budou pro zjednodušení používat názvy v češtině, nicméně jakmile už nebudete v
programování úplní nováčci, silně vám doporučujeme psát zdrojové kódy v angličtině.</li>
<li>Pokud v textu naleznete gramatickou či faktickou chybu nebo budete mít jakoukoliv zpětnou vazbu
k obsahu či formě textu, dejte nám prosím vědět na <a href="mailto:jakub.beranek@vsb.cz?subject=UPR%20skripta%20-%20chyba">tento e-mail</a>
nebo vytvořte issue na <a href="https://github.com/mrlvsb/upr-skripta/issues/new">GitHubu</a>.</li>
</ul>
<p>Autory textu jsou <a href="https://github.com/geordi">Jan Gaura</a>, <a href="https://github.com/trnila">Dan Trnka</a> a
<a href="https://github.com/kobzol">Kuba Beránek</a>.</p>
<p><em>Historii změn</em> tohoto studijního textu můžete naleznout v jeho
<a href="https://github.com/mrlvsb/upr-skripta/commits/master">GitHub repozitáři</a>.</p>
<h1><a class="header" href="#programování" id="programování">Programování</a></h1>
<p>Programování je proces tvorby programu, tj. sady příkazů pro počítač, který slouží k vyřešení
nějakého konkrétního <strong>problému</strong>. Problémem se zde myslí nějaká úloha, kterou chceme vyřešit.
Takovéto úlohy obsahují nějaký (počítačem zpracovatelný) vstup, například:</p>
<ul>
<li>pohyb myši</li>
<li>stisk klávesy</li>
<li>zvuk z mikrofonu</li>
<li>textový soubor na disku</li>
</ul>
<p>a k nim určený výstup, například:</p>
<ul>
<li>vykreslení obrazce či textu na monitoru</li>
<li>zapsání dat do souboru na disku</li>
<li>odeslání informací přes síť</li>
</ul>
<p>Aby počítačový program korektně řešil nějakou úlohu, tak musí na všechny validní vstupy vrátit
správný výstup. Pokud vstup neodpovídá zadání, tak by měl program vrátit rozumnou chybovou hlášku.
Postup pro řešení nějaké úlohy daný jasně definovanými kroky se nazývá <strong>algoritmus</strong>. Zápisu
(algoritmu) v nějakém konkrétním programovacím jazyce se pak říká <strong>implementace</strong> (algoritmu).</p>
<p>Zde je příklad úloh, které se během semestru naučíte řešit pomocí jazyka <em>C</em>:</p>
<ul>
<li>Spočítej průměr seznamu čísel</li>
<li>Načti údaje o uživateli ze souboru a vypiš je v podobě tabulky</li>
<li>Načti obrázek z disku, změň jeho velikost a ulož ho do jiného souboru</li>
<li>Vytvoř animaci ze sady obrázků na disku</li>
</ul>
<p>Řešením podobných úloh si osvojíte základy programování a budete poté moct řešit zajímavější úlohy,
jako je například tvorba počítačové hry nebo aplikace komunikující přes internet.</p>
<h1><a class="header" href="#programovací-jazyky" id="programovací-jazyky">Programovací jazyky</a></h1>
<p>Z pohledu počítače je program sekvence příkazů (nazývaných <strong>instrukce</strong>), které může počítač
vykonat k vyřešení nějakého problému. Abychom mohli počítači říct, co má vykonávat, potřebujeme mu
příkazy zadat ve formě, které bude rozumět. Ač se to možná nezdá, tak počítače umí vykonávat pouze
velmi jednoduché příkazy. V podstatě umí pouze provádět aritmetické a logické operace (sčítání,
odčítání, násobení) s čísly a manipulovat (číst, zapisovat, přesouvat) s těmito čísly v paměti.</p>
<p>Veškeré složitější úkoly, jako třeba vykreslení obrázku na obrazovku, zapsání textu do dokumentu
nebo simulace světa v počítačové hře je výsledkem kombinací tisíců či milionů takovýchto
jednoduchých instrukcí.</p>
<p>Zde je ukázka jednoduchého programu, který zdvojnásobí číslo <code>8</code> pomocí příkazů <code>MOV</code> a <code>ADD</code>:</p>
<pre><code class="language-x86asm">MOV EAX, 8
ADD EAX, EAX
</code></pre>
<p>Pokud bychom programy psali pouze pomocí těchto jednoduchých příkazů<sup class='margin-toggle sidenote-number'>1</sup>, tak by bylo složité se v
nich vyznat, obzvláště, pokud by obsahovaly stovky, tisíce nebo dokonce miliony takovýchto příkazů.
Ideálně bychom chtěli programy zapisovat v přirozeném jazyce (<code>Vykresli čtverec na obrazovku</code>,
<code>Zapiš text do dokumentu</code>), nicméně tomu počítače nerozumí a je velmi náročné jej převést na
správnou sekvenci příkazů pro počítač, protože jazyky, které používáme, jsou často nejednoznačné a
nemají jednotnou strukturu.</p>
<span class='sidenote'><p><sup class='number'>1</sup>Vyzkoušíte si to v navazujícím předmětu <a href="https://poli.cs.vsb.cz/edu/apps/">Architektury počítačů a paralelních systémů</a>.</p>
</span>
<p>Jako kompromis tak vznikly <strong>programovací jazyky</strong>, které umožňují zápis programů ve formě, která
je lidem srozumitelná, ale zároveň ji lze relativně jednoduše převést na příkazy, které je schopen
počítač provést. Převodu programu zapsaného v programovacím jazyce na počítačové instrukce se
říká <strong>překlad</strong>
(<em>compilation</em>) a programy, které tento překlad provádějí, se nazývají <strong>překladače</strong> (<em>compilers</em>)
. Později si ukážeme, jak takovýto překladač použít k překladu kódu.</p>
<p>Zde je ukázka části programu v jazyce <em>C</em>:</p>
<pre><code class="language-c">while (je_tlacitko_zmacknuto(MEZERNIK)) {
    posun_nahoru(postava);
}
</code></pre>
<p>I někdo, kdo se s jazykem <em>C</em> nikdy nesetkal, může z tohoto kusu kódu zhruba odvodit, co asi dělá,
pokud ho přečte jako větu. Tento program však může být převeden na stovky až tisíce počítačových
instrukcí a z takového množství příkazů už by bylo složité odvodit, k čemu je program určen.</p>
<h1><a class="header" href="#jazyk-c" id="jazyk-c">Jazyk <em>C</em></a></h1>
<p>Existuje nespočet programovacích jazyků, například Python, Java, C#, PHP, Rust či JavaScript. Každý
z nich má své výhody a nevýhody a záleží na konkrétním problému, který je třeba vyřešit, pro
zvolení vhodného programovacího jazyka.</p>
<p>V tomto kurzu se budeme zabývat pouze programovacím jazykem <strong>C</strong>. Tento jazyk vytvořili Dennis
Ritchie a Ken Thompson v laboratořích firmy Bell v roce 1972, tedy před více než 50 lety, a za tu
dobu se nedočkal mnoha výrazných změn.</p>
<p>I když pro něj v dnešní době asi nenaleznete tolik pracovních nabídek (jako třeba pro JavaScript),
a není primární volbou pro tvorbu webových či mobilních aplikací, vyplatí se mu rozumět a umět ho
používat, a to hned z několika důvodů:</p>
<ul>
<li>Jazyk <em>C</em> lze použít na téměř všech existujících platformách a je tak velmi univerzálním jazykem.
Téměř veškerý existující software obsahuje kusy kódu v jazyce <em>C</em>. Operační systémy (Linux,
macOS, Windows, Android, iOS), prohlížeče (Chrome, Firefox, Edge), multimediální programy
(Photoshop, PowerPoint, Word, BitTorrent), hry (World of Warcraft, Quake, Doom, Call of Duty,
League of Legends, DOTA 2, Fortnite), vestavěná zařízení (mikročipy, pračky, řídící jednotky
vesmírných letadel nebo aut). Všechny tyto věci jsou buď částečně anebo zcela poháněny jazykem
<em>C</em>.</li>
<li>Je to relativně jednoduchý jazyk, který neobsahuje velké množství funkcí, které lze naleznout
ve většině modernějších jazyků. Díky tomu se dají jeho základy naučit za jeden semestr.</li>
<li>Jeho úroveň abstrakce není o mnoho výše než základní počítačové instrukce. Při výuce <em>C</em> tak lze
zároveň pochopit, jak funguje počítač a operační systém. Díky tomu lze také při správném
zacházení psát velmi efektivní programy (to ale nicméně není obsahem tohoto kurzu). Pochopení toho,
jak věci &quot;na pozadí počítače&quot; fungují, je jednou z přidanou hodnot studia jazyka C.</li>
<li><strong>Syntaxe</strong> (způsob zápisu) jazyka <em>C</em> ovlivnila velké množství jazyků, které vznikly po něm.
Jakmile se ji naučíte, tak budete schopni rozumět syntaxi většiny současných nejpoužívanějších
jazyků (C++, C#, Java, Kotlin, JavaScript, PHP, Rust, …).</li>
</ul>
<p>Jazyk <em>C</em> má samozřejmě také řadu nevýhod. Vzhledem k jeho stáří a omezené sadě funkcionalit je
často značně pracnější a zdlouhavější pomocí něj dosáhnout stejného výsledku než u modernějších
programovacích jazyků. Nevede také programátory za ručičku – při psaní programu v jazyce <em>C</em> je
velmi jednoduché udělat chybu, která může způsobit (v lepším případě) pád programu nebo
(v horším případě) může běžící program poškodit tak, že začne vydávat chybný výstup nebo se začne
chovat zcela nepředvídatelně.  Tyto chyby se můžou projevit jen někdy, nebo jenom na určité kombinaci
hardwaru či operačního systému, a programátor na ně není často nijak upozorněn a musí je najít ručně
zkoumáním zdrojového kódu. Podobný typ chyb je také nejčastějším zdrojem bezpečnostních děr ve všech
možných softwarech, které (jak už víme) téměř vždy obsahují alespoň část kódu napsaného v &quot;Céčku&quot;.</p>
<blockquote>
<p>Tím, že jazyk <em>C</em> existuje přes 50 let, je v něm spousta pravidel, které nemusí dávat smysl nebo
nejdou odvodit a pokud je neznáte, váš program nemusí správně fungovat. Při práci s tímto jazykem
se tak zkuste obrnit trpělivostí. Budete ji potřebovat 🙂.</p>
</blockquote>
<p>Pokud byste se chtěli podívat, jak můžou vypadat velké programy napsané v jazyce <em>C</em>, zde je
seznam několika vybraných populárních programů, které jsou v něm napsané. Tyto programy jsou tzv. <strong>open-source</strong><sup class='margin-toggle sidenote-number'>2</sup>,
takže si jejich zdrojový kód můžete prohlédnout a v případě potřeby i modifikovat:</p>
<span class='sidenote'><p><sup class='number'>2</sup>Jejich zdrojový kód je volně k dispozici a je sdílený na internetu.</p>
</span>
<ul>
<li><a href="https://github.com/torvalds/linux">Linux</a> (operační systém)</li>
<li><a href="https://github.com/id-Software/Quake-III-Arena">Quake III</a> (počítačová hra)</li>
<li><a href="https://github.com/git/git">git</a> (verzovací systém)</li>
<li><a href="https://github.com/php/php-src">PHP</a> (překladač/interpret jazyka PHP)</li>
<li><a href="https://github.com/obsproject/obs-studio">OBS Studio</a> (streamovací software)</li>
</ul>
<h1><a class="header" href="#paměť" id="paměť">Paměť</a></h1>
<p>Počítače si potřebují ukládat výsledky výpočtů do paměti, aby je později mohly opět načíst a
pracovat s nimi. Je mnoho typů paměti, s kterými lze pracovat, nejběžněji se setkáme s tzv.
operační pamětí (<strong>RAM</strong>). RAM znamená Random-Access Memory, tedy paměť s náhodným přístupem. To
znamená, že počítač může do paměti šahat v libovolném pořadí a na libovolném místě, kde je to
potřeba.</p>
<h3><a class="header" href="#reprezentace-hodnot-v-paměti" id="reprezentace-hodnot-v-paměti">Reprezentace hodnot v paměti</a></h3>
<p>Počítačová paměť uchovává informace v buňkách, které obsahují jedno číslo, které může obsahovat 256
různých hodnot. To vychází z toho, že informace je reprezentována <strong>bity</strong>, jednotkou informací,
která může nabývat pouze dvě hodnoty - pravda (<em>true</em>) nebo nepravda (<em>false</em>). Každá buňka paměti
obsahuje jeden <strong>byte</strong>, neboli 8 bitů.</p>
<p>Pracuje se zde s dvojkovou (binární) soustavou, pokud tedy máme k dispozici <em>n</em> bitů, tak pomocí
nich můžeme reprezentovat \( 2^n \) hodnot. Např. s dvěma bity můžeme reprezentovat 4 různé
hodnoty (00, 01, 10, 11), a s 8 bity (jedním bytem) můžeme reprezentovat právě 256 hodnot. Více o binární
soustavě a bytech se dozvíte v předmětu
<a href="https://edison.sso.vsb.cz/cz.vsb.edison.edu.study.prepare.web/SubjectVersion.faces?version=440-2104/01&amp;subjectBlockAssignmentId=375761&amp;studyFormId=2&amp;studyPlanId=22001&amp;locale=cs&amp;back=true">Základy digitálních systémů (ZDS)</a>.</p>
<p>I když paměť vždy obsahuje hodnoty (čísla) v dvojkové soustavě, je důležité si uvědomit, že význam
těmto hodnotám přiřazujeme my, tedy programátoři a uživatelé počítače. Pokud je v paměti hodnota <strong>65</strong>,
tak může reprezentovat například:</p>
<ul>
<li>počet získaných bodů studenta (interpretujeme ji jako číslo)</li>
<li>písmeno <code>A</code> v nějakém dokumentu (interpretujeme ji jako znak v
kódování <a href="https://www.asciitable.com/">ASCII</a>)</li>
<li>tmavě šedý pixel (interpretujeme ji jako barvu)</li>
</ul>
<p>I v případě, že hodnoty v paměti interpretujeme přímo jako čísla, tak reprezentované číslo nemusí
přímo odpovídat číselné hodnotě v paměti. Například hodnotu <strong>255</strong> uloženou v <em>bytu</em> paměti můžeme
vnímat jako celé nezáporné číslo (<em>unsigned integer</em>) <strong>255</strong>, anebo také jako celé číslo se
znaménkem (<em>signed integer</em>) <strong>-1</strong>
v <a href="https://cs.wikipedia.org/wiki/Dvojkov%C3%BD_dopln%C4%9Bk">dvojkovém doplňku</a>.<sup class='margin-toggle sidenote-number'>1</sup></p>
<span class='sidenote'><p><sup class='number'>1</sup>Můžeme si ale klidně vymyslet i reprezentaci, kde hodnota <code>255</code> v paměti bude reprezentovat
číslo <code>42</code>. Nebo třeba emoji 😈. Záleží jen na nás.</p>
</span>
<p><strong>Čísla v paměti tak sama o sobě nemají žádný význam, záleží pouze na tom, jak je my, a obzvláště naše
programy, interpretují a jaké operace nad nimi provádějí.</strong></p>
<h3><a class="header" href="#adresování-paměti" id="adresování-paměti">Adresování paměti</a></h3>
<p>Abychom se mohli odkazovat na hodnoty v paměti, tak musíme mít možnost rozlišit jednotlivé buňky od
sebe. Toho dosáhneme pomocí <strong>adresy</strong>. Paměť je adresována tak, že každá paměťová buňka (každý <em>byte</em>)
má číselnou adresu od 0 do velikosti paměti (nevčetně). Velmi zjednodušeně řečeno, pokud máte RAM
paměť o velikosti 8 GiB (8 589 934 592 &quot;bajtů&quot;), tak můžete adresovat buňky od 0 do 8589934591<sup class='margin-toggle sidenote-number'>2</sup>.</p>
<span class='sidenote'><p><sup class='number'>2</sup>Programy běžně nemají přístup k celé paměti počítače (mimo jiné z bezpečnostních důvodů). Váš
operační systém používá tzv. <strong>virtuální paměť</strong>, která každému běžícímu programu přiděluje určité
rozsahy paměti, s kterými může pracovat. Více se dozvíte v předmětu
<a href="http://poli.cs.vsb.cz/edu/osy/">Operační systémy</a>.</p>
</span>
<p>Pokud byste programovali počítač přímo pomocí instrukcí, tak mu můžete dát například instrukci
<code>Nastav byte na adrese 58 na hodnotu 5</code> nebo <code>Přečti 4 byty začínající na adrese 1028</code>. Při
programování v <em>C</em> ovšem často budou adresy skryté na pozadí a bude se o ně starat překladač, my se
budeme na konkrétní úsek paměti obvykle odkazovat jménem, které mu přiřadíme.</p>
<h1><a class="header" href="#nastavení-prostředí" id="nastavení-prostředí">Nastavení prostředí</a></h1>
<p>Abyste mohli efektivně programovat v <em>C</em>, musíte si nainstalovat, nakonfigurovat a naučit se používat
sadu programů. V této kapitole naleznete stručný popis toho, jak si nastavit
<a href="prostredi/os/linux.html">operační systém Linux</a>, <a href="prostredi/editor/editor.html">textový editor</a>
k psaní programů, <a href="prostredi/preklad_programu.html">překladač</a> pro překlad z jazyka <em>C</em> do spustitelného souboru
a také jak <a href="prostredi/ladeni.html">řešit chyby</a> při psaní programů.</p>
<p>Pokud používáte WSL, tak jakmile budete mít vše potřebné nainstalované, projděte si návod níže.</p>
<h2><a class="header" href="#prvotní-nastavení-projektu-na-wsl" id="prvotní-nastavení-projektu-na-wsl">Prvotní nastavení projektu na WSL</a></h2>
<p>Pokud používáte WSL na Windows a nevíte si rady s tím,
jak přeložit a zprovoznit svůj první program, zkuste následovat návod uvedený níže. Tento návod předpokládá, že již máte
nainstalované <a href="prostredi/./os/linux.html#windows-subsystem-for-linux-doporu%C4%8Deno">WSL</a>, <a href="prostredi/editor/editor.html">editor</a> a <a href="prostredi/./preklad_programu.html">překladač</a>.</p>
<blockquote>
<p>Kroky 1, 3 a 4 budete dělat pokaždé, když budete chtít jít programovat.</p>
</blockquote>
<ol>
<li>
<p>Nejprve je potřeba spustit příkazovou řádku (tzv. terminál), který poběží pod Ubuntu/WSL. Dosáhnete toho tak, že z
nabídky Start spustíte program <code>Ubuntu</code>.</p>
<ul>
<li>
<p>Měl by se vám spustit terminál, jehož řádek s textem bude končit znakem <code>$</code> nebo <code>#</code>:</p>
<p><img src="prostredi/../static/img/terminal1.png" alt="" /></p>
</li>
<li>
<p>Pokud místo toho uvidíte terminál zakončený šipkou <code>&gt;</code>, tak jste ve Windows terminálu. To je špatně:</p>
<p><img src="prostredi/../static/img/terminal-windows.png" alt="" /></p>
</li>
</ul>
</li>
<li>
<p>Nyní je ideální si vytvořit nějakou složku, do které budete dávat své zdrojové kódy. Můžete ji nazvat např. <code>upr</code>.
Spusťte tedy v terminálu příkaz <code>mkdir upr</code>, který složku vytvoří.</p>
</li>
<li>
<p>Přepněte se v terminálu do právě vytvořené složky pomocí příkazu <code>cd upr</code>.</p>
</li>
<li>
<p>Spusťte editor VS Code v právě aktivní složce (<code>upr</code>) pomocí příkazu <code>code .</code></p>
<ul>
<li>Všimněte si tečky na konci příkazu!</li>
</ul>
</li>
<li>
<p>Nyní můžete vytvořit zdrojový soubor s příponou <code>.c</code>, například <code>main.c</code>. V liště vlevo nahoře ve VS Code klikněte na
<code>File -&gt; New File</code> a vytvořte soubor s názvem <code>main.c</code> v současné složce (<code>upr</code>).</p>
</li>
<li>
<p>Do souboru <code>main.c</code> vložte nějaký C kód, např:</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int main() {
    printf(&quot;Hello world\n&quot;);
    return 0;
}
</code></pre>
</li>
<li>
<p>Otevřete terminál ve VS Code (v liště nahoře <code>View -&gt; Terminal</code> nebo zkratka <code>Ctrl + J</code>).</p>
</li>
<li>
<p>Ověřte si, že jste ve složce <code>upr</code> (například pomocí příkaz <code>pwd</code>), a také že v této složce existuje soubor <code>main.c</code> (pomocí příkazu <code>ls</code>).</p>
</li>
<li>
<p>Přeložte tento soubor překladačem pomocí příkazu <code>gcc main.c -omain</code> v terminálu.</p>
</li>
<li>
<p>A finálně přeložený program spusťte pomocí příkazu <code>./main</code> v terminálu.</p>
</li>
</ol>
<h1><a class="header" href="#operační-systém" id="operační-systém">Operační systém</a></h1>
<p>Jak už bylo zmíněno v <a href="prostredi/os/../../uvod/uvod.html">úvodu</a>, v UPR budeme psát a spouštět programy v operačním
systém <a href="https://en.wikipedia.org/wiki/Linux">Linux</a>. Je tak nutné, abyste si na svém počítači
tento operační systém zprovoznili.</p>
<h2><a class="header" href="#proč-linux" id="proč-linux">Proč Linux?</a></h2>
<p>Linux je v současné době v oblasti IT téměř všude - používá ho většina webových serverů, cloudových
služeb, mobilních zařízení nebo třeba i superpočítačů. Umožňuje nám ovládat počítač jednoduše pomocí
textových příkazů v terminálu, díky čehož si můžeme zautomatizovat a ulehčit práci s počítačem, a
zároveň můžeme trochu nahlédnout pod pokličku toho, jak počítač funguje.</p>
<p>Pro používání jazyka <em>C</em> nám Linux umožňuje velmi jednoduše překládat programy právě z terminálu,
a díky tomu, že je <em>C</em> na Linuxu &quot;jako doma&quot;, tak nám to usnadní i další věci, např. používání knihoven
(kódu, který již pro nás naprogramoval někdo jiný). Ostatně i samotný Linux je napsán téměř výlučně
v jazyce <em>C</em> a samotný jazyk <em>C</em> vznikl před 50 lety pro tvorbu operačních systémů <code>Unix</code>, které
byly inspirací pro vznik Linuxu.</p>
<h2><a class="header" href="#co-si-mám-nainstalovat" id="co-si-mám-nainstalovat">Co si mám nainstalovat?</a></h2>
<ul>
<li>Pokud používáte operační systém Windows, tak si musíte Linux nainstalovat. Jako návod k tomu
slouží <a href="prostredi/os/linux.html">samostatná stránka</a>.</li>
<li>Pokud používáte operační systém macOS, tak teoreticky Linux instalovat nemusíte, stačí si nastavit
překladač GCC. Návod na nastavení systému macOS pro překlad C naleznete <a href="prostredi/os/macos.html">zde</a>.</li>
<li>Pokud již používáte operační systém Linux, nemusíte nic dalšího řešit a můžete přejít k
nastavení <a href="prostredi/os/../editor/editor.html">editoru</a>.</li>
</ul>
<blockquote>
<p><strong>Pokud při instalaci Linuxu narazíte na problémy, které se vám nepodaří vyřešit, konzultujte je
ihned s vaším cvičícím, který vám s instalací pomůže. Je nezbytné mít zprovozněný překladač GCC
a Linux (nebo macOS), abyste mohli řešit úlohy do UPR.</strong></p>
</blockquote>
<h2><a class="header" href="#základy-používání-příkazů-linuxuunixusup-classmargin-toggle-sidenote-number1sup" id="základy-používání-příkazů-linuxuunixusup-classmargin-toggle-sidenote-number1sup">Základy používání příkazů Linuxu/UNIXu<sup class='margin-toggle sidenote-number'>1</sup></a></h2>
<p>Linux se v zásadě používá velmi podobně jako operační systém Windows, nicméně narozdíl od Windows,
kde jste asi zvyklí ovládat počítač zejména myší, se v Linuxu běžně spousta úkonů provádí v tzv.
<strong>terminálu</strong>, neboli příkazové řádce (<em>command line</em>), kde ovládáte počítač pomocí textových příkazů.</p>
<span class='sidenote'><p><sup class='number'>1</sup>Většina základních příkazů Linuxu funguje i na macOS, protože macOS je system, odvozený z <a href="https://cs.wikipedia.org/wiki/Unix">UNIXu</a>, stejně jako Linux.</p>
</span>
<p>Pro otevření terminálu na Linuxu zmáčkněte <code>Ctrl + Alt + T</code> nebo zmáčkněte klávesu <code>Start</code>
a vyhledejte program <code>Terminal</code>. Pokud používáte WSL, tak spusťte z nabídky Start program <code>Ubuntu</code>.</p>
<p>Po otevření terminálu byste měli vidět něco podobného:
<img src="prostredi/os/../../static/img/terminal1.png" alt="" /></p>
<p>Před znakem dolaru (<code>$</code>) vždy uvidíte adresář<sup class='margin-toggle sidenote-number'>2</sup>, ve kterém se zrovna v terminálu nacházíte. Odpovídá
to zhruba tomu, jako když na Windows v prohlížeči souborů rozkliknete nějaký adresář a vidíte soubory,
které se v něm nachází. Pomocí příkazu <code>cd</code> (viz níže) se můžete mezi adresáři přepínat.</p>
<span class='sidenote'><p><sup class='number'>2</sup>Adresář (nebo taky složka) označuje pojmenovanou sadu souborů umístěnou na nějaké <strong>cestě</strong> (např. <code>/home/franta/soubor.c</code> nebo <code>/mnt/c/users/franta/Desktop/soubor.c</code>) na
disku. Adresáře mohou obsahovat jak soubory, tak další adresáře.</p>
</span>
<p>Nyní můžete do terminálu psát příkazy, pomocí kterých si můžete např. vypsat soubory v současném
adresáři, vytvořit nový adresář, spustit nějaký program nebo se přesunout do jiného adresáře:</p>
<ul>
<li>Vypsání souborů v současném adresáři (<code>ls = list files</code>)
<pre><code class="language-bash">~$ ls
soubor1
soubor2
slozka1
</code></pre>
</li>
<li>Přepnutí se do jiného adresáře (<code>cd = change directory</code>)
<pre><code class="language-bash">~$ cd slozka1
~/slozka1$
</code></pre>
</li>
<li>Vytvoření adresáře (<code>mkdir = make directory</code>)
<pre><code class="language-bash">~$ mkdir moje-slozka
~$ ls
moje-slozka
</code></pre>
</li>
<li>Spuštění programu
<pre><code class="language-bash">~$ ./program
</code></pre>
</li>
</ul>
<p>Více informací o práci s terminálem a Linuxem se dozvíte na internetu. Zkuste se podívat např.
na <a href="https://naucse.python.cz/2021/linuxadmin-podzim/sessions/shell-1/">tento kurz</a>.
<a href="https://github.com/geordi/upr-course/blob/master/assets/cheatsheets/linux.pdf">Zde</a> poté naleznete
tahák různých užitečných příkazů, které můžete v terminálu použít.</p>
<h1><a class="header" href="#instalace-linuxu" id="instalace-linuxu">Instalace Linuxu</a></h1>
<p>Pokud používáte operační systém Windows, tak pro použití Linuxu můžete využít jednu z následujících
tří možností.</p>
<blockquote>
<p>Linux není pouze jeden operační systém, ale pouze tzv. <strong>jádro</strong> (<em>kernel</em>) operačního systému,
nad kterým vznikají tzv. <em>distribuce</em>, které se liší ve vizuální stránce, způsobu ovládání, správě
softwarových balíčků atd. Jednou z nejpoužívanějších a také nejjednodušší distribucí Linuxu
je <strong>Ubuntu</strong>. Při instalaci Linuxu vám tak doporučujeme použít právě tuto distribuci.</p>
</blockquote>
<h2><a class="header" href="#windows-subsystem-for-linux-doporučeno" id="windows-subsystem-for-linux-doporučeno">Windows Subsystem for Linux (doporučeno)</a></h2>
<p><code>WSL</code> je systém, který umožňuje nainstalovat Linux pod operačním systémem Windows tak, že se Linux
bude chovat jako program spouštěný pod Windows. Tato varianta vám umožní jednoduše sdílet data
mezi Windows a Linuxem, a také vám umožní si jednoduše pod Windows spustit Linuxový terminál, ze
kterého budete moct např. překládat své <em>C</em> programy.</p>
<p>Nejprve si musíte na Windows <code>WSL</code> nainstalovat. Návod pro instalaci naleznete <a href="https://docs.microsoft.com/cs-cz/windows/wsl/install">zde</a>.
Pokud máte aktualizovaný Windows 10/11, tak by mělo stačit spustit příkazovou řádku Windows jako administrátor<sup class='margin-toggle sidenote-number'>1</sup>,
poté napsat <code>wsl.exe --install</code> a zmáčknout klávesu Enter. Jakmile se WSL nainstaluje, tak restartujte počítač.
Tento příkaz by vám měl nainstalovat distribuci <em>Ubuntu</em> do vašeho Windows počítače.</p>
<span class='sidenote'><p><sup class='number'>1</sup>Nabídka start -&gt; Napište <code>cmd</code> -&gt; Klikněte pravým tlačítkem na nalezený příkazový řádek -&gt; Spustit jako administrátor</p>
</span>
<p>Poté můžete spustit terminál (<code>bash</code>) běžící pod Ubuntu spuštěním programu <code>Ubuntu</code> (např. z nabídky
Start). Tento <a href="prostredi/os/os.html#z%C3%A1klady-pou%C5%BE%C3%ADv%C3%A1n%C3%AD-linuxu">terminál</a> můžete používat pro práci se soubory nebo
překlad <em>C</em> programů.</p>
<blockquote>
<p>Soubory z Windows jsou v příkazové řádce Ubuntu pod WSL dostupné na cestě <code>/mnt/c</code>. Pokud byste
se tak například chtěli v terminálu přesunout do složky <code>C:/Users/Katka/Desktop</code>, tak v terminálu
spusťte příkaz <code>cd /mnt/c/Users/Katka/Desktop</code>.</p>
<p>Naopak soubory z WSL jsou pod Windows dostupné na cestě <code>\\wsl$\Ubuntu\&lt;cesta&gt;</code>. Když do adresního
řádku prohlížeče souborů ve Windows napíšete <code>\\wsl$</code>, tak se můžete k souborům proklikat.</p>
</blockquote>
<p>Jakmile budete ve WSL <code>bash</code> terminálu, tak si nejprve nainstalujte programy nutné pro práci s <code>C</code>
(zejména překladač) pomocí následujích dvou příkazů:</p>
<pre><code class="language-bash">$ sudo apt update
$ sudo apt install build-essential gdb
</code></pre>
<blockquote>
<p>Při pokusu o instalaci vás program vyzve, abyste instalaci potvrdili. Udělejte to zmáčknutím klávesy <code>y</code>
a potvrďte klávesou Enter.</p>
</blockquote>
<h2><a class="header" href="#virtualizovaný-linux" id="virtualizovaný-linux">Virtualizovaný Linux</a></h2>
<p>Linux můžete také používat ve virtualizované podobě pomocí
<a href="https://cs.wikipedia.org/wiki/Virtu%C3%A1ln%C3%AD_stroj">virtuálního stroje</a>. V této variantě se
pod Windows spustí celý virtuální počítač, na kterém poběží Linux, který nebude mít vůbec tušení o
tom, že je spuštěn pod Windows. Výhodou tohoto řešení je, že se virtuální počítač bude chovat jako
plnohodnotná instalace Linuxu, a téměř vše by tedy na něm mělo fungovat (i včetně např. grafických
aplikací, které pod WSL nemusí fungovat). Nevýhodou je, že virtuální počítač je značně náročný na procesor
i paměť počítače, a může být obtížnější s virtuálním počítačem sdílet data z Windows (ve srovnání s WSL).</p>
<p>Připravili jsme pro vás tzv. obraz virtuálního stroje, který obsahuje již nastavený Linux, konkrétně
<code>Ubuntu 20.04</code>, se vším potřebným pro předmět UPR. Abyste jej mohli použít, tak si nejprve musíte
nainstalovat virtualizační program <a href="https://www.virtualbox.org/wiki/Downloads">VirtualBox</a>. Poté si
<a href="https://drive.google.com/file/d/1RsFoternYw1vNYlHefa5wr1ZwLv81wBi/view?usp=sharing">předpřipravený obraz</a> stáhněte, otevřete ho ve VirtualBoxu
a potvrďte import s výchozím nastavením.</p>
<p>Virtuální počítač poté bude možné spustit z programu VirtualBox. Uživatelské jméno i heslo je
<code>student</code>.</p>
<h2><a class="header" href="#nativní-instalace-linuxu" id="nativní-instalace-linuxu">Nativní instalace Linuxu</a></h2>
<p>Nejspolehlivější variantou použití Linuxu je nainstalovat si ho přímo &quot;na železo&quot;, tj. bez
virtualizace. Můžete jej například nastavit v režimu
<a href="https://www.tecmint.com/install-ubuntu-alongside-with-windows-dual-boot/">dual boot</a>, kdy se při
startu počítače můžete rozhodnout, zdali se nabootuje do Windows (či jiného operačního systému)
nebo do Linuxu. Pokud jste s Linuxem nikdy nepracovali, tak doporučujeme použít Linuxovou
<a href="https://itsfoss.com/install-ubuntu/">distribuci Ubuntu</a> ve verzi <code>24.04</code>.</p>
<h1><a class="header" href="#macos" id="macos">macOS</a></h1>
<p>Během výuky UPR používáme překladač GCC. Jelikož ve výchozím nastavení není v macOS zahrnutý, musíme ho vlastnoručně nainstalovat.</p>
<p>Nejprve musíme nainstalovat nástroje příkazového řádku, tzv. <em>Xcode Command Line Tools</em>:</p>
<p>Otevřete si <code>Terminál</code><sup class='margin-toggle sidenote-number'>1</sup> pomocí Launchpadu nebo Spotlightu (⌘ + mezerník) a zadejte následující příkaz:</p>
<span class='sidenote'><p><sup class='number'>1</sup>Více o práci s terminálem se dozvíte v sekci <a href="prostredi/os/os.html">Operační systém</a></p>
</span>
<pre><code class="language-zsh">$ xcode-select --install
</code></pre>
<blockquote>
<p>Při pokusu o instalaci vás program vyzve, abyste instalaci potvrdili. Udělejte to stisknutím klávesy <code>y</code>
a potvrďte klávesou Enter.</p>
</blockquote>
<h2><a class="header" href="#instalace-homebrew" id="instalace-homebrew">Instalace Homebrew</a></h2>
<p>Abychom zjednodušili postup, nainstalujeme <a href="https://cs.wikipedia.org/wiki/Spr%C3%A1vce_bal%C3%AD%C4%8Dk%C5%AF">správce balíčků</a>, konkrétně <a href="https://brew.sh/cs/">Homebrew</a>, který se vám jistě ještě bude hodit.</p>
<p>Pro instalaci vložte do okna terminálu:</p>
<pre><code class="language-zsh">$ /bin/bash -c &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)&quot;
</code></pre>
<p>Jestliže jste neměli předtím nainstalované <em>Xcode Command Line Tools</em>, Homebrew je také nainstaluje.</p>
<blockquote>
<p>⚠️ Po plné instalaci Homebrew se zobrazí odstavec: <code>Next steps</code>. V něm budou uvedeny příkazy, které musíte také spustit, aby vám příkaz <code>brew</code> fungoval.</p>
</blockquote>
<p>V případě, že máte všechno nainstalováno správně, po zadání příkazu <code>brew</code> v terminálu uvidíte následující:</p>
<center><img src="prostredi/os/../../static/img/macos/brew.png" height="400"></center>
<h2><a class="header" href="#instalace-gcc" id="instalace-gcc">Instalace GCC</a></h2>
<p>Teď můžeme jednoduše nainstalovat GCC pomocí:</p>
<pre><code class="language-zsh">$ brew install gcc
</code></pre>
<h2><a class="header" href="#spouštění-gcc" id="spouštění-gcc">Spouštění GCC</a></h2>
<p>Po instalaci nástrojů příkazového řádku můžeme zkusit použít příkaz <code>gcc</code>, ale ve skutečnosti se spustí jiný, zabudovaný do macOS překladač Clang.</p>
<p>Abychom mohli spouštět příkazy GCC, musíme použít: <code>gcc-&lt;verze&gt;</code>.</p>
<p>Zjistit, jakou verzi GCC máme nainstalovanou, můžeme pomocí:</p>
<pre><code class="language-zsh">$ ls -l /opt/homebrew/bin/gcc-*
</code></pre>
<p>Po spuštění uvidíte něco jako:</p>
<center><img src="prostredi/os/../../static/img/macos/gcc-ver.png" height=200 ></center>
<p>Lze vidět, že výsledek obsahuje cesty do složek překladače, ve kterých se často opakuje <code>gcc-15</code>, tzn. verze GCC je 15.</p>
<p>Takže, pro používání GCC budeme vždy psát <code>gcc-15 ...</code>. Pokud máme jinou verzi, určitě budeme v příkazu psát jiné číslo.</p>
<p>Ověříme to a porovnáme s příkazem <code>gcc</code>:</p>
<center><img src="prostredi/os/../../static/img/macos/gcc-clang.png" height="200" ></center>
<p>Příkaz s určením verze opravdu volá GCC.</p>
<p>Teď můžeme dál nastavovat prostředí. Zbytek postupu bude téměř úplně stejný jako na Linuxu, až na pár klávesových zkratek a instalačních detailů.</p>
<h1><a class="header" href="#vývojové-prostředí" id="vývojové-prostředí">Vývojové prostředí</a></h1>
<p>Abychom mohli přeložit a spustit nějaký program, musíme ho obvykle nejprve zapsat do
jednoho nebo více souborů ve formě tzv. <strong>zdrojového kódu</strong> (<em>source code</em>). K usnadnění tohoto procesu
existují <strong>textové editory</strong> a <strong>vývojová prostředí</strong> jako například <code>Microsoft Visual Studio</code>, <code>Microsoft Visual Studio Code</code>, <code>Qt Creator</code>, <code>JetBrains CLion</code>,
<code>Code::Blocks</code>, <code>Vim</code>, <code>GNU Emacs</code> apod. Tyto programy usnadňují psaní kódu pomocí zvýrazňování
syntaxe, automatizace překladu, spouštění a testování programů a také správy projektů.</p>
<p>Na cvičeních UPR budeme používat editor <code>Visual Studio Code</code>, který je
<a href="https://code.visualstudio.com/">dostupný zdarma</a>. <a href="prostredi/editor/vscode.html">Zde</a> je stručný návod k jeho použití. Při
programování se hodí detailně znát a efektivně využívat editor, který používáte, ale pro začátek
nám budou stačit naprosté základy.</p>
<p>Jako alternativu lze použít <a href="prostredi/editor/clion.html"><code>CLion</code></a>, plnohodnotné <strong>IDE</strong> (<em>Integrated Development Environment</em>) s pokročilými funkcemi, které usnadňují vývoj v C a C++.
Nabízí nativní integraci s build systémem <a href="prostredi/editor/../../c/automatizace_prekladu.html#cmake">CMake</a>.</p>
<h1><a class="header" href="#instalace-vs-code" id="instalace-vs-code">Instalace VS Code</a></h1>
<ul>
<li>
<p>Pokud používáte virtualizovaný nebo nativní Linux (Ubuntu), stáhněte si <a href="https://code.visualstudio.com/">odsud</a>
<code>.deb</code> soubor s balíčkem VS Code a nainstalujte jej (poklikáním myši na soubor nebo spuštěním příkazu</p>
<pre><code class="language-bash">$ sudo apt install ./&lt;nazev-souboru&gt;.deb
</code></pre>
</li>
<li>
<p>Pokud používáte <code>WSL</code>, tak by už měl být VS Code předinstalovaný<sup class='margin-toggle sidenote-number'>1</sup>. Spustíte ho tak, že v <code>bash</code>
terminálu spustíte tento příkaz:</p>
<span class='sidenote'><p><sup class='number'>1</sup>Pokud by tomu tak nebylo, návod na instalaci VS Code na Linuxu naleznete
<a href="https://code.visualstudio.com/docs/setup/linux">zde</a>.</p>
</span>
<pre><code class="language-bash">$ code .
</code></pre>
<p>Ten otevře VS Code v adresáři, ve kterém se zrovna v terminálu budete nacházet. Ve VS Code
si poté také nainstalujte dodatečné rozšíření
<a href="https://marketplace.visualstudio.com/items?itemName=ms-vscode-remote.vscode-remote-extensionpack"><code>Remote Development</code></a>
(viz návod, jak instalovat rozšíření <a href="prostredi/editor/vscode.html#instalace-roz%C5%A1%C3%AD%C5%99en%C3%AD-pomoc%C3%AD-u%C5%BEivatelsk%C3%A9ho-rozhran%C3%AD">níže</a>).</p>
<p>Podrobný návod, jak zprovoznit VS Code v kombinaci s WSL, naleznete
<a href="https://code.visualstudio.com/docs/remote/wsl">zde</a> nebo <a href="https://code.visualstudio.com/docs/cpp/config-wsl">zde</a>.</p>
</li>
</ul>
<h2><a class="header" href="#instalace-rozšíření-pomocí-terminálu" id="instalace-rozšíření-pomocí-terminálu">Instalace rozšíření (pomocí terminálu)</a></h2>
<p>VS Code podporuje programovací jazyky pomocí rozšíření, po první instalaci VS Code
tak nejprve musíme nainstalovat potřebná rozšíření pro jazyk <em>C</em>. V terminálu spusťte tyto příkazy:</p>
<pre><code class="language-bash">$ code --install-extension ms-vscode.cpptools
</code></pre>
<p>Doporučujeme si také nainstalovat následující <a href="https://marketplace.visualstudio.com/items?itemName=jakub-beranek.memviz">rozšíření</a> pro vizualizaci paměti programů, které jsme pro vás nachystali:</p>
<pre><code class="language-bash">$ code --install-extension jakub-beranek.memviz
</code></pre>
<h2><a class="header" href="#instalace-rozšíření-pomocí-uživatelského-rozhraní" id="instalace-rozšíření-pomocí-uživatelského-rozhraní">Instalace rozšíření (pomocí uživatelského rozhraní)</a></h2>
<ol>
<li>Spusťte Visual Studio Code</li>
<li>Otevřete obrazovku rozšíření (<code>Ctrl+Shift+X</code> nebo spusťte akci <code>Install Extensions</code>)</li>
<li>Vyhledejte rozšíření (<code>C/C++</code>) a nainstalujte jej</li>
<li>Můžete také vyhledat <code>memviz</code> a nainstalovat rozšíření <a href="https://marketplace.visualstudio.com/items?itemName=jakub-beranek.memviz">Memory visualizer</a> pro vizualizaci paměti.</li>
</ol>
<h2><a class="header" href="#Časté-problémy" id="Časté-problémy">Časté problémy</a></h2>
<p>Tato sekce obsahuje vybrané problémy, se kterými se studenti často setkávají při práci s Visual Studio Code (obzvláště
na WSL).</p>
<h3><a class="header" href="#chybějící-hlavičkové-soubory" id="chybějící-hlavičkové-soubory">Chybějící hlavičkové soubory</a></h3>
<p>Pokud spustíte VS Code, otevřete v něm nějaký program s <em>C</em> kódem a budete mít červeně podtržený např.
takovýto řádek:</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
</code></pre>
<p>je to pravděpodobně způsobeno jedním ze dvou následujících důvodů:</p>
<ol>
<li>
<p>Spouštíte VS Code z Windows a ne z Ubuntu WSL terminálu. Spouštějte VS Code vždy přímo z Ubuntu
terminálu, aby mělo správný přístup k systémovým souborům jazyka <em>C</em>.</p>
<p>Podle ikony dvou šipek v levém dolním rohu okna VS Code můžete rozpoznat, zdali jste připojení ve VS Code k WSL, nebo ne.</p>
</li>
</ol>
<ul>
<li>
<p>Pokud je u ikony napsáno WSL, tak je VS Code správně připojen k WSL terminálu:</p>
<p><img src="prostredi/editor/../../static/img/vsc-wsl.png" alt="" /></p>
</li>
<li>
<p>Pokud tam jsou pouze dvě šipky a nic více, tak jste VS Code spustili ve Windows místo ve WSL, to je špatně:</p>
<p><img src="prostredi/editor/../../static/img/vsc-windows.png" alt="" /></p>
<p>Klikněte na ikonu dvou šipek a připojte se k WSL.</p>
</li>
</ul>
<ol start="2">
<li>Nemáte nainstalovaný překladač (GCC). Spusťte Ubuntu terminál a nainstalujte jej, viz
<a href="prostredi/editor/../preklad_programu.html">překlad programu</a>.</li>
</ol>
<blockquote>
<p>Obecně řečeno, to, že se vám ve VS Code ukazuje nějaký problém s kódem, ještě neznamená, že tento
problém v kódu opravdu je. Důležité je, co řekne <a href="prostredi/editor/../preklad_programu.html">překladač</a> při překladu
programu, VS Code je občas zmatené anebo není správně nastavené. Samozřejmě je ale ideální si ho správně
nastavit, ať vás to neplete.</p>
</blockquote>
<h3><a class="header" href="#změny-ve-zdrojovém-kódu-se-nepromítají-v-přeloženém-programu" id="změny-ve-zdrojovém-kódu-se-nepromítají-v-přeloženém-programu">Změny ve zdrojovém kódu se nepromítají v přeloženém programu</a></h3>
<p>Pokud v otevřeném zdrojovém souboru provedete nějaké změny, tak se neuloží na disk, dokud soubor neuložíte (pomocí
klávesové zkratky <code>Ctrl + S</code>). Občas se studentům stává, že provedou změnu, poté se snaží přeložit program, ale jejich
změny se neprojeví a studenti nerozumí, proč tomu tak je. Často je to právě proto, že soubor není uložen!
<strong>Neuložený soubor</strong> poznáte tak, že v záložce s názvem souboru je bílé kolečko:
<img src="prostredi/editor/../../static/img/vsc-unsaved-file.png" alt="" /></p>
<p>Vždy tak po provedení změn ukládejte soubor pomocí <code>Ctrl + S</code>, případně si můžete v nastavení (<code>Settings</code>) zapnout volbu
<code>Auto Save</code>.</p>
<h2><a class="header" href="#ukázka-nastavení-projektu" id="ukázka-nastavení-projektu">Ukázka nastavení projektu</a></h2>
<p>Jako vzorový projekt můžete použít <a href="https://github.com/geordi/upr-course/tree/master/faq/vscode-template-project">tuto</a>
šablonu. Pro otevření adresáře ve VS Code klikněte na <code>Soubor (File) -&gt; Otevřít adresář (Open Folder)</code>
a vyberte nějaký adresář, ve kterém chcete programovat.</p>
<p><img src="prostredi/editor/../../static/video/vsc_first_run.gif" alt="Nastavení VS Code" /></p>
<h2><a class="header" href="#pokročilé-možnosti-nastavení-projektu" id="pokročilé-možnosti-nastavení-projektu">Pokročilé možnosti nastavení projektu</a></h2>
<p>Pokud byste si chtěli nastavit VS Code tak, aby překládal nebo spouštěl váš program s jiným, než základním
nastavením, můžete k tomu využít konfiguraci pomocí souborů <code>launch.json</code>, který definuje, jak bude VS Code
váš program spouštět, případně <code>tasks.json</code>, pomocí kterého můžeme nastavit, jak se bude program překládat.</p>
<p><code>launch.json</code> je možno vytvořit po kliknutí na záložku <code>Run and Debug</code> (Ctrl+Shift+D) a poté na tlačítko <code>create a launch.json file</code> (tlačítko se zobrazí, pokud máte otevřený soubor s příponou <code>.c</code> ve VS Code). Soubor se vytvoří v současně otevřeném adresáři, ve složce <code>.vscode</code> (můžete ho případně i vytvořit manuálně).</p>
<p>Do vygenerovaného souboru můžete zkopírovat tento obsah:</p>
<pre><code class="language-json">{
    &quot;version&quot;: &quot;0.2.0&quot;,
    &quot;configurations&quot;: [
        {
            &quot;name&quot;: &quot;C program (gdb) Launch&quot;,
            &quot;type&quot;: &quot;cppdbg&quot;,
            &quot;request&quot;: &quot;launch&quot;,
            &quot;program&quot;: &quot;${workspaceFolder}/main&quot;,
            &quot;args&quot;: [],
            &quot;cwd&quot;: &quot;${workspaceFolder}&quot;,
            &quot;MIMode&quot;: &quot;gdb&quot;,
            &quot;miDebuggerPath&quot;: &quot;/usr/bin/gdb&quot;,
            &quot;preLaunchTask&quot;: &quot;C compile&quot;
        }
    ]
}
</code></pre>
<p>Atributy této konfigurace poté můžete upravovat. Užitečné pro vás budou zejména tyto atributy:</p>
<ul>
<li><strong>program</strong> - cesta ke <strong>spustitelnému</strong> (přeloženému) souboru, který bude konfigurace spouštět</li>
<li><strong>cwd</strong> - pracovní adresář, ve kterém se program spustí</li>
<li><strong>args</strong> - <a href="prostredi/editor/../../ruzne/funkce_main.html#vstupn%C3%AD-parametry-funkce-main">argumenty příkazového řádku</a> předané
spouštěnému programu</li>
</ul>
<p>Pokud byste si chtěli při ladění přesměrovat obsah souboru na <a href="prostredi/editor/../../c/text/vstup.html">standardní vstup</a> programu,
tak přidejte na konec <code>args</code> šipku doleva a cestu k souboru, který chcete přesměrovat na vstup:</p>
<pre><code class="language-json">&quot;args&quot;: [
    &quot;&lt;&quot;,
    &quot;${workspaceFolder}/stdin_file.stdin&quot;
]
</code></pre>
<p>Dále budete muset nastavit soubor <strong>tasks.json</strong>, pro automatický překlad programu
(vytvořte jej opět ve <code>.vscode</code> složce projektu). Pokud tento soubor bude chybět, při pokusu o ladění programu
dostanete chybovou hlášku podobnou této:</p>
<blockquote>
<p>launch: program <code>&lt;cesta&gt;/main</code> does not exist</p>
</blockquote>
<p>Do <code>tasks.json</code> si můžete zkopírovat tento obsah:</p>
<pre><code class="language-json">{
    &quot;version&quot;: &quot;2.0.0&quot;,
    &quot;tasks&quot;: [
        {
            &quot;type&quot;: &quot;cppbuild&quot;,
            &quot;label&quot;: &quot;C compile&quot;,
            &quot;command&quot;: &quot;gcc&quot;,
            &quot;args&quot;: [
                &quot;${workspaceFolder}/main.c&quot;,
                &quot;-g&quot;,
                &quot;-o&quot;,
                &quot;${workspaceFolder}/main&quot;
            ]
        }
    ]
}
</code></pre>
<p>Zde jsou důležité hlavně dva atributy:</p>
<ul>
<li><strong>label</strong> - název tasku pro spuštění. <strong>Tento název musí odpovídat atributu <code>preLaunchTask</code> v souboru <code>launch.json</code></strong>.</li>
<li><strong>args</strong> - <a href="prostredi/editor/../../ruzne/parametry_prekladace.html">parametry překladače</a> použité při překladu.
<ul>
<li>Prvním argumentem by měla být cesta k překládanému C zdrojovému souboru.</li>
<li>Dále by v <code>args</code> měla být cesta k výslednému přeloženého souboru, předaná za parametrem <code>-o</code>.
<strong>Tato cesta musí odpovídat atributu <code>program</code> v souboru <code>launch.json</code></strong>.</li>
<li>Dále zde můžete předávat další parametry překladače, např. zapnout <a href="prostredi/editor/../ladeni.html#address-sanitizer">Address sanitizer</a>
(<code>-fsanitize=address</code>) nebo přilinkovat nějaké <a href="prostredi/editor/../../c/modularizace/knihovny.html">knihovny</a> (např. <code>-lm</code>).</li>
</ul>
</li>
</ul>
<p>Více informací o možnostech nastavení těchto dvou souborů můžete naleznout na těchto odkazech:</p>
<ul>
<li><a href="https://code.visualstudio.com/docs/cpp/launch-json-reference">Microsoft Configure C/C++ debugging</a></li>
<li><a href="https://code.visualstudio.com/docs/editor/variables-reference">Microsoft Variables Reference</a></li>
</ul>
<h2><a class="header" href="#automatické-formátování-kódu" id="automatické-formátování-kódu">Automatické formátování kódu</a></h2>
<p>Pokud s programováním začínáte, tak budete ze začátku nejspíše trochu bojovat s tím, jak zformátovat zdrojový kód,
aby byl přehledný a dalo se v něm vyznat. Tuto činnost však můžete nechat plně na editoru či vývojovém prostředí.
Ve Visual Studio Code můžete použít klávesovou zkratku <code>Ctrl + Shift + I</code>, která vám právě otevřený soubor s kódem
automaticky zformátuje.</p>
<p>Můžete si dokonce editor nastavit tak, aby po každém uložení souboru kód automaticky zformátoval. Klikněte na
<code>File -&gt; Preferences -&gt; Settings</code>, poté do vyhledávacího okénka napište <code>Format On Save</code> a zaškrtněte tuto možnost:
<img src="prostredi/editor/../../static/img/vsc-format-on-save.png" alt="" /></p>
<h2><a class="header" href="#užitečné-zkratky" id="užitečné-zkratky">Užitečné zkratky</a></h2>
<ul>
<li>Spustit program - <code>F5</code></li>
<li>Naformátovat kód - <code>Ctrl + Shift + I</code></li>
<li>Uložit provedené změny v souboru - <code>Ctrl + S</code></li>
<li>Zobrazit vyhledávač akcí - <code>Ctrl + Shift + P</code></li>
</ul>
<h1><a class="header" href="#instalace-clionu" id="instalace-clionu">Instalace CLionu</a></h1>
<p>Nejlepší způsob instalace je použití aplikace <a href="https://www.jetbrains.com/toolbox-app/">Toolbox</a>, která vám umožní spravovat všechna vaše IDE od JetBrains. Pokud narazíte na problém, kompletní návod
naleznete <a href="https://www.jetbrains.com/help/clion/installation-guide.html#toolbox">zde</a>.</p>
<h2><a class="header" href="#první-projekt" id="první-projekt">První projekt</a></h2>
<p>Po spuštění CLionu klikněte na <code>New Project</code> a vyberte <code>C Executable</code>. Nastavte umístění projektu a můžete také zvolit standard jazyka C, který lze později změnit i v CMaku. Program spustíte pomocí
klávesové zkratky <code>Shift + F10</code> nebo kliknutím na tlačítko <strong>Run</strong>.</p>
<img src="prostredi/editor/../../static/img/clion/clion_run.png" width="557" height="432" >
<h3><a class="header" href="#výběr-kompilátoru" id="výběr-kompilátoru">Výběr kompilátoru</a></h3>
<p>Pokud chcete používat <strong>GCC</strong> kompilátor z <strong>WSL</strong>, stačí jej přepnout v nastavení.</p>
<ol>
<li>Stisknutím klávesové zkratky <code>CTRL + Shift + A</code> otevřete vyhledávací okno.</li>
<li>Napište <strong>Toolchains</strong> a stiskněte <code>Enter</code>.</li>
<li>Pokud máte správně nainstalované WSL, mělo by se objevit v nabídce. Klikněte na něj a posuňte jej nahoru pomocí <code>Alt + Up</code>.</li>
<li>Potvrďte kliknutím na <strong>Apply</strong> a následně <strong>OK</strong>.</li>
</ol>
<blockquote>
<p>⚠️ Pokud vám program nejde spustit po přepnutí na WSL, může to být způsobeno chybějícími balíčky nebo starší verzí CMaku.</p>
</blockquote>
<p>Nainstalujte potřebné balíčky:</p>
<pre><code class="language-bash">$ sudo apt-get install build-essential cmake gdb
</code></pre>
<p>V souboru CMakeLists.txt nastavíme starší verzi CMaku na verzi 3.21</p>
<pre><code class="language-cmake">cmake_minimum_required(VERSION 3.21)
</code></pre>
<blockquote>
<p>Pokaždé, když v CMaku uděláme změnu je potřeba soubor znovu načíst. Buď si zapnete auto-reload pomocí příkazu <code>Auto-Reload CMake Project</code> nebo kliknete na soubor pravým a dáte <code>Reload CMake Project</code></p>
</blockquote>
<p>Pokud chcete pochopit fungování CMaku, tak můžete <a href="prostredi/editor/../../c/automatizace_prekladu.html#cmake">zde</a>.</p>
<p>Jak naimportovat SDL pro následující projekt můžete najít <a href="prostredi/editor/../../c/aplikovane_ulohy/sdl.html#p%C5%99ilinkov%C3%A1n%C3%AD-knihovny-sdl">zde</a>.</p>
<h2><a class="header" href="#licence-education-pack-na-jíne-produkty-jetbrains" id="licence-education-pack-na-jíne-produkty-jetbrains">Licence Education Pack na jíne produkty JetBrains</a></h2>
<p>JetBrains má spoustu jiných produktů na vývoj, ladění, práci s databázemi atd. Část z nich potřebuje pro používání licenci, o kterou můžete jako studenti požádat zdarma <a href="https://www.jetbrains.com/shop/eform/students">zde</a>.</p>
<ul>
<li>
<p>Na stránce jsou čtyři způsoby, jak licenci získat. Nejjednodušší je použít váš školní e-mail. Email je v následujícím tvaru: <code>&lt;login&gt;@vsb.cz</code>, např. <code>UPR0123@vsb.cz</code></p>
</li>
<li>
<p>Po vyplnění dotazníku vám přijde potvrzovací e-mail o schválení <strong>Educational Packu</strong>. Otevřete odkaz v e-mailu a potvrďte podmínky. Poté si vytvořte účet s vaším školním
e-mailem <a href="https://account.jetbrains.com/login">zde</a>.</p>
</li>
<li>
<p>Stav vaší licence můžete zkontrolovat <a href="https://account.jetbrains.com/licenses">zde</a>. Zde také uvidíte všechny produkty, na které se licence vztahuje.</p>
</li>
<li>
<p>Nakonec se stačí v <strong>Toolboxu</strong> přihlásit pod účtem, který jste si vytvořili.</p>
</li>
</ul>
<img src="prostredi/editor/../../static/video/toolbox_login.gif" width="288" height="409" >
<h1><a class="header" href="#překlad-programu" id="překlad-programu">Překlad programu</a></h1>
<p>Pro překlad programů, které budeme psát v jazyce <em>C</em>, do <strong>spustitelného</strong> (<em>executable</em>) souboru
budeme používat program, kterému se říká překladač.
Překladačů jazyka <em>C</em> existuje celá řada, my budeme využívat asi nejpoužívanější překladač pro
Linuxové systémy s názvem <a href="https://gcc.gnu.org/"><strong>GCC</strong></a> (GNU Compiler Collection).</p>
<p>Překladač GCC, spolu s dalšími potřebnými nástroji, můžete na Ubuntu v terminálu nainstalovat
pomocí následujících dvou příkazů:</p>
<pre><code class="language-bash">$ sudo apt update
$ sudo apt install build-essential gdb
</code></pre>
<blockquote>
<p>Při pokusu o instalaci vás program vyzve, abyste instalaci potvrdili. Udělejte to zmáčknutím klávesy <code>y</code>
a potvrďte klávesou Enter.</p>
</blockquote>
<h2><a class="header" href="#překlad-prvního-programu" id="překlad-prvního-programu">Překlad prvního programu</a></h2>
<p>Ještě než si ukážeme, jak vlastně programovací jazyk <em>C</em> funguje, tak zkusíme přeložit velmi jednoduchý
<em>C</em> program do spustitelného souboru a spustit jej.
Vytvořte soubor s názvem <code>main.c</code> a nakopírujte<sup class='margin-toggle sidenote-number'>1</sup> do něj následující <em>C</em> kód (později si vysvětlíme,
jak tento kód funguje):</p>
<span class='sidenote'><p><sup class='number'>1</sup>Kód z buněk můžete kopírovat pomocí tlačítka <i class="fa fa-copy"></i> v pravém horním rohu
buňky s kódem.</p>
</span>
<pre><code class="language-c editable">#include &lt;stdio.h&gt;

int main() {
    printf(&quot;Hello world!\n&quot;);
    return 0;
}
</code></pre>
<blockquote>
<p>Tento program se nazývá <code>Hello world</code>, jelikož tento text vypíše na obrazovku.
Podobný jednoduchý program je zpravidla tím prvním, co programátor vytvoří, když se učí nějaký
programovací jazyk.</p>
</blockquote>
<p>Nyní otevřete terminál (<code>Ctrl + Alt + T</code> v Ubuntu), přesuňte se do složky s tímto souborem pomocí
příkazu <code>cd</code>, spusťte program <code>gcc</code> a předejte mu cestu k tomuto souboru:</p>
<pre><code class="language-bash">$ gcc main.c -o program
</code></pre>
<p>Tímto příkazem řeknete &quot;Gécécéčku&quot;, aby přeložil zdrojový soubor <code>main.c</code> a uložil výsledný spustitelný
soubor do souboru <code>program</code><sup class='margin-toggle sidenote-number'>2</sup>. Pokud byste přepínač <code>-o &lt;nazev souboru&gt;</code> nepoužili, tak se vytvoří spustitelný
soubor s názvem <code>a.out</code>.</p>
<span class='sidenote'><p><sup class='number'>2</sup>Na Windowsu spustitelné soubory mají obvykle příponu <code>.exe</code>, na Linuxu to však není běžnou praxí a spustitelné soubory typicky žádnou příponu nemají.</p>
</span>
<p>Pokud chcete nyní program spustit, stačí v terminálu zadat cestu k danému spustitelnému souboru.</p>
<pre><code class="language-bash">$ ./program
Hello world!
</code></pre>
<p>Program by měl na výstup vytisknout text <code>Hello world!</code>.</p>
<details>
<summary>Tipy pro práci s příkazovou řádkou</summary>
<ul>
<li>
<p>Při psaní programu budete chtít často po úpravě zdrojového kódu opětovně provést překlad a poté
program spustit. Abyste to provedli v jednom terminálovém příkazu, můžete tyto dva příkazy spojit pomocí <code>&amp;&amp;</code>:</p>
<pre><code class="language-bash">$ gcc main.c -o main &amp;&amp; ./main
</code></pre>
<p>Pokud překlad proběhne úspěšně, tak operátor <code>&amp;&amp;</code> zajistí spuštění následujícího příkazu.</p>
</li>
<li>
<p>Pokud nechcete příkazy v terminálu psát neustále dokola, šipkou nahoru (↑) můžete vyvolat nedávno
spuštěné příkazy v terminálu.</p>
</li>
<li>
<p>Můžete používat i terminál vestavený přímo ve <code>Visual Studio Code</code> (<code>View -&gt; Terminal</code>).</p>
</li>
</ul>
</details>
<p>📹 Pro lepší představu o překladu programů zde máte k dispozici ještě krátké shrnující video:</p>
<iframe width="560" height="315" src="https://www.youtube.com/embed/Hu7l9NpQ3g8" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
<h3><a class="header" href="#jak-překlad-probíhá" id="jak-překlad-probíhá">Jak překlad probíhá?</a></h3>
<p>Překlad programu bude detailně vysvětlen později v sekci o <a href="prostredi/../c/modularizace/linker.html">linkeru</a>.
Prozatím nám bude stačit tato zkrácená verze:</p>
<p>Překlad programů probíhá ve dvou hlavních fázích: <strong>překlad</strong> (<em>translation</em>) a <strong>linkování</strong> (<em>linking</em>).
Dohromady se oboum těmto krokům také říká <strong>kompilace</strong> (<em>compilation</em>).</p>
<p>Při překladu překladač vezme každý <em>C</em> zdrojový soubor, který mu předložíme, a samostatně jej přeloží
do tzv. <strong>objektového souboru</strong> (<em>object file</em>). Takovýto soubor obsahuje již přeložené instrukce pro
procesor, ale není sám o sobě spustitelný, tj. nejedná se o program, ale pouze o přeložený binární kód.</p>
<p>Jakmile jsou všechny zdrojové soubory přeloženy do objektových souborů, tak přichází na řadu další
program, tzv. <strong>linker</strong>, který tyto objektové soubory spojí dohromady,
<a href="https://cs.wikipedia.org/wiki/Linker#Funkce_linkeru">propojí</a> je dle potřeby, případně k nim připojí
externí <a href="prostredi/../c/modularizace/knihovny.html">knihovny</a> a na konci vytvoří finální spustitelný soubor, který lze poté
spustit.</p>
<p>Když použijete program <code>gcc</code> způsobem, jaký jsme si ukázali výše, tak se na pozadí spustí překladač
a poté i linker a oba dva tyto kroky se tak provedou automaticky. Je ale možné provést je i separátně:</p>
<pre><code class="language-bash">$ gcc -c main.c      # vytvoří objektový soubor main.o
$ gcc main.o -o main # slinkování souboru main.o
</code></pre>
<h1><a class="header" href="#ladění-programů" id="ladění-programů">Ladění programů</a></h1>
<p>Tato sekce slouží k řešení často se vyskytujících problémů při programování v C. Pokud váš program
padá při běhu nebo se nechová tak, jak má, tak v něm nejspíše máte nějakou chybu (tzv. <strong>bug</strong>).
Proces hledání chyby, která způsobuje pád nebo špatné chování programu se pak nazývá <strong>ladění</strong> (<em>debugging</em>).</p>
<p><strong>Zejména se podívejte na sekci o <a href="prostredi/ladeni.html#krokov%C3%A1n%C3%AD">krokování</a>!</strong></p>
<h3><a class="header" href="#chyby-při-překladu-programu" id="chyby-při-překladu-programu">Chyby při překladu programu</a></h3>
<p>Pokud váš program nelze přeložit a překladač vypisuje nějakou chybovou hlášku, tak máte v zápisu programu
nějakou chybu, obvykle v syntaxi, tedy zápisu kódu. Je dobré si danou chybovou hlášku pořádně přečíst,
obvykle se odkazuje na relativně přesné místo, kde máte kód špatně, a někdy dokonce i nabízí řešení,
jak problém vyřešit.</p>
<p>Při překladu můžete dostat například následující chybovou hlášku:</p>
<pre><code class="language-bash">main.c: In function ‘main’:
main.c:2:2: error: ‘a’ undeclared (first use in this function)
    2 |  a = 0;
</code></pre>
<p>Tato konkrétní chyba byla způsobena tím, že byla použitá proměnná bez její předchozí deklarace. Pokud
chybě nerozumíte, zkuste ji nejprve vygooglit, ideálně pouze část, která není konkrétně závislá na
podobě vašeho projektu. Nemá cenu googlit <code>main.c:2:2</code>, protože tento text je závislý na tom, jak jste
si pojmenovali své soubory, ostatní programátoři nejspíše mají jiné názvy souborů. V případě této chyby
by tedy bylo lepší googlit text <code>error: undeclared (first use in this function)</code>.</p>
<p>Může se stát, že překladač vypíše více chybových hlášek zároveň, i když chyba
v programu je pouze jedna. Zkuste scrollovat výstupem hlášek nahoru, abyste zjistili, která chyba
byla vypsána jako první, zbytek výpisu může být &quot;planý poplach&quot;.</p>
<p>Pokud se vám nedaří chybu vygooglit, tak kontaktujte svého cvičícího.</p>
<p>Při překladu můžete použít dodatečné přepínače, při jejichž použití vydá překladač více varování o
možných problémových místech ve vašem kódu:</p>
<pre><code class="language-bash">$ gcc -Wall -Wextra -pedantic -Werror=uninitialized -Werror=vla -Werror=return-type ...
</code></pre>
<p>Podívejte se také do sekce <a href="prostredi/../caste_chyby/caste_chyby.html">Časté chyby</a>, kde je seznam často se
vyskytujících chyb.</p>
<h3><a class="header" href="#chyby-při-běhu-programu" id="chyby-při-běhu-programu">Chyby při běhu programu</a></h3>
<p>Pokud váš program tzv. &quot;padá&quot; při běhu, můžete zkusit následující způsoby ladění:</p>
<h4><a class="header" href="#address-sanitizer" id="address-sanitizer">Address sanitizer</a></h4>
<p>Tento nástroj modifikuje váš program tak, aby dokázal detekovat značné množství chyb při jeho běhu,
a pokud nějakou chybu najde, tak váš program okamžitě ukončí a popíše, k jakému problému došlo. </p>
<pre><code class="language-bash">$ gcc -g -fsanitize=address main.c -o program
</code></pre>
<p>Jakmile takto přeložený program spustíte a dojde k nějaké chybě, tak bude její popis vypsán na výstup.</p>
<p>Pokud se chyba opraví těsně po svém vzniku, je to mnohem jednodušší, než když se chyba projeví až
později v úplně jiné části kódu. <strong>Doporučujeme tak vždy používat Address Sanitizer při vývoji programů v C</strong>.
Ušetříte si tak spoustu času a námahy při ladění chyb.</p>
<h4><a class="header" href="#valgrind" id="valgrind">Valgrind</a></h4>
<p>Address sanitizer je velmi užitečný nástroj, ale nedokáže odhalit všechny problémové situace v programech napsaných v
jazyce <em>C</em>. Dále existuje také nástroj <a href="https://valgrind.org/">Valgrind</a>, který dokáže odhalit možných chyb více
(např. čtení z <a href="prostredi/../c/promenne/promenne.html#v%C5%BEdy-inicializujte-prom%C4%9Bnn%C3%A9">nedefinované proměnné</a>). Pokud
se vás program chová &quot;divně&quot;, a Address sanitizer v něm nenachází žádné chyby, můžete místo něj zkusit Valgrind s
nástrojem Memcheck:</p>
<ol>
<li>Nejprve si nainstalujte Valgrind:
<pre><code class="language-bash">$ sudo apt update
$ sudo apt install valgrind
</code></pre>
</li>
<li>A poté spusťte svůj přeložený program pod Valgrindem/Memcheckem:
<pre><code class="language-bash">$ valgrind --tool=memcheck --track-origins=yes --leak-check=full -s ./program
</code></pre>
</li>
</ol>
<p>Valgrind a Address sanitizer nelze kombinovat, proto při použití Valgrindu <strong>nepoužívejte</strong> parametr překladače
<code>-fsanitize=address</code>. Stačí program přeložit pomocí <code>gcc -g main.c -o program</code>.</p>
<h4><a class="header" href="#logování" id="logování">Logování</a></h4>
<p>Jedním z nejjednodušších způsobů, jak se dozvědět, co se v programu děje, je jednoduše tisknout
hodnoty zajímavých proměnných na výstup programu. Pokud přidáte takovýto výstup na různá místa v kódu,
můžete pak podle výstupu zpětně rekonstruovat, co se při běhu programu dělo.</p>
<h4><a class="header" href="#krokování" id="krokování">Krokování</a></h4>
<p>Pro interaktivnější zkoumání chování programů je možné je tzv. <strong>krokovat</strong>. K tomu je potřeba nástroj,
který umí program pozastavit při jeho běhu a zobrazit uživateli, co se v něm děje. Takovéto nástroje se nazývají
<strong>debuggery</strong>. Při krokování se program zastaví na určitém místě (řádku) v kódu, a programátor pak může
zkoumat hodnoty proměnných a spouštět program řádek po řádku.</p>
<blockquote>
<p>Doporučujeme za začátku používat <strong>krokování</strong> neustále, abyste se naučili, jak se vlastně program
provádí a lépe tak pochopili, co vykonávají jednotlivé příkazy, které v kódu píšete. Je to také mocný
nástroj na hledání chyb v programech.</p>
</blockquote>
<p>Pro vás je nejjednodušší použít krokování integrované ve VS Code:</p>
<ul>
<li>Klikněte na sloupeček vlevo od čísla řádku, na kterém chcete, aby se program zastavil.
Objeví se tam červené kolečko (tzv. <strong>breakpoint</strong>).</li>
<li>Spusťte program s laděním (<code>F5</code>). Program by se na řádku s breakpointem měl zastavit.</li>
<li>Ve sloupci <code>Variables</code> v levé části VSCode můžete prozkoumat hodnoty proměnných.</li>
<li>Pomocí příkazu <code>Step Over</code> (<code>F10</code>) program vykoná následující řádek a poté se opět zastaví. Pokud
nechcete přeskakovat volání funkcí, použijte <code>Step Into</code> (<code>F11</code>).</li>
</ul>
<p><video src="../static/video/debugging.webm" controls></video></p>
<p>Pokud si <a href="prostredi/editor/vscode.html#instalace-roz%C5%A1%C3%AD%C5%99en%C3%AD-pomoc%C3%AD-termin%C3%A1lu">nainstalujete</a> rozšíření <a href="https://marketplace.visualstudio.com/items?itemName=jakub-beranek.memviz">Memory Visualizer</a>, tak se vám při krokování zároveň bude zobrazovat vizualizace paměti běžícího programu, což se může hodit pro pochopení toho, jak se váš program chová:</p>
<p><img src="prostredi/../static/img/vsc-memviz-screenshot.png" alt="memviz" /></p>
<p>Pro správné fungování rozšíření <code>Memory Visualizer</code> je nutné mít debugger <code>gdb</code> ve verzi 12.1 (nebo novější).
Verzi <code>gdb</code> můžete zjistit pomocí následujícího příkazu:</p>
<pre><code class="language-bash">$ gdb --version
</code></pre>
<blockquote>
<p>VS Code používá pro ladění vašeho programu debugger <code>gdb</code>. Pokud ho chcete použít manuálně, návod
můžete najít například <a href="https://www.root.cz/clanky/trasovani-a-ladeni-nativnich-aplikaci-v-linuxu-pouziti-gdb-a-jeho-nadstaveb/">zde</a>.</p>
</blockquote>
<h1><a class="header" href="#použití-ai" id="použití-ai">Použití AI</a></h1>
<p>Jistě jste zaznamenali, že lze dnes technologie velkých jazykových modelů (LLM), jako je např. ChatGPT nebo Claude, využít pro spoustu úkonů spojených s kontrolou, analýzou a generováním textu i kódu, vyhledáváním informací, vysvětlováním konceptů apod. Tyto technologie mohou být skvělými pomocníky pro dodatečné vysvětlení programovacích konceptů nebo např. provádění tzv. &quot;code review&quot; kódu, který napíšete, a může vám tak usnadnit výuku programování.</p>
<p>Je ale i jeden další způsob, jak tyto modely používat, který je bohužel pro účely UPR (a ostatně i většiny ostatních programovacích předmětů na FEI) extrémně problematický. Můžete tyto modely použít k tomu, abyste si nechali vygenerovat kompletní řešení nějaké programovací úlohy. Můžeme vám rovnou říci, že nástroje typu Claude Code budou schopny velmi rychle vyřešit pravděpodobně všechny úlohy, které vám v tomto předmětu zadáme. A to způsobem, kdy nemůžeme rozumně rozpoznat, jestli daný kód psal student, nebo jazykový model, bez toho, abychom zaváděli určité drakonické metody sledování toho, jak programy vytváříte.</p>
<p><strong>Chtěli bychom na vás apelovat, abyste jazykové modely nepoužívali pro generování kódu UPR úloh</strong>. Pokud si necháte řešení úloh vygenerovat, tak se tím absolutně nic nenaučíte. To je přitom smyslem studia na vysoké škole - naučit se, jak věci fungují na pozadí. Zastáváme názor, že programování se můžete opravdu naučit pouze tím, že budete programovat :) Tím, že budete zkoušet řešit čím dál tím složitější úlohy, budete se dostávat do situací, kdy nebudete vědět, jak daný problém vyřešit, a budete muset sami přijít na řešení.</p>
<p>Zatím přesně nevíme, jak bude vypadat budoucnost programování, a jakou roli v něm bude mít AI/LLM. Pokud chcete programovat pouze stylem psaní &quot;promptů&quot;, bez toho, abyste rozuměli, co se děje na pozadí, tak vám v tom nic nebrání - ale nemá smysl kvůli tomu studovat vysokou školu. Zkuste si tedy prosím rozmyslet, jestli se chcete něco naučit, nebo pouze psát prompty. Pokud za sebe necháte kód úloh generovat pomocí AI, tak tento předmět pro vás nemá opravdu žádný smysl.</p>
<p>Na konci semestru proběhne tzv. &quot;real-time test&quot;, kde budete muset naprogramovat netriviální úlohu v jazyce <em>C</em>. Na tomto testu budete programovat v kontrolovaném prostředí, kde budeme velmi striktně hlídat, abyste žádné jazykové modely nepoužívali. Pokud budete řešit domácí úlohy pomocí AI, a nenaučíte se tak programovat sami, tak tímto testem velmi pravděpodobně neprojdete.</p>
<h1><a class="header" href="#programování-v-c" id="programování-v-c">Programování v <em>C</em></a></h1>
<p>V této kapitole naleznete popis základních konstrukcí jazyka <em>C</em>, které jsou základními
stavebními kameny pro tvorbu programů. Ke každému tématu je k dispozici také sada úloh. Pokud úlohy
zvládnete vypracovat, tak budete mít jistotu, že jste dané téma pochopili a můžete se posunout dále.
Pokud nezvládnete úlohy splnit, tak můžete mít s navazujícími koncepty problém. Pokud nebudete
stíhat, tak kontaktujte svého cvičícího.</p>
<p>Před přečtením této kapitoly si nejprve přečtěte předchozí kapitoly, zejména sekci o
<a href="c/../uvod/pamet.html">paměti</a>.</p>
<p>Níže je přibližný seznam témat, které si během semestru ukážeme. Pořadí témat probíraných na cvičení
a přednáškách se může od tohoto seznamu lišit, tento text je určen spíše jako &quot;kuchařka&quot;, ve které
se můžete k jednotlivým tématům vracet, abyste si je připomněli. Text je nicméně psaný tak, aby se
dal zhruba číst v uvedeném pořadí bez toho, aby používal pojmy, které zatím nebyly vysvětleny.</p>
<h2><a class="header" href="#základní-témata" id="základní-témata">Základní témata</a></h2>
<ul>
<li><a href="c/syntaxe.html">Syntaxe</a> - jak vypadá syntaxe (způsob zápisu) jazyka <em>C</em></li>
<li><a href="c/prikazy_vyrazy.html">Příkazy a výrazy</a> - jak provádět výpočty</li>
<li><a href="c/promenne/promenne.html">Proměnné</a> - jak něco uložit a načíst z paměti</li>
<li><a href="c/datove_typy/datove_typy.html">Datové typy</a> - jak interpretovat hodnoty v paměti</li>
<li><a href="c/rizeni_toku/rizeni_toku.html">Řízení toku</a> - jak se rozhodovat a provádět akce opakovaně</li>
<li><a href="c/funkce/funkce.html">Funkce</a> - jak opakovaně využít a parametrizovat opakující se kód</li>
<li><a href="c/prace_s_pameti/ukazatele.html">Ukazatele</a> - jak sdílet data v paměti a pracovat s adresami</li>
<li><a href="c/pole/pole.html">Pole</a> - jak jednotně pracovat s velkým množstvím dat</li>
<li><a href="c/text/text.html">Text</a> - jak v programech pracovat s textem</li>
<li><a href="c/struktury/vlastni_datove_typy.html">Struktury</a> - jak vytvořit vlastní datové typy</li>
<li><a href="c/soubory/soubory.html">Soubory</a> - jak číst a zapisovat soubory</li>
<li><a href="c/modularizace/modularizace.html">Modularizace</a> - jak rozdělit program do více zdrojových souborů</li>
<li><a href="c/modularizace/knihovny.html">Knihovny</a> - jak využít existující kód od jiných programátorů</li>
</ul>
<p>Všechny tyto koncepty jsou velmi univerzální a v
tzv. <a href="https://cs.wikipedia.org/wiki/Imperativn%C3%AD_programov%C3%A1n%C3%AD">imperativních</a>
programovacích jazycích jsou v podstatě všudypřítomné. Jakmile se je jednou naučíte, tak je budete
moct využívat téměř v libovolném populárním programovacím jazyku (Java, C#, Kotlin, Python, PHP,
JavaScript, Rust, C++ atd.).</p>
<p>Zkomprimovanou formu těchto témat můžete naleznout v <a href="c/../ruzne/tahak.html">taháku</a>.</p>
<h2><a class="header" href="#upozornění-ohledně-využívání-umělé-inteligence" id="upozornění-ohledně-využívání-umělé-inteligence">Upozornění ohledně využívání umělé inteligence</a></h2>
<p>Jistě tušíte, že dnes je možné využívat nástroje umělé inteligence k tomu, aby vám pomáhaly s programováním, konkrétně
aby za vás přímo generovaly kód. Tyto nástroje mohou být velmi užitečné ve chvíli, kdy už víte, co děláte, a pouze si
chcete usnadnit práci. Pokud jste však na začátku, a teprve se programovat učíte, tak se z AI stane velmi zlý pán.
Umí sice vyřešit jednodušší úlohy, ale když si kód pouze necháte vygenerovat za vás, nic se tím nenaučíte. A u složitějších úloh (a následujících
předmětů, ve kterých budete už muset mít určitou znalost programování) už bude mít AI problém. Pokud za vás jednoduché úlohy
vyřeší někdo jiný, tak nezískáte znalosti potřebné k vyřešení složitějších úloh. Nebudete si ani umět ověřit, jestli je
vygenerovaný kód správný, a případně ho upravit nebo opravit. Bez této znalosti se ve světě programování neobejdete. I když
je to zpočátku náročné, toto se musíte naučit jedině neustálým zkoušením, experimentováním a programováním.</p>
<p>Pokud odevzdáte úlohy napsané pomocí AI, a nebudete je umět vysvětlit, upravit či napsat vlastním způsobem, budeme to vnímat
jako plagiarismus a podvádění, a reagovat na to odpovídající srážkou bodů.</p>
<p><strong>Proto vám silně doporučujeme V PŘEDMĚTU UPR NEPOUŽÍVAT UMĚLOU INTELIGENCI.</strong> Radši potrénujte svou vlastní :)</p>
<h2><a class="header" href="#navazující-aplikovaná-témata" id="navazující-aplikovaná-témata">Navazující aplikovaná témata</a></h2>
<ul>
<li><a href="c/aplikovane_ulohy/tga.html">TGA</a> - jak vytvořit obrázek</li>
<li><a href="c/aplikovane_ulohy/gif.html">GIF</a> - jak vytvořit animaci</li>
<li><a href="c/aplikovane_ulohy/sdl.html">SDL</a> - jak vytvořit interaktivní grafickou aplikaci či hru</li>
<li><a href="c/aplikovane_ulohy/chipmunk.html">Chipmunk</a> - jak simulovat fyzikální procesy</li>
</ul>
<h2><a class="header" href="#struktura-textu" id="struktura-textu">Struktura textu</a></h2>
<p>V textu se občas budou objevovat ikonky označující různé sekce či důležité pojmy. Zde je jejich vysvětlení:</p>
<ul>
<li>🏋: Sekce označené jako <strong>Cvičení</strong> 🏋 obsahují zadání krátkých úloh pro procvičení vysvětlované látky. Další úlohy k
procvičení naleznete také v kapitole <a href="c/../ulohy/ulohy.html">Úlohy</a>.</li>
<li>🤔: Sekce označené jako <strong>Kvízy</strong> 🤔 obsahují ukázky C programů, ve kterých dochází k různým &quot;zapeklitým situacím&quot;.
Vaší úlohou je zamyslet se nad tím, jak takovýto program bude fungovat, a např. si tipnout, jaký výstup vypíše,
či zda obsahuje tzv. nedefinované chování.</li>
<li>🤓: Kapitoly označené touto ikonou slouží jako doplňující učivo. To není nezbytně nutné zcela pochopit, abyste se mohli
v textu posunout dále. Pokud tedy nebudete stíhat nebo toho na vás bude moc, můžete tyto sekce prozatím přeskočit, nicméně
později byste se k nim měli vrátit.</li>
<li>💣: Označuje situace, při kterých dochází k <a href="c/../ruzne/nedefinovane_chovani.html">nedefinovanému chování</a>. Tyto situace
prostudujte obzvláště pečlivě!</li>
<li>📹: Označuje videozáznam s doplňujícím vysvětlením učiva.</li>
</ul>
<p><strong>Pouze si o programování číst nestačí k tomu, abyste se naučili programovat! Proto si co nejvíce cvičení, kvízů a úloh
vypracujte a naprogramujte, jedině tak se v programování zlepšíte.</strong></p>
<h1><a class="header" href="#základy-syntaxe" id="základy-syntaxe">Základy syntaxe</a></h1>
<p><em>C</em> je (programovací) jazyk a jako každý jazyk má svá pravidla, která je nutno dodržovat.
Například v češtině musíme dodržovat určitá pravidla a zvyklosti, abychom byli schopni výsledný
text pochopit. Věty <code>jsme, M y máma, táta a</code> nebo <code>.o dku  d! ty z, jsi</code> nedávají smysl,
protože obsahují interpunkční znaménka na špatných místech, větné členy jsou ve špatném pořadí
a některá slova obsahují mezery na místech, kam nepatří. Stejně tak v jazyce <em>C</em> můžete velmi jednoduše
napsat program, kterému <a href="c/../prostredi/preklad_programu.html">překladač</a> nebude rozumět a překlad poté skončí se
syntaktickou chybou (<em>syntax error</em>). Na syntax <em>C</em> si musíte postupně zvyknout, poté už podobné chyby
budete schopni snadno vyřešit.</p>
<p>Zde je asi nejkratší možný program v jazyce <em>C</em>:</p>
<pre><code class="language-c">int main() {
    return 0;
}
</code></pre>
<p>Tento program nic nedělá, pouze se zapne a poté vypne. V programu je pouze <a href="c/funkce/funkce.html">funkce</a>
s názvem <code>main</code>. Funkce si popíšeme později, prozatím budeme psát kód vždy uvnitř funkce <code>main</code>,
tj. mezi složené závorky <code>{</code> <code>}</code>, na řádky před <code>return 0;</code>. Jednotlivé prvky programu si
postupně vysvětlíme v následujících sekcích, prozatím si však všimněte, že <strong>bílé znaky</strong> (<em>whitespace</em>)<sup class='margin-toggle sidenote-number'>1</sup>
jsou obvykle překladačem ignorovány. Například</p>
<span class='sidenote'><p><sup class='number'>1</sup><a href="https://cs.wikipedia.org/wiki/B%C3%ADl%C3%BD_znak">Bílé znaky</a> jsou (neviditelné) znaky,
které reprezentují mezery v textu, tj. odřádkování, mezerník, tabulátor atd.</p>
</span>
<pre><code class="language-c">int 


main()                 {
    
    
    return         0;
}

</code></pre>
<p>reprezentuje úplně stejný program. Nicméně asi sami uznáte, že pokud bychom s bílými znaky nakládali
takto nerozvážně, tak by zdrojový kód byl pro lidi špatně čitelný. Ideální je
<a href="c/../prostredi/editor/vscode.html#automatick%C3%A9-form%C3%A1tov%C3%A1n%C3%AD-k%C3%B3du">nastavit si automatické formátování</a> přímo v editoru kódu, abyste
nad formátováním vůbec nemuseli přemýšlet.</p>
<p>Bílé znaky nicméně nejsou ignorovány úplně na všech místech. Později se dozvíme, že například v <a href="c/text/retezce.html">řetězcích</a>
jsou bílé znaky brány jako součást textu. Nemůžeme také rozdělovat mezerami názvy (např. <code>in t</code> nebo
<code>ma in</code>) v programu výše by způsobily chybu při překladu).</p>
<h3><a class="header" href="#komentáře" id="komentáře">Komentáře</a></h3>
<p>Abychom mohli v následujících sekcích popisovat kusy kódu, ukážeme si teď <strong>komentáře</strong>. Jedná se
o text ve zdrojovém kódu, který je určen pro programátory, a ne pro překladač, který je zcela ignoruje.
Bez komentářů bychom nemohli do zdrojového kódu dodávat poznámky, protože překladač by jinak měl snahu
je interpretovat jako <em>C</em> kód. Komentáře v kódu obvykle poznáte snadno, protože je váš editor bude vykreslovat
jinou barvou než zbytek kódu.</p>
<p>V <em>C</em> existují dva typy komentářů:</p>
<ul>
<li>Řádkové komentáře - pokud do kódu napíšete <code>//</code>, tak vše za těmito lomítky až do konce řádku se 
bude brát jako komentář.
<pre><code class="language-c">// komentář 1
int main() {
    // komentář 2
    return 0; // komentář 3
}
</code></pre>
</li>
<li>Blokové komenáře - pokud do kódu napíšete <code>/*</code>, tak bude jako komentář označen všechen následující
text, dokud nedojde k ukončení komentáře pomocí <code>*/</code>.
<pre><code class="language-c">int main() {
    /* zde je komentář
zde taky
a tady taky */
    return 0;
}
</code></pre>
</li>
</ul>
<p>Ze začátku je asi jednodušší používat řádkové komentáře, ve VS Code můžete použít klávesovou zkratku
<code>Ctrl + /</code> pro zakomentování/odkomentování řádku kódu. Pokud vám přijde nějaký kus kódu komplikovaný,
tak si k němu zkuste dopsat komentář, který vysvětlí, proč byl kód napsán právě takto (případně vyloženě popište, co kód dělá).
Porozumíte tak kódu snadněji, až se k němu např. za měsíc vrátíte.</p>
<h3><a class="header" href="#klíčová-slova" id="klíčová-slova">Klíčová slova</a></h3>
<p><strong>Klíčová slova</strong> (<em>keywords</em>) jsou vestavěné názvy, kterým překladač přiřazuje speciální
význam. V textovém editoru je typicky poznáte tak, že budou zabarvená jinou barvou než názvy
vytvořené programátorem. Například v tomto kódu jsou <code>int</code> a <code>return</code> klíčová slova:</p>
<pre><code class="language-c">int main() {
    return 0;
}
</code></pre>
<p>Během semestru se postupně naučíte, k čemu se jednotlivá klíčová slova používají. Jejich kompletní
seznam můžete najít například <a href="https://www.programiz.com/c-programming/list-all-keywords-c-language">zde</a>.</p>
<h3><a class="header" href="#speciální-znaky" id="speciální-znaky">Speciální znaky</a></h3>
<p>Při programování (jak už v <em>C</em>, tak i v jiných jazycích) budete používat spousty symbolů, které běžně
asi často nevyužíváte (například <code>[</code>, <code>]</code>, <code>{</code>, <code>}</code>, <code>&lt;</code>, <code>&gt;</code>, <code>=</code>, <code>%</code>, <code>#</code>, <code>&amp;</code>, <code>*</code>, <code>;</code>, <code>\</code>,
<code>&quot;</code>, <code>'</code>). Obzvláště pokud pro programování budete používat českou klávesnici, je dobré si ze začátku
najít nějaký tahák (např. <a href="https://github.com/geordi/upr-course/blob/master/assets/cheatsheets/keyboard-cs.pdf">tento</a>),
abyste nemuseli pokaždé zdlouhavě vzpomínat, na které klávese se daný znak nachází.</p>
<h3><a class="header" href="#formátování-kódu" id="formátování-kódu">Formátování kódu</a></h3>
<p>Už víme, že překladač ignoruje bílé znaky a celkové formátování kódu. Nicméně programátorům obvykle
velmi záleží na tom, jaké má kód odsazení, zarovnání, závorkování atd. Existuje mnoho
<a href="https://en.wikipedia.org/wiki/Indentation_style">stylů</a>, pomocí kterých můžete kód formátovat.
Například programátoři se dokážou pohádat o tom, zda složené závorky na začátku bloku psát na
stejném:</p>
<pre><code class="language-c">if (...) {

}
while (...) {

}
</code></pre>
<p>nebo novém řádku:</p>
<pre><code class="language-c">if (...)
{
}
while (...)
{
}
</code></pre>
<p>Jaký styl formátování použijete je na vás, nicméně obecně platným pravidlem je, že byste se měli
držet ve svých programech jednotného stylu a nemíchat více stylů dohromady.</p>
<p>Pokud budete využívat <a href="c/../prostredi/editor/vscode.html#automatick%C3%A9-form%C3%A1tov%C3%A1n%C3%AD-k%C3%B3du">automatické formátování</a> ve vašem editoru,
tak toto nemusíte vůbec řešit, protože editor bude kód formátovat automaticky za vás.</p>
<hr />
<p><strong>Cvičení</strong> 🏋</p>
<ol>
<li>Vytvořte si ve VS Code soubor pojmenovaný např. <code>main.c</code> (<code>File -&gt; New File…</code>) a nakopírujte nebo napište do něj
&quot;prázdný&quot; <em>C</em> program ukázaný výše. Zkuste program
<a href="c/../prostredi/preklad_programu.html#p%C5%99eklad-prvn%C3%ADho-programu">přeložit</a> a spustit.</li>
<li>Zkuste do kódu přidat komentáře nebo bílé znaky (např. prázdné řádky nebo mezery). Otestujte, že
překladač tyto věci při překladu ignoruje.</li>
<li>Zkuste v programu záměrně vložit mezeru např. do slova <code>main</code> nebo <code>int</code>. Podívejte se, jakou chybovou hlášku vám ukáže
překladač.</li>
</ol>
<h1><a class="header" href="#vykonávání-programů" id="vykonávání-programů">Vykonávání programů</a></h1>
<p>Jak už víme, programy jsou <a href="c/../uvod/programovaci_jazyky.html">sekvence příkazů</a> pro počítač, který je provádí
instrukci po instrukci (resp. řádek po řádku). Jakmile počítač vykoná jeden řádek vašeho programu, tak skočí
na řádek níže, dokud nedojde na konec programu. Aby počítač věděl, kterou instrukci má provést
jako první, tak mu musíme říct, kde má začít. K tomu přesně slouží <a href="c/funkce/funkce.html">funkce</a> (pojmenovaný
blok kódu) se speciálním názvem <code>main</code>:</p>
<pre><code class="language-c">int main() {
    // ZDE
    return 0;
}
</code></pre>
<p>Výše zmíněný program se po <a href="c/../prostredi/preklad_programu.html">překladu</a> a spuštění začne vykonávat na prvním řádku
funkce <code>main</code>, a jakmile provede všechny řádky, tak program skončí. Tento program je
v podstatě prázdný, takže se pouze zapne a vypne. Prozatím budeme veškerý kód psát dovnitř funkce
<code>main</code>, mezi složené závorky (<code>{</code>, <code>}</code>) a před řádek <code>return 0;</code> (tedy na místo komentáře <code>ZDE</code>).
<a href="c/../ruzne/funkce_main.html">Později</a> si vysvětlíme, jak tato funkce funguje, prozatím to berte tak,
že v programu vždy musí funkce <code>main</code> být, aby počítač věděl, odkud začít vykonávání kódu. </p>
<h1><a class="header" href="#příkazy" id="příkazy">Příkazy</a></h1>
<p>Programy v <em>C</em> se skládají z <strong>příkazů</strong> (<em>statements</em>). Příkaz říká počítači, co má provést, na
mnohem vyšší úrovni než <a href="c/../uvod/programovaci_jazyky.html">instrukce</a> - jeden C příkaz může být přeložen
překladačem na desítky instrukcí pro procesor. Existuje mnoho různých typů příkazů, které naleznete
v následujících sekcích. Většina příkazů nějakým způsobem pracuje s <em>výrazy</em>, začneme tedy jejich popisem.</p>
<h1><a class="header" href="#výrazy" id="výrazy">Výrazy</a></h1>
<p>Jak už vyplývá z jeho názvu, hlavní funkcí počítače je něco počítat. Jedním ze
základních konstrukcí jazyka <em>C</em> (i jiných programovacích jazyků) tak je možnost vypočítat různé hodnoty.
Něco, co se dá vypočítat (tak, aby výsledkem byla nějaká hodnota), se nazývá <strong>výraz</strong> (<em>expression</em>).
Příkladem asi nejjednoduššího výrazu je číslo, např. <code>5</code>. Takovýto výraz již není nutné dále vyhodnocovat,
jeho hodnota je prostě <code>5</code>. Pokud v programu použijete přímo hodnotu nějakého čísla (popř. něčeho
jiného, jak uvidíme později), tak se takový výraz označuje jako <strong>literál</strong> (<em>literal</em>).</p>
<p>V <em>C</em> můžeme s výrazy provádět různé operace pomocí <strong>operátorů</strong>. Můžeme například použít operátor <code>+</code>
s dvěma výrazy, čímž vznikne složitější výraz: <code>5 + 5</code>, který se v programu vyhodnotí na hodnotu <code>10</code>.
O operátorech si více povíme v kapitole o <a href="c/datove_typy/celociselne_typy.html#operace-s-%C4%8D%C3%ADseln%C3%BDmi-typy">datových typech</a>.</p>
<h3><a class="header" href="#výpis-výrazů" id="výpis-výrazů">Výpis výrazů</a></h3>
<p>Abyste si ze začátku mohli jednoduše zobrazit hodnoty výrazů, tak si ukážeme kód, pomocí kterého
můžete vypsat text na výstup programu (do terminálu). K výpisu textu můžete použít příkaz</p>
<pre><code class="language-c">printf(&quot;&lt;text&gt;&quot;);
</code></pre>
<p>Text, který vložíte mezi uvozovky (<code>&quot;</code>) se vypíše na výstup programu<sup class='margin-toggle sidenote-number'>2</sup>:</p>
<span class='sidenote'><p><sup class='number'>2</sup>Tento kód můžete modifikovat i spustit přímo v prohlížeči. Stačí kliknout na ikonu
<i class="fa fa-play"></i> vpravo nahoře nebo stisknout <code>Ctrl+Enter</code>.</p>
</span>
<pre><code class="language-c editable">#include &lt;stdio.h&gt;

int main() {
    printf(&quot;Hello world!\n&quot;);
    return 0;
}
</code></pre>
<p>Abyste <code>printf</code> mohli použít, musíte na začátek programu vložit řádek <code>#include &lt;stdio.h&gt;</code>.
Tento řádek i <code>printf</code> zatím berte jako &quot;black box&quot;, <a href="c/preprocesor/vkladani_souboru.html">později</a> si
vysvětlíme, jak přesně fungují.</p>
<p>V zadaném textu můžete používat určité speciální znaky. Například sekvence znaků <code>\n</code> způsobí, že
na výstupu dojde k <strong>odřádkování</strong> (<em>newline</em>), po kterém se text začne vypisovat na dalším řádku:</p>
<pre><code class="language-c editable">#include &lt;stdio.h&gt;

int main() {
    printf(&quot;Prvni radek\nDruhy radek&quot;);
    return 0;
}
</code></pre>
<p>Abyste mohli tisknout hodnoty výrazů, můžete použít <strong>zástupné znaky</strong> (<em>placeholders</em>). Pokud chcete
vypsat <em>číselnou</em> hodnotu na výstup programu, stačí v textu použít zástupný znak <code>%d</code>, za uvozovky
přidat čárku a doplnit výraz na místo určené komentářem:</p>
<pre><code class="language-c editable">#include &lt;stdio.h&gt;

int main() {
    printf(&quot;Cislo: %d\n&quot;, /* Hodnota tohoto výrazu se vypíše na výstup */ 1);
    return 0;
}
</code></pre>
<p>Když chcete vypsat například výsledek vyhodnocení výrazu <code>10 + 5</code>, tak stačí napsat:
<code>printf(&quot;%d\n&quot;, 10 + 5);</code> a na výstup programu by se měl vypsat text <code>15</code>.</p>
<p>Pokud chcete vytisknout více hodnot, tak prostě řádek s <code>printf(…);</code> zkopírujte a na uvedené místo
vložte jiný výraz. Počítač provádí programy řádek po řádku, odshora dolů. Doplňte na místo komentáře
do programu níže nějaký výraz a zkuste uhodnout, co se vypíše na výstup po přeložení a spuštění programu.</p>
<pre><code class="language-c editable">#include &lt;stdio.h&gt;

int main() {
    printf(&quot;%d\n&quot;, 1);
    printf(&quot;%d\n&quot;, /* tady vložte výraz */);
    return 0;
}
</code></pre>
<hr />
<p><strong>Cvičení</strong> 🏋</p>
<p>Zkuste si na místo komentáře doplnit několik výrazů (např. <code>5 + 8</code>, <code>8 * 3</code>, <code>12 * (2 + 3)</code>),
přeložit program, spustit ho a podívat se, co vypíše na výstup, abyste si vyzkoušeli vyhodnocování
výrazů. <strong>Zkuste to na svém počítači pomocí <a href="c/../prostredi/editor/editor.html">editoru</a> a <a href="c/../prostredi/preklad_programu.html">překladače</a>,
ne pouze v prohlížeči!</strong></p>
<hr />
<h3><a class="header" href="#datové-typy" id="datové-typy">Datové typy</a></h3>
<p>Každý výraz má svůj datový typ, který udává, jak je hodnota výrazu v programu interpretována a také
jaké operace má smysl nad výrazem dělat. Více o datových typech a operátorech se dozvíte v sekci
<a href="c/datove_typy/datove_typy.html">Datové typy</a>.</p>
<h3><a class="header" href="#příkazy-vs-výrazy" id="příkazy-vs-výrazy">Příkazy vs výrazy</a></h3>
<p>Jakmile se budete postupně učit o jednotlivých konstrukcích jazyka C, je důležité uvědomit si, jaký
je rozdíl mezi výrazem (něco, co se dá vypočítat) a příkazem, pomocí kterého počítači říkáme, aby
něco (s nějakým výrazem) udělal (například vypsal ho na výstup, zapsal do paměti atd.).</p>
<h3><a class="header" href="#vedlejší-efekty" id="vedlejší-efekty">Vedlejší efekty</a></h3>
<p>Pokud chcete pouze vypočítat výraz (&quot;jen tak&quot;), mimo nějaký příkaz, stačí za něj dát středník. Tím
ze samostatného výrazu uděláte příkaz:</p>
<pre><code class="language-c">1 + 1; // vypočte se `2`, výsledek se na nic nepoužije
</code></pre>
<p>Toto má smysl dělat pouze u výrazů, které mají nějaký <strong>vedlejší efekt</strong> (<em>side effect</em>), který
způsobí, že při provádění výrazu se v programu něco změní. Jinak by výraz sám o sobě byl vypočten,
ale nic dalšího by se nestalo. O výrazech, které umí produkovat vedlejší efekty, se dozvíte v pozdějších
sekcích.</p>
<h1><a class="header" href="#proměnné" id="proměnné">Proměnné</a></h1>
<p>Aby programy mohly řešit nějaký úkol, tak si téměř vždy musí umět něco zapamatovat. K tomu
slouží tzv. <strong>proměnné</strong> (<em>variables</em>). Proměnné nám umožňují pracovat s pamětí počítače (RAM)
intuitivním způsobem - část paměti si pojmenujeme nějakým jménem a dále se na ni tímto jménem
odkazujeme. Do proměnné poté můžeme uložit nějakou hodnotu, čímž si ji počítač &quot;zapamatuje&quot;. Tuto
hodnotu můžeme později v programu přečíst anebo ji změnit.</p>
<p>Příklady použití proměnných:</p>
<ul>
<li>Ve webové aplikaci si číselná proměnná pamatuje počet návštěvníků. Při zobrazení stránky
se hodnota proměnné zvýší o 1.</li>
<li>Ve hře si číselná proměnná pamatuje počet životů hráčovy postavy. Pokud dojde k zásahu postavy
nepřítelem, tak se počet životů sníží o zranění (<em>damage</em>) nepřítelovy zbraně. Pokud hráč sebere lékárníčku,
tak se počet jeho životů opět zvýší.</li>
<li>V terminálu si proměnná reprezentující znaky pamatuje text, který byl zadán na klávesnici.</li>
</ul>
<h3><a class="header" href="#definice" id="definice">Definice</a></h3>
<p>Proměnné jsou jedním z nejzákladnějších a nejčastěji používaných stavebních kamenů většiny programů, během
semestru se s nimi budeme setkávat neustále. Není tak náhodou, že jedním z nejzákladnějších příkazů
v <em>C</em> je právě vytvoření proměnné. Tím řekneme počítači, aby vyčlenil (tzv. <strong>naalokoval</strong>) místo v paměti,
které si v programu nějak pojmenujeme a dále se na něho pomocí jeho jména můžeme odkazovat<sup class='margin-toggle sidenote-number'>1</sup>.</p>
<span class='sidenote'><p><sup class='number'>1</sup>O tom, jak přesně tato alokace paměti probíhá, se dozvíte později v sekci o
<a href="c/promenne/../prace_s_pameti/automaticka_pamet.html">práci s pamětí</a>.</p>
</span>
<p>Takto vypadá příkaz <strong>definice</strong> (vytvoření) proměnné s názvem <code>vek</code> s datovým typem <code>int</code>:</p>
<pre><code class="language-c">int vek;
</code></pre>
<p>Jakmile proměnnou nadefinujeme, tak z ní můžeme buď číst anebo zapisovat paměť, kterou tato proměnná
reprezentuje, pomocí jejího názvu (zde <code>vek</code>).</p>
<h3><a class="header" href="#platnost" id="platnost">Platnost</a></h3>
<p>Proměnná je platná (lze ji používat) vždy od místa (řádku) definice do konce <strong>bloku</strong>, ve kterém byla
nadefinována. Bloky jsou kusy kódu ohraničené složenými závorkami (<code>{</code> a <code>}</code>):</p>
<pre><code class="language-c">int main() {
    // zde není platné ani `a`, ani `b`
    int a;
    // zde je platné pouze `a`

    {
        // zde je platné pouze `a`
        int b;
        // zde je platné `a` i `b`
    } // zde končí platnost proměnné `b`

    // zde je platné pouze `a`

    return 0;
} // zde končí platnost proměnné `a`
</code></pre>
<p>Všimněte si, že bloky lze vnořovat (lze vytvořit blok v bloku), a proměnné jsou platné i ve vnořených
blocích. Oblast kódu, ve které je proměnná validní, se nazývá <em>(variable) scope</em>.</p>
<h3><a class="header" href="#datový-typ" id="datový-typ">Datový typ</a></h3>
<p><code>int</code> před názvem proměnné udává její datový typ, o kterém pojednává <a href="c/promenne/../datove_typy/datove_typy.html">následující kapitola</a>.
Prozatím si řekněme, že <code>int</code> je zkratka pro <code>integer</code>, tedy celé číslo. Tím říkáme programu, že má
tuto proměnnou (resp. paměť, kterou proměnná reprezentuje) interpretovat jako celé číslo se znaménkem.</p>
<h3><a class="header" href="#inicializace" id="inicializace">Inicializace</a></h3>
<p>Do proměnné bychom měli při jejím vytvoření rovnou uložit nějaký <em>výraz</em>, který musí být stejného
datového typu jako je typ proměnné:</p>
<pre><code class="language-c">int a = 10;
int b = 10 + 15;
</code></pre>
<p>Obecná syntaxe pro definici proměnné je</p>
<p><code>&lt;datový typ&gt; &lt;název&gt;;</code></p>
<p>popřípadě</p>
<p><code>&lt;datový typ&gt; &lt;název&gt; = &lt;výraz&gt;;</code></p>
<p>pokud použijeme inicializaci.</p>
<blockquote>
<p>Všimněte si, že na konci definice proměnné vždy musí následovat středník (<strong>;</strong>).
Opomenutí středníku na konci příkazu je velmi častá chyba, která často končí těžko srozumitelnými chybovými
hláškami při překladu. Dávejte si tak na středníky pozor, obzvláště ze začátku.</p>
</blockquote>
<h4><a class="header" href="#vždy-inicializujte-proměnné" id="vždy-inicializujte-proměnné">Vždy inicializujte proměnné!</a></h4>
<p>Je opravdu důležité do proměnné vždy při její definici přiřadit nějakou úvodní hodnotu. Pokud to
neuděláme, tak její hodnota bude <strong>nedefinovaná</strong> (<em>undefined</em>). Čtení hodnoty takovéto nedefinované proměnné
způsobuje <a href="c/promenne/../../ruzne/nedefinovane_chovani.html"><strong>nedefinované chování</strong></a> (<em>undefined behaviour</em>, <em>UB</em>)<sup class='margin-toggle sidenote-number'>2</sup> programu.
Pokud k tomu dojde, tak si překladač s vaším programem může udělat, co se mu zachce, a váš program se poté může chovat nepředvídatelně.</p>
<span class='sidenote'><p><sup class='number'>2</sup>Situace, které můžou způsobit <a href="c/promenne/../../ruzne/nedefinovane_chovani.html">nedefinované chování</a>, budou dále v textu označené pomocí ikony
💣.</p>
</span>
<p><strong>Proto vždy dávejte proměnným iniciální hodnotu!</strong></p>
<h3><a class="header" href="#Čtení" id="Čtení">Čtení</a></h3>
<p>Pokud v programu použijeme název platné proměnné, tak vytvoříme výraz, který se vyhodnotí jako její
současná hodnota:</p>
<pre><code class="language-c editable">#include &lt;stdio.h&gt;

int main() {
    int a = 5;
    int b = a;  // hodnota `b` je 5
    int c = b + a + 1;  // hodnota `c` je 11

    printf(&quot;a = %d, b krat 2 = %d, c = %d&quot;, a, b * 2, c);

    return 0;
}
</code></pre>
<p>Proměnnou (resp. její název) tak lze použít kdekoliv, kde je očekáván výraz (pokud sedí datové typy).
Pro výpis hodnot proměnných na výstup programu můžete použít <code>printf</code>.
Hodnoty proměnných můžete zkoumat také krokováním pomocí <a href="c/promenne/../../prostredi/ladeni.html#krokov%C3%A1n%C3%AD">debuggeru</a>.</p>
<h3><a class="header" href="#zápis" id="zápis">Zápis</a></h3>
<p>Pokud by proměnná měla pouze svou původní hodnotu, tak by nebyla moc užitečná. Hodnoty proměnných
naštěstí jde měnit. Můžeme k tomu použít výraz <strong>přiřazení</strong> (<em>assignment</em>):</p>
<pre><code class="language-c editable">#include &lt;stdio.h&gt;

int main() {
    int a = 5;  // hodnota `a` je 5
    printf(&quot;%d\n&quot;, a);

    a = 8;      // hodnota `a` je nyní 8
    printf(&quot;%d\n&quot;, a);

    return 0;
}
</code></pre>
<p>Obecná syntaxe pro přiřazení do proměnné je</p>
<p><code>&lt;název proměnné&gt; = &lt;výraz&gt;</code></p>
<p>Opět musí platit, že výraz musí být stejného typu<sup class='margin-toggle sidenote-number'>3</sup>, jako je proměnná, do které přiřazujeme. Na konci
řádku také nesmí chybět středník. Přiřazení je příklad výrazu, který má <a href="c/promenne/../prikazy_vyrazy.html#vedlej%C5%A1%C3%AD-efekty">vedlejší efekt</a>.
Abychom z něj udělali příkaz, musíme za něj dát středník <code>;</code>.</p>
<span class='sidenote'><p><sup class='number'>3</sup><em>C</em> umožňuje automatické (tzv. <strong>implicitní</strong>) konverze mezi některými datovými typy, takže typ výrazu
nemusí být nutně vždy stejný. Tyto konverze se nicméně často chovají neintuitivně a překladač vás před nimi
obvykle nijak nevaruje, i když vrátí výsledek, který nedává smysl. Snažte se tak ze začátku opravdu vždy
používat odpovídající typy. Více se dozvíte v sekci o <a href="c/promenne/../datove_typy/datove_typy.html">datových typech</a>. </p>
</span>
<blockquote>
<p><strong>Jak přiřazení funguje?</strong> Počítač se podívá, na jaké adrese v paměti daná proměnná leží, a zapíše do
paměti hodnotu výrazu, který do proměnné zapisujeme, čímž změní její hodnotu v paměti. Z toho vyplývá,
že dává smysl zapisovat hodnoty pouze do něčeho, co má adresu v paměti<sup class='margin-toggle sidenote-number'>4</sup>. Například příkaz <code>5 = 8;</code> nedává smysl. <code>5</code>
je výraz, číselná hodnota, která nemá žádnou adresu v paměti, nemůžeme tak do ní nic zapsat. Stejně tak
jako nedává smysl říct <code>Číslo 5 odteď bude mít hodnotu 8</code>.</p>
<span class='sidenote'><p><sup class='number'>4</sup>Zatím známe pouze proměnné, později si však ukážeme <a href="c/promenne/../prace_s_pameti/ukazatele.html">další možnosti</a>, jak vytvořit
&quot;něco, co má adresu v paměti&quot;, a co tak půjde použít na levé straně výrazu přiřazení <code>=</code>.</p>
</span></blockquote>
<h3><a class="header" href="#kde-vytvářet-proměnné" id="kde-vytvářet-proměnné">Kde vytvářet proměnné?</a></h3>
<p>Proměnnou vždy vytvářejte (deklarujte) až na místě v programu, kde ji opravdu budete poprvé potřebovat. Bude pak mnohem
jasnější, k čemu se proměnná využívá, kde opravdu začíná její <a href="c/promenne/promenne.html#platnost">platnost</a>, a kde naopak ještě není potřeba.
Pokud byste všechny proměnné vytvořili na začátku funkce (bloku kódu, např. <code>main</code>)<sup class='margin-toggle sidenote-number'>5</sup>, tak nebude zřejmé, k čemu vlastně
jednotlivé proměnné jsou, a může se vám jednoduššeji stát, že proměnnou omylem použijete v kusu kódu, se kterým nesouvisí.</p>
<span class='sidenote'><p><sup class='number'>5</sup>Pokud už jste se s jazykem <em>C</em> dříve setkali, možná jste byli přesvědčeni, že musíte všechny proměnné deklarovat
již na začátku každé funkce. Vězte, že tomu tak není již zhruba 25 let, od standardu <code>C99</code> :)</p>
</span>
<h3><a class="header" href="#definice-více-proměnných-najednou" id="definice-více-proměnných-najednou">Definice více proměnných najednou</a></h3>
<p>Pokud potřebujete vytvořit více proměnných stejného datového typu, můžete použít více názvů
oddělených čárkou za datovým typem proměnné. Takto například lze vytvořit tři celočíselné proměnné
s názvy <code>x</code>, <code>y</code> a <code>z</code>:</p>
<pre><code class="language-c">int x = 1, y = 2, z = 3;
</code></pre>
<blockquote>
<p>Doporučujeme však tento způsob tvorby více proměnných spíše nepoužívat, aby byl kód přehlednější.</p>
</blockquote>
<hr />
<p><strong>Cvičení</strong> 🏋</p>
<ol>
<li>Zkuste napsat program, který vytvoří několik proměnných, přečte a změní jejich hodnoty
a pak je vypíše na výstup programu (k výpisu využijte <code>printf</code>, který jsme si již ukázali <a href="c/promenne/../prikazy_vyrazy.html#v%C3%BDpis-v%C3%BDraz%C5%AF">dříve</a>).</li>
<li>Použijte <a href="c/promenne/../../prostredi/ladeni.html#krokov%C3%A1n%C3%AD">debugger</a>, abyste se interaktivně za běhu programu
podívali, jaké jsou hodnoty jednotlivých proměnných a jak se měni v čase po provedení přiřazení.</li>
</ol>
<p>Více úloh naleznete <a href="c/promenne/../../ulohy/promenne.html">zde</a>.</p>
<hr />
<p><strong>Kvíz</strong> 🤔</p>
<ol>
<li>
<p>Co vypíše následující program?</p>
<pre><code class="language-c editable mainbody">#include &lt;stdio.h&gt;

int main() {
    int a = 5;
    printf(&quot;a\n&quot;);

    return 0;
}
</code></pre>
<details>
 <summary>Odpověď</summary>
<p>Program vypíše znak <code>a</code>, jelikož vše uvnitř uvozovek se bere jako text. Aby program vypsal
hodnotu proměnné <code>a</code>, museli bychom použít např. příkaz <code>printf(&quot;a=%d\n&quot;, a);</code>.</p>
</details>
</li>
<li>
<p>Co vypíše následující program?</p>
<pre><code class="language-c editable mainbody">#include &lt;stdio.h&gt;

int main() {
    int a = 5;
    printf(&quot;%d\n&quot;, a);
    a = 8;

    return 0;
}
</code></pre>
<details>
 <summary>Odpověď</summary>
<p>Program vypíše znak <code>5</code>, protože v době, kdy proměnnou vypisujeme, tak je její hodnota <code>5</code>.
Po vypsání proměnné sice její hodnotu změníme na <code>8</code>, ale poté už ji nevypíšeme a program skončí.</p>
</details>
</li>
<li>
<p>Co vypíše následující program?</p>
<pre><code class="language-c editable mainbody">#include &lt;stdio.h&gt;

int main() {
    int a = 5;
    a + 1;
    printf(&quot;%d\n&quot;, a);

    return 0;
}
</code></pre>
<details>
 <summary>Odpověď</summary>
<p>Program vypíše znak <code>5</code>. Provedeme sice výraz <code>a + 1</code>, který se vyhodnotí jako <code>6</code>, ale výsledek
tohoto výrazu se &quot;zahodí&quot;, nijak tedy neovlivní další chování programu. Abychom změnili hodnotu
proměnné <code>a</code>, museli bychom výsledek tohoto výrazu zpět do proměnné uložit: <code>a = a + 1;</code>.
Vyzkoušejte si to.</p>
</details>
</li>
<li>
<p>Co vypíše následující program?</p>
<pre><code class="language-c editable mainbody">#include &lt;stdio.h&gt;

int main() {
    int a = 5;
    int b = a;
    a = 8;

    printf(&quot;%d\n&quot;, a);
    printf(&quot;%d\n&quot;, b);

    return 0;
}
</code></pre>
<details>
 <summary>Odpověď</summary>
<p>Program vypíše:</p>
<pre><code>8
5
</code></pre>
<p>Při definici proměnné <code>b</code> jsme ji inicializovali hodnotou proměnné <code>a</code>. Výraz <code>a</code> se tedy
vyhodnotil jako hodnota <code>5</code>, která byla uložena do proměnné <code>b</code>. Dále však už spolu proměnné
nesouvisí, změna hodnoty proměnné <code>a</code> tedy nijak neovlivní hodnotu uloženou v proměnné <code>b</code>.</p>
</details>
</li>
<li>
<p>Co vypíše následující program?</p>
<pre><code class="language-c editable mainbody">#include &lt;stdio.h&gt;

int main() {
    printf(&quot;%d\n&quot;, a);
    int a = 5;

    return 0;
}
</code></pre>
<details>
 <summary>Odpověď</summary>
<p>Překlad programu skončí s chybou (<code>use of undeclared identifier 'a'</code>), protože se snažíme číst
hodnotu proměnné, která na daném řádku zatím nebyla nadefinována. Proměnnou <code>a</code> můžeme začít
používat až poté, co ji nadefinujeme, tj. za řádkem <code>int a = 5;</code>.</p>
</details>
</li>
<li>
<p>Co vypíše následující program?</p>
<pre><code class="language-c editable mainbody">#include &lt;stdio.h&gt;

int main() {
    a = 5;
    printf(&quot;%d\n&quot;, a);

    return 0;
}
</code></pre>
<details>
 <summary>Odpověď</summary>
<p>Překlad programu skončí s chybou (<code>use of undeclared identifier 'a'</code>), protože se snažíme zapsat
výraz <code>5</code> do proměnné, která neexistuje. Před prvním použitím proměnné ji vždy nejprve musíme
nadefinovat: <code>int a = 5;</code>.</p>
</details>
</li>
<li>
<p>Co vypíše následující program?</p>
<pre><code class="language-c editable mainbody">#include &lt;stdio.h&gt;

int main() {
    int a = 1;
    int b = a = 5;
    printf(&quot;%d\n&quot;, a);
    printf(&quot;%d\n&quot;, b);

    return 0;
}
</code></pre>
<details>
 <summary>Odpověď</summary>
<p>Program vypíše:</p>
<pre><code>5
5
</code></pre>
<p>Výraz přiřazení (<code>&lt;promenna&gt; = &lt;vyraz&gt;</code>) se vyhodnotí jako přiřazená hodnota (<code>&lt;vyraz&gt;</code>), a takto
vyhodnocený výraz lze dále v programu použít a např. přiřadit do jiné proměnné. Přiřazení se
vyhodnotí následovně:</p>
<pre><code class="language-c">int b = a = 5;
// int b = 5;
</code></pre>
<p>Nicméně jak asi sami uznáte, takovýto zápis je dosti zmatečný a nemusí být na první pohled jasné,
jak se takovýto výraz vyhodnotí. Proto výsledek výrazu přiřazení raději dále nepoužívejte a
přiřazení vždy používejte na samostatném řádku se středníkem.</p>
</details>
</li>
<li>
<p>Co vypíše následující program?</p>
<pre><code class="language-c editable mainbody">#include &lt;stdio.h&gt;

int main() {
    int a = 1;
    5 = a + 1;
    printf(&quot;%d\n&quot;, a);

    return 0;
}
</code></pre>
<details>
 <summary>Odpověď</summary>
<p>Překlad programu skončí s chybou <code>expression is not assignable</code>. Snažíme se zde uložit hodnotu
výrazu <code>a + 1</code> na nějaké místo v paměti, ale <code>5</code> žádné takové místo neoznačuje, <code>5</code> je prostě
číselný literál s hodnotou <code>5</code>, který nemůžeme přepsat či změnit.</p>
</details>
</li>
<li>
<p>Co vypíše následující program?</p>
<pre><code class="language-c editable mainbody">#include &lt;stdio.h&gt;

int main() {
    int a;
    printf(&quot;%d\n&quot;, a + 1);

    return 0;
}
</code></pre>
<details>
 <summary>Odpověď</summary>
<p>Tento program obsahuje <a href="c/promenne/../../ruzne/nedefinovane_chovani.html"><strong>nedefinované chování</strong></a> 💣, protože čteme
hodnotu proměnné, která nebyla inicializována, a její hodnota je tedy nedefinovaná. Nelze tak určit, co
tento program provede, překladač jej může přeložit na totální nesmysl. Takovýto program je špatně a nemá
smysl zkoumat, co provede, je potřeba jej nejprve opravit tak, že proměnnou <code>a</code> nainicializujeme.</p>
</details>
</li>
<li>
<p>Co vypíše následující program?</p>
<pre><code class="language-c editable mainbody">#include &lt;stdio.h&gt;

int main() {
    int a = a + 1;
    printf(&quot;%d\n&quot;, a);

    return 0;
}
</code></pre>
<details>
<summary>Odpověď</summary>
<p>Tento program obsahuje <a href="c/promenne/../../ruzne/nedefinovane_chovani.html"><strong>nedefinované chování</strong></a> 💣, stejně jako předchozí
ukázka. Při inicializaci proměnné <code>a</code> používáme její hodnotu, která ale v té době není definovaná. Je to jako kdybychom napsali</p>
<pre><code class="language-c">int a;
a = a + 1;
</code></pre>
</details>
</li>
<li>
<p>Co vypíše následující program?</p>
<pre><code class="language-c editable mainbody">#include &lt;stdio.h&gt;

int main() {
    printf(&quot;cislo: %d\n&quot;);

    return 0;
}
</code></pre>
<details>
<summary>Odpověď</summary>
<p>Tento program obsahuje <a href="c/promenne/../../ruzne/nedefinovane_chovani.html"><strong>nedefinované chování</strong></a> 💣. Pokud při použití
příkazu <code>printf</code> v textu mezi uvozovkami použijeme zástupný znak (<code>%d</code>), musíme za každý takovýto použitý
znak předat této <em>funkci</em> také nějaký celočíselný výraz. V opačném případě bude chování programu nedefinované.</p>
</details>
</li>
</ol>
<h1><a class="header" href="#globální-proměnné" id="globální-proměnné">Globální proměnné</a></h1>
<p>Proměnné, které jsme si ukázali, byly vytvářeny uvnitř <a href="c/promenne/../funkce/funkce.html">funkcí</a> (tj. ne na nejvyšší
úrovni souboru). Takovéto proměnné se nazývají <strong>lokální proměnné</strong>. Pokud chceme, aby k nějaké
proměnné byl přístup odkudkoliv v programu, tak můžeme vytvořit proměnnou na úrovni souboru.
Takovéto proměnné se nazývají <strong>globální</strong>.</p>
<p>V rámci jednoho souboru lze globální proměnnou použít od místa, kde je definována, až po
konec souboru:</p>
<pre><code class="language-c editable">#include &lt;stdio.h&gt;

// zde nelze použít proměnnou `globalni_promenna`

int globalni_promenna = 1;

// zde lze použít proměnnou `globalni_promenna`

int main() {
    // zde lze použít proměnnou `globalni_promenna`

    globalni_promenna += 1;
    printf(&quot;%d\n&quot;, globalni_promenna);

    return 0;
}

void funkce2() {
    // zde lze použít proměnnou `globalni_promenna`
    printf(&quot;%d\n&quot;, globalni_promenna);
}
</code></pre>
<h3><a class="header" href="#iniciální-hodnota" id="iniciální-hodnota">Iniciální hodnota</a></h3>
<p>Narozdíl od lokálních proměnných, globální proměnné se nainicializují na hodnotu <code>0</code><sup class='margin-toggle sidenote-number'>1</sup>, i když
jim žádnou úvodní hodnotu nedáte. I tak je ale dobrým zvykem úvodní hodnotu takovýmto proměnným dát,
aby šlo jasně vidět, že absence úvodní hodnoty není pouze nedopatřením ze strany programátora.</p>
<span class='sidenote'><p><sup class='number'>1</sup>Je to zajištěno tím, že jsou uloženy v sekci spustitelného souboru nazývané
<a href="https://en.wikipedia.org/wiki/.bss"><code>.bss</code></a>. Po spuštění programu jsou tak automaticky vynulovány.</p>
</span>
<h3><a class="header" href="#nepoužívání-globálních-proměnných" id="nepoužívání-globálních-proměnných">(Ne)používání globálních proměnných</a></h3>
<p>Globální proměnné jsou zde zmíněny pro úplnost, nicméně doporučujeme je používat spíše zřídka,
obzvláště pokud půjde o globální proměnné, které půjde měnit (tj. pokud to nebudou
<a href="c/promenne/konstanty.html">konstanty</a>). Obecně řečeno, na čím více místech je proměnná dostupná, tím složitější
je přemýšlení nad tím, jak přesně s ní pracovat, proto je lepší používat proměnné lokální, pokud to
jde. </p>
<p>Když je proměnná globální, tak je k ní přístup v podstatě odkudkoliv v programu. To sice zní
neškodně, ba i užitečně, nicméně přináší to s sebou značné nevýhody, pokud lze proměnnou zároveň
měnit. Jakmile totiž lze proměnnou odkudkoliv změnit, snadno se vám může stát, že nějaký kus programu
vám bude hodnotu takovéto proměnné měnit &quot;pod rukama&quot;, a bude obtížné najít kód, který danou proměnnou
změnil (a také důvod, proč ji změnil).</p>
<blockquote>
<p>Globální proměnné také mohou způsobovat problémy, pokud ve vašem problému budete využívat více jader
procesoru. Tzv. paralelní programy nicméně nebudeme v tomto předmětu řešit, více se o nich dozvíte
například v předmětu <a href="http://poli.cs.vsb.cz/edu/apps/">Architektury počítačů a paralelních systémů</a>.</p>
</blockquote>
<h1><a class="header" href="#konstanty" id="konstanty">Konstanty</a></h1>
<p>V určitých případech můžeme chtít mít proměnné s konstantní hodnotou, které by se neměly v průběhu
programu měnit. Takové proměnné se nazývají <strong>konstanty</strong> (<em>constants</em>).</p>
<p>Abychom zamezili nechtěné změně hodnoty konstanty, můžeme datový typ proměnné označit
<a href="c/promenne/../syntaxe.html#kl%C3%AD%C4%8Dov%C3%A1-slova">klíčovým slovem</a> <code>const</code>, který umístíme před<sup class='margin-toggle sidenote-number'>1</sup> název datového typu.
Pokud bychom se snažili o změnu proměnné s takovýmto datovým typem, překladač nám to nedovolí.</p>
<span class='sidenote'><p><sup class='number'>1</sup>Modifikátor <code>const</code> lze umístit i za datový typ. Někteří programátoři o umístění tohoto
modifikátoru vedou
<a href="https://mariusbancila.ro/blog/2018/11/23/join-the-east-const-revolution">vášnivé diskuze</a>. Důležité
hlavně je, abyste ve volbě umístění modifikátorů byli konzistentní a používali je na všech místech
stejně.</p>
</span>
<pre><code class="language-c editable mainbody">int main() {
    const int a = 5;
    a = a + 1; // chyba, nelze přeložit

    return 0;
}
</code></pre>
<p>Použití konstant může mít několik důvodů:</p>
<ul>
<li>
<p>V programech někdy opakovaně používáme konstantní hodnoty, které mají pevně danou hodnotu. Při
čtení zdrojového kódu nemusí být jasné, co takového hodnoty znamenají (v takovém případě se hanlivě
označují jako &quot;magické konstanty&quot;). Abychom takového hodnoty pojmenovali, můžeme je uložit do
konstantní proměnné. Při čtení programu pak bude zřejmé, co reprezentují. Porovnejte variantu
s nepopsanými číselnými hodnotami:</p>
<pre><code class="language-c">float vypocti_cenu(float cena) {
    return cena * (1 + 0.21);
}
float vypocti_odvod(float celkova_cena, bool dph) {
    if (dph) {
        return celkova_cena * 0.21;
    } else {
        return 0;
    }
}
</code></pre>
<p>s variantou využívající pojmenované konstanty:</p>
<pre><code class="language-c">const float DPH = 0.21f;

float vypocti_cenu(float cena) {
    return cena * (1 + DPH);
}
float vypocti_odvod(float celkova_cena, bool dph) {
    if (dph) {
        return celkova_cena * DPH;
    } else {
        return 0;
    }
}
</code></pre>
<p>Druhá varianta kódu je jistě čitelnější.</p>
</li>
<li>
<p>V určitých případech, například u konstantních <a href="c/promenne/../text/retezce.html">řetězců</a>, jsou data uložena v oblasti
paměti, kterou nelze měnit. Pomocí <code>const</code> si můžeme pohlídat, že se takováto paměť opravdu nezmění.</p>
</li>
</ul>
<h1><a class="header" href="#složený-zápis" id="složený-zápis">Složený zápis</a></h1>
<p>Často potřebujeme hodnotu proměnné pouze trochu poupravit, a ne do ní vyloženě zapsat novou hodnotu.
Běžná je například operace zvýšení hodnoty proměnné o <code>1</code> (tzv. <strong>inkrementace</strong> proměnné).
K tomu můžeme použít tento příkaz:</p>
<pre><code class="language-c">pocet = pocet + 1; // zvýšení hodnoty proměnné `pocet` o 1
</code></pre>
<p>nicméně to je docela zdlouhavé. Proto <em>C</em> nabízí tzv. operátory <strong>složeného zápisu</strong> (<em>compound
assignment</em>). Tyto operátory jsou spojené z normálního operátoru (např. <code>+</code>) a operátoru <code>=</code>, například:</p>
<ul>
<li><code>+=</code></li>
<li><code>-=</code></li>
<li><code>*=</code></li>
<li><code>/=</code></li>
</ul>
<p>Složený zápis</p>
<pre><code class="language-c">&lt;proměnná&gt; &lt;operátor&gt;= &lt;výraz&gt;;
</code></pre>
<p>je ekvivalentní příkazu</p>
<pre><code class="language-c">&lt;proměnná&gt; = &lt;proměnná&gt; &lt;operátor&gt; &lt;výraz&gt;;
</code></pre>
<p>Například:</p>
<pre><code class="language-c">int pocet = 0;
pocet += 1;   // stejné jako pocet = pocet + 1;
pocet *= 3;   // stejné jako pocet = pocet * 3; 
</code></pre>
<p>Stejně jako <a href="c/promenne/promenne.html#z%C3%A1pis">zápis</a> je složený zápis příkladem výrazu s
<a href="c/promenne/../prikazy_vyrazy.html#vedlej%C5%A1%C3%AD-efekty">vedlejším efektem</a>.</p>
<h3><a class="header" href="#inkrementace-a-dekrementace" id="inkrementace-a-dekrementace">Inkrementace a dekrementace</a></h3>
<p>Speciálním případem složeného zápisu je tzv. <strong>inkrementace</strong> (zvýšení hodnoty proměnné o jedničku)
a <strong>dekrementace</strong> (snížení hodnoty proměnné o jedničku). Tyto operace jsou tak časté, že <em>C</em> obsahuje
speciální &quot;zkratky&quot; pro jejich provedení. Aby to nebylo tak jednoduché, tak tyto zkratky
existují ve dvou variantách:</p>
<ul>
<li><em>Postfixová</em>: <code>&lt;proměnná&gt;++</code>. Tento výraz se nejprve vyhodnotí jako hodnota dané proměnné, a
<strong>poté</strong> (provede vedlejší efekt, který) zvýší hodnotu proměnné o jedničku. Zkuste uhodnout, co vypíše následující program:
<pre><code class="language-c editable mainbody">#include &lt;stdio.h&gt;

int main() {
    int a = 1;
    int b = a++;
    printf(&quot;%d\n&quot;, a);
    printf(&quot;%d\n&quot;, b);

    return 0;
}
</code></pre>
</li>
<li><em>Prefixová</em>: <code>++&lt;proměnná&gt;</code>. Tento výraz <strong>nejprve</strong> zvýší hodnotu proměnné, a až poté se vyhodnotí
jako (nová, již zvýšená) hodnota dané proměnné. Zkuste uhodnout, co vypíše následující program:
<pre><code class="language-c editable mainbody">#include &lt;stdio.h&gt;

int main() {
    int a = 1;
    int b = ++a;
    printf(&quot;%d\n&quot;, a);
    printf(&quot;%d\n&quot;, b);

    return 0;
}
</code></pre>
</li>
</ul>
<p>Dekrementace se chová totožně jako inkrementace, pouze s tím rozdílem, že snižuje hodnotu
proměnné o <code>1</code> a místo <code>++</code> používá <code>--</code>.</p>
<p>Inkrementace a dekrementace jsou opět příklady výrazů s vedlejším efektem.</p>
<blockquote>
<p>Tyto zkratky jsou sice užitečné, ale také můžou vyústit v překvapivé chování díky způsobu, kterým
jsou vyhodnocovány. Ze začátku je radši využívejte pouze v situacích, kdy budou použity jako příkaz,
který změní hodnotu proměnné (<code>i++;</code>). Jinak řečeno, raději se moc nespoléhejte na hodnotu, na
kterou se inkrementace/dekrementace vyhodnotí.</p>
</blockquote>
<h1><a class="header" href="#pojmenovávání-proměnných" id="pojmenovávání-proměnných">Pojmenovávání proměnných</a></h1>
<p>V <em>C</em> existují určitá pravidla pro pojmenování proměnných:</p>
<ul>
<li>Proměnné se nesmí jmenovat stejně jako <a href="c/promenne/../syntaxe.html#kl%C3%AD%C4%8Dov%C3%A1-slova">klíčová slova</a>, jinak by
překladač neuměl rozlišit, co je název proměnné a co klíčové slovo (například <code>int int;</code>).</li>
<li>Název proměnné může obsahovat pouze malá (<code>a-z</code>) a velká (<code>A-Z</code>) písmena anglické abecedy, číslice
(<code>0-9</code>) a podtržítko (<code>_</code>).</li>
<li>Název proměnné nesmí začínat číslicí, tj. <code>5x</code> není validní název proměnné.</li>
</ul>
<p>V programech je nutné neustále přiřazovat něčemu název, což zdaleka není tak jednoduché, jak se
může na první pohled zdát. Kromě výše zmíněných pravidel je zároveň vhodné volit názvy tak, aby byly
přehledné pro vás (a ostatní programátory, kteří váš zdrojový kód budou číst). Názvy proměnných jako
<code>a</code> nebo <code>x</code> jsou nicneříkající a kód s podobnými názvy je pak složitější pochopit. Porovnejte
následující dva úseky kódu, které se liší pouze v použitých názvech proměnných:</p>
<pre><code class="language-c">int c = 1337;
int x = c - y;
int d = x * z;

// vs

int zakladni_cena = 1337;
int zlevnena_cena = zakladni_cena - sleva;
int finalni_cena = zlevnena_cena * dph;
</code></pre>
<p>I když je druhá varianta delší, tak jde okamžitě poznat, co program počítá, narozdíl od první varianty.</p>
<h3><a class="header" href="#víceslovné-názvy" id="víceslovné-názvy">Víceslovné názvy</a></h3>
<p>Existuje několik zaběhlých stylistických způsobů pro zápis názvů v <em>C</em>, které obsahují více slov. Zde
je seznam nejpoužívanějších konvencí:</p>
<ul>
<li><strong>Camel case</strong>: <code>mujUcet</code>, <code>prvniKlikUzivatele</code></li>
<li><strong>Pascal case</strong>: <code>MujUcet</code>, <code>PrvniKlikUzivatele</code></li>
<li><strong>Snake case</strong>: <code>muj_ucet</code>, <code>prvni_klik_uzivatele</code></li>
<li><strong>Screaming snake case</strong>: <code>MUJ_UCET</code>, <code>PRVNI_KLIK_UZIVATELE</code></li>
</ul>
<p>Různé konstrukce <em>C</em> můžou využívat různé styly, například častá konvence je použití <code>snake_case</code>
pro názvy <a href="c/promenne/promenne.html">proměnných</a> a <a href="c/promenne/../funkce/funkce.html">funkcí</a> a <code>PascalCase</code> pro názvy
<a href="c/promenne/../struktury/struktury.html">struktur</a>. Který styl budete používat záleží na vaší osobní preferenci,
nicméně důležité je zejména držet se jednotného stylu a nekombinovat různé styly (pro stejný
typ konstrukcí) v jednom programu.</p>
<h3><a class="header" href="#Čeština-nebo-angličtina" id="Čeština-nebo-angličtina">Čeština nebo angličtina?</a></h3>
<p>Pokud vám to přijde přehlednější, tak ze začátku můžete používat české názvy<sup class='margin-toggle sidenote-number'>1</sup> pro názvy proměnných
a dalších konstrukcí. Může tak pro vás být snadnější odlišit, kterou část kódu jste vytvořili vy (ta
bude mít český název), a co je naopak vestavěná součást <em>C</em> (např. <code>int</code>). </p>
<span class='sidenote'><p><sup class='number'>1</sup>Bez diakritiky.</p>
</span>
<p>Nicméně, jak už bylo naznačeno v <a href="c/promenne/../../uvod/uvod.html">úvodu</a>, primárním jazykem programování je
angličtina. Pokud byste se někdy setkali s cizím kódem a museli ho pochopit či upravit, určitě oceníte,
když bude v angličtině, než kdyby byl například ve finštině. Stejně tak pokud budete sdílet svůj
kód online, můžete s ním oslovit mnohem širší skupinu programátorů, když bude v angličtině, než kdyby
byl v češtině.</p>
<p>Jakmile se tedy v programování trochu aklimatizujete, používejte ve všech svých programech raději
anglické názvy.</p>
<h1><a class="header" href="#datové-typy-1" id="datové-typy-1">Datové typy</a></h1>
<p><a href="c/datove_typy/../../uvod/pamet.html">Paměť</a> počítače pracuje s jednotlivými <em>byty</em>, nicméně pro lidi
je žádoucí používat popis dat v paměti na mnohem vyšší úrovni abstrakce, aby se nám o datech
jednoduššeji přemýšlelo. Pokud programujeme textový editor, chceme se bavit o znacích, odstavcích,
fontech či barvách, pokud programujeme počítačovou hru, chceme se bavit o zbraních, brnění, kouzlech
či pixelech.</p>
<p>Přesně k tomu slouží <strong>datové typy</strong>, které popisují, jak budeme interpretovat konkrétní hodnoty
daného typu v paměti, kolik bytů budou zabírat a jaké operace nad nimi budeme moct provádět. Jazyk
Nejprve se podíváme na několik datových typů, které jsou vestavěné v jazyce <em>C</em>, a
<a href="c/datove_typy/../struktury/struktury.html">později</a> si ukážeme, jak si vytvořit své vlastní datové typy.</p>
<h1><a class="header" href="#celočíselné-datové-typy" id="celočíselné-datové-typy">Celočíselné datové typy</a></h1>
<p>Asi nejpřirozenějším a nejpoužívanějším datovým typem ve většině programovacích jazyků jsou (celá)
čísla. Tyto číselné datové typy nám umožňují pracovat s celými čísly, které mají typicky jednotky
(1 - 8) bytů<sup class='margin-toggle sidenote-number'>1</sup>. Počet bytů udává, jak velký rozsah mohou hodnoty daného typu obsahovat. Například
číslo s 2 byty (16 bity) bez znaménka může obsahovat hodnoty 0 až 2<sup>16</sup>-1. Čím více bytů,
tím více zabere hodnota daného typu místa v paměti.</p>
<span class='sidenote'><p><sup class='number'>1</sup>I když 8 bytů (64 bitů) může znít jako málo, tak pomocí takového čísla můžeme vyjádřit 2<sup>64</sup>
(neboli <code>18 446 744 073 709 551 616</code>) různých hodnot, což pro naprostou většinu běžného použití čísel
bohatě stačí.</p>
</span>
<p>U celých číselných typů se rozlišuje, zda jsou <strong>signed</strong> (se znaménkem) nebo <strong>unsigned</strong> (bez
znaménka, nezáporné). Tato vlastnost udává, jaké hodnoty může typ nabývat
(tj. jestli mohou být i záporné nebo ne). Například číslem o velikosti jednoho bytu můžeme
reprezentovat 256 různých hodnot:</p>
<ul>
<li>Pokud ho budeme interpretovat bez znaménka, tak může uchovávat hodnoty 0 až 255.</li>
<li>Pokud ho budeme interpretovat se znaménkem, tak může uchovávat hodnoty -128 až 127.</li>
</ul>
<p><em>C</em> obsahuje několik základních typů celočíselných proměnných, které se liší v tom, kolik mají bytů a
jestli jsou znaménkové nebo ne. Pokud před název typu napíšeme <code>signed</code>, bude se jednat o znaménkový
typ, pokud použijeme <code>unsigned</code>, tak použijeme typ bez znaménka. Většina typů je implicitně se
znaménkem, tj. <code>int</code> je to samé jako <code>signed int</code>. V následující tabulce je seznam nejčastějších
celočíselných typů<sup class='margin-toggle sidenote-number'>2</sup>:</p>
<span class='sidenote'><p><sup class='number'>2</sup>Počet bytů (a znaménkovost u typu <code>char</code>) záleží na kombinaci použitého hardwaru,
operačního systému a překladače. Zde jsou uvedeny hodnoty, se kterými se můžete
nejčastěji setkat na 64-bitovém x86 Linuxovém systému s překladačem GCC při použití
<a href="https://cs.wikipedia.org/wiki/Dvojkov%C3%BD_dopln%C4%9Bk">dvojkového doplňku</a>.</p>
</span><table><thead><tr><th>Název</th><th align="center">Počet bytů</th><th align="center">Rozsah hodnot</th><th align="center">Se znaménkem</th></tr></thead><tbody>
<tr><td><code>char</code> nebo<br /><code>signed char</code></td><td align="center">1</td><td align="center">[-128; 127]</td><td align="center"><i class="fa fa-check"></i></td></tr>
<tr><td><code>unsigned char</code></td><td align="center">1</td><td align="center">[0; 255]</td><td align="center"><i class="fa fa-times"></i></td></tr>
<tr><td><code>short</code> nebo<br /><code>signed short</code></td><td align="center">2</td><td align="center">[-32 768; 32 767]</td><td align="center"><i class="fa fa-check"></i></td></tr>
<tr><td><code>unsigned short</code></td><td align="center">2</td><td align="center">[0; 65 535]</td><td align="center"><i class="fa fa-times"></i></td></tr>
<tr><td><strong><code>int</code></strong> nebo<br /><code>signed int</code></td><td align="center">4</td><td align="center">[-2 147 483 648; 2 147 483 647]</td><td align="center"><i class="fa fa-check"></i></td></tr>
<tr><td><code>unsigned int</code></td><td align="center">4</td><td align="center">[0; 4 294 967 295]</td><td align="center"><i class="fa fa-times"></i></td></tr>
<tr><td><code>long</code> nebo<br /><code>signed long</code></td><td align="center">8</td><td align="center">[-9 223 372 036 854 775 808;<br />9 223 372 036 854 775 807]</td><td align="center"><i class="fa fa-check"></i></td></tr>
<tr><td><code>unsigned long</code></td><td align="center">8</td><td align="center">[0; 18 446 744 073 709 551 615]</td><td align="center"><i class="fa fa-times"></i></td></tr>
</tbody></table>
<p>Každý vestavěný datový typ (<code>char</code>, <code>short</code>, <code>int</code>) a modifikátor znaménkovosti (<code>signed</code>, <code>unsigned</code>)
je zároveň klíčovým slovem.</p>
<p>Pokud ze začátku nebudete vědět, který typ zvolit, tak pro základní aritmetické operace používejte
ze začátku typy se znaménkem s 4 byty, tedy <code>int</code>. Tento typ je také implicitně použit, když v programu
použijete číselný výraz, například výraz <code>1</code> má datový typ <code>int</code><sup class='margin-toggle sidenote-number'>3</sup>.</p>
<span class='sidenote'><p><sup class='number'>3</sup>Pouze pokud by výraz nešel reprezentovat typem <code>int</code>, použije se číselný typ s více byty.</p>
</span>
<blockquote>
<p>Typ <code>char</code> je speciální v tom, že zároveň běžně reprezentuje textové znaky v
<a href="https://www.asciitable.com/">ASCII</a> kódování. Více o reprezentaci textu v programech se dozvíte
v sekci o <a href="c/datove_typy/../text/retezce.html">řetězcích</a>.</p>
</blockquote>
<h3><a class="header" href="#operace-s-číselnými-typy" id="operace-s-číselnými-typy">Operace s číselnými typy</a></h3>
<p><em>C</em> umožňuje provádět operace nad vestavěnými datovými typy pomocí tzv. <strong>operátorů</strong>. Při práci s
výrazy celočíselných typů lze provádět běžné aritmetické operace <code>+</code>, <code>-</code>, <code>/</code>, <code>*</code> nebo <code>%</code> (zbytek
po dělení). Například <code>5 + 8</code> nebo <code>2 * 16</code> tak bude obvykle fungovat tak, jak byste očekávali. Je si
ale třeba dát pozor na několik zrádných věcí:</p>
<ul>
<li>Při dělení dvou celočíselných čísel pomocí operátoru <code>/</code> dochází k celočíselnému dělení, tj. například
výsledek výrazu <code>5 / 2</code> je <code>2</code>, a ne <code>2.5</code>. Pokud chcete provádět dělení desetinných čísel, musíte
použít <a href="c/datove_typy/desetinne_typy.html">odpovídající</a> datový typ. Zkuste si to:
<pre><code class="language-c editable mainbody">#include &lt;stdio.h&gt;
int main() {
    printf(&quot;%d\n&quot;, 5 / 2);
    return 0;
}
</code></pre>
</li>
<li>Jelikož mají čísla v počítači omezenou přesnost (typicky několik jednotek bytů), tak může při matematických
operacích dojít k tzv. <strong>přetečení</strong> (<em>overflow</em>). Například pokud vynásobíme jednobytové číslo <code>50</code>
hodnotou <code>10</code>, tak bychom očekávali výsledek <code>500</code>, nicméně tak velké číslo nelze v jednom bytu reprezentovat.
Výsledkem místo toho bude <code>244</code> (<code>500 % 256</code>), pokud se jedná o číslo bez znaménka, nebo <code>-12</code>, pokud
jde o číslo se znaménkem. Podobné výsledky jsou silně neintuitivní, pokud tedy váš program vrácí zvláštní
číselný výsledek, zkontrolujte si, jestli neprovádíte operace, při kterých mohlo dojít k přetečení.</li>
<li><em>C</em> provádí <a href="https://www.guru99.com/c-type-casting.html">implicitní konverze</a> mezi datovými typy,
které mohou změnit datový typ výrazů, které používáte, bez vašeho vědomí. Je tak (obzvláště ze začátku)
vhodné ujistit se, že provádíte operace mezi stejnými datovými typy.</li>
<li>Stejně jako v matematice, tak i v <em>C</em> záleží u operátorů na jejich prioritě a asociativitě.
Seznam všech operátorů spolu s jejich prioritiou naleznete <a href="https://en.cppreference.com/w/c/language/operator_precedence">zde</a>.
Například výsledek výrazu <code>1 + 2 * 3</code> je <code>7</code>, a ne <code>9</code>. Pokud budete chtít prioritu ovlivnit, můžete
výrazy <strong>uzávorkovat</strong>, abyste jim dali větší přednost: <code>(1 + 2) * 3</code> se vyhodnotí jako <code>9</code>.</li>
</ul>
<p>Kromě základních aritmetických operací <em>C</em> podporuje také <a href="https://cs.wikipedia.org/wiki/Bitov%C3%A1_operace">bitové operace</a>:</p>
<ul>
<li>AND: operátor <code>&amp;</code></li>
<li>OR: operátor <code>|</code></li>
<li>XOR: operátor <code>^</code></li>
</ul>
<blockquote>
<p>Zkuste si procvičit, jestli správně rozumíte, jak <em>C</em> vyhodnocuje výrazy, na
<a href="c/datove_typy/../../ruzne/vyhodnocovani_vyrazu.html">této</a> stránce.</p>
</blockquote>
<hr />
<p><strong>Cvičení</strong> 🏋</p>
<p>Zkuste napsat jednoduchý program, který vypočítá různé matematické výrazy a vypíše
je na výstup. Vyhodnocování výrazů si můžete procvičit <a href="c/datove_typy/../../ruzne/vyhodnocovani_vyrazu.html">zde</a>
nebo <a href="c/datove_typy/../../ulohy/promenne.html">zde</a>. </p>
<hr />
<h3><a class="header" href="#tabulka-aritmetických-operátorů" id="tabulka-aritmetických-operátorů">Tabulka aritmetických operátorů</a></h3>
<p>Zde je pro přehlednost tabulka se základními aritmetickými operátory.
Datový typ výsledku těchto operátorů záleží na datovém typu jejich parametrů.</p>
<table><thead><tr><th align="center">Operátor</th><th align="center">Popis</th><th align="center">Příklad</th></tr></thead><tbody>
<tr><td align="center"><code>+</code></td><td align="center">Sečtení</td><td align="center"><code>1 + 5</code></td></tr>
<tr><td align="center"><code>-</code></td><td align="center">Odečtení</td><td align="center"><code>2.3 - 4.8</code></td></tr>
<tr><td align="center"><code>*</code></td><td align="center">Násobení</td><td align="center"><code>3 * 8</code></td></tr>
<tr><td align="center"><code>/</code></td><td align="center">Dělení</td><td align="center"><code>4 / 2</code></td></tr>
<tr><td align="center"><code>%</code></td><td align="center">Zbytek po dělení (modulo)</td><td align="center"><code>5 % 2</code></td></tr>
<tr><td align="center"><code>&amp;</code></td><td align="center">Bitový součin</td><td align="center"><code>12 &amp; 4</code></td></tr>
<tr><td align="center"><code>|</code></td><td align="center">Bitový součet</td><td align="center"><code>12 | 4</code></td></tr>
<tr><td align="center"><code>~</code></td><td align="center">Bitová negace</td><td align="center"><code>~8</code></td></tr>
<tr><td align="center"><code>^</code></td><td align="center">Bitový XOR</td><td align="center"><code>14 ^ 18</code></td></tr>
<tr><td align="center"><code>&lt;&lt;</code></td><td align="center">Bitový posun doleva</td><td align="center"><code>137 &lt;&lt; 2</code></td></tr>
<tr><td align="center"><code>&gt;&gt;</code></td><td align="center">Bitový posun doprava</td><td align="center"><code>140 &gt;&gt; 3</code></td></tr>
</tbody></table>
<p>O dalších typech operátorů se postupně dozvíte během semestru.
Plný seznam <em>C</em> operátorů naleznete <a href="https://en.cppreference.com/w/c/language/operator_precedence">zde</a>.</p>
<h3><a class="header" href="#hexadecimální-a-oktální-zápis-čísel" id="hexadecimální-a-oktální-zápis-čísel">Hexadecimální a oktální zápis čísel</a></h3>
<p>V <em>C</em> můžete zapisovat číselné hodnoty také pomocí oktální (osmičkové) či hexadecimální (šestnáctkové)
soustavy. Čísla začínající na <code>0</code> budou interpretována jako osmičková soustava, čísla začínající na
<code>0x</code> budou interpretována jako šestnáctková soustava:</p>
<pre><code class="language-c editable mainbody">#include &lt;stdio.h&gt;

int main() {
    int a = 13;     // hodnota 13
    int b = 015;    // hodnota 13
    int c = 0xD;    // hodnota 13
    printf(&quot;%d\n&quot;, a);
    printf(&quot;%d\n&quot;, b);
    printf(&quot;%d\n&quot;, c);

    return 0;
}
</code></pre>
<hr />
<p><strong>Kvíz</strong> 🤔</p>
<ol>
<li>
<p>Co vypíše následující program?</p>
<pre><code class="language-c editable mainbody">#include &lt;stdio.h&gt;

int main() {
    printf(&quot;%d\n&quot;, 1 + 3 * 8 - 2);

    return 0;
}
</code></pre>
<details>
 <summary>Odpověď</summary>
<p>Program vypíše <code>23</code>.</p>
</details>
</li>
<li>
<p>Co vypíše následující program?</p>
<pre><code class="language-c editable mainbody">#include &lt;stdio.h&gt;

int main() {
    int a = 1 + 4 * 2;
    int b = a + 2 * a;
    printf(&quot;%d\n&quot;, (b + 1) * 2);

    return 0;
}
</code></pre>
<details>
 <summary>Odpověď</summary>
<p>Program vypíše <code>56</code>.</p>
</details>
</li>
</ol>
<h1><a class="header" href="#desetinné-číselné-typy" id="desetinné-číselné-typy">Desetinné číselné typy</a></h1>
<p>Pokud budete chtít provádět výpočty s desetinnými čísly, tak můžete využít datové typy s tzv.
<strong>plovoucí řádovou čárkou</strong> (<em>floating point numbers</em>). Hodnoty těchto datových typů umožňují pracovat
s čísly, které se skládají z celé a z desetinné části. Díky
tomu, jak jsou <a href="https://cs.wikipedia.org/wiki/Pohybliv%C3%A1_%C5%99%C3%A1dov%C3%A1_%C4%8D%C3%A1rka">navržena</a>,
tato čísla dokáží reprezentovat jak velmi malé, tak velmi velké hodnoty (za cenu menší přesnosti
desetinné části).</p>
<p>V <em>C</em> jsou dva základní vestavěné datové typy pro práci s desetinnými čísly, které se liší velikostí
(a tedy i tím, jak přesně dokáží desetinná čísla reprezentovat). Oba dva typy jsou znaménkové:</p>
<table><thead><tr><th>Název</th><th align="center">Počet bytů</th><th align="center">Rozsah hodnot</th><th align="center">Přesnost</th><th align="center">Se znaménkem</th></tr></thead><tbody>
<tr><td><code>float</code></td><td align="center">4</td><td align="center">[-3.4x10<sup>38</sup>; 3.4x10<sup>38</sup>]</td><td align="center">~7 des. míst</td><td align="center"><i class="fa fa-check"></i></td></tr>
<tr><td><code>double</code></td><td align="center">8</td><td align="center">[-1.7x10<sup>308</sup>; 1.7x10 <sup>308</sup>]</td><td align="center">~16 des. míst</td><td align="center"><i class="fa fa-check"></i></td></tr>
</tbody></table>
<p>Slovo <code>double</code> pochází z pojmu &quot;double precision&quot;, tedy dvojitá přesnost (typ <code>float</code> se také někdy
označuje pomocí &quot;single precision&quot;).</p>
<p>Pokud chcete v programu vytvořit výraz datového typu <code>double</code>, stačí napsat desetinné číslo (jako
desetinný oddělovač se používá tečka, ne čárka): <code>10.5</code>, <code>-0.73</code>. Pokud chcete vytvořit výraz typu
<code>float</code>, tak za toto číslo ještě přidejte znak <code>f</code>: <code>10.5f</code>, <code>-0.73f</code>.</p>
<h3><a class="header" href="#formátovaný-výstup-desetinných-čísel" id="formátovaný-výstup-desetinných-čísel">Formátovaný výstup desetinných čísel</a></h3>
<p>Pokud chcete vytisknout na výstup hodnotu datového typu <code>float</code> nebo <code>double</code>, můžete použít
<a href="c/datove_typy/../prikazy_vyrazy.html#v%C3%BDpis-v%C3%BDraz%C5%AF">zástupný znak</a> <code>%f</code>:</p>
<pre><code class="language-c">printf(&quot;Desetinne cislo: %f\n&quot;, 1.0);
</code></pre>
<p>Jednoduché použití zástupného znaku <code>%f</code> však způsobí, že se desetinné číslo vypíše v rozvoji,
tj. pro číslo <code>1.0</code> se vypíše do termínálu <code>1.000000</code>.</p>
<p>Abychom mohli specifikovat, kolik číslic chceme vypsat za desetinnou tečkou, musíme k zástupnému znaku
doplnit formátování. Pro datový typ <code>float</code> a <code>double</code> používáme následující syntaxi:</p>
<pre><code class="language-c">printf(&quot;Desetinne cislo: %.2f\n&quot;, 1.0);
</code></pre>
<p>kde před zástupný znak <code>f</code> napíšeme <code>.</code> a doplníme požadovaným počtem číslic za desetinnou tečkou.
Takto specifikovaný řetězec se zástupným znakem již vytiskne číslo <code>1.00</code>.</p>
<h3><a class="header" href="#přesnost-desetinných-čísel" id="přesnost-desetinných-čísel">Přesnost desetinných čísel</a></h3>
<p>Je třeba si uvědomit, že desetinná čísla v počítači mají pouze konečnou přesnost a jsou reprezentována
v dvojkové soustavě:</p>
<ul>
<li>V počítači nelze reprezentovat iracionální čísla s nekonečnou přesností. Pokud tedy chcete do paměti
uložit například hodnotu <code>π</code>, budete ji muset zaokrouhlit.</li>
<li>Kvůli použití dvojkové soustavy některé desetinné hodnoty nelze vyjádřit přesně. Například číslo
\( \frac{1}{3} \) lze v desítkové soustavě vyjádřit zlomkem, ale v dvojkové soustavě toto číslo
má nekonečný desetinný rozvoj (<code>0.010101…</code>) a opět tedy nelze vyjádřit přesně:
<pre><code class="language-c editable mainbody">#include &lt;stdio.h&gt;
int main() {
    printf(&quot;%f\n&quot;, 1.0 / 3.0);
    return 0;
}
</code></pre>
</li>
</ul>
<h3><a class="header" href="#konverze-na-celé-číslo" id="konverze-na-celé-číslo">Konverze na celé číslo</a></h3>
<p>Pokud budete <a href="c/datove_typy/konverze.html">konvertovat</a> desetinné číslo na celé číslo, tak dojde k &quot;useknutí&quot;
desetinné části:</p>
<pre><code class="language-c editable mainbody">#include &lt;stdio.h&gt;
int main() {
    printf(&quot;%d\n&quot;, (int) 1.6);
    printf(&quot;%d\n&quot;, (int) -1.6);
    return 0;
}
</code></pre>
<p>Toto chování odpovídá zaokrouhlení k nule, tj. kladná čísla se zaokrouhlí dolů a záporná čísla nahoru.</p>
<hr />
<p><strong>Kvíz</strong> 🤔</p>
<ol>
<li>
<p>Co vypíše následující program?</p>
<pre><code class="language-c editable mainbody">#include &lt;stdio.h&gt;

int main() {
    printf(&quot;%d\n&quot;, 1.5);

    return 0;
}
</code></pre>
<details>
 <summary>Odpověď</summary>
<p>Tento program obsahuje <a href="c/datove_typy/../../ruzne/nedefinovane_chovani.html"><strong>nedefinované chování</strong></a> 💣. Pokud při použití příkazu
<code>printf</code> v textu mezi uvozovkami použijeme zástupný znak <code>%d</code>, musíme za čárkou předat výraz datového typu celého
čísla. Zde jsme ale předali výraz datového typu desetinného čísla.</p>
</details>
</li>
<li>
<p>Co vypíše následující program?</p>
<pre><code class="language-c editable mainbody">#include &lt;stdio.h&gt;

int main() {
    float a = 2.0f;
    float b = 5.0f;
    int c = b / a;
    printf(&quot;%d\n&quot;, c);

    return 0;
}
</code></pre>
<details>
 <summary>Odpověď</summary>
<p>Program vypíše <code>2</code>, protože výraz desetinného číselného typu <code>b / a</code>, který se vyhodnotil na
<code>2.5</code>, byl poté uložen do proměnné celočíselného typu, která si z něj ponechala pouze celou část,
tj. <code>2</code>.</p>
</details>
</li>
</ol>
<h1><a class="header" href="#pravdivostní-typy" id="pravdivostní-typy">Pravdivostní typy</a></h1>
<p>Posledním základním datovým typem, který si ukážeme, je pravdivostní typ
<strong><a href="https://cs.wikipedia.org/wiki/Boolean">Booleovské logiky</a></strong>. Hodnoty tohoto datového typu mají
pouze dvě možné varianty - <strong>pravda</strong> (<em>true</em>) nebo <strong>nepravda</strong> (<em>false</em>). Tento typ se hodí
zejména pro různé logické operace, například porovnávání hodnot (<code>Je a menší než b?</code> - <code>ano</code>/<code>ne</code>).</p>
<p>V <em>C</em> se Booleovský datový typ nazývá <code>_Bool</code>. Nicméně tento název je docela krkolomný, obvykle se
proto používá spíše název <code>bool</code>. Abyste ho mohli použít, tak na začátek programu musíte vložit řádek
<code>#include &lt;stdbool.h&gt;</code>. <a href="c/datove_typy/../preprocesor/vkladani_souboru.html">Později</a> si vysvětlíme, co tento řádek
dělá.</p>
<pre><code class="language-c editable mainbody">#include &lt;stdbool.h&gt;
#include &lt;stdio.h&gt;

int main() {
    bool venku_je_hezky = true;
    bool upr_je_slozite = false;

    printf(&quot;%d\n&quot;, venku_je_hezky);
    printf(&quot;%d\n&quot;, upr_je_slozite);

    return 0;
}
</code></pre>
<p>Jak lze v ukázce výše vidět, <code>true</code> reprezentuje pravdivý Booleovský výraz a <code>false</code> nepravdivý
Booleovský výraz a <code>bool</code> hodnoty lze vytisknout na výstup stejným způsobem jako celočíselné hodnoty.<sup class='margin-toggle sidenote-number'>1</sup>
Hodnoty Booleovského typu obvykle zabírají v paměti jeden <em>byte</em>.</p>
<span class='sidenote'><p><sup class='number'>1</sup>Při výpisu dojde ke <a href="c/datove_typy/pravdivostni_typy.html#konverze">konverzi</a> <code>bool</code>u na celé číslo.</p>
</span>
<h3><a class="header" href="#logické-operace" id="logické-operace">Logické operace</a></h3>
<p>V (Booleovské) logice existují tři základní operátory:</p>
<ul>
<li><strong>logický součin</strong> (<em>AND</em>): <code>platí X a zároveň Y</code></li>
<li><strong>logický součet</strong> (<em>OR</em>): <code>platí X nebo Y</code></li>
<li><strong>logická negace</strong> (<em>NOT</em>): <code>neplatí X</code></li>
</ul>
<p>Tyto logické operace lze v <em>C</em> použít pomocí následujících operátorů:</p>
<ul>
<li><strong>AND</strong>: <code>&amp;&amp;</code></li>
<li><strong>OR</strong>: <code>||</code></li>
<li><strong>NOT</strong>: <code>!</code></li>
</ul>
<p>Tyto operátory můžete použít mezi dvěma výrazy datového typu <code>bool</code>. Například:</p>
<pre><code class="language-c">bool je_muz = true;
bool je_zena = false;
bool je_clovek = je_muz || je_zena; // true || false -&gt; true

bool je_rodic = true;
bool je_otec = je_rodic &amp;&amp; je_muz;  // true &amp;&amp; true -&gt; true
bool je_matka = je_rodic &amp;&amp; !je_otec; // true &amp;&amp; !true -&gt; true &amp;&amp; false -&gt; false
</code></pre>
<p>Pro připomenutí, zde je pravdivostní tabulka těchto logických operátorů:</p>
<table><thead><tr><th><code>X</code></th><th align="center"><code>Y</code></th><th align="center"><code>X &amp;&amp; Y</code></th><th align="center"><code>X || Y</code></th><th align="center"><code>!X</code></th></tr></thead><tbody>
<tr><td><code>false</code></td><td align="center"><code>false</code></td><td align="center"><code>false</code></td><td align="center"><code>false</code></td><td align="center"><code>true</code></td></tr>
<tr><td><code>false</code></td><td align="center"><code>true</code></td><td align="center"><code>false</code></td><td align="center"><code>true</code></td><td align="center"><code>true</code></td></tr>
<tr><td><code>true</code></td><td align="center"><code>false</code></td><td align="center"><code>false</code></td><td align="center"><code>true</code></td><td align="center"><code>false</code></td></tr>
<tr><td><code>true</code></td><td align="center"><code>true</code></td><td align="center"><code>true</code></td><td align="center"><code>true</code></td><td align="center"><code>false</code></td></tr>
</tbody></table>
<h3><a class="header" href="#porovnávání-hodnot" id="porovnávání-hodnot">Porovnávání hodnot</a></h3>
<p>Při programování často potřebujete porovnat hodnoty mezi sebou:</p>
<ul>
<li><code>Má Jarda více bodů než Kamil?</code></li>
<li><code>Má uživatelovo heslo více než 5 znaků?</code></li>
<li><code>Má Lenka na účtu alespoň 100 dolarů?</code></li>
</ul>
<p>K tomu slouží šest základních porovnávacích operátorů:</p>
<ul>
<li><strong>Rovná se</strong><sup class='margin-toggle sidenote-number'>2</sup>: <code>==</code><span class='sidenote'><p><sup class='number'>2</sup>Zde si dávejte velký pozor na rozdíl mezi <code>=</code> (přiřazení hodnoty) a <code>==</code> (porovnání dvou hodnot).
Záměna těchto dvou operátorů je častou <a href="c/datove_typy/../../caste_chyby/caste_chyby.html#z%C3%A1m%C4%9Bna--a-">začátečnickou chybou</a>
a vede k obtížně nalezitelným chybám.</p>
</span></li>
<li><strong>Nerovná se</strong>: <code>!=</code></li>
<li><strong>Větší</strong>: <code>&gt;</code></li>
<li><strong>Větší nebo rovno</strong>: <code>&gt;=</code></li>
<li><strong>Menší</strong>: <code>&lt;</code></li>
<li><strong>Menší nebo rovno</strong>: <code>&lt;=</code></li>
</ul>
<p>Porovnávat mezi sebou můžete libovolné hodnoty dvou stejných datových typů. Výsledkem porovnání
je výraz datového typu <code>bool</code>:</p>
<pre><code class="language-c">int jarda_body = 13;
int kamil_body = 10;

bool remiza = jarda_body == kamil_body; // false
bool vyhra_jardy = jarda_body &gt; kamil_body; // true

int delka_hesla = 8;
bool heslo_moc_kratke = delka_hesla &lt;= 5; // false
</code></pre>
<p>Dávejte si ovšem pozor na to, že pouze operátory <code>==</code> a <code>!=</code> lze použít univerzálně na všechny datové typy.
Například použít <code>&lt;</code> pro porovnání dvou Booleovských hodnot obvykle nedává valný smysl, operátory
<code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code> a <code>&gt;=</code> jsou obvykle využívány pouze pro porovnávání čísel.</p>
<p>Porovnávání hodnot můžete zkombinovat s logickými operátory pro vyhodnocení komplexních pravdivostních
výrazů:</p>
<pre><code class="language-c editable mainbody">#include &lt;stdbool.h&gt;
#include &lt;stdio.h&gt;

int main() {
    int delka_hesla = 8;
    bool email_overen = false;
    int rok_narozeni = 1994;

    bool uzivatel_validni = delka_hesla &gt;= 9 &amp;&amp; (email_overen || rok_narozeni &gt; 1990); // false
    bool uzivatel_validni2 = delka_hesla &gt;= 9 &amp;&amp; email_overen || rok_narozeni &gt; 1990; // true

    printf(&quot;%d\n&quot;, uzivatel_validni);
    printf(&quot;%d\n&quot;, uzivatel_validni2);

    return 0;
}
</code></pre>
<p>Zde je opět třeba dávat si pozor na <a href="https://en.cppreference.com/w/c/language/operator_precedence">prioritu operátorů</a>
(například <code>&amp;&amp;</code> má větší prioritu než <code>||</code>) a v případě potřeby výrazy uzávorkovat. Pokud si zkusíte
přeložit tento program, tak vás dokonce překladač bude varovat před tím, že jste výraz neuzávorkovali a
může tak vracet jiný výsledek, než očekáváte.</p>
<h3><a class="header" href="#tabulka-logických-operátorů" id="tabulka-logických-operátorů">Tabulka logických operátorů</a></h3>
<p>Zde je pro přehlednost tabulka s logickými operátory.
Datový typ výsledku je u těchto operátorů vždy <code>bool</code>.</p>
<table><thead><tr><th align="center">Operátor</th><th align="center">Popis</th><th align="center">Příklad</th></tr></thead><tbody>
<tr><td align="center"><code>&amp;&amp;</code></td><td align="center">Logický součin (AND)</td><td align="center"><code>a == b &amp;&amp; c &gt;= d</code></td></tr>
<tr><td align="center"><code>||</code></td><td align="center">Logický součet (OR)</td><td align="center"><code>a &lt; b || c == d</code></td></tr>
<tr><td align="center"><code>!</code></td><td align="center">Logická negace (NOT)</td><td align="center"><code>!(a &gt; b &amp;&amp; c &lt; d)</code></td></tr>
<tr><td align="center"><code>==</code></td><td align="center">Rovná se</td><td align="center"><code>a == 5</code></td></tr>
<tr><td align="center"><code>!=</code></td><td align="center">Nerovná se</td><td align="center"><code>a != 5</code></td></tr>
<tr><td align="center"><code>&gt;</code></td><td align="center">Větší než</td><td align="center"><code>a &gt; 5</code></td></tr>
<tr><td align="center"><code>&gt;=</code></td><td align="center">Větší nebo rovno než</td><td align="center"><code>a &gt;= 5</code></td></tr>
<tr><td align="center"><code>&lt;</code></td><td align="center">Menší než</td><td align="center"><code>a &lt; 5</code></td></tr>
<tr><td align="center"><code>&lt;=</code></td><td align="center">Menší nebo rovno než</td><td align="center"><code>a &lt;= 5</code></td></tr>
</tbody></table>
<h3><a class="header" href="#zkrácené-vyhodnocování" id="zkrácené-vyhodnocování">Zkrácené vyhodnocování</a></h3>
<p>Při vyhodnocování Booleovských výrazů s logickými operátory se v <em>C</em> používá tzv. <strong>zkrácené vyhodnocování</strong>
(<em>short-circuit evaluation</em>). Například pokud se vyhodnocuje výraz <code>a || b</code>, tak může dojít k následující
situaci:</p>
<ul>
<li>Počítač vše provádí v sekvenčních krocích, tj. nejprve vyhodnotí <code>a</code>.</li>
<li>Pokud má výraz <code>a</code> hodnotu <code>true</code>, tak už je jasné, že celý výraz <code>a || b</code> bude mít hodnotu <code>true</code>.</li>
<li>K vyhodnocení výrazu <code>b</code> tak už nedojde, protože je to zbytečné.</li>
</ul>
<p>Toto chování může urychlit provádění programu, protože přeskakuje provádění zbytečných příkazů,
nicméně může také způsobit nečekané chyby. Pokud by například vyhodnocení výrazu <code>b</code> obsahovalo nějaké
<a href="c/datove_typy/../prikazy_vyrazy.html#vedlej%C5%A1%C3%AD-efekty">vedlejší efekty</a>, které se projeví při jeho provedení (například
změna hodnoty v paměti), tak může být problematické, pokud se vyhodnocení tohoto výrazu zcela
přeskočí. Pokud si pamatujete na <a href="c/datove_typy/../promenne/slozeny_zapis.html#inkrementace-a-dekrementace">inkrementaci</a>,
tak ta je jedním z případů výrazů, které mají vedlejší efekt (změnu hodnoty proměnné).</p>
<h3><a class="header" href="#konverze" id="konverze">Konverze</a></h3>
<p>Pokud se pokusíte o převod celého či desetinného čísla na <code>bool</code>, tak můžou nastat dvě varianty:</p>
<ul>
<li>Pokud je číslo nenulové, výsledkem bude <code>true</code>.</li>
<li>Pokud je číslo nula, výsledkem bude <code>false</code>.</li>
</ul>
<p>V opačném směru (konverze <code>bool</code> u na číslo) dojde k následující konverzi:</p>
<ul>
<li><code>true</code> se převede na <code>1</code></li>
<li><code>false</code> se převede na <code>0</code></li>
</ul>
<hr />
<p><strong>Kvíz</strong> 🤔</p>
<ol>
<li>
<p>Co vypíše následující program?</p>
<pre><code class="language-c editable mainbody">#include &lt;stdio.h&gt;
#include &lt;stdbool.h&gt;

int main() {
    int pocet_zidli = 14;
    int pocet_lidi = 8;
    int pocet_znicenych_zidli = 4;

    bool dostatek_zidli = (pocet_zidli - pocet_znicenych_zidli) &gt;= pocet_lidi;
    bool dostatek_lidi = pocet_lidi &gt;= 6;
    bool party_pripravena = dostatek_zidli &amp;&amp; dostatek_lidi;

    printf(&quot;Party: %d\n&quot;, party_pripravena);

    return 0;
}
</code></pre>
<details>
 <summary>Odpověď</summary>
<p>Program vypíše <code>Party: 1</code>.</p>
</details>
</li>
<li>
<p>Co vypíše následující program?</p>
<pre><code class="language-c editable mainbody">#include &lt;stdio.h&gt;
#include &lt;stdbool.h&gt;

int main() {
    int a = 5;
    int b = 4;

    bool x = a &gt;= 3 || (b = 8);

    printf(&quot;a=%d\n&quot;, a);
    printf(&quot;b=%d\n&quot;, b);
    printf(&quot;x=%d\n&quot;, x);

    return 0;
}
</code></pre>
<details>
 <summary>Odpověď</summary>
<p>Program vypíše:</p>
<pre><code>a=5
b=4
x=1
</code></pre>
<p>Výraz přiřazení <code>b = 8</code> se neprovede kvůli <a href="c/datove_typy/pravdivostni_typy.html#zkr%C3%A1cen%C3%A9-vyhodnocov%C3%A1n%C3%AD">zkrácenému vyhodnocování</a>,
hodnota proměnné <code>b</code> se tak nezmění. Raději nepoužívejte výrazy obsahující vedlejší efekty v
kombinaci s <code>||</code> a <code>&amp;&amp;</code>.</p>
</details>
</li>
</ol>
<h1><a class="header" href="#explicitní-konverze" id="explicitní-konverze">Explicitní konverze</a></h1>
<p>Někdy potřebujete převést hodnoty mezi různými datovými typy. K tomu slouží <strong>operátor přetypování</strong>
(<em>cast operator</em>), který má syntaxi <code>(&lt;datový typ&gt;) &lt;výraz&gt;</code> a převede výraz na daný datový typ.
Například <code>(short) 1</code> převede výraz <code>1</code> z typu <code>int</code> na <code>short</code>. Je dobré si uvědomit, k čemu může
dojít při převodu mezi různými datovými typy:</p>
<ul>
<li>Pokud je cílový datový typ menší a převáděnou hodnotu v něm nelze reprezentovat, tak dojde k
oseknutí hodnoty. V důsledku způsobu reprezentace hodnot v počítači takováto operace odpovídá
zbytku po dělení:
<pre><code class="language-c">unsigned short a = 256;
(unsigned char) a // hodnota tohoto výrazu je 0 (256 % 256)
</code></pre>
</li>
<li>Pokud převádíte znaménkový typ na bezznaménkový a hodnota převáděného výrazu je záporná, tak nedojde
k intuitivnímu použití absolutní hodnoty<sup class='margin-toggle sidenote-number'>1</sup>. V důsledku způsobu reprezentace hodnot v počítači takováto
operace odpovídá přičtení dané hodnoty k maximální možné hodnotě cílového typu:
<pre><code class="language-c">signed char c = -50;
(unsigned char) c // hodnota tohoto výrazu je 206 (256 - 50)
</code></pre>
<span class='sidenote'><p><sup class='number'>1</sup>K tomu můžete použít například funkci <a href="https://devdocs.io/c/numeric/math/abs">abs</a>.</p>
</span></li>
</ul>
<h2><a class="header" href="#převod-z-desetinné-hodnoty-na-celočíselnou-hodnotu" id="převod-z-desetinné-hodnoty-na-celočíselnou-hodnotu">Převod z desetinné hodnoty na celočíselnou hodnotu</a></h2>
<p>Často se hodí převádět mezi desetinnými a celočíselnými typy. Při převodu z desetinné hodnoty na celočíselnou dojde k
zaokrouhlení směrem k nule:</p>
<pre><code class="language-c editable mainbody">#include &lt;stdio.h&gt;

int main() {
  float a = 5.8;
  float b = -7.2;

  printf(&quot;Kladne cislo zaokrouhlene: %d\n&quot;, (int) a);
  printf(&quot;Zaporne cislo zaokrouhlene: %d\n&quot;, (int) b);
  return 0;
}
</code></pre>
<p>Pokud se chcete dozvědět více o tom, proč konverze mezi typy fungují tak, jak fungují, tak se podívejte
na to, jak funguje <a href="https://cs.wikipedia.org/wiki/Dvojkov%C3%BD_dopln%C4%9Bk">dvojkový doplněk</a>.</p>
<h1><a class="header" href="#Řízení-toku" id="Řízení-toku">Řízení toku</a></h1>
<p>Pokud by počítače program vždy pouze vykonaly od začátku do konce a provedly pokaždé ty stejné
operace, tak by nebyly moc užitečné. Sice by zvládly něco rychle vypočítat, ale už ne se rozhodovat,
jakou operaci mají provést, nebo nějakou operaci provádět opakovaně, což jsou velmi užitečné vlastnosti.</p>
<p>Instrukce programu se běžně vykonávají (&quot;tečou&quot;) jedna po druhé (&quot;odshora dolů&quot;). <em>C</em> obsahuje příkazy
pro tzv. <strong>řízení toku</strong> (<em>control flow</em>), které můžou toto vykonávání instrukcí ovlivnit:</p>
<ul>
<li><a href="c/rizeni_toku/podminky.html">Podmínky</a> umožňují vykonat kus kódu, pouze pokud platí nějaký výraz (Booleovského typu).
Díky tomu se může program rozhodnout, zda má nějakou operaci provést, nebo ne, v závislosti na vstupu.</li>
<li><a href="c/rizeni_toku/cykly.html">Cykly</a> umožňují vykonávat kus kódu opakovaně. Díky tomu můžeme například provést nějakou
operaci pro všechny prvky ze vstupu programu anebo ji provádět, dokud nedojde ke splnění nějaké podmínky.</li>
</ul>
<blockquote>
<p>Ač se to možná nezdá, tak použití výrazů, proměnných, podmínek a cyklů bohatě stačí k tomu, abyste
byli schopni napsat libovolný počítačový program. Pomocí těchto tří jednoduchých konstrukcí byste
tak teoreticky mohli vytvořit třeba textový editor, hru nebo i celý operační systém. Nicméně, pokud
bychom využívali pouze tyto konstrukce, tak ve větších programech by bylo složité se zorientovat a
byly by také dost neefektivní. V následujících sekcích se tak dozvíte o několika dalších konstrukcích,
které vám můžou programování usnadnit.</p>
</blockquote>
<h1><a class="header" href="#podmínky" id="podmínky">Podmínky</a></h1>
<p>V programech se často potřebujeme rozhodnout, co by se mělo stát v závislosti na hodnotě nějakého
výrazu:</p>
<ul>
<li>Pokud uživatel nakoupil zboží v posledním týdnu, odešli mu e-mail.</li>
<li>Zadal uživatel správné heslo? Pokud ano, tak ho přesměruj na jeho profil. Pokud ne, tak zobraz chybovou hlášku.</li>
<li>Jaké má uživatel konto? Pokud kladné, tak ho vykresli zelenou barvou, pokud záporné, tak červenou a
pokud nulové, tak černou.</li>
</ul>
<p>V <em>C</em> můžeme provádět takováto rozhodnutí pomocí <strong>podmíněných příkazů</strong> (<em>conditional statements</em>)
<a href="c/rizeni_toku/if.html"><code>if</code></a> a <a href="c/rizeni_toku/switch.html"><code>switch</code></a>, případně pomocí <a href="c/rizeni_toku/ternarni_operator.html">ternárního operátoru</a>.</p>
<h1><a class="header" href="#příkaz-if" id="příkaz-if">Příkaz <code>if</code></a></h1>
<p>Základním příkazem pro tzv. <strong>podmíněné vykonání</strong> kódu je příkaz <code>if</code>:</p>
<pre><code class="language-c">if (&lt;výraz typu bool&gt;) {
    // blok kódu
}
</code></pre>
<p>Pokud se výraz v závorce za <code>if</code> vyhodnotí jako <code>true</code> (pravda), tak se provede
<a href="c/rizeni_toku/../promenne/promenne.html#platnost">blok</a> kódu za závorkou tak, jak jste zvyklí, a poté bude program
dále pokračovat za příkazem <code>if</code>. Pokud se však výraz vyhodnotí jako <code>false</code> (nepravda), tak se blok
kódu za závorkou vůbec neprovede. V následujícím programu zkuste změnit výraz uvnitř závorek za <code>if</code>
tak, aby se blok v podmínce vykonal:</p>
<pre><code class="language-c editable mainbody">#include &lt;stdio.h&gt;

int main() {
    int delka_hesla = 5;

    printf(&quot;Kontroluji heslo...\n&quot;);
    if (delka_hesla &gt; 5) {
        printf(&quot;Heslo je dostatecne dlouhe\n&quot;);
    }
    printf(&quot;Kontrola hesla dokoncena\n&quot;);

    return 0;
}
</code></pre>
<p>Booleovské výrazy použité v podmíněných příkazech se označují jako <strong>podmínky</strong> (<em>conditions</em>), protože
podmiňují vykonávání programu.</p>
<blockquote>
<p>Anglické slovo <code>if</code> znamená v češtině <code>Jestliže</code>. Všimněte si tak, že kód výše můžete přečíst jako
větu, která bude mít stejný význam jako uvedený <em>C</em> kód: <code>Jestliže je délka hesla větší než pět, tak (proveď kód v bloku)</code>.</p>
</blockquote>
<h3><a class="header" href="#provádění-alternativ" id="provádění-alternativ">Provádění alternativ</a></h3>
<p>Často v programu chceme provést <em>právě jednu</em> ze dvou (nebo více) alternativ, opět v závislosti na hodnotě
nějakého výrazu (podmínky). To sice můžeme provést pomocí několika <code>if</code> příkazů za sebou:</p>
<pre><code class="language-c">if (body &gt; 90) { znamka = 1; }
if (body &lt;= 90 &amp;&amp; body &gt; 80) { znamka = 2; }
if (body &lt;= 80 &amp;&amp; body &gt; 50) { znamka = 3; }
...
</code></pre>
<p>Nicméně to může být často dosti &quot;ukecané&quot;, protože se musíme v každé podmínce ujistit, že již nebyla
splněna předchozí podmínka, jinak by se mohla provést více než jedna alternativa.</p>
<p>Jazyk <em>C</em> tak umožňuje přidat k příkazu <code>if</code> další příkaz, který se provede pouze v případě, že podmínka
&quot;<code>if</code>u&quot; není splněna. Takto lze řetězit více podmínek za sebou, kdy v každé následující podmínce víme,
že žádná z předchozích nebyla splněna. Dosáhneme toho tak, že za blokem podmínky <code>if</code> použijeme klíčové
slovo <code>else</code> (&quot;v opačném případě&quot;):</p>
<pre><code class="language-c">if (&lt;výraz typu bool&gt;) {
    // blok kódu
} else ...
</code></pre>
<p>Pokud za blok podmínky <code>if</code> přidáte <code>else</code>, tak se program začne vykonávat za <code>else</code>, pokud výraz
podmínky není splněn. Za <code>else</code> pak může následovat:</p>
<ul>
<li>
<p>Blok kódu, který se rovnou provede:</p>
<pre><code class="language-c">if (body &gt; 90) {
    // blok A
} else {
    // blok B
}
// X
</code></pre>
<p>Pokud platí <code>body &gt; 90</code>, provede se blok A, pokud ne, tak se provede blok B. V obou případech
bude dále program vykonávat kód od bodu <code>X</code>.</p>
</li>
<li>
<p>Další <code>if</code> podmínka, která je opět vyhodnocena. Takovýchto podmínek může následovat libovolný počet:</p>
<pre><code class="language-c">if (body &gt; 90) {
    // blok A, více než 90 bodů
} else if (body &gt; 80) {
    // blok B, méně než 91 bodů, ale více než 80 bodů
} else if (body &gt; 70) {
    // blok C, méně než 81 bodů, ale více než 70 bodů
}
// X
</code></pre>
<p>Takovéto spojené podmínky se vyhodnocují postupně shora dolů. První podmínka <code>if</code>, jejíž výraz
je vyhodnocen jako <code>true</code>, způsobí, že se provede blok této podmínky, a následně program pokračuje
za celou spojenou podmínkou (bod <code>X</code>).</p>
<p>Na konec spojené podmínky můžete opět vložit klíčové slovo <code>else</code> s blokem bez podmínky. Tento blok
se provede pouze, pokud žádná z předchozích podmínek není splněna:</p>
<pre><code class="language-c">if (body &gt; 90) {
    // blok A, více než 90 bodů
} else if (body &gt; 80) {
    // blok B, méně než 90 bodů, ale více než 80 bodů
} else {
    // blok C, méně než 81 bodů
}
</code></pre>
<blockquote>
<p>Všimněte si, že tento kód opět můžeme přečíst jako intuitivní větu. Pokud je počet
bodů vyšší, než 90, tak proveď A. V opačném případě, pokud je vyšší než 80, tak proveď B. Jinak
proveď C.</p>
</blockquote>
</li>
</ul>
<hr />
<p><strong>Cvičení</strong> 🏋</p>
<p>Upravte následující program, aby vypsal:</p>
<ul>
<li><code>Student uspel s vyznamenanim</code>, pokud je hodnota proměnné <code>body</code> větší než <code>90</code>.</li>
<li><code>Student uspel</code>, pokud je hodnota proměnné <code>body</code> v (uzavřeném) intervalu <code>[51, 90]</code>.</li>
<li><code>Student neuspel</code>, pokud je hodnota proměnné <code>body</code> menší než <code>51</code>.</li>
</ul>
<pre><code class="language-c editable mainbody">#include &lt;stdio.h&gt;

int main() {
    int body = 50;

    printf(&quot;Student uspel\n&quot;);

    return 0;
}
</code></pre>
<hr />
<h3><a class="header" href="#vnořování-podmínek" id="vnořování-podmínek">Vnořování podmínek</a></h3>
<p>Někdy potřebujeme vyhodnotit složitou podmínku (nebo sadu podmínek). Jelikož <code>if</code> je <em>příkaz</em>
a bloky kódu mohou obsahovat libovolné příkazy, tak vám nic nebrání v tom příkazy <code>if</code> <em>vnořovat</em>:</p>
<pre><code class="language-c editable mainbody">#include &lt;stdio.h&gt;

int main() {
    int delka_hesla = 4;
    int delka_jmena = 3;
    if (delka_hesla &gt; 5) {
        if (delka_jmena &gt; 3) {
            printf(&quot;Uzivatel byl zaregistrovan\n&quot;);
        } else {
            printf(&quot;Uzivatelske jmeno neni dostatecne dlouhe\n&quot;);
        }
    } else {
        printf(&quot;Heslo neni dostatecne dlouhe\n&quot;);
    }

    return 0;
}
</code></pre>
<hr />
<p><strong>Cvičení</strong> 🏋</p>
<p>Upravte hodnotu proměnných <code>delka_hesla</code> a <code>delka_jmena</code> v programu výše tak, aby program
vypsal <code>Uzivatel byl zaregistrovan</code>. Neměňte v programu nic jiného.</p>
<hr />
<h4><a class="header" href="#vynechání-složených-zárovek" id="vynechání-složených-zárovek">Vynechání složených zárovek</a></h4>
<p>Za <code>if</code> nebo <code>else</code> můžete vynechat složené závorky (<code>{</code>, <code>}</code>). V takovém případě se bude podmínka
vztahovat k (jednomu) příkazu následujícímu za <code>if/else</code>:</p>
<pre><code class="language-c">if (body &gt; 80) printf(&quot;Student uspel\n&quot;);
else printf(&quot;Student neuspel\n&quot;);
</code></pre>
<blockquote>
<p>Zejména ze začátku za podmínkami vždy však raději používejte složené závorky, abyste předešli případným
<a href="c/rizeni_toku/../../caste_chyby/caste_chyby.html#st%C5%99edn%C3%ADk-za-for-while-nebo-if">chybám</a> a učinili kód přehlednějším.</p>
</blockquote>
<hr />
<p><strong>Kvíz</strong> 🤔</p>
<ol>
<li>
<p>Co vypíše následující program?</p>
<pre><code class="language-c editable mainbody">#include &lt;stdio.h&gt;

int main() {
    int a = 2;
    if (a &gt;= 3) {
      printf(&quot;a &gt;= 3\n&quot;);
    } else if (a &gt;= 2) {
      printf(&quot;a &gt;= 2\n&quot;);
    } else if (a &gt;= 1) {
      printf(&quot;a &gt;= 1\n&quot;);
    }

    return 0;
}
</code></pre>
<details>
 <summary>Odpověď</summary>
<p>Program vypíše <code>a &gt;= 2</code>. Příkaz <code>if</code>, za kterým následuje sada návazných příkazů <code>else if</code>,
případně na poslední pozici <code>else</code>, se vyhodnocuje shora dolů. Provede se blok kódu prvního <code>if</code>u,
jehož podmínka (výraz v závorce) se vyhodnotí jako <code>true</code>, což je v tomto případě podmínka <code>else if (a &gt;= 2)</code>.
I když jistě platí i podmínka <code>a &gt;= 1</code>, tak blok kódu za posledním <code>else if</code> se zde neprovede, protože
se už provedl blok kódu za dřívější podmínkou.</p>
</details>
</li>
<li>
<p>Co vypíše následující program?</p>
<pre><code class="language-c editable mainbody">#include &lt;stdio.h&gt;

int main() {
    int a = 2;
    if (a &gt;= 3) {
      printf(&quot;a &gt;= 3\n&quot;);
    } else if (a &gt;= 2) {
      printf(&quot;a &gt;= 2\n&quot;);
    } if (a &gt;= 1) {
      printf(&quot;a &gt;= 1\n&quot;);
    }

    return 0;
}
</code></pre>
<details>
 <summary>Odpověď</summary>
<p>Program vypíše:</p>
<pre><code>a &gt;= 2
a &gt;= 1
</code></pre>
<p>Všimněte si, že před posledním příkazem <code>if</code> není <code>else</code>! To znamená, že se jedná o nezávislý
příkaz <code>if</code>, který nijak nesouvisí s prvním příkazem <code>if</code> nad ním. Kvůli toho se tento příkaz
provede, i když byl předtím proveden blok za podmínkou <code>else if (a &gt;= 2)</code>.</p>
<p>V běžném programu by byl tento kód formátován spíše následovně:</p>
<pre><code class="language-c">int a = 2;
if (a &gt;= 3) {
  printf(&quot;a &gt;= 3\n&quot;);
} else if (a &gt;= 2) {
  printf(&quot;a &gt;= 2\n&quot;);
}

if (a &gt;= 1) {
  printf(&quot;a &gt;= 1\n&quot;);
}
</code></pre>
<p>S tímto formátováním je mnohem jednodušší rozpoznat, že spolu tyto dva příkazy <code>if</code> nesouvisí.</p>
</details>
</li>
<li>
<p>Co vypíše následující program?</p>
<pre><code class="language-c editable mainbody">#include &lt;stdio.h&gt;

int main() {
    int a = 1;
    int b = 4;

    if (a &gt; 1) {
      if (b == 4) {
         printf(&quot;b == 4\n&quot;);
      } else {
         printf(&quot;b != 4\n&quot;);
      }
    }

    return 0;
}
</code></pre>
<details>
 <summary>Odpověď</summary>
<p>Tento program nevypíše nic. Podmínka <code>a &gt; 1</code> se vyhodnotí jako <code>false</code>, takže blok kódu za touto
podmínkou se vůbec nevykoná.</p>
</details>
</li>
<li>
<p>Co vypíše následující program?</p>
<pre><code class="language-c editable mainbody">#include &lt;stdio.h&gt;

int main() {
    int a = 1;
    if (a = 2) {
      printf(&quot;a se rovna dvoum\n&quot;);
    }

    return 0;
}
</code></pre>
<details>
 <summary>Odpověď</summary>
<p>Tento program vypíše <code>a se rovna dvoum</code>. Pozor na to, že operátor přiřazení <code>[x] = [y]</code> přiřadí
výraz <code>[y]</code> do <code>[x]</code>, a vyhodnotí se jako hodnota <code>[y]</code>. V tomto případě se tedy do proměnné
<code>a</code> uloží hodnota <code>2</code>, a jelikož <code>2</code> se po <a href="c/rizeni_toku/../datove_typy/pravdivostni_typy.html#konverze">převodu</a>
na <code>bool</code> vyhodnotí jako pravda (<code>true</code>), se tělo příkazu <code>if</code> provede. Záměna přiřazení (<code>=</code>)
a <code>==</code> (porovnání) je častou <a href="c/rizeni_toku/../../caste_chyby/caste_chyby.html#z%C3%A1m%C4%9Bna--a-">začátečnickou chybou</a>.</p>
</details>
</li>
</ol>
<h1><a class="header" href="#příkaz-switch" id="příkaz-switch">Příkaz <code>switch</code></a></h1>
<blockquote>
<p>🤓 Tato sekce obsahuje doplňující učivo. Pokud je toho na vás moc, můžete ji prozatím přeskočit
a vrátit se k ní později.</p>
</blockquote>
<p>V případě, že byste chtěli provést rozlišný kód v závislosti na hodnotě nějakého výrazu,
a tento výraz (např. hodnota proměnné) může nabývat většího množství různých hodnot, tak může být
zdlouhavé použít spoustu <code>if</code>ů:</p>
<pre><code class="language-c">if (a == 0) {
    ...
}
else if (a == 1) {
    ...
}
else if (a == 2) {
    ...
}
...
</code></pre>
<p>Jako jistá zkratka může sloužit příkaz <code>switch</code>. Ten má následující syntaxi:</p>
<pre><code class="language-c">switch (&lt;výraz&gt;) {
    case &lt;hodnota A&gt;: &lt;blok kódu&gt;
    case &lt;hodnota B&gt;: &lt;blok kódu&gt;
    case &lt;hodnota C&gt;: &lt;blok kódu&gt;
    ...
}
</code></pre>
<p>Tento příkaz vyhodnotí výraz v závorce za klíčovým slovem <code>switch</code>. Pokud se v bloku kódu za závorkou
nachází klíčové slovo <code>case</code> následované hodnotou odpovídající hodnotě výrazu, tak program začne vykonávat
blok kódu, který následuje za tímto <code>case</code>. Dále se program bude vykonávat sekvenčně až do bloku <code>switch</code>e
(při tomto vykonávání už se klíčová slovo <code>case</code> i hodnoty za ním ignorují)<sup class='margin-toggle sidenote-number'>1</sup>.</p>
<span class='sidenote'><p><sup class='number'>1</sup>Toto chování se anglicky označuje jako <em>fallthrough</em>.</p>
</span>
<p>Tento program vypíše <code>52</code>, protože předaný výraz má hodnotu <code>5</code>, takže program skočí na blok za
<code>case 5</code> a dále pokračuje sekvenčně až do konce bloku <code>switch</code> příkazu.</p>
<pre><code class="language-c editable mainbody">#include &lt;stdio.h&gt;

int main() {
    switch (5) {
        case 0: printf(&quot;0&quot;);
        case 1: printf(&quot;1&quot;);
        case 5: printf(&quot;5&quot;);
        case 2: printf(&quot;2&quot;);
    }

    return 0;
}
</code></pre>
<h2><a class="header" href="#klíčové-slovo-default" id="klíčové-slovo-default">Klíčové slovo <code>default</code></a></h2>
<p>Do bloku kódu příkazu <code>switch</code> lze předat i blok pojmenovaný <code>default</code>, na který program skočí v
případě, že se nenalezne žádný <code>case</code> s odpovídající hodnotou:</p>
<pre><code class="language-c editable mainbody">#include &lt;stdio.h&gt;

int main() {
    switch (10) {
        case 0: printf(&quot;0&quot;);
        case 1: printf(&quot;1&quot;);
        case 5: printf(&quot;5&quot;);
        case 2: printf(&quot;2&quot;);
        default: printf(&quot;nenalezeno&quot;);
    }

    return 0;
}
</code></pre>
<h2><a class="header" href="#klíčové-slovo-break" id="klíčové-slovo-break">Klíčové slovo <code>break</code></a></h2>
<p>Velmi často chceme provést pouze jeden blok kódu u jednoho <code>case</code> a nepokračovat po něm až do konce
celého <code>switch</code> bloku. Běžně se tedy za každým <code>case</code> blokem používá příkaz <code>break</code>, který ukončí
provádění celého <code>switch</code> příkazu:</p>
<pre><code class="language-c editable mainbody">#include &lt;stdio.h&gt;

int main() {
    switch (1) {
        case 0: printf(&quot;0&quot;); break;
        case 1: printf(&quot;1&quot;); break;
        case 2: printf(&quot;2&quot;); break;
        default: printf(&quot;nenalezeno&quot;);
    }

    return 0;
}
</code></pre>
<h2><a class="header" href="#hodnota-za-case" id="hodnota-za-case">Hodnota za <code>case</code></a></h2>
<p>Hodnota za klíčovým slovem <code>case</code> musí být konstantní, jinak řečeno musí to být hodnota známá již v
době překladu programu, např. <a href="c/rizeni_toku/../prikazy_vyrazy.html#v%C3%BDrazy">literál</a>. Za <code>case</code> tak nelze dát např.
výraz obsahující název proměnné.</p>
<h2><a class="header" href="#použití-příkazu-switch" id="použití-příkazu-switch">Použití příkazu <code>switch</code></a></h2>
<p>Výraz v závorce za <code>switch</code> vestavěný datový typ, v podstatě se zde dá použít pouze celé číslo.
Nelze jej použít např. na porovnávání <a href="c/rizeni_toku/../struktury/struktury.html">struktur</a> či <a href="c/rizeni_toku/../text/retezce.html">řetězců</a>.
Jeho chování také může být matoucí, pokud se za jednotlivými <code>case</code> konstrukcemi nepoužije příkaz
<code>break</code>. Proto tak doporučujeme ze začátku používat pro podmíněné vykonávání spíše příkaz <a href="c/rizeni_toku/if.html"><code>if</code></a>.</p>
<h1><a class="header" href="#ternární-operátor" id="ternární-operátor">Ternární operátor</a></h1>
<blockquote>
<p>🤓 Tato sekce obsahuje doplňující učivo. Pokud je toho na vás moc, můžete ji prozatím přeskočit
a vrátit se k ní později.</p>
</blockquote>
<p>Občas se nám může hodit vytvořit výraz, který bude mít hodnotu jednoho ze dvou konkrétních výrazů,
v závislosti na hodnotě nějaké podmínky. Například pokud bychom chtěli přiřadit minimum ze dvou
hodnot do proměnné, tak to můžeme napsat takto:</p>
<pre><code class="language-c">int a = 1;
int b = 5;

int c = 0;
if (a &lt; b) {
    c = a;
} else {
    c = b;
}
</code></pre>
<p>Všimněte si, že do proměnné <code>c</code> ukládáme buď výraz <code>a</code> nebo výraz <code>b</code>, v závislosti na tom, jaká je
hodnota podmínky <code>a &lt; b</code>.</p>
<p>Jelikož je tato situace relativně častá, a její vyřešení pomocí příkazu <code>if</code> je relativně zdlouhavé,
tak jazyk <code>C</code> obsahuje zkratku v podobě <strong>ternárního operátoru</strong> (<em>ternary operator</em>). Tento výraz
má následující syntaxi:</p>
<pre><code class="language-c">&lt;výraz X typu bool&gt; ? &lt;výraz A&gt; : &lt;výraz B&gt;
</code></pre>
<p>Pokud je výraz <code>X</code> pravdivý, tak se ternární operátor vyhodnotí jako hodnota výrazu <code>A</code>, v opačném
případě se vyhodnotí jako hodnota výrazu <code>B</code>. Uhodnete, co vypíše následující program?</p>
<pre><code class="language-c editable mainbody">#include &lt;stdio.h&gt;

int main() {
    int a = 1;
    int b = 5;
    int c = (a &gt;= b) ? a - b : a + b;
    printf(&quot;%d\n&quot;, c);

    return 0;
}
</code></pre>
<h1><a class="header" href="#cykly" id="cykly">Cykly</a></h1>
<p>Ve svých programech budete často chtít provádět nějakou operaci opakovaně, například:</p>
<ul>
<li>Pro každý záznam v databázi vypiš řádek do souboru.</li>
<li>Pošli zprávu každému účastníkovi chatu.</li>
<li>Načítej řádky ze souboru, dokud nedojdeš na konec souboru.</li>
</ul>
<p>Pokud bychom vždy pouze přidávali nové příkazy pod sebe, tak, jak to zatím známe, abychom nějaký příkaz
provedli vícekrát, tak by naše programy jednak byly nejspíše dost dlouhé. Nejspíše bychom bychom
neustále kopírovali (&quot;copy-pastovali&quot;) velmi podobný kód:</p>
<pre><code class="language-c">printf(&quot;0\n&quot;);
printf(&quot;1\n&quot;);
printf(&quot;2\n&quot;);
...
</code></pre>
<p>což by vedlo k nepřehledným programům<sup class='margin-toggle sidenote-number'>1</sup>. Pokud bychom navíc našli v programu chybu, museli bychom ji
opravit na všech místech, kam jsme kód zkopírovali.</p>
<span class='sidenote'><p><sup class='number'>1</sup>Představte si, že chcete na výstup programu nebo do souboru vypsat třeba tisíc různých řádků textu.</p>
</span>
<p>Ani s kopírováním kódu bychom si však nevystačili, pokud bychom potřebovali provádět kód opakovaně
v závislosti na vstupu programu. Představte si situaci, kdy nám uživatel na vstup programu zadá číslo,
kolikrát má náš program vypsat nějaký řádek textu na výstup. Uživatel se při každém spuštění programu
může rozhodnout pro jiné číslo, <code>0</code>, <code>1</code>, <code>42</code>, <code>1000</code>. Program však zůstává stále stejný - už při
tvorbě (psaní) programu se musíme rozhodnout, kolik příkazů pro výpis do něj vložíme. Poté se program
<a href="c/rizeni_toku/../../prostredi/preklad_programu.html">přeloží</a> na spustitelný soubor a poté už naši volbu nemůžeme
jednoduše změnit. Takovýto program bychom tedy zatím (pouze pomocí proměnných a podmínek) neměli jak
naprogramovat. </p>
<p>Proto programovací jazyky nabízí tzv. <strong>cykly</strong> (<em>loops</em>), pomocí kterých můžeme jednoduše říct
počítači, aby určitý blok kódu opakoval, kolikrát budeme chtít. Díky tomu může program i s pouze
několika málo řádky kódu říct počítači, aby provedl spoustu instrukcí. Jazyk <em>C</em> nabízí dva základní
typy cyklů, <a href="c/rizeni_toku/while.html">while</a> a <a href="c/rizeni_toku/for.html">for</a>.</p>
<blockquote>
<p>Další motivací pro využití cyklů je to, že moderní procesory počítačů mají běžně frekvence od
1 do 4 GHz, takže za vteřinu zvládnou provést několik miliard
<a href="https://cs.wikipedia.org/wiki/Hodinov%C3%BD_sign%C3%A1l">taktů</a> a během každého taktu navíc až
<a href="https://cs.wikipedia.org/wiki/Superskal%C3%A1rn%C3%AD_architektura">desítky</a> různých operací.
Jistě si dovedete představit, že s pouze sekvenčním zápisem kódu bychom tento potenciál nemohli
naplno využít. I když jeden řádek <em>C</em> kódu může být přeložen až na desítky procesorových instrukcí,
tak i kdybychom zvládli napsat program se stovkami milionů řádek, pořád bychom takovýmto programem
&quot;zabavili&quot; procesor na pouhou vteřinu. Běžící programy tak obvykle tráví většinu času právě
prováděním nějakého cyklu.</p>
</blockquote>
<h1><a class="header" href="#cyklus-while" id="cyklus-while">Cyklus <code>while</code></a></h1>
<p>Nejjednodušším cyklem v <em>C</em> je cyklus <code>while</code> (&quot;dokud&quot;):</p>
<pre><code class="language-c">while (&lt;výraz typu bool&gt;) {
    // blok cyklu
}
</code></pre>
<p>Funguje následovně:</p>
<ol>
<li>Nejprve se vyhodnotí (Booleovský) výraz v závorce za <code>while</code> a provede se bod 2.</li>
<li>Pokud:
<ul>
<li>Je výraz pravdivý, tak se provede blok<sup class='margin-toggle sidenote-number'>1</sup> cyklu a dále se pokračuje opět bodem 1.<span class='sidenote'><p><sup class='number'>1</sup><a href="c/rizeni_toku/../promenne/promenne.html#platnost">Blok</a> cyklu se také často nazývá jako <strong>tělo</strong> (<em>body</em>) cyklu.</p>
</span></li>
<li>Není výraz pravdivý, tak se provede bod 3.</li>
</ul>
</li>
<li>Program pokračuje za cyklem <code>while</code>.</li>
</ol>
<p>Jinak řečeno, dokud bude splněná podmínka za <code>while</code>, tak se budou opakovaně provádět příkazy uvnitř
těla cyklu. Vyzkoušejte si to na následujícím příkladu:</p>
<pre><code class="language-c editable mainbody">#include &lt;stdio.h&gt;

int main() {
    int pocet = 0;
    while (pocet &lt; 5) {
        printf(&quot;Telo cyklu se provedlo, hodnota promenne pocet=%d\n&quot;, pocet);
        pocet = pocet + 1;
    }
    return 0;
}
</code></pre>
<p>Tento kód opět můžeme přečíst jako větu: <code>Dokud je hodnota proměnné pocet menší než pět, prováděj tělo cyklu</code>. Jedno vykonání těla cyklu se nazývá <strong>iterace</strong>. Cyklus v ukázce výše tedy provede pět iterací,
protože se tělo cyklu provede pětkrát.</p>
<p>Pokud výraz za <code>while</code> není vyhodnocen jako pravdivý v momentě, kdy se <code>while</code> začne vykonávat, tak
se tělo cyklu nemusí provést ani jednou (tj. bude mít nula iterací).</p>
<h3><a class="header" href="#nekonečný-cyklus" id="nekonečný-cyklus">Nekonečný cyklus</a></h3>
<p>Je důležité dávat si pozor na to, aby cyklus, který použijeme, nebyl nechtěně <strong>nekonečný</strong>
(<em>infinite loop</em>), jinak by náš program nikdy neskončil. Zkuste v kódu výše zakomentovat nebo odstranit
řádek <code>pocet = pocet + 1;</code> a zkuste program spustit. Jelikož se hodnota proměnné <code>pocet</code> nebude nijak
měnit, tak výraz <code>pocet &lt; 5</code> bude stále pravdivý a cyklus se tak bude provádět neustále dokola.
Této situaci se lidově říká &quot;zacyklení&quot;<sup class='margin-toggle sidenote-number'>2</sup>.</p>
<span class='sidenote'><p><sup class='number'>2</sup>Pokud program spouštíte v terminálu a zacyklí se, můžete ho přerušit pomocí klávesové zkratky <code>Ctrl + C</code>.
Pokud jej spustíte v prohlížeči, tak poté radši restartujte tuto stránku pomocí <code>F5</code> :)</p>
</span>
<blockquote>
<p>Pokud se vám někdy stalo, že se program, který jste zrovna používali, &quot;zaseknul&quot; a přestal reagovat
na váš vstup, mohlo to být právě například tím, že v něm nechtěně došlo k provedení nekonečného
cyklu (došlo k zacyklení).</p>
</blockquote>
<h3><a class="header" href="#Řídící-proměnná" id="Řídící-proměnná">Řídící proměnná</a></h3>
<p>Provést úplně identický kód opakovaně se někdy hodí, ale většinou chceme provést v těle cyklu trochu
jiné příkazy, v závislosti na tom, která iterace se zrovna vykonává.
K tomu můžeme použít proměnnou, která si budeme pamatovat, v jaké iteraci cyklu
se nacházíme, a podle ní se poté provede odpovídající operace. Takováto proměnná se obvykle označuje
jako <strong>řídící proměnná</strong> (<em>index variable</em>).</p>
<p>Například pokud chceme něco provést pouze v první iteraci cyklu, můžeme použít
příkaz <a href="c/rizeni_toku/if.html">if</a> s podmínkou, ve které zkontrolujeme aktuální hodnotu řídící proměnné:</p>
<pre><code class="language-c editable mainbody">#include &lt;stdio.h&gt;

int main() {
    int i = 0;
    while (i &lt; 5) {
        if (i == 0) {
            printf(&quot;Prvni iterace\n&quot;);
        }
        printf(&quot;Hodnota i=%d\n&quot;, i);
        i += 1;
    }
    return 0;
}
</code></pre>
<p>Řídící proměnná je zde <code>i</code> - tento název se pro řídící proměnné pro jednoduchost často používá.</p>
<hr/>
<p><strong>Cvičení</strong> 🏋</p>
<p>Upravte kód výše tak, aby program vypsal <code>Posledni iterace</code> při provádění poslední
iterace cyklu. Zkuste poté kód upravit tak, aby fungoval pro libovolný počet iterací (tj.
ať už bude počet iterací libovolný, kód v těle i podmínce samotného cyklu musí zůstat stejný).</p>
<hr/>
<h3><a class="header" href="#Řízení-toku-cyklu" id="Řízení-toku-cyklu">Řízení toku cyklu</a></h3>
<p>V cyklech můžete využít dva speciální příkazy, které fungují pouze uvnitř těla (bloku kódu) nějakého
cyklu:</p>
<ul>
<li>Příkaz <code>continue;</code> způsobí, že se přestane vykonávat tělo cyklu, a program bude pokračovat ve
vykonávání na začátku cyklu (tedy u <code>while</code> na vyhodnocení výrazu). <code>continue</code> lze chápat jako skok
na další iteraci cyklu. Zkuste uhodnout, co vypíše následující kód:
<pre><code class="language-c editable mainbody">#include &lt;stdio.h&gt;

int main() {
    int pocet = 0;
    while (pocet &lt; 10) {
        pocet = pocet + 1;

        if (pocet &lt; 5) {
            continue;
        }

        printf(&quot;Hodnota: %d\n&quot;, pocet); 
    }

    return 0;
}
</code></pre>
</li>
<li>Příkaz <code>break;</code> způsobí, že se cyklus přestane vykonávat a program začne vykonávat kód, který
následuje za cyklem. Cyklus se tak zcela přeruší. Zkuste uhodnout, co vypíše následující kód:
<pre><code class="language-c editable mainbody">#include &lt;stdio.h&gt;

int main() {
    int pocet = 0;
    while (pocet &lt; 10) {
        if (pocet * 2 &gt; 12) {
            break;
        }

        printf(&quot;Hodnota: %d\n&quot;, pocet);
        pocet = pocet + 1;
    }

    return 0;
}
</code></pre>
</li>
</ul>
<details>
<summary>Tip pro návrh cyklů while</summary>
<p>Příkaz <code>break</code> lze také někdy použít k usnadnění návrhu cyklů. Pokud potřebujete napsat <code>while</code> cyklus
s nějakou složitou podmínkou ukončení, ze které se vám motá hlava, zkuste nejprve vytvořit &quot;nekonečný&quot;
cyklus pomocí <code>while (1) { … }</code>, dále vytvořte tělo cyklu a až nakonec vymyslete podmínku,
která cyklus ukončí pomocí příkazu <code>break</code>:</p>
<pre><code class="language-c editable mainbody">#include &lt;stdio.h&gt;

int main() {
    int pocet = 0;
    int pocet2 = 1;
    while (1) {
        printf(&quot;Hodnota: %d\n&quot;, pocet);
        pocet = pocet + 1;
        pocet2 += pocet * 2;

        if (pocet &gt; 10) break;
        if (pocet2 &gt; 64) break;
    }

    return 0;
}
</code></pre>
<p>Nemusíte tak hned ze začátku vymýšlet výraz pro <code>while</code>, na čemž byste se mohli zaseknout. </p>
<p>Místo <code>while (1)</code> můžete použít také <code>while (true)</code>. Nezapomeňte ale na
<a href="c/rizeni_toku/../datove_typy/pravdivostni_typy.html">vložení řádku</a></p>
<pre><code class="language-c">#include &lt;stdbool.h&gt;
</code></pre>
<p>na začátek programu!</p>
</details>
<h3><a class="header" href="#vnořování-cyklů" id="vnořování-cyklů">Vnořování cyklů</a></h3>
<p>Stejně jako podmínky, i cykly jsou příkazy, a můžete je tak používat libovolně v blocích <em>C</em> kódu
a také je <a href="c/rizeni_toku/if.html#vno%C5%99ov%C3%A1n%C3%AD-podm%C3%ADnek">vnořovat</a>. Chování vnořených cyklů může být ze začátku
trochu neintuitivní, proto je dobré si je procvičit. Zkuste si pomocí
<a href="c/rizeni_toku/../../prostredi/ladeni.html#krokov%C3%A1n%C3%AD">debuggeru</a> krokovat následující kód, abyste pochopili, jak se
provádí, a zkuste odhadnout, jakých hodnot budou postupně nabývat proměnné <code>i</code> a <code>j</code>. Poté odkomentujte
výpisy <code>printf</code> a ověřte, jestli byl váš odhad správný:</p>
<pre><code class="language-c editable mainbody">#include &lt;stdio.h&gt;

int main() {
    int i = 0;
    while (i &lt; 3) {
        // printf(&quot;i: %d\n&quot;, i);
        int j = 0;
        while (j &lt; 4) {
            // printf(&quot;  j: %d\n&quot;, j);
            j = j + 1;
        }

        i = i + 1;
    }
    printf(&quot;Konec programu\n&quot;);

    return 0;
}
</code></pre>
<p>Pro každou iteraci &quot;vnějšího&quot; <code>while</code> cyklu se provedou čtyři iterace &quot;vnitřního&quot; <code>while</code> cyklu.
Dohromady se tak provede celkem <code>3 * 4</code> iterací.</p>
<h3><a class="header" href="#cyklus-do-while" id="cyklus-do-while">Cyklus <code>do while</code></a></h3>
<p>Cyklus <code>while</code> má také alternativu zvanou <code>do while</code>. Tento cyklus má následující syntaxi:</p>
<pre><code class="language-c">do {
    // tělo cyklu
}
while (&lt;výraz typu bool&gt;);
</code></pre>
<p>Tento kód můžeme číst jako <code>Prováděj &lt;tělo cyklu&gt;, dokud platí &lt;výraz&gt;</code>.</p>
<p>Jediný rozdíl mezi <code>while</code> a <code>do while</code> je ten, že v cyklu <code>do while</code> se výraz, který určuje, jestli
se má provést další iterace cyklu, vyhodnocuje až na konci cyklu. Tělo cyklu tak bude pokaždé provedeno
alespoň jednou (i kdyby byl výraz od začátku nepravdivý).</p>
<p>Pokud pro to nemáte zvláštní důvod, asi není třeba tento typ cyklu používat.</p>
<hr />
<p><strong>Kvíz</strong> 🤔</p>
<ol>
<li>
<p>Co vypíše následující program?</p>
<pre><code class="language-c editable mainbody">#include &lt;stdio.h&gt;
#include &lt;stdbool.h&gt;

int main() {
    int a = 0;
    int b = 8;

    while (true) {
      if (a &gt; 2) {
        printf(&quot;Hodnota a = %d\n&quot;, a);
      }

      a = a + 2;

      if (a &gt;= b) {
        break;
      }
    }

    return 0;
}
</code></pre>
<details>
 <summary>Odpověď</summary>
<p>Program vypíše:</p>
<pre><code>Hodnota a = 4
Hodnota a = 6
</code></pre>
<p>V každé iteraci cyklu se hodnota proměnné <code>a</code> zvýší o dvojku. Pokud je na začátku iterace hodnota
<code>a</code> větší, než dva, tak se vypíše její hodnota. V čtvrté iteraci cyklu se hodnota proměnné <code>a</code>
zvýší na osm. Poté se podmínka příkazu <code>if</code> vyhodnotí jako <code>true</code>, takže se provede příkaz
<code>break</code>, který provádění cyklu ukončí. Hodnota proměnné <code>a</code> se tak vypíše pouze dvakrát.</p>
</details>
</li>
<li>
<p>Co vypíše následující program?</p>
<pre><code class="language-c editable mainbody">#include &lt;stdio.h&gt;
#include &lt;stdbool.h&gt;

int main() {
    int a = 0;
    int b = 8;

    while (true) {
      if (a &gt; 2) {
        printf(&quot;Hodnota a = %d\n&quot;, a);
      }

      if (a &gt;= b) {
        break;
      }
      a = a + 2;
    }

    return 0;
}
</code></pre>
<details>
 <summary>Odpověď</summary>
<p>Program vypíše:</p>
<pre><code>Hodnota a = 4
Hodnota a = 6
Hodnota a = 8
</code></pre>
<p>V každé iteraci cyklu se hodnota proměnné <code>a</code> zvýší o dvojku. Pokud je na začátku iterace hodnota
<code>a</code> větší, než dva, tak se vypíše její hodnota. V páté iteraci cyklu je hodnota proměnné <code>a</code>
osm, takže se cyklus ukončí příkazem <code>break</code>. Všimněte si rozdílu pořadí příkazu <code>if</code> a zvýšení
hodnoty proměnné <code>a</code> v tomto a předchozím příkladu.</p>
</details>
</li>
<li>
<p>Co vypíše následující program?</p>
<pre><code class="language-c editable mainbody">#include &lt;stdio.h&gt;

int main() {
    int a = 0;
    int b = 6;

    while (a &gt; b) {
      printf(&quot;Hodnota b = %d\n&quot;, b);
      b = b + 1;
    }

    return 0;
}
</code></pre>
<details>
 <summary>Odpověď</summary>
<p>Program nevypíše nic, protože podmínka <code>a &gt; b</code> se vyhodnotí jako <code>false</code>. Tělo cyklu se tak
neprovede ani jednou.</p>
</details>
</li>
</ol>
<h1><a class="header" href="#cyklus-for" id="cyklus-for">Cyklus <code>for</code></a></h1>
<p>V programech velmi často potřebujeme vykonat nějaký blok kódu přesně <code>n</code>-krát:</p>
<ul>
<li>Projdi <code>n</code> řádků ze vstupního souboru a sečti jejich hodnoty.</li>
<li>Pošli zprávu všem <code>n</code> účastníkům chatu.</li>
<li>Vystřel přesně třikrát ze zbraně.</li>
</ul>
<p>I když pomocí cyklu <code>while</code> můžeme vyjádřit provedení <code>n</code> iterací, je to relativně zdlouhavé,
protože je k tomu potřeba alespoň tří řádků kódu:</p>
<ul>
<li>Inicializace cyklu: vytvoření řídící proměnné, která se bude kontrolovat v cyklu</li>
<li>Kontrola výrazu: kontrola, jestli už řídící proměnná dosáhla požadované hodnoty</li>
<li>Operace na konci cyklu: změna hodnoty řídící proměnné</li>
</ul>
<pre><code class="language-c">int i = 0; // inicializace řídící proměnné
while (i &lt; 10) { // kontrola hodnoty řídící proměnné
    // tělo cyklu
    i += 1; // změna hodnoty řídící proměnné
}
</code></pre>
<p>Cyklus <code>for</code> existuje, aby tuto častou situaci zjednodušil. Kód výše by se dal pomocí cyklu <code>for</code>
přepsat takto:</p>
<pre><code class="language-c">for (int i = 0; i &lt; 10; i += 1) {
    // tělo cyklu
}
</code></pre>
<p>Jak lze vidět, <code>for</code> cyklus v sobě kombinuje inicializaci cyklu, kontrolu výrazu a provedení příkazu
po každé iteraci. Obecná syntaxe tohoto cyklu vypadá takto:</p>
<pre><code class="language-c">for (&lt;příkaz A&gt;; &lt;výraz typu bool&gt;; &lt;příkaz B&gt;) {
    // tělo cyklu
}
</code></pre>
<p>Takovýto cyklus se vykoná následovně:</p>
<ol>
<li>Jakmile se cyklus začne vykonávat, nejprve se provede příkaz <code>A</code>. Zde se typicky vytvoří
řídící proměnná s nějakou počáteční hodnotou.</li>
<li>Zkontroluje se výraz. Pokud není pravdivý, cyklus končí a program pokračuje za cyklem <code>for</code>.
Pokud je pravdivý, provede se tělo cyklu a program pokračuje bodem 3.</li>
<li>Provede se příkaz <code>B</code> a program pokračuje bodem 2.</li>
</ol>
<blockquote>
<p>Výraz v příkazu <code>for</code> může chybět, v takovém případě se pokládá automaticky za <code>true</code>. Zároveň platí,
že středníkem (<code>;</code>) lze vyjádřit tzv. <em>prázdný příkaz</em>, který nic neprovede. Všechny tři části cyklu
<code>for</code> tak můžou chybět, v tom případě se pak jedná o <a href="c/rizeni_toku/while.html#nekone%C4%8Dn%C3%BD-cyklus">nekonečný cyklus</a>:</p>
<pre><code class="language-c">for (;;) {
   ...
}
</code></pre>
</blockquote>
<hr/>
<p><strong>Cvičení</strong> 🏋</p>
<ul>
<li>Napište program, který pomocí cyklu <code>for</code> na výstup vypíše čísla od 0 do 9 (včetně).</li>
<li>Vypište na výstup řádek <code>Licha iterace</code> v každé liché iteraci cyklu a řádek <code>Suda iterace</code> v každé
sudé iteraci tohoto cyklu.</li>
</ul>
<hr/>
<p><strong>Kvíz</strong> 🤔</p>
<ol>
<li>
<p>Co vypíše následující program?</p>
<pre><code class="language-c editable mainbody">#include &lt;stdio.h&gt;

int main() {
    int a = 5;
    for (; a &gt;= 0; a = a - 1) {
       printf(&quot;iterace %d\n&quot;, a);
    }
    printf(&quot;a = %d\n&quot;, a);

    return 0;
}
</code></pre>
<details>
 <summary>Odpověď</summary>
<p>Program vypíše:</p>
<pre><code class="language-c">iterace 5
iterace 4
iterace 3
iterace 2
iterace 1
iterace 0
a = -1
</code></pre>
<p>Při poslední iteraci cyklu se hodnota proměnné <code>a</code> zmenší z <code>0</code> na <code>-1</code>, poté už se podmínka cyklu
vyhodnotí na <code>false</code> a cyklus skončí.</p>
<p>Všimněte si, že definice a inicializace řídící proměnné je mimo cyklus, jinak bychom k této proměnné
po ukončení provádění cyklu již neměli přístup. Definice řídící proměnné před cyklem se nám může
občas hodit, pokud bychom s hodnotou řídící proměnné chtěli pracovat dále za cyklem (například
abychom zjistili, kolik iterací cyklus provedl).</p>
</details>
</li>
<li>
<p>Co vypíše následující program?</p>
<pre><code class="language-c editable mainbody">#include &lt;stdio.h&gt;

int main() {
    for (int a = 0; a &lt;= 5; a = a + 1) {
       printf(&quot;iterace %d\n&quot;, a);
       if (a &lt;= 2) {
         a = a + 1;
       }
    }

    return 0;
}
</code></pre>
<details>
 <summary>Odpověď</summary>
<p>Program vypíše:</p>
<pre><code class="language-c">iterace 0
iterace 2
iterace 4
iterace 5
</code></pre>
<p>Pokud je při provádění iterace cyklu hodnota <code>a</code> menší nebo rovno dvěma, tak se hodnota <code>a</code> v
iteraci zvýší o jedničku dvakrát (jednou uvnitř příkazu <code>if</code> a jednou na konci iterace cyklu <code>for</code>).</p>
</details>
</li>
<li>
<p>Co vypíše následující program?</p>
<pre><code class="language-c editable mainbody">#include &lt;stdio.h&gt;

int main() {
    for (int a = 0; a = 5; a = a + 1) {
       printf(&quot;iterace %d\n&quot;, a);
    }

    return 0;
}
</code></pre>
<details>
 <summary>Odpověď</summary>
<p>Program bude neustále vypisovat hodnotu proměnné <code>a</code>, protože výraz <code>a = 5</code> se vyhodnotí
jako <code>5</code>, a toto číslo se při <a href="c/rizeni_toku/../datove_typy/pravdivostni_typy.html#konverze">převodu</a> na <code>bool</code>
vyhodnotí jako pravda (<code>true</code>), takže tento cyklus je nekonečný. Záměna přiřazení (<code>=</code>)
a <code>==</code> (porovnání) je častou <a href="c/rizeni_toku/../../caste_chyby/caste_chyby.html#z%C3%A1m%C4%9Bna--a-">začátečnickou chybou</a>.</p>
</details>
</li>
</ol>
<h1><a class="header" href="#funkce" id="funkce">Funkce</a></h1>
<p>Zatím jsme veškerý kód psali pouze na jedno místo v programu, do <a href="c/funkce/../../ruzne/funkce_main.html">&quot;mainu&quot;</a>.
Jakmile programy začnou být větší a větší, tak začne také být neustále těžší a těžší se v nich zorientovat
a udržet je celé v hlavě, abychom nad nimi mohli přemýšlet. Zároveň se nám v programu brzy začnou
objevovat úseky kódu, které jsou téměř totožné, ale liší se v drobných detailech. Chtěli bychom tak
mít možnost takovýto kód napsat pouze jednou a tyto měnící se detaily do něj pouze &quot;dosadit&quot;.
K rozdělení kódu programu do sady ucelených částí a jejich parametrizaci slouží <strong>funkce</strong> (<em>functions</em>).</p>
<p>Funkce je pojmenovaný blok kódu, na který se můžeme odkázat v jiné části programu a vykonat tak
kód, který se ve funkci nachází. S jednou funkcí už jsme se setkali. Jedná se o funkci <code>main</code>, jejíž
kód je proveden při spuštění programu. My si nicméně můžeme vytvořit vlastní funkce. Zde je
příklad vytvoření, tj. <strong>definice</strong> (<em>definition</em>) jednoduché funkce s názvem<sup class='margin-toggle sidenote-number'>1</sup> <code>vypis_text</code>:</p>
<span class='sidenote'><p><sup class='number'>1</sup>Pravidla pro pojmenovávání funkcí jsou totožná s pravidly pro
<a href="c/funkce/../promenne/pojmenovavani.html">pojmenovávání proměnných</a>.</p>
</span>
<pre><code class="language-c">void vypis_text() {
    printf(&quot;Ahoj\n&quot;);
}
</code></pre>
<p>Před názvem funkce je nutné uvést datový typ (zde je uveden typ <code>void</code>). <a href="c/funkce/funkce.html#n%C3%A1vratov%C3%A1-hodnota-funkc%C3%AD">Níže</a>
bude vysvětleno, k čemu tento typ slouží.</p>
<p>Tento blok<sup class='margin-toggle sidenote-number'>2</sup> kódu se přeloží na instrukce a bude existovat v přeloženém programu stejně jako funkce
<code>main</code>, nicméně sám o sobě se nezačne provádět. Abychom kód této funkce provedli, musíme ji tzv.
<strong>zavolat</strong> (<em>call</em>). To provedeme tak, že napíšeme název této funkce a za něj dáme
závorky (<code>()</code>):</p>
<span class='sidenote'><p><sup class='number'>2</sup>Stejně jako u <a href="c/funkce/../rizeni_toku/while.html">cyklů</a> se bloku kódu funkce často říká <strong>tělo funkce</strong> (<em>function body</em>).</p>
</span>
<pre><code class="language-c editable mainbody">#include &lt;stdio.h&gt;

void vypis_text() {
    printf(&quot;Ahoj\n&quot;);
}
int main() {
    vypis_text(); // zavolání funkce vypis_text
    return 0;
}
</code></pre>
<p>Zavolání funkce je výraz, při jehož vyhodnocení dojde k provedení kódu funkce, která se volá.
Když se v programu nahoře ve funkci <code>main</code> vykoná řádek <code>vypis_text();</code>, tak se začne vykonávat kód
funkce <code>vypis_text</code>. Jakmile se příkazy z této funkce vykonají, tak program bude pokračovat ve funkci
<code>main</code>.</p>
<p>Pomocí volání funkcí můžeme mít kus kódu v programu zapsán pouze jednou ve funkci, a poté ho
můžeme spouštět z různých částí programu, podle toho, kdy se nám to zrovna bude hodit.</p>
<blockquote>
<p>Funkce <code>main</code> je zavolána při spuštění programu, čímž dojde k tomu, že se začnou vykonávat její
příkazy.</p>
</blockquote>
<h2><a class="header" href="#parametrizace-funkcí" id="parametrizace-funkcí">Parametrizace funkcí</a></h2>
<p>Funkcím můžeme přiřadit vstupy zvané <strong>parametry</strong> (<em>parameters</em>). Parametry jsou proměnné dostupné
uvnitř funkce, jejichž hodnotu nastavujeme při zavolání dané funkce. Například následující funkce
<code>vypis_cislo</code> má parametr <code>cislo</code> s datovým typem <code>int</code>.</p>
<pre><code class="language-c editable">#include &lt;stdio.h&gt;

void vypis_cislo(int cislo) {
    printf(&quot;Cislo: %d\n&quot;, cislo);
}
int main() {
    vypis_cislo(5);
    return 0;
}
</code></pre>
<p>Při zavolání funkce musíme pro každý její parametr do závorek dát hodnotu odpovídajícího datového typu.
Zde je jediný parameter typu <code>int</code>, takže při zavolání této funkce musíme do závorek dát jednu hodnotu
datového typu <code>int</code>: <code>vypis_cislo(5)</code>. Před spuštěním příkazů ve funkci dojde k tomu, že se každý
parametr nastaví na hodnotu předanou při volání funkce<sup class='margin-toggle sidenote-number'>3</sup>. Při zavolání <code>vypis_cislo(5)</code> si tak můžete
představit, že se vykoná následující kód:</p>
<span class='sidenote'><p><sup class='number'>3</sup>Hodnoty (výrazy) předávané při volání funkce se nazývají <strong>argumenty</strong> (<em>arguments</em>). Při
volání <code>vypis_cislo(5)</code> se tedy do parametru <code>cislo</code> nastaví hodnota argumentu <code>5</code>.</p>
</span>
<pre><code class="language-c">{
    // nastavení hodnot parametrů
    int cislo = 5;

    // tělo funkce
    printf(&quot;Cislo: %d\n&quot;, cislo); 
}
</code></pre>
<p>Je důležité si uvědomit, že při každém zavolání funkce můžeme použít různé hodnoty argumentů:</p>
<pre><code class="language-c editable">#include &lt;stdio.h&gt;

void vypis_cislo(int cislo) {
    printf(&quot;Cislo: %d\n&quot;, cislo);
    if (cislo &lt; 0) {
        printf(&quot;Predane cislo je zaporne\n&quot;);
    } else {
        printf(&quot;Predane cislo je nezaporne\n&quot;);
    }
}
int main() {
    vypis_cislo(5);
    vypis_cislo(1 + 8);

    int x = -10;
    vypis_cislo(x);

    return 0;
}
</code></pre>
<p>Parametrů mohou funkce brát libovolný počet, nicméně obvykle se používají jednotky (maximálně cca 5)
parametrů, aby funkce a její používání (volání) nebylo příliš složité. Jednotlivé parametry jsou
odděleny v definici funkce i v jejím volání čárkami:</p>
<pre><code class="language-c editable">#include &lt;stdio.h&gt;

void vypis_cisla(int a, int b) {
    printf(&quot;Cislo a: %d\n&quot;, a);
    printf(&quot;Cislo b: %d\n&quot;, b);
}
int main() {
    vypis_cisla(5 + 5, 11 * 2);
    return 0;
}
</code></pre>
<p>Pomocí parametrů můžeme vytvořit kód, který není &quot;zadrátovaný&quot; na konkrétní hodnoty, ale umí pracovat
s libovolnou hodnotou vstupu. Díky toho lze takovou funkci využít v různých situacích bez toho, abychom
její kód museli kopírovat. Příklady použití parametrů funkcí:</p>
<ul>
<li>Funkci <code>vypis_ctverec</code>, která přijme jako parametr číslo <code>n</code> a vypíše na výstup čtverec tvořený
znaky <code>x</code> o straně <code>n</code>.</li>
<li>Funkci <code>vykresli_pixel</code>, která přijme jako parametry souřadnici na obrazovce a barvu a vykreslí
na obrazovce na dané pozici pixel s odpovídající barvou.</li>
</ul>
<hr />
<p><strong>Cvičení</strong> 🏋</p>
<p>Zkuste naprogramovat funkci <code>vypis_ctverec</code>. Další zadání jednoduchých funkcí naleznete
<a href="c/funkce/../../ulohy/funkce.html">zde</a>.</p>
<hr />
<h2><a class="header" href="#návratová-hodnota-funkcí" id="návratová-hodnota-funkcí">Návratová hodnota funkcí</a></h2>
<p>Nejenom, že funkce mohou přijímat vstup, ale umí také vracet výstup. Datový typ uvedený před názvem
funkce udává, jakého typu bude tzv. <strong>návratová hodnota</strong> (<em>return value</em>) dané funkce. V příkladech
výše jsme viděli datový typ <code>void</code>. Tento datový typ je speciální, protože říká, že funkce nebude
vracet <em>nic</em>. Pokud funkce má návratový typ <code>void</code>, tak nevrací žádnou hodnotu - pokud zavoláme
takovouto funkci, tak se sice provede její kód, ale výraz zavolání nevrátí žádnou hodnotu:</p>
<pre><code class="language-c editable">void funkce() {}

int main() {
    // chyba při překladu, funkce nic nevrací
    int x = funkce();
    return 0;
}
</code></pre>
<p>Často bychom nicméně chtěli funkci, která přijme nějaké hodnoty (parametry), vypočte nějakou hodnotu
a poté ji vrátí. Toho můžeme dosáhnout tak, že funkci dáme návratový typ jiný než <code>void</code> a poté
ve funkci použijeme příkaz <code>return &lt;výraz&gt;;</code>. Při provedení tohoto výrazu
se přestane funkce vykonávat a její volání se vyhodnotí hodnotou předaného výrazu. Zde je příklad
funkce, která bere jako vstup jedno číslo a spočítá jeho třetí mocninu:</p>
<pre><code class="language-c editable">#include &lt;stdio.h&gt;

int treti_mocnina(int cislo) {
   return cislo * cislo * cislo;
}
int main() {
   printf(&quot;%d\n&quot;, treti_mocnina(5 + 1));
   return 0;
}
</code></pre>
<blockquote>
<p>Jak probíhá vyhodnocování funkcí si můžete procvičit <a href="c/funkce/../../ruzne/vyhodnocovani_vyrazu.html">zde</a>.</p>
</blockquote>
<p>Příkazů <code>return</code> může být ve funkci více:</p>
<pre><code class="language-c">int absolutni_hodnota(int cislo) {
    if (cislo &gt;= 0) {
        return cislo;
    }
    return -cislo;
}
</code></pre>
<p>Nicméně je důležité si uvědomit, že po provedení příkazu <code>return</code> už funkce dále nebude pokračovat:</p>
<pre><code class="language-c">int zvetsi(int cislo) {
    return cislo + 1;
    printf(&quot;Provadi se funkce zvetsi\n&quot;); // tento řádek se nikdy neprovede
}
</code></pre>
<blockquote>
<p>Pokud má funkce jakýkoliv jiný návratový typ než <code>void</code>, tak v ní musí být vždy proveden příkaz
<code>return</code>! Pokud k tomu nedojde, tak program může začít vykazovat <a href="c/funkce/../../ruzne/nedefinovane_chovani.html">nedefinované chování</a>
💣 a může se tak chovat nepředvídatelně. Například následující funkce je špatně, protože pokud hodnota
parametru <code>cislo</code> bude nezáporná, tak se ve funkci neprovede příkaz <code>return</code>:</p>
<pre><code class="language-c">int absolutni_hodnota(int cislo) {
    if (cislo &lt; 0) {
      return -cislo;
    }
}
</code></pre>
</blockquote>
<p>Pokud má funkce návratový typ <code>void</code>, tak její provádění můžeme ukončit pomocí příkazu <code>return;</code>
(zde nepředáváme žádný výraz, protože funkce nic nevrací).</p>
<h2><a class="header" href="#syntaxe" id="syntaxe">Syntaxe</a></h2>
<p>Syntaxe funkcí v <em>C</em> vypadá takto:</p>
<pre><code class="language-c">&lt;datový typ&gt; &lt;název funkce&gt;(&lt;dat. typ par. 1&gt; &lt;název par. 1&gt;, &lt;dat. typ par. 2&gt; &lt;název par. 2&gt;, …) {
    // blok kódu
} 
</code></pre>
<p>Datovému typu, názvu funkce a jejím parametrům se dohromady říká <strong>signatura</strong> (<em>signature</em>) funkce.
Abychom věděli, jak s danou funkcí pracovat (jak ji volat), tak nám stačí znát její signaturu,
nemusíme nutné znát obsah jejího těla.<sup class='margin-toggle sidenote-number'>4</sup></p>
<span class='sidenote'><p><sup class='number'>4</sup>Tento fakt bude důležitý <a href="c/funkce/../modularizace/pouzivani_kodu_z_jinych_souboru.html#deklarace-vs-definice">později</a>.</p>
</span>
<h2><a class="header" href="#výhody-funkcí" id="výhody-funkcí">Výhody funkcí</a></h2>
<p>Zde je pro zopakování uveden přehled výhod používání funkcí:</p>
<ul>
<li><strong>Znovupoužitelnost kódu</strong> Pokud chcete stejný kód použít na více místech programu, nemusíte ho
&quot;copy-pastovat&quot;. Stačí ho vložit do funkce a tu poté opakovaně volat.</li>
<li><strong>Parametrizace kódu</strong> Pokud chcete spouštět stejný kód s různými vstupními hodnotami, stačí udělat
funkci, která dané hodnoty přijme jako parametry (a případně vrátí výsledek výpočtu jako svou
návratovou hodnotu).</li>
<li><strong>Abstrakce</strong> Když rozdělíte logiku programu do sady funkcí, tak si značně usnadníte přemýšlení nad
celým programem. Jednotlivé funkce budete moct testovat a přemýšlet nad nimi separátně, nezávisle na
zbytku programu. Pomocí používání funkcí také bude mnohem přehlednější čtení programu, protože bude
stačit číst, co se provádí (která funkce se volá) a ne jak se to provádí (jaké příkazy jsou v těle
funkce). Takovýhle kód pak lze číst téměř jako větu v přirozeném jazyce:
<pre><code class="language-c">int zivot = vrat_zivoty_hrace(id_hrace);
zivot = zivot - vypocti_zraneni_prisery(id_prisery);
nastav_zivoty_hrace(id_hrace, zivot);
</code></pre>
</li>
<li><strong>Sdílení kódu</strong> Pokud budete chtít použít kód, který napsal někdo jiný, tak toho můžete dosáhnout
právě používáním funkcí, které vám někdo <a href="c/funkce/../modularizace/knihovny.html">nasdílí</a>.</li>
</ul>
<h2><a class="header" href="#umístění-funkcí" id="umístění-funkcí">Umístění funkcí</a></h2>
<p>Funkce v <em>C</em> musíme psát vždy na nejvyšší úrovni souboru. V <em>C</em> tedy například není možné definovat
funkci uvnitř jiné funkce:</p>
<pre><code class="language-c editable readonly">int main() {
    int test() { }
}
</code></pre>
<p>Důležité je ale také to, kam přesně funkci ve zdrojovém kódu umístíte. Abyste mohli nějakou funkci
zavolat, tak její definice se musí v kódu nacházet nad řádkem, kde funkci voláte. Tento kód tak nebude
fungovat:</p>
<pre><code class="language-c">int main() {
    vypis_text();
    return 0;
}
void vypis_text() {
    // ...
}
</code></pre>
<p>Proč tomu tak je, a jak lze toto pravidlo obejít, si řekneme
<a href="c/funkce/../modularizace/pouzivani_kodu_z_jinych_souboru.html#deklarace-vs-definice">později</a>. </p>
<h2><a class="header" href="#proč-název-funkce" id="proč-název-funkce">Proč název &quot;funkce&quot;?</a></h2>
<p>Možná vás napadlo, že název funkce zní podobně jako <a href="https://matematika.cz/co-je-to-funkce">funkce</a>
v matematice. Není to náhoda, funkce v programech se tak opravdu dají částečně chápat – berou nějaký
vstup (parametry) a vracejí výstup (návratovou hodnotu). Například následující matematickou funkci:</p>
<p>\( f(x) = 2 * x \)</p>
<p>můžeme v <em>C</em> naprogramovat takto:</p>
<pre><code class="language-c">int f(int x) {
    return 2 * x;
}
</code></pre>
<p>Aby ale funkce v <em>C</em> splňovala požadavky matematické funkce, musí být splněno několik podmínek:</p>
<ul>
<li>Funkce nesmí mít žádné <a href="c/funkce/../prikazy_vyrazy.html#vedlej%C5%A1%C3%AD-efekty">vedlejší efekty</a>. To znamená, že by
měla pouze provést výpočet na základě vstupních parametrů a vrátit vypočtenou hodnotu. Neměla by
číst ani modifikovat <a href="c/funkce/../promenne/globalni_promenne.html">globální proměnné</a> nebo například pracovat
se soubory na disku či komunikovat po síti.</li>
<li>Funkce musí mít návratový typ jiný než <code>void</code>, aby vracela nějakou hodnotu. Z toho také vyplývá,
že funkce s návratovým typem <code>void</code> by měla mít nějaké vedlejší efekty, jinak by totiž nemělo
smysl ji volat (protože nic nevrací).</li>
<li>Pokud je funkce zavolána se stejnými hodnotami parametrů, musí vždy vrátit stejnou návratovou
hodnotu. Této vlastnosti se říká <em>idempotence</em>. Jelikož jsou počítače deterministické, tato
vlastnost by měla být triviálně splněna, pokud funkce neobsahuje žádné vedlejší efekty.</li>
</ul>
<p>Funkce splňující tyto vlastnosti se nazývají <em>čisté</em> (<em>pure</em>). S takovýmito funkcemi je jednodušší
pracovat a přemýšlet nad tím, co dělají, protože si můžeme být jistí, že nemodifikují okolní stav
programu a pouze spočítají výsledek v závislosti na svých parametrech. Pokud to tedy jde, snažte se
funkce psát tímto stylem (samozřejmě ne vždy je to možné).</p>
<p>V předmětu
<a href="http://behalek.cs.vsb.cz/wiki/index.php/Functional_programming/cs">Funkcionální programování</a>
budete pracovat s funkcionálními programovacími jazyky, ve kterých je právě většina funkcí čistých.</p>
<hr />
<p><strong>Kvíz</strong> 🤔</p>
<ol>
<li>
<p>Co vypíše následující program?</p>
<pre><code class="language-c editable">#include &lt;stdio.h&gt;

void zmen_cislo(int cislo) {
    cislo = 5;
}

int main() {
    int cislo = 8;
    zmen_cislo(cislo);
    printf(&quot;%d\n&quot;, cislo);

    return 0;
}
</code></pre>
<details>
 <summary>Odpověď</summary>
<p>Program vypíše <code>8</code>. Při volání <code>zmen_cislo</code> se uvnitř této funkce vytvoří nová lokální proměnná
pro parametr <code>cislo</code> a uloží se do ní hodnota z odpovídajícího předaného argumentu. Změna hodnoty
tohoto parametru uvnitř <code>zmen_cislo</code> nijak neovlivní proměnnou <code>cislo</code> uvnitř funkce <code>main</code>.</p>
<p>Můžete si to představit tak, že se při zavolání této funkce provedl cca takovýto kód:</p>
<pre><code class="language-c">{
  // nastavení parametru
  int cislo = 8;

  // kód funkce
  cislo = 5;
}
</code></pre>
<p>To, že se zde parametr jmenuje stejně jako proměnná, kterou předáváme jako argument, nemá žádný
speciální význam. Funkci jsme mohli klidně zavolat např. takto: <code>zmen_cislo(1 + 9)</code>. Z toho je zřejmé,
že změna hodnoty parametru nijak neovlivní předaný argument.</p>
<blockquote>
<p>Mimochodem, tím, že <code>zmen_cislo</code> nic nevrací a nemá žádný vedlejší efekt, tak v podstatě ani nemá
žádný smysl. Je to pouze ukázka.</p>
</blockquote>
</details>
</li>
<li>
<p>Co vypíše následující program?</p>
<pre><code class="language-c editable">#include &lt;stdio.h&gt;

void vytvor_promennou() {
    int x = 5;
}

int main() {
    vytvor_promennou();
    printf(&quot;%d\n&quot;, x);

    return 0;
}
</code></pre>
<details>
 <summary>Odpověď</summary>
<p>Tento program se nepřeloží, protože uvnitř funkce <code>main</code> neexistuje proměnná s názvem <code>x</code>.
Lokální proměnné jsou dostupné pouze v rámci <a href="c/funkce/../promenne/promenne.html#platnost">bloku</a>, ve kterém
byly nadefinovány. Proměnnou <code>x</code> tak lze použít pouze v kódu uvnitř funkce <code>vytvor_promennou</code>.</p>
</details>
</li>
<li>
<p>Co vypíše následující program?</p>
<pre><code class="language-c editable">#include &lt;stdio.h&gt;

void vypis_soucet(int x) {
    int soucet = x + b;
    printf(&quot;%d\n&quot;, soucet);
}

int main() {
    int a = 5;
    int b = 8;

    vypis_soucet(a);

    return 0;
}
</code></pre>
<details>
 <summary>Odpověď</summary>
<p>Tento program se nepřeloží, protože uvnitř funkce <code>vypis_soucet</code> neexistuje proměnná s názvem
<code>b</code>. Na řádku, kde funkci voláme, sice existuje proměnná <code>b</code> uvnitř funkce <code>main</code>, ale to s tím 
nijak nesouvisí - co kdybychom <code>vypis_soucet</code> volali z nějakého jiného místa programu, kde
by žádná proměnná <code>b</code> neexistovala? Funkce má přístup pouze ke svým lokálním proměnným a parametrům
(případně také ještě ke <a href="c/funkce/../promenne/globalni_promenne.html">globálním</a> proměnným). Pokud chceme
nějakou hodnotu z jedné funkce použít v jiné funkci, musíme ji předat jako parametr:</p>
<pre><code class="language-c">void vypis_soucet(int x, int b) {
    int soucet = x + b;
    printf(&quot;%d\n&quot;, soucet);
}

int main() {
    int a = 5;
    int b = 8;

    vypis_soucet(a, b);

    return 0;
}
</code></pre>
</details>
</li>
<li>
<p>Co vypíše následující program?</p>
<pre><code class="language-c editable">#include &lt;stdio.h&gt;

int vrat_cislo(int x) {
    return x;
}

int main() {
    int cislo = 5;
    vrat_cislo(cislo) = 8;
    printf(&quot;%d\n&quot;, cislo);

    return 0;
}
</code></pre>
<details>
 <summary>Odpověď</summary>
<p>Tento program se nepřeloží, protože se snažíme provést operaci přiřazení (<code>=</code>), ale na levé straně
od rovnítka není místo v paměti (např. proměnná), do které bychom mohli hodnotu <code>8</code> zapsat.
Volání funkce je výraz, který se vyhodnotí jako návratová hodnota, kterou tato funkce vrátí.
Je to jako bychom napsali toto:</p>
<pre><code class="language-c">5 = 8;
</code></pre>
<p>Což zřejmě nedává smysl, a proto se program nepřeloží.</p>
</details>
</li>
<li>
<p>Co vypíše následující program?</p>
<pre><code class="language-c editable">#include &lt;stdio.h&gt;

int umocni(int x) {
    return x * x;
}

int main() {
    int cislo = 5;
    umocni(cislo);
    printf(&quot;%d\n&quot;, cislo);

    return 0;
}
</code></pre>
<details>
 <summary>Odpověď</summary>
<p>Program vypíše <code>5</code>. Volání funkce <code>umocni</code> sice vrátí hodnotu <code>25</code>, ale tato hodnota se okamžitě
&quot;zahodí&quot;, protože ji nikam neuložíme. Hodnota proměnné <code>cislo</code> se tak nezmění. Aby program vypsal
<code>25</code>, tak bychom museli návratovou hodnotu z volání funkce uložit zpět do proměnné <code>cislo</code>:</p>
<pre><code class="language-c">cislo = umocni(cislo);
</code></pre>
</details>
</li>
<li>
<p>Co vypíše následující program?</p>
<pre><code class="language-c editable">#include &lt;stdio.h&gt;

void vypis_cislo(int x) {
    if (x &lt; 0) {
        return;
    }
    printf(&quot;cislo = %d\n&quot;, x);
}

int main() {
    vypis_cislo(1);
    vypis_cislo(-1);

    return 0;
}
</code></pre>
<details>
 <summary>Odpověď</summary>
<p>Program vypíše <code>cislo = 1</code>. Při volání <code>vypis_cislo(-1)</code> bude splněna podmínka uvnitř <code>vypis_cislo</code>,
takže dojde k ukončení provádění funkce příkazem <code>return;</code> a nedojde tak k vypsání tohoto
záporného čísla.</p>
</details>
</li>
<li>
<p>Co vypíše následující program?</p>
<pre><code class="language-c editable">#include &lt;stdio.h&gt;

int vypocet(int x) {
    if (x &gt; 5) {
        return x + 1;
    }
    return x * 2;
}

int main() {
    int a = 6;
    int b = 4;
    int c = vypocet(vypocet(a) + vypocet(b));
    printf(&quot;%d\n&quot;, c);

    return 0;
}
</code></pre>
<details>
 <summary>Odpověď</summary>
<p>Program vypíše <code>16</code>. Není zde žádná zrada :) Nejprve se vyhodnotí <code>vypocet(a)</code> na <code>7</code>, poté
<code>vypocet(b)</code> na <code>8</code>, a poté se zavolá <code>vypocet(7 + 8)</code>, který se vyhodnotí na <code>16</code>. Vyhodnocování
výrazů a volání funkcí si můžete procvičit <a href="c/funkce/../../ruzne/vyhodnocovani_vyrazu.html">zde</a>.</p>
</details>
</li>
<li>
<p>Co vypíše následující program?</p>
<pre><code class="language-c editable">#include &lt;stdio.h&gt;

int cislo = 1;

void uprav_promennou() {
    cislo = 2;
}

int main() {
    printf(&quot;%d\n&quot;, cislo);
    uprav_promennou();
    printf(&quot;%d\n&quot;, cislo);

    return 0;
}
</code></pre>
<details>
 <summary>Odpověď</summary>
<p>Program vypíše:</p>
<pre><code>1
2
</code></pre>
<p>Jelikož je proměnná <code>cislo</code> globální, tak k ní mají přístup funkce <code>uprav_promennou</code> i <code>main</code>.
Změna této proměnné ve funkci <code>uprav_promennou</code> se tedy promítne, když budeme číst hodnotu této
proměnné ve funkci <code>main</code>.</p>
</details>
</li>
</ol>
<h1><a class="header" href="#rekurze" id="rekurze">Rekurze</a></h1>
<blockquote>
<p>🤓 Tato sekce obsahuje doplňující učivo. Pokud je toho na vás moc, můžete ji prozatím přeskočit
a vrátit se k ní později.</p>
</blockquote>
<p>Pokud funkce obsahuje volání sama sebe, tak tuto situaci nazýváme <strong>rekurzí</strong> (<em>recursion</em>).
Pro řešení některých problémů může být přirozené rozdělovat je na čím dál tím menší podproblémy,
dokud se nedostaneme k podproblému, který je dostatečně jednoduchý, abychom ho vyřešili rovnou.
Toto můžeme modelovat právě rekurzí, kdy voláme stejnou funkci s různými argumenty, dokud se
nedostaneme k hodnotám, pro které umíme problém vyřešit jednoduše, a v ten moment rekurzi ukončíme.</p>
<p>Jedním z jednoduchých problémů, na kterém můžeme rekurzi demonstrovat, je výpočet
<a href="https://cs.wikipedia.org/wiki/Faktori%C3%A1l">faktoriálu</a>. Faktoriál lze nadefinovat například takto:</p>
<p>\(n! = n * (n - 1)!\)</p>
<p>Vidíme, že tato samotná definice je &quot;rekurzivní&quot;: pro výpočet faktoriálu <code>n</code> musíme znát hodnotu
faktoriálu <code>n - 1</code>. Výpočet faktoriálu můžeme provést například následující funkcí:</p>
<pre><code class="language-c">int faktorial(int n) {
    if (n &lt;= 1) return 1;
    return n * faktorial(n - 1);
}
</code></pre>
<p>Pokud je parametr <code>n</code> menší než <code>1</code>, umíme faktoriál vypočítat triviálně. Pokud ne, tak spočteme
faktoriál <code>n - 1</code> a vynásobíme ho hodnotou <code>n</code>. Je důležité si uvědomit, v jakém pořadí zde probíhá
výpočet. Například při volání <code>factorial(4)</code>:</p>
<ol>
<li>Zavolá se <code>factorial(4)</code>.</li>
<li><code>factorial(4)</code> zavolá <code>factorial(3)</code>.</li>
<li><code>factorial(3)</code> zavolá <code>factorial(2)</code>.</li>
<li><code>factorial(2)</code> zavolá <code>factorial(1)</code>.</li>
<li><code>factorial(1)</code> vrátí <code>1</code>.</li>
<li><code>factorial(2)</code> vrátí <code>2 * 1</code>.</li>
<li><code>factorial(3)</code> vrátí <code>3 * 2 * 1</code>.</li>
<li><code>factorial(4)</code> vrátí <code>4 * 3 * 2 * 1</code>.</li>
</ol>
<p>Nejprve tak dojde k vypočtení <code>factorial(1)</code>, poté <code>factorial(2)</code> atd. Výpočet je tak v jistém
smyslu &quot;otočen&quot;. Zkuste si výpočet faktoriálu <a href="c/funkce/../../prostredi/ladeni.html#krokov%C3%A1n%C3%AD">odkrokovat</a>, abyste
si ujasnili, jak výpočet probíhá.</p>
<h2><a class="header" href="#přetečení-zásobníku" id="přetečení-zásobníku">Přetečení zásobníku</a></h2>
<p>Je důležité dávat si pozor na to, abychom vždy ve funkci měli podmínku, která rekurzi ukončí.
Jinak by se funkce volala &quot;donekonečna&quot;, dokud by nakonec nedošlo k
<a href="c/funkce/../../caste_chyby/pametove_chyby.html#stack-overflow">přetečení zásobníku</a>.</p>
<h1><a class="header" href="#funkce-standardní-knihovny" id="funkce-standardní-knihovny">Funkce standardní knihovny</a></h1>
<p>Když už nyní víme, co jsou to <a href="c/funkce/funkce.html">funkce</a>, tak si můžeme vysvětlit, odkud
se berou některé funkce, které jsme doposud používali, i když jsme je sami nenapsali.</p>
<p>Například výraz <code>printf(&quot;…&quot;)</code> je volání funkce s názvem <code>printf</code>. Tato funkce pochází ze
<strong>standardní knihovny C</strong> (<em>C standard library</em>). Jedná se o sadu užitečných funkcí, které jsou tak
často využívané, že jsou implicitně překladačem přidány k vašemu programu, abyste je mohli jednoduše
využívat a nemuseli ztrácet čas jejich psaním v každém programu od nuly.</p>
<p>Tyto funkce se starají například o následující oblasti:</p>
<ul>
<li>Čtení ze vstupu programu a zápis na výstup programu (například funkce <code>printf</code>)</li>
<li><a href="c/funkce/../prace_s_pameti/dynamicka_pamet.html">Dynamická alokace</a> paměti</li>
<li>Čtení a zápis <a href="c/funkce/../soubory/soubory.html">souborů</a> na disku</li>
<li><a href="c/funkce/../../ruzne/nahodna_cisla.html">Generování náhodných čísel</a></li>
<li><a href="c/funkce/../text/text.html">Práce s textem</a></li>
<li><a href="https://devdocs.io/c/chrono">Práce s časem a datem</a></li>
</ul>
<p>a mnoho dalších.</p>
<p>Abychom mohli tyto funkce používat, potřebujeme do našich programů vložit kód, který obsahuje
signatury těchto funkcí. Toho dosáhneme pomocí použití <a href="c/funkce/../preprocesor/preprocesor.html">preprocesoru</a>
– zde se dozvíte, jak funguje příkaz <code>#include &lt;…&gt;</code>, který jsme doposud používali jako &quot;black box&quot;.</p>
<p>Seznam funkcí dostupných v standardní knihovně můžete naleznout například
<a href="https://devdocs.io/c/">zde</a>.</p>
<p>Jak je standardní knihovna <em>C</em> připojena k vašim programům a jak si vytvořit vlastní knihovnu se
dozvíme později v sekci o <a href="c/funkce/../modularizace/knihovny.html">knihovnách</a>.</p>
<h1><a class="header" href="#preprocesor" id="preprocesor">Preprocesor</a></h1>
<p>Než je váš zdrojový soubor přeložen na strojové instrukce, tak jej
<a href="c/preprocesor/../../prostredi/preklad_programu.html">překladač</a> nejprve prožene tzv. <strong>preprocesorem</strong>
(<em>preprocessor</em>). Tento program nedělá nic jiného, než že projde váš zdrojový kód a zpracuje řádky
se speciálními příkazy začínajícími na <code>#</code>.</p>
<p>Ukážeme si dva typy příkazů, které preprocesor umí zpracovávat:</p>
<ul>
<li><a href="c/preprocesor/vkladani_souboru.html">Vkládání souborů</a> do vašeho kódu (<code>#include</code>)</li>
<li>Vytváření <a href="c/preprocesor/makra.html">maker</a> (<code>#define</code>)</li>
</ul>
<p>Pokud si chcete ověřit, jak vypadá váš zdrojový soubor poté, co jej zpracuje preprocesor, ale předtím,
než je přeložen na strojové instrukce, můžete k tomu použít tento příkaz<sup class='margin-toggle sidenote-number'>1</sup>:</p>
<span class='sidenote'><p><sup class='number'>1</sup>Místo <code>main.c</code> doplňte název zdrojového souboru, který chcete zpracovat preprocesorem.</p>
</span>
<pre><code class="language-bash">$ gcc -P -E main.c
</code></pre>
<h1><a class="header" href="#vkládání-souborů" id="vkládání-souborů">Vkládání souborů</a></h1>
<p>Příkaz <code>#include</code> slouží ke vložení obsahu jiného souboru do vašeho zdrojového kódu. Tento příkaz
existuje ve dvou variantách:</p>
<pre><code class="language-c">#include &lt;cesta k souboru&gt;
#include &quot;cesta k souboru&quot;
</code></pre>
<p>Rozdíl mezi nimi je popsán <a href="c/preprocesor/vkladani_souboru.html#rozd%C3%ADl-mezi-include--a-include-">níže</a>.</p>
<p>Jakmile preprocesor narazí na tento příkaz, tak se pokusí najít soubor na uvedené cestě, zpracuje
jeho obsah (tj. vyhodnotí případné další příkazy jako <code>#include</code>, které v něm mohou být) a poté jeho
obsah vloží na místo, kde je <code>#include</code> použit. Jedná se o prosté textové nahrazení (<code>Ctrl+C -&gt; Ctrl+V</code>).</p>
<p>Tento příkaz slouží k tomu, abychom mohli používat stejný kód ve více souborech bez toho, abychom
jej museli neustále ručně kopírovat. Prozatím budeme vkládat do našeho kódu zejména soubory
obsahující různé funkce <a href="c/preprocesor/../funkce/stdlib.html">standardní knihovny <em>C</em></a>. Později si ukážeme, jak
vytvořit vlastní soubory, které lze vkládat, a vytvářet tak <em>C</em> programy sestávající se z
<a href="c/preprocesor/../modularizace/modularizace.html">více zdrojových souborů</a>.</p>
<p>Zkuste si například tento zdrojový soubor pojmenovat jako <code>main.c</code> a pomocí příkazu <code>gcc -P -E main.c</code>
v terminálu zjistit, jak vypadá poté, co na něj byl aplikován preprocesor:</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int main() {
    printf(&quot;Hello world\n&quot;);
    return 0;
}
</code></pre>
<details>
<summary>Výstup může vypadat například takto</summary>
<pre><code class="language-c">typedef long unsigned int size_t;
typedef __builtin_va_list __gnuc_va_list;
typedef unsigned char __u_char;
typedef unsigned short int __u_short;
typedef unsigned int __u_int;
typedef unsigned long int __u_long;
typedef signed char __int8_t;
typedef unsigned char __uint8_t;
typedef signed short int __int16_t;
typedef unsigned short int __uint16_t;
typedef signed int __int32_t;
typedef unsigned int __uint32_t;
typedef signed long int __int64_t;
typedef unsigned long int __uint64_t;
typedef __int8_t __int_least8_t;
typedef __uint8_t __uint_least8_t;
typedef __int16_t __int_least16_t;
typedef __uint16_t __uint_least16_t;
typedef __int32_t __int_least32_t;
typedef __uint32_t __uint_least32_t;
typedef __int64_t __int_least64_t;
typedef __uint64_t __uint_least64_t;
typedef long int __quad_t;
typedef unsigned long int __u_quad_t;
typedef long int __intmax_t;
typedef unsigned long int __uintmax_t;
typedef unsigned long int __dev_t;
typedef unsigned int __uid_t;
typedef unsigned int __gid_t;
typedef unsigned long int __ino_t;
typedef unsigned long int __ino64_t;
typedef unsigned int __mode_t;
typedef unsigned long int __nlink_t;
typedef long int __off_t;
typedef long int __off64_t;
typedef int __pid_t;
typedef struct { int __val[2]; } __fsid_t;
typedef long int __clock_t;
typedef unsigned long int __rlim_t;
typedef unsigned long int __rlim64_t;
typedef unsigned int __id_t;
typedef long int __time_t;
typedef unsigned int __useconds_t;
typedef long int __suseconds_t;
typedef long int __suseconds64_t;
typedef int __daddr_t;
typedef int __key_t;
typedef int __clockid_t;
typedef void * __timer_t;
typedef long int __blksize_t;
typedef long int __blkcnt_t;
typedef long int __blkcnt64_t;
typedef unsigned long int __fsblkcnt_t;
typedef unsigned long int __fsblkcnt64_t;
typedef unsigned long int __fsfilcnt_t;
typedef unsigned long int __fsfilcnt64_t;
typedef long int __fsword_t;
typedef long int __ssize_t;
typedef long int __syscall_slong_t;
typedef unsigned long int __syscall_ulong_t;
typedef __off64_t __loff_t;
typedef char *__caddr_t;
typedef long int __intptr_t;
typedef unsigned int __socklen_t;
typedef int __sig_atomic_t;
typedef struct
{
  int __count;
  union
  {
    unsigned int __wch;
    char __wchb[4];
  } __value;
} __mbstate_t;
typedef struct _G_fpos_t
{
  __off_t __pos;
  __mbstate_t __state;
} __fpos_t;
typedef struct _G_fpos64_t
{
  __off64_t __pos;
  __mbstate_t __state;
} __fpos64_t;
struct _IO_FILE;
typedef struct _IO_FILE __FILE;
struct _IO_FILE;
typedef struct _IO_FILE FILE;
struct _IO_FILE;
struct _IO_marker;
struct _IO_codecvt;
struct _IO_wide_data;
typedef void _IO_lock_t;
struct _IO_FILE
{
  int _flags;
  char *_IO_read_ptr;
  char *_IO_read_end;
  char *_IO_read_base;
  char *_IO_write_base;
  char *_IO_write_ptr;
  char *_IO_write_end;
  char *_IO_buf_base;
  char *_IO_buf_end;
  char *_IO_save_base;
  char *_IO_backup_base;
  char *_IO_save_end;
  struct _IO_marker *_markers;
  struct _IO_FILE *_chain;
  int _fileno;
  int _flags2;
  __off_t _old_offset;
  unsigned short _cur_column;
  signed char _vtable_offset;
  char _shortbuf[1];
  _IO_lock_t *_lock;
  __off64_t _offset;
  struct _IO_codecvt *_codecvt;
  struct _IO_wide_data *_wide_data;
  struct _IO_FILE *_freeres_list;
  void *_freeres_buf;
  size_t __pad5;
  int _mode;
  char _unused2[15 * sizeof (int) - 4 * sizeof (void *) - sizeof (size_t)];
};
typedef __gnuc_va_list va_list;
typedef __off_t off_t;
typedef __ssize_t ssize_t;
typedef __fpos_t fpos_t;
extern FILE *stdin;
extern FILE *stdout;
extern FILE *stderr;
extern int remove (const char *__filename) __attribute__ ((__nothrow__ , __leaf__));
extern int rename (const char *__old, const char *__new) __attribute__ ((__nothrow__ , __leaf__));
extern int renameat (int __oldfd, const char *__old, int __newfd,
       const char *__new) __attribute__ ((__nothrow__ , __leaf__));
extern FILE *tmpfile (void) ;
extern char *tmpnam (char *__s) __attribute__ ((__nothrow__ , __leaf__)) ;
extern char *tmpnam_r (char *__s) __attribute__ ((__nothrow__ , __leaf__)) ;
extern char *tempnam (const char *__dir, const char *__pfx)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__malloc__)) ;
extern int fclose (FILE *__stream);
extern int fflush (FILE *__stream);
extern int fflush_unlocked (FILE *__stream);
extern FILE *fopen (const char *__restrict __filename,
      const char *__restrict __modes) ;
extern FILE *freopen (const char *__restrict __filename,
        const char *__restrict __modes,
        FILE *__restrict __stream) ;
extern FILE *fdopen (int __fd, const char *__modes) __attribute__ ((__nothrow__ , __leaf__)) ;
extern FILE *fmemopen (void *__s, size_t __len, const char *__modes)
  __attribute__ ((__nothrow__ , __leaf__)) ;
extern FILE *open_memstream (char **__bufloc, size_t *__sizeloc) __attribute__ ((__nothrow__ , __leaf__)) ;
extern void setbuf (FILE *__restrict __stream, char *__restrict __buf) __attribute__ ((__nothrow__ , __leaf__));
extern int setvbuf (FILE *__restrict __stream, char *__restrict __buf,
      int __modes, size_t __n) __attribute__ ((__nothrow__ , __leaf__));
extern void setbuffer (FILE *__restrict __stream, char *__restrict __buf,
         size_t __size) __attribute__ ((__nothrow__ , __leaf__));
extern void setlinebuf (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__));
extern int fprintf (FILE *__restrict __stream,
      const char *__restrict __format, ...);
extern int printf (const char *__restrict __format, ...);
extern int sprintf (char *__restrict __s,
      const char *__restrict __format, ...) __attribute__ ((__nothrow__));
extern int vfprintf (FILE *__restrict __s, const char *__restrict __format,
       __gnuc_va_list __arg);
extern int vprintf (const char *__restrict __format, __gnuc_va_list __arg);
extern int vsprintf (char *__restrict __s, const char *__restrict __format,
       __gnuc_va_list __arg) __attribute__ ((__nothrow__));
extern int snprintf (char *__restrict __s, size_t __maxlen,
       const char *__restrict __format, ...)
     __attribute__ ((__nothrow__)) __attribute__ ((__format__ (__printf__, 3, 4)));
extern int vsnprintf (char *__restrict __s, size_t __maxlen,
        const char *__restrict __format, __gnuc_va_list __arg)
     __attribute__ ((__nothrow__)) __attribute__ ((__format__ (__printf__, 3, 0)));
extern int vdprintf (int __fd, const char *__restrict __fmt,
       __gnuc_va_list __arg)
     __attribute__ ((__format__ (__printf__, 2, 0)));
extern int dprintf (int __fd, const char *__restrict __fmt, ...)
     __attribute__ ((__format__ (__printf__, 2, 3)));
extern int fscanf (FILE *__restrict __stream,
     const char *__restrict __format, ...) ;
extern int scanf (const char *__restrict __format, ...) ;
extern int sscanf (const char *__restrict __s,
     const char *__restrict __format, ...) __attribute__ ((__nothrow__ , __leaf__));
extern int fscanf (FILE *__restrict __stream, const char *__restrict __format, ...) __asm__ (&quot;&quot; &quot;__isoc99_fscanf&quot;) ;
extern int scanf (const char *__restrict __format, ...) __asm__ (&quot;&quot; &quot;__isoc99_scanf&quot;) ;
extern int sscanf (const char *__restrict __s, const char *__restrict __format, ...) __asm__ (&quot;&quot; &quot;__isoc99_sscanf&quot;) __attribute__ ((__nothrow__ , __leaf__));
extern int vfscanf (FILE *__restrict __s, const char *__restrict __format,
      __gnuc_va_list __arg)
     __attribute__ ((__format__ (__scanf__, 2, 0))) ;
extern int vscanf (const char *__restrict __format, __gnuc_va_list __arg)
     __attribute__ ((__format__ (__scanf__, 1, 0))) ;
extern int vsscanf (const char *__restrict __s,
      const char *__restrict __format, __gnuc_va_list __arg)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__format__ (__scanf__, 2, 0)));
extern int vfscanf (FILE *__restrict __s, const char *__restrict __format, __gnuc_va_list __arg) __asm__ (&quot;&quot; &quot;__isoc99_vfscanf&quot;)
     __attribute__ ((__format__ (__scanf__, 2, 0))) ;
extern int vscanf (const char *__restrict __format, __gnuc_va_list __arg) __asm__ (&quot;&quot; &quot;__isoc99_vscanf&quot;)
     __attribute__ ((__format__ (__scanf__, 1, 0))) ;
extern int vsscanf (const char *__restrict __s, const char *__restrict __format, __gnuc_va_list __arg) __asm__ (&quot;&quot; &quot;__isoc99_vsscanf&quot;) __attribute__ ((__nothrow__ , __leaf__))
     __attribute__ ((__format__ (__scanf__, 2, 0)));
extern int fgetc (FILE *__stream);
extern int getc (FILE *__stream);
extern int getchar (void);
extern int getc_unlocked (FILE *__stream);
extern int getchar_unlocked (void);
extern int fgetc_unlocked (FILE *__stream);
extern int fputc (int __c, FILE *__stream);
extern int putc (int __c, FILE *__stream);
extern int putchar (int __c);
extern int fputc_unlocked (int __c, FILE *__stream);
extern int putc_unlocked (int __c, FILE *__stream);
extern int putchar_unlocked (int __c);
extern int getw (FILE *__stream);
extern int putw (int __w, FILE *__stream);
extern char *fgets (char *__restrict __s, int __n, FILE *__restrict __stream)
     __attribute__ ((__access__ (__write_only__, 1, 2)));
extern __ssize_t __getdelim (char **__restrict __lineptr,
                             size_t *__restrict __n, int __delimiter,
                             FILE *__restrict __stream) ;
extern __ssize_t getdelim (char **__restrict __lineptr,
                           size_t *__restrict __n, int __delimiter,
                           FILE *__restrict __stream) ;
extern __ssize_t getline (char **__restrict __lineptr,
                          size_t *__restrict __n,
                          FILE *__restrict __stream) ;
extern int fputs (const char *__restrict __s, FILE *__restrict __stream);
extern int puts (const char *__s);
extern int ungetc (int __c, FILE *__stream);
extern size_t fread (void *__restrict __ptr, size_t __size,
       size_t __n, FILE *__restrict __stream) ;
extern size_t fwrite (const void *__restrict __ptr, size_t __size,
        size_t __n, FILE *__restrict __s);
extern size_t fread_unlocked (void *__restrict __ptr, size_t __size,
         size_t __n, FILE *__restrict __stream) ;
extern size_t fwrite_unlocked (const void *__restrict __ptr, size_t __size,
          size_t __n, FILE *__restrict __stream);
extern int fseek (FILE *__stream, long int __off, int __whence);
extern long int ftell (FILE *__stream) ;
extern void rewind (FILE *__stream);
extern int fseeko (FILE *__stream, __off_t __off, int __whence);
extern __off_t ftello (FILE *__stream) ;
extern int fgetpos (FILE *__restrict __stream, fpos_t *__restrict __pos);
extern int fsetpos (FILE *__stream, const fpos_t *__pos);
extern void clearerr (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__));
extern int feof (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__)) ;
extern int ferror (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__)) ;
extern void clearerr_unlocked (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__));
extern int feof_unlocked (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__)) ;
extern int ferror_unlocked (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__)) ;
extern void perror (const char *__s);
extern int fileno (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__)) ;
extern int fileno_unlocked (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__)) ;
extern FILE *popen (const char *__command, const char *__modes) ;
extern int pclose (FILE *__stream);
extern char *ctermid (char *__s) __attribute__ ((__nothrow__ , __leaf__));
extern void flockfile (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__));
extern int ftrylockfile (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__)) ;
extern void funlockfile (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__));
extern int __uflow (FILE *);
extern int __overflow (FILE *, int);

int main() {
    printf(&quot;Hello world\n&quot;);
    return 0;
}
</code></pre>
</details>
<p>Asi je zřejmé, že by nebylo praktické kopírovat ručně všechen tento kód pokaždé, když bychom chtěli
něco vytisknout na výstup programu.</p>
<h2><a class="header" href="#relativní-cesta" id="relativní-cesta">Relativní cesta</a></h2>
<p>Cesta k souboru zadávaná v <code>#include</code> by měla být relativní, tj. není dobrý nápad používat něco
podobného:</p>
<pre><code class="language-c">#include &quot;C:/Users/Kamil/Desktop/upr/muj_soubor.h&quot;
</code></pre>
<p>Takovýto program by totiž jistě nefungoval na jiném, než vašem počítači. Z kterého adresáře se tato
relativní cesta vyhodnotí je popsáno níže.</p>
<h2><a class="header" href="#rozdíl-mezi-include--a-include-" id="rozdíl-mezi-include--a-include-">Rozdíl mezi <code>#include &lt;…&gt;</code> a <code>#include &quot;…&quot;</code></a></h2>
<p>Rozdíl mezi těmito variantami není pevně definován, nicméně většina preprocesorů (resp. překladačů)
funguje takto:</p>
<ul>
<li>
<p><code>#include &lt;…&gt;</code> nejprve vyhledá zadanou cestu v tzv. systémových cestách. Jedná se o známé adresáře,
ve kterých jsou uloženy jak soubory standardní knihovny <em>C</em>, tak i dalších knihoven, které máte
v systému nainstalované. Pouze pokud se zde daný soubor nenalezne, tak se cesta vyhodnotí relativně
k zdrojovému souboru, ve kterém byl <code>#include</code> použit.</p>
<p>Seznam systémových cest si můžete vypsat pomocí příkazu <code>echo | gcc -E -Wp,-v -</code> v Linuxovém
terminálu. Do tohoto seznamu můžete také přidat dodatečné adresáře, pokud <code>gcc</code> předáte parametr
<code>-I</code>. Více se dozvíte v sekci o <a href="c/preprocesor/../modularizace/knihovny.html">knihovnách</a>.</p>
<p>Pokud se soubor, který chcete do vašeho kódu vložit, nachází v externí knihovně, která nepatří
do vašeho projektu, je běžné používat právě <code>#include &lt;&gt;</code>.</p>
</li>
<li>
<p><code>#include &quot;…&quot;</code> se nedívá do systémových cest, ale rovnou hledá zadanou cestu relativně k souboru,
ve kterém byl <code>#include</code> použit. Tuto formu používejte, pokud budete vkládat soubory z vašeho
projektu.</p>
</li>
</ul>
<h1><a class="header" href="#makra" id="makra">Makra</a></h1>
<blockquote>
<p>🤓 Tato sekce obsahuje doplňující učivo. Pokud je toho na vás moc, můžete ji prozatím přeskočit
a vrátit se k ní později.</p>
</blockquote>
<p>Občas můžeme chtít v programech použít stejnou hodnotu na více místech. V takovém případě se hodí
danou hodnotu pojmenovat, aby bylo zřejmé, co reprezentuje. Zároveň by bylo užitečné ji nadefinovat
pouze na jednom místě, abychom její hodnotu mohli jednoduše upravit bez toho, abychom při tom
museli upravovat všechna místa, kde danou hodnotu používáme.</p>
<p>Pomocí příkazu <code>#define &lt;název&gt; &lt;hodnota&gt;</code> můžeme vytvořit <strong>makro</strong> (<em>macro</em>) s daným názvem a
hodnotou. Pokud preprocesor v kódu od řádku s <code>#define</code> do konce zdrojového souboru narazí na název
makra, tak tento název nahradí hodnotou makra (opět se jedná o prosté textové nahrazení, tedy
<code>Ctrl+C -&gt; Ctrl+V</code>). Zkuste si například, co vypíše tento program:</p>
<pre><code class="language-c editable">#include &lt;stdio.h&gt;

#define CENA 25

int main() {
    printf(&quot;Cena je %d\n&quot;, CENA);
    printf(&quot;Dvojnasobek ceny je %d\n&quot;, CENA * 2);

    return 0;
}
</code></pre>
<p>Představte si, že hodnotu tohoto makra používáme v programu na stovkách míst. Pokud bychom ji
potřebovali změnit, tak stačí změnit jeden řádek s <code>#define</code> a preprocesor se poté postará o to,
že se hodnota aktualizuje na všech použitých místech.</p>
<p>Makra jsou dle konvence obvykle pojmenována s &quot;caps-lockem&quot;, tedy velkými písmeny (respektive stylem
<a href="c/preprocesor/../promenne/pojmenovavani.html#v%C3%ADceslovn%C3%A9-n%C3%A1zvy">screaming snake case</a>).</p>
<p>Je třeba brát na vědomí, že preprocesor opravdu dělá pouhé textové nahrazení. Například následující
kód tak nedává smysl:</p>
<pre><code class="language-c">#define CENA 25
int main() {
    CENA = 0;
    return 0;
}
</code></pre>
<p>protože po spuštění preprocesoru se z něj stane tento (nesmyslný) kód:</p>
<pre><code class="language-c">int main() {
    25 = 0;
    return 0;
}
</code></pre>
<h2><a class="header" href="#makra-s-parametry" id="makra-s-parametry">Makra s parametry</a></h2>
<p>Makra mohou také obsahovat parametry:</p>
<pre><code class="language-c">#define &lt;název_makra&gt;(&lt;param1&gt;, &lt;param2&gt;, …) &lt;hodnota_makra&gt;
</code></pre>
<p>Tyto parametry můžete použít pro definici hodnoty. Nicméně je opět třeba dát pozor na to, že
preprocesor pracuje pouze s textem, nerozumí jazyku <em>C</em>. Parametry tak jsou předávány čistě jako
text, je tak potřeba dávat si pozor na několik věcí:</p>
<ul>
<li>
<p><strong>Priorita operátorů</strong> Pokud bychom chtěli vytvořit například makro pro výpočet druhé mocniny,
můžeme ho napsat takto:</p>
<pre><code class="language-c">#define MOCNINA(a) a * a
</code></pre>
<p>Pokud však takovéto makro použijeme s nějakým komplexním výrazem, nemusíme dosáhnout kýženého
výsledku kvůli priority operátorů:</p>
<pre><code class="language-c editable mainbody">#include &lt;stdio.h&gt;

#define MOCNINA(a) a * a

int main() {
    printf(&quot;%d\n&quot;, MOCNINA(1 + 1));
    return 0;
}
</code></pre>
<p>Řádek s <code>printf</code> totiž preprocesor změní na <code>printf(&quot;%d\n&quot;, 1 + 1 * 1 + 1);</code>, což jistě není to,
co jsme chtěli. Proto je dobré při použití maker s parametry obalovat jednotlivé parametry
závorkami:</p>
<pre><code class="language-c">#define MOCNINA(a) (a) * (a)
</code></pre>
<p>Pak by zde již došlo k úpravě na <code>printf(&quot;%d\n&quot;, (1 + 1) * (1 + 1));</code>, což vrátí druhou mocninu
výrazu <code>1 + 1</code>, tedy <code>4</code>.</p>
</li>
<li>
<p><strong>Vedlejší efekty</strong> Pokud mají argumenty předávané do makra nějaké
<a href="c/preprocesor/../prikazy_vyrazy.html#vedlej%C5%A1%C3%AD-efekty">vedlejší efekty</a>, je třeba si dávat pozor na to, že makro může
jednoduše takovýto argument rozkopírovat a tím pádem vedlejší efekt provést vícekrát. Například při
použití makra <code>MOCNINA</code> výše by zde došlo k dvojnásobené inkrementaci proměnné <code>x</code>:</p>
<pre><code class="language-c editable mainbody">#include &lt;stdio.h&gt;

#define MOCNINA(a) a * a

int main() {
    int x = 0;
    int mocnina = MOCNINA(x++);
    printf(&quot;x=%d, mocnina=%d\n&quot;, x, mocnina);

    return 0;
}
</code></pre>
<p>Do maker tak radši nedávejte argumenty, které způsobují vedlejší efekty.</p>
</li>
</ul>
<h2><a class="header" href="#makra-vs-globální-proměnné" id="makra-vs-globální-proměnné">Makra vs globální proměnné</a></h2>
<p><a href="c/preprocesor/../promenne/globalni_promenne.html">Globální proměnné</a> jsou také pojmenované hodnoty definované na
jednom místě, proč tedy potřebujeme makra? Je to z několika důvodů:</p>
<ul>
<li>Makra s parametry umožňují definici hodnot či textu závislou na použitých parametrech, což
globální proměnné neumožňují.</li>
<li>Konstantní globální proměnné nelze použít například pro určení velikosti statických
<a href="c/preprocesor/../pole/pole.html">polí</a>.</li>
<li>Globální proměnné zabírají místo v paměti programu a zároveň zvyšují velikost spustitelného
souboru, protože v něm musí být uložena jejich iniciální hodnota
(pokud to tedy <a href="c/preprocesor/../promenne/globalni_promenne.html#inici%C3%A1ln%C3%AD-hodnota">není <code>0</code></a>). Makra se pouze textově
nahradí během překladu programu, takže samy o sobě žádnou paměť nezabírají.</li>
</ul>
<p>Nicméně, makra jsou občas problémová kvůli toho, že se nahrazují čistě jako text. <strong>Pokud je to tedy
možné, zkuste raději použít pro definici konstant v kódu konstantní globální proměnné.</strong></p>
<h2><a class="header" href="#podmíněný-překlad" id="podmíněný-překlad">Podmíněný překlad</a></h2>
<p>Makra mohou také být použity k tzv. <strong>podmíněnému překladu</strong> (<em>conditional compilation</em>). Pomocí
příkazů preprocesoru jako <code>#ifdef</code> nebo <code>#if</code> můžete přeložit kus kódu pouze, pokud je nadefinované
určité makro (popřípadě pouze pokud má určitou hodnotu). Toho se běžně využívá například pro tvorbu
programů, které jsou kompatibilní s více operačními systémy (např. jedna funkce může mít jinou
implementaci pro Linux a jinou pro Windows).</p>
<p>V UPR se s podmíněným překladem nesetkáme, více se o něm můžete dozvědět například
<a href="https://docs.microsoft.com/en-us/cpp/preprocessor/hash-if-hash-elif-hash-else-and-hash-endif-directives-c-cpp">zde</a>.</p>
<h1><a class="header" href="#práce-s-pamětí" id="práce-s-pamětí">Práce s pamětí</a></h1>
<p>V sekci o <a href="c/prace_s_pameti/../../uvod/pamet.html">paměti</a> jsme se dozvěděli, že operační paměť počítače lze adresovat
pomocí číselných adres. Prozatím jsme nicméně v našich programech s žádnými adresami explicitně
nepracovali, pouze jsme vytvářeli proměnné, jejichž paměť byla spravována automaticky. V této sekci
se dozvíte základy toho, jak tzv. <strong>správa paměti</strong> (<em>memory management</em>) funguje.</p>
<blockquote>
<p>Práce s pamětí je asi nejklíčovější částí jazyka <em>C</em>. Je potřeba ji správně pochopit, jinak
vaše programy nebudou správně fungovat a nebudete schopni odhalit, proč tomu tak je. Věnujte tedy
této kapitole zvláštní pozornost.</p>
</blockquote>
<h2><a class="header" href="#adresní-prostor-programu" id="adresní-prostor-programu">Adresní prostor programu</a></h2>
<p>Když spustíte svůj program, tak pro něj operační systém vytvoří tzv. <strong>adresní prostor</strong>
(<em>address space</em>), což je oblast paměti, se kterou program může pracovat.<sup class='margin-toggle sidenote-number'>1</sup> Tato oblast je typicky
rozdělena na několik částí, z nichž každá slouží pro různé typy dat:</p>
<span class='sidenote'><p><sup class='number'>1</sup>Díky mechanismu
<a href="https://cs.wikipedia.org/wiki/Virtu%C3%A1ln%C3%AD_pam%C4%9B%C5%A5">virtuální paměti</a> je tento
prostor soukromý pro váš běžící program - ostatní běžící programy do něj nemají přístup, pokud jim
to explicitně nepovolíte.<br /><br />
Obrázek adresního prostoru je pouze ilustrativní, různé operační systémy či běhová prostředí mohou
umísťovat jednotlivé oblasti v adresním prostoru různě.</p>
</span><div style="display: flex; justify-content: center;">
    <img src="c/prace_s_pameti/../../static/img/address_space.png" alt="Adresní prostor běžícího programu" width="300px" />
</div>
<ul>
<li><strong>Zásobník</strong> Tato část uchovává automaticky spravovaná data, zejména lokální proměnné a parametry
funkcí. Tuto oblast popisuje sekce o <a href="c/prace_s_pameti/automaticka_pamet.html">automatické paměti</a>.</li>
<li><strong>Halda</strong> Tuto část můžete využít k dynamické alokaci paměti. To nám umožňují
<a href="c/prace_s_pameti/ukazatele.html">ukazatele</a>, díky kterým můžeme explicitně pracovat s adresami v paměti. Tuto oblast
adresního prostoru popisuje sekce o <a href="c/prace_s_pameti/dynamicka_pamet.html">dynamické paměti</a>.</li>
<li><strong>Globální data</strong> Tato část obsahuje <a href="c/prace_s_pameti/../promenne/globalni_promenne.html">globální proměnné</a>,
které žijí po celou dobu běhu programu.</li>
<li><strong>Instrukce programu</strong> Do této části paměti se při spuštění programu zkopírují jeho instrukce
ze spustitelného souboru na disku. Nachází se tak v ní přeložený kód
<a href="c/prace_s_pameti/../funkce/funkce.html">funkcí</a> vašeho programu. Procesor poté čte instrukce, které má vykonat, právě
z této části paměti. Tato paměť je obvykle chráněna proti zápisu a slouží pouze pro čtení.</li>
</ul>
<h1><a class="header" href="#automatická-paměť" id="automatická-paměť">Automatická paměť</a></h1>
<p>Zatím jsme používali (lokální) proměnné, které vznikají a zanikají uvnitř funkcí. Nemuseli jsme se
tedy nijak starat o to, kde existují v paměti. Lokální proměnné se ukládají do oblasti v paměti,
kterou nazýváme <strong>zásobník</strong> (<em>stack</em>). Každý běžící program má vyhrazen určitou oblast
adresovatelné paměti, která je použita právě jako zásobník.</p>
<p>Při každém zavolání funkce vznikne na zásobníku tzv. <strong>zásobníkový rámec</strong> (<em>stack frame</em>).
V tomto rámci je vyhrazena (tzv. <strong>naalokována</strong>) paměť pro lokální proměnné volané funkce a také pro
její <a href="c/prace_s_pameti/../funkce/funkce.html#parametrizace-funkc%C3%AD">parametry</a>. Rámec vzniká při každém zavolání funkce,
v jednu chvíli tak na zásobníku může existovat více rámců (s různými hodnotami proměnných a parametrů)
pro stejnou funkci. Rámce vznikají v paměti za sebou, a jsou uvolněny v momentě, kdy se jejich
funkce dokončí.<sup class='margin-toggle sidenote-number'>1</sup></p>
<span class='sidenote'><p><sup class='number'>1</sup>Rámce tak mohou vznikat nebo zanikat pouze na konci zásobníku, ne uprostřed. Proto se tato
oblast nazývá zásobník, podle
<a href="https://cs.wikipedia.org/wiki/Z%C3%A1sobn%C3%ADk_(datov%C3%A1_struktura)">datové struktury</a>, která
má tuto vlastnost.</p>
</span>
<p>Při zavolání funkce se do paměti určené pro jednotlivé parametry v rámci nakopírují hodnoty předaných
argumentů. Jakmile funkce skončí, tak je rámec, a tedy i paměť obsahující lokální proměnné a parametry
dané funkce, uvolněn<sup class='margin-toggle sidenote-number'>2</sup>.</p>
<span class='sidenote'><p><sup class='number'>2</sup>Uvolnění zde znamená pouze to, že program bude pokládat danou paměť za volnou k dalšímu použití.
Pokud tak například funkce bude mít lokální proměnnou s hodnotou <code>5</code> a vykonání funkce skončí, tato
hodnota v paměti zůstane, dokud nebude přepsána příštím zavoláním funkce.</p>
</span>
<p>V následující animaci můžete vidět sekvenci volání funkcí. Ve sloupci vpravo je zobrazen stav
zásobníku při provádění tohoto programu:</p>
<ul>
<li>Šedé obdélníky označují zásobníkové rámce.</li>
<li>Modré obdélníky znázorňují hodnoty parametrů v rámci.</li>
<li>Červené obdélníky znázorňují hodnoty lokálních proměnných v rámci. Můžete si
všimnout, že lokální proměnné mají
<a href="c/prace_s_pameti/../promenne/promenne.html#v%C5%BEdy-inicializujte-prom%C4%9Bnn%C3%A9">nedefinovanou hodnotu</a>, dokud do nich není
nějaká hodnota zapsána, nicméně paměť pro ně již existuje od začátku provádění funkce.</li>
<li>Oranžová šipka označuje, který řádek programu je právě prováděn.</li>
</ul>
<p>Pomocí šipek v levém horním rohu animace se můžete postupně proklikat průběhem vykonání tohoto programu.
Uhodnete, jaké číslo tento program vypíše?</p>
<div style="height: 450px">
    <upr-slideshow src="../../static/animations/stack/stack-" to="15" extension="png"></upr-slideshow>
</div>
<p>V animaci si můžete všimnout, že rámce vždy vznikají a zanikají pouze na konci zásobníku.<sup class='margin-toggle sidenote-number'>3</sup>
Pokud byste si chtěli tento program spustit lokálně, tak jeho zdrojový kód je dostupný níže.</p>
<span class='sidenote'><p><sup class='number'>3</sup>Z <a href="https://stackoverflow.com/questions/2035568/why-do-stacks-typically-grow-downwards">historických</a>
důvodů zásobník roste &quot;dolů&quot;, tj. nové rámce se vytvářejí na nižší adrese v paměti.</p>
</span><details>
<summary>Zdrojový kód programu</summary>
<pre><code class="language-c editable">#include &lt;stdio.h&gt;

int fun1(int par) {
    int res = par * 2;
    if (res &lt; 50) {
        return fun1(res);
    }
    else { return res; }
}
int fun2(int a, int b) {
    int x = a + b * 2;
    int y = fun1(x);
    return x + y;
}
int main() {
    printf(&quot;%d\n&quot;, fun2(5, 6));
    return 0;
}
</code></pre>
</details>
<h2><a class="header" href="#výhody-automatické-paměti" id="výhody-automatické-paměti">Výhody automatické paměti</a></h2>
<p>Používání automatické paměti má značné výhody:</p>
<ul>
<li>Nemusíme se starat o to, jak je paměť alokována a uvolňována, vše za nás řeší překladač, který
generuje instrukce pro vytváření a uvolňování rámců při volání/dokončení provádění funkce.</li>
<li>Alokace i uvolnění paměti je velmi rychlá. Jde v podstatě o provedení jediné instrukce, která si
pamatuje, kde zrovna zásobník &quot;končí&quot; v paměti.</li>
</ul>
<p>Pokud tedy nepotřebujete žádnou složitější funkcionalitu, první volbou by mělo být právě použití
automatické paměti (tedy lokálních proměnných).</p>
<h2><a class="header" href="#nevýhody-automatické-paměti" id="nevýhody-automatické-paměti">Nevýhody automatické paměti</a></h2>
<p>Automatická paměť je sice velmi užitečná, nicméně někdy potřebujeme použít i jiné typy paměti,
protože automatická paměť má i určité nedostatky:</p>
<ul>
<li>Maximální velikost zásobníku je omezena<sup class='margin-toggle sidenote-number'>4</sup>. Nemůžeme tak na něm naalokovat větší množství paměti.<span class='sidenote'><p><sup class='number'>4</sup>Obvykle jde o jednotky KiB nebo MiB.</p>
</span></li>
<li>Počet a velikost lokálních proměnných je &quot;zadrátována&quot; do programu během jeho překladu. Nemůžeme
tak naalokovat paměť s velikostí závislou na vstupu programu. Například pokud uživatel zadá
číslo <code>n</code> a my bychom chtěli vytvořit paměť pro <code>n</code> čísel, tak
<a href="https://mrlvsb.github.io/upr-skripta/c/pole/staticka_pole.html#konstantn%C3%AD-velikost-statick%C3%A9ho-pole">obvykle nestačí</a>
použití zásobníku.</li>
<li>Paměť lokálních proměnných a parametrů je uvolněna při dokončení provádění funkce. Jediným způsobem,
jak předat hodnotu z volání funkce, je pomocí návratové hodnoty. Takto lze vrátit pouze jednu
hodnotu a nelze jednoduše sdílet paměť mezi funkcemi, protože paměť lokálních proměnných je po dokončení
volání funkce uvolněna a nelze ji tak použít z volající funkce.</li>
<li>Argumenty předávané do funkcí se kopírují do zásobníkového rámce volané funkce a návratová hodnota
se zase kopíruje zpět do rámce volající funkce. Toto kopírování může být zbytečně pomalé pro hodnoty
zabírající velký počet bytů.</li>
</ul>
<p>Abychom mohli alokovat větší množství paměti či jednoduššeji sdílet hodnoty proměnných mezi funkcemi,
tak musíme mít možnost alokovat a uvolňovat paměť manuálně. K tomu ale nejprve potřebujeme vědět,
jak pracovat přímo s adresami v paměti, k čemuž slouží <a href="c/prace_s_pameti/ukazatele.html">ukazatele</a>.</p>
<h1><a class="header" href="#ukazatele" id="ukazatele">Ukazatele</a></h1>
<p>Abychom v <em>C</em> mohli manuálně pracovat s pamětí, potřebujeme mít možnost odkazovat se na jednotlivé
hodnoty v paměti pomocí <a href="c/prace_s_pameti/../../uvod/pamet.html#adresov%C3%A1n%C3%AD-pam%C4%9Bti">adres</a>. Adresa je číslo, takže
bychom mohli pro popis adres používat například datový typ <code>unsigned int</code><sup class='margin-toggle sidenote-number'>1</sup>. To by ale nebyl dobrý
nápad, protože tento datový typ neumožňuje provádět operace, které bychom s adresami chtěli dělat
(načíst hodnotu z adresy či zapsat hodnotu na adresu), a naopak umožňuje provádět operace, které s
adresami dělat nechceme (například násobení či dělení adres obvykle nedává valný smysl).</p>
<span class='sidenote'><p><sup class='number'>1</sup>Nejnižší možná adresa je <code>0</code>, takže záporné hodnoty nemá cenu reprezentovat.</p>
</span>
<p>Z tohoto důvodu <em>C</em> obsahuje datový typ, který je interpretován jako adresa v paměti běžícího
programu. Nazývá se <strong>ukazatel</strong> (<em>pointer</em>). Kromě toho, že reprezentuje adresu, tak každý datový
typ ukazatele také obsahuje informaci o tom, jaký typ hodnoty by měl být uložen v paměti na adrese
obsažené v ukazateli. Poté říkáme, že ukazatel &quot;ukazuje na&quot; daný datový typ.</p>
<p>Abychom vytvořili datový typ ukazatele, vezmeme datový typ, na který bude ukazovat, a přidáme za něj
hvezdičku (<code>*</code>). Takto například vypadá proměnná datového typu &quot;ukazatel na <code>int</code>&quot;<sup class='margin-toggle sidenote-number'>2</sup>:</p>
<span class='sidenote'><p><sup class='number'>2</sup>Je jedno, jestli hvězdičku napíšete k datovému typu (<code>int* p</code>) anebo k názvu proměnné
(<code>int *p</code>), bílé znaky jsou zde ignorovány. Pozor však na vytváření více ukazatelů na
<a href="c/prace_s_pameti/ukazatele.html#definice-v%C3%ADce-ukazatel%C5%AF-najednou">jednom řádku</a>.</p>
</span>
<pre><code class="language-c">int* ukazatel;
</code></pre>
<p>Je důležité si uvědomit, co tato proměnná reprezentuje. Datový typ <code>int*</code> zde říká, že v proměnné
<code>ukazatel</code> bude uloženo číslo, které budeme interpretovat jako adresu. V paměti na této adrese poté
bude ležet číslo, které budeme interpretovat jako datový typ <code>int</code> (celé číslo se znaménkem).</p>
<p>Ukazatele lze libovolně &quot;vnořovat&quot;, tj. můžeme mít například &quot;ukazatel na ukazatel na celé číslo&quot;
(<code>int**</code>). Ukazatel ale i tehdy bude prostě číslo, akorát ho budeme interpretovat jako adresu jiné
adresy. Pro procvičení je níže uvedeno několik datových typů spolu s tím, jak je interpretujeme.</p>
<ul>
<li><code>int</code> - interpretujeme jako celé číslo</li>
<li><code>int*</code> - interpretujeme jako adresu, na které je uloženo celé číslo</li>
<li><code>float*</code> - interpretujeme jako adresu, na které je uloženo desetinné číslo</li>
<li><code>int**</code> - interpretujeme jako adresu, na které je uložena adresa, na které je uloženo celé číslo</li>
</ul>
<p>Někdy chceme použít &quot;univerzální&quot; ukazatel, který prostě obsahuje adresu, bez toho, abychom striktně
určovali, jak interpretovat hodnotu na dané adrese. V tom případě můžeme použít datový typ <code>void*</code>.</p>
<blockquote>
<p>Velikost všech ukazatelů v programu je obvykle stejná a je dána použitým operačním systémem a
překladačem. Ukazatele musí být dostatečně velké, aby zvládly reprezentovat libovolnou adresu,
která se v programu může vyskytnout. Na vašem počítači to bude nejspíše <strong>8 bytů</strong>, protože
pravděpodobně používáte 64-bitový systém.</p>
</blockquote>
<h2><a class="header" href="#inicializace-ukazatele" id="inicializace-ukazatele">Inicializace ukazatele</a></h2>
<p>Jelikož před spuštěním programu nevíme, na jaké adrese budou uloženy hodnoty, které nás budou
zajímat, tak obvykle nedává smysl inicializovat ukazatel na konkrétní adresu (např. <code>int* p = 5;</code>).
Pro inicializaci ukazatele tak existuje několik standardních možností:</p>
<ul>
<li>
<p><strong>Inicializace na nulu</strong> Pokud chceme vytvořit &quot;prázdný&quot; ukazatel, který zatím neukazuje na
žádnou validní adresu, tak se dle konvence inicializuje na hodnotu <code>0</code>. Takovému ukazateli se pak
říká <strong>nulový ukazatel</strong> (<em>null pointer</em>). Jelikož datový typ výrazu <code>0</code> je <code>int</code>, tak před
přiřazením této hodnoty do ukazatele jej musíme
<a href="c/prace_s_pameti/../datove_typy/konverze.html">přetypovat</a> na datový typ cílového
ukazatele:</p>
<pre><code class="language-c">float* p = (float*) 0;
</code></pre>
<p>Jelikož tento typ inicializace je velmi častý, <a href="c/prace_s_pameti/../funkce/stdlib.html">standardní knihovna <em>C</em></a>
obsahuje <a href="c/prace_s_pameti/../preprocesor/makra.html">makro</a> <code>NULL</code>, které konverzi nuly na ukazatel provede za
vás. Můžete jej najít například v souboru <code>stdlib.h</code>:</p>
<pre><code class="language-c">#include &lt;stdlib.h&gt;
// ...
float* p = NULL;
</code></pre>
</li>
<li>
<p><strong>Využití alokační funkce</strong> Pokud budete alokovat paměť <a href="c/prace_s_pameti/dynamicka_pamet.html">manuálně</a>, tak
použijete funkce, které vám vrátí adresu jako svou návratovou hodnotu.</p>
</li>
<li>
<p><strong>Využití operátoru adresy</strong> Pokud chcete ukazatel nastavit na adresu již existující hodnoty v
paměti, můžete použít <strong>operátor adresy</strong> (<em>address-of operator</em>). Ten má syntaxi <code>&amp;&lt;proměnná&gt;</code>.
Tento operátor se vyhodnotí jako adresa předané proměnné<sup class='margin-toggle sidenote-number'>3</sup>:</p>
<span class='sidenote'><p><sup class='number'>3</sup>Všimněte si, že pro výpis ukazatelů ve funkci <code>printf</code> se používá <code>%p</code> místo <code>%d</code>.</p>
</span>
<pre><code class="language-c editable mainbody">#include &lt;stdio.h&gt;

int main() {
    int x = 1;
    int* p = &amp;x;

    printf(&quot;%d\n&quot;, x);  // hodnota proměnné x
    printf(&quot;%p\n&quot;, p);  // adresa v paměti, kde je uložena proměnná x

    return 0;
}
</code></pre>
<p>Výraz předaný operátoru <code>&amp;</code> se musí vyhodnotit na něco, co má adresu v paměti (většinou to bude
<a href="c/prace_s_pameti/../promenne/promenne.html">proměnná</a>). Nedává tedy smysl použít něco jako <code>&amp;5</code>, protože 5 je
číslo, které nemá samo o sobě žádnou adresu v paměti.</p>
<p>Při použití tohoto operátoru je také třeba dávat si pozor na to, aby hodnota v paměti, jejíž
adresu použitím <code>&amp;</code> získáme, stále existovala, když se budeme později snažit k této adrese
pomocí ukazatele přistoupit. V opačném případu by mohlo dojít k
<a href="c/prace_s_pameti/../../caste_chyby/pametove_chyby.html#segmentation-fault">paměťové chybě</a> 💣.</p>
</li>
</ul>
<h2><a class="header" href="#přístup-k-paměti-pomocí-ukazatele" id="přístup-k-paměti-pomocí-ukazatele">Přístup k paměti pomocí ukazatele</a></h2>
<p>Když už máme v ukazateli uloženou nějakou (validní) adresu v paměti, tak k této paměti můžeme
přistoupit pomocí operátoru <strong>dereference</strong>. Ten má syntaxi <code>*&lt;výraz typu ukazatel&gt;</code>. Při použití
tohoto operátoru na ukazateli program přečte adresu v ukazateli, podívá se do paměti a načte hodnotu
uloženou na této adrese. Podle toho, na jaký datový typ ukazatel ukazuje, se načte odpovídající
počet bytů z paměti:</p>
<pre><code class="language-c editable mainbody">#include &lt;stdio.h&gt;

int main() {
    int cislo = 1;
    int* ukazatel = &amp;cislo;

    printf(&quot;%p\n&quot;, ukazatel);
    printf(&quot;%d\n&quot;, *ukazatel);
    printf(&quot;%d\n&quot;, cislo);

    return 0;
}
</code></pre>
<p>V tomto programu se do proměnné <code>ukazatel</code> uloží adresa proměnné <code>cislo</code>, a poté dojde k načtení
hodnoty (<code>*ukazatel</code>) této proměnné z paměti přes adresu uloženou v ukazateli.</p>
<details>
  <summary>Interaktivní vizualizace kódu</summary>
<iframe width="750" height="500" frameborder="0" src="https://pythontutor.com/iframe-embed.html#code=%23include%20%3Cstdio.h%3E%0A%0Aint%20main%28%29%20%7B%0A%20%20%20%20int%20cislo%20%3D%201%3B%0A%20%20%20%20int*%20ukazatel%20%3D%20%26cislo%3B%0A%0A%20%20%20%20printf%28%22%25p%5Cn%22,%20ukazatel%29%3B%0A%20%20%20%20printf%28%22%25d%5Cn%22,%20*ukazatel%29%3B%0A%20%20%20%20printf%28%22%25d%5Cn%22,%20cislo%29%3B%0A%0A%20%20%20%20return%200%3B%0A%7D%0A&codeDivHeight=400&codeDivWidth=350&curInstr=5&origin=opt-frontend.js&py=c_gcc9.3.0&rawInputLstJSON=%5B%5D"> </iframe>
</details>
<p>Pokud chceme do adresy uložené v ukazateli naopak nějakou hodnotu zapsat, tak můžeme operátor
dereference použít také na levé straně operátoru <a href="c/prace_s_pameti/../promenne/promenne.html#z%C3%A1pis">zápisu</a>:</p>
<pre><code class="language-c editable mainbody">#include &lt;stdio.h&gt;

int main() {
    int cislo = 1;
    int* ukazatel = &amp;cislo;
    *ukazatel = 5;

    printf(&quot;%d\n&quot;, cislo);

    return 0;
}
</code></pre>
<p>Tento program vypíše <code>5</code>, protože jsme pomocí ukazatele změnili hodnotu na adrese v paměti, kde leží
proměnná <code>cislo</code>. Když při výpisu poté načteme hodnotu proměnné <code>cislo</code>, tak už v ní bude upravená
hodnota.</p>
<details>
  <summary>Interaktivní vizualizace kódu</summary>
<iframe width="750" height="500" frameborder="0" src="https://pythontutor.com/iframe-embed.html#code=%23include%20%3Cstdio.h%3E%0A%0Aint%20main%28%29%20%7B%0A%20%20%20%20int%20cislo%20%3D%201%3B%0A%20%20%20%20int*%20ukazatel%20%3D%20%26cislo%3B%0A%20%20%20%20*ukazatel%20%3D%205%3B%0A%0A%20%20%20%20printf%28%22%25d%5Cn%22,%20cislo%29%3B%0A%0A%20%20%20%20return%200%3B%0A%7D&codeDivHeight=400&codeDivWidth=350&curInstr=0&origin=opt-frontend.js&py=c_gcc9.3.0&rawInputLstJSON=%5B%5D"> </iframe>
</details>
<p>Pokud provádíte operace s přímo s proměnnou ukazatele, budete vždy pracovat &quot;pouze&quot; s adresou,
která je v něm uložena. Pokud chcete načíst nebo změnit hodnotu, která leží v paměti na adrese
uložené v ukazateli, musíte použít operátor dereference.</p>
<blockquote>
<p>Pozor na rozdíl mezi <code>*</code> používanou pro deklaraci datového typu ukazatel, operátorem dereference
a operátorem násobení. Všechny tyto věci sice používají hvězdičku, ale jinak spolu nesouvisí.
Vždy záleží na kontextu, kde jsou tyto znaky použity:</p>
<pre><code class="language-c">// hvězdička říká, že datový typ proměnné `p` je ukazatel na `int`
int* p;

// hvězdička provede dereferenci návratové hodnoty funkce `vrat_ukazatel`
int x = *vrat_ukazatel();

// hvězdička provede násobení dvou čísel
int a = 5 * 6;
</code></pre>
</blockquote>
<h2><a class="header" href="#aritmetika-s-ukazateli" id="aritmetika-s-ukazateli">Aritmetika s ukazateli</a></h2>
<p>Abychom se mohli v paměti &quot;posouvat&quot; o určitý kus dopředu či dozadu (relativně k nějaké adrese),
můžeme k ukazatelům přičítat či odčítat čísla. Toto se označuje jako <strong>aritmetika s ukazateli</strong>
(<em>pointer arithmetic</em>). Tato aritmetika má důležité pravidlo – pokud k ukazateli na konkrétní datový
typ přičteme hodnotu <code>n</code>, tak se adresa v ukazateli zvýší o <code>n</code>-násobek velikosti datového typu,
na který ukazatel ukazuje. Při aritmetice s ukazateli se tak neposouváme po jednotlivých bytech,
ale po celých hodnotách daného datového typu<sup class='margin-toggle sidenote-number'>4</sup>.</p>
<span class='sidenote'><p><sup class='number'>4</sup>Z toho vyplývá, že aritmetiku nemůžeme provádět nad ukazateli typu <code>void*</code>, protože ty neukazují
na žádný konkrétní datový typ.</p>
</span>
<p>Například, pokud bychom měli ukazatel <code>int* p</code> s hodnotou <code>16</code> (tj. &quot;ukazuje&quot; na adresu <code>16</code>) a
velikost <code>int</code>u by byla <code>4</code>, tak výraz <code>p + 1</code> bude ukazatel s hodnotou <code>20</code>, výraz <code>p + 2</code> bude
ukazatel s adresou <code>24</code> atd.</p>
<p>Je důležité <a href="c/prace_s_pameti/../../caste_chyby/caste_chyby.html#%C5%A0patn%C3%A1-pr%C3%A1ce-s-ukazatelem">rozlišovat</a>, jestli při
použití sčítání/odčítání pracujeme s hodnotou ukazatele anebo s hodnotou na adrese, která je v
ukazateli uložena:</p>
<pre><code class="language-c">int x = 1;
int* p = &amp;x;

*p += 1;    // zvýšili jsme hodnotu na adrese v `p` (tj. proměnnou `x`) o `1`
p += 1;     // zvýšili jsme adresu v `p` o `4` (tj. p nyní už neukazuje na `x`)
</code></pre>
<blockquote>
<p>K čemu je aritmetika s ukazateli užitečná se dozvíte v sekci o práci s
<a href="c/prace_s_pameti/../pole/staticka_pole.html#p%C5%99%C3%ADstup-k-prvk%C5%AFm-pole">více proměnnými zároveň</a>.</p>
</blockquote>
<p>Kromě dereference a aritmetiky lze s ukazateli provádět také porovnávání (klasicky pomocí operátoru
<code>==</code>). Díky tomu můžeme zjistit, jestli se dvě adresy rovnají.</p>
<h2><a class="header" href="#využití-ukazatelů" id="využití-ukazatelů">Využití ukazatelů</a></h2>
<p>Jak se dozvíte v <a href="c/prace_s_pameti/dynamicka_pamet.html">následující sekci</a>, ukazatele jsou nezbytné pro
dynamickou alokaci paměti. Hodí se také při práci s <a href="c/prace_s_pameti/../pole/pole.html">více proměnnými</a> zároveň. Kromě
toho je ale lze použít také například v následujících situacích, které všechny souvisí s předáváním
adres (ukazatelů) do funkcí:</p>
<ul>
<li>
<p><strong>Změna vnějších hodnot zevnitř funkce</strong> Hodnoty argumentů předávaných při
<a href="c/prace_s_pameti/../funkce/funkce.html#parametrizace-funkc%C3%AD">volání funkcí</a> se do funkce kopírují, nelze tak jednoduše
zevnitř funkce měnit hodnoty proměnných, které existují mimo danou funkci. To je sice samo o sobě
vhodná vlastnost, protože pokud bude funkce měnit pouze své lokální proměnné, případně parametry,
tak bude jednodušší se v ní vyznat. Nicméně, někdy opravdu chceme ve funkci změnit hodnoty externích
proměnných.</p>
<p>Toho můžeme dosáhnout tak, že si do funkce místo hodnoty proměnné pošleme její adresu v
ukazateli, a pomocí této adresy pak hodnotu proměnné změníme. Takto například můžeme vytvořit funkci,
která vezme adresy dvou proměnných a prohodí jejich hodnoty:</p>
<pre><code class="language-c editable">#include &lt;stdio.h&gt;

void vymen(int* a, int* b) {
    int docasna_hodnota = *a;  // načti hodnotu na adrese v `a`
    *a = *b;  // načti hodnotu na adrese v `b` a ulož ji na adresu v `a`
    *b = docasna_hodnota;  // ulož uloženou hodnotu na adresu v `b`
}
int main() {
    int x = 5;
    int y = 10;
    vymen(&amp;x, &amp;y);
    printf(&quot;Po prehozeni: x=%d, y=%d\n&quot;, x, y);
    return 0;
}
</code></pre>
<details>
  <summary>Interaktivní vizualizace kódu</summary>
<iframe width="750" height="500" frameborder="0" src="https://pythontutor.com/iframe-embed.html#code=%23include%20%3Cstdio.h%3E%0Avoid%20vymen%28int*%20a,%20int*%20b%29%20%7B%0A%20%20%20%20int%20docasna_hodnota%20%3D%20*a%3B%0A%20%20%20%20*a%20%3D%20*b%3B%0A%20%20%20%20*b%20%3D%20docasna_hodnota%3B%0A%7D%0Aint%20main%28%29%20%7B%0A%20%20%20%20int%20x%20%3D%205%3B%0A%20%20%20%20int%20y%20%3D%2010%3B%0A%20%20%20%20vymen%28%26x,%20%26y%29%3B%0A%20%20%20%20printf%28%22Po%20prehozeni%3A%20x%3D%25d,%20y%3D%25d%5Cn%22,%20x,%20y%29%3B%0A%20%20%20%20return%200%3B%0A%7D&codeDivHeight=400&codeDivWidth=350&curInstr=12&origin=opt-frontend.js&py=c_gcc9.3.0&rawInputLstJSON=%5B%5D"> </iframe>
</details>
</li>
<li>
<p><strong>Vrácení více návratových hodnot</strong> Posílání adres proměnných do funkce můžeme využít také k
tomu, abychom z funkce vrátili více než jednu návratovou hodnotu (do adres uložených v parametrech
totiž můžeme zapsat &quot;návratové&quot; hodnoty). Toho bychom však měli využívat pouze, pokud je to opravdu
nezbytné. Takovéto funkce je totiž složitější volat a nejsou
<a href="c/prace_s_pameti/../funkce/funkce.html#pro%C4%8D-n%C3%A1zev-funkce">čisté</a>, protože obsahují vedlejší efekt - mění externí stav
programu.</p>
<pre><code class="language-c editable">#include &lt;stdio.h&gt;

void vrat_dve_hodnoty(int* a, int* b) {
    *a = 5;
    *b = 6;
}

int main() {
    int a = 0;
    int b = 0;
    vrat_dve_hodnoty(&amp;a, &amp;b);

    printf(&quot;a=%d, b=%d\n&quot;, a, b);

    return 0;
}
</code></pre>
</li>
<li>
<p><strong>Sdílení hodnot bez kopírování</strong> Pokud bychom měli proměnné, které v paměti zabírají velké
množství bytů (například <a href="c/prace_s_pameti/../struktury/struktury.html">struktury</a>), a předávali je jako argumenty
funkci, tak může být zbytečně pomalé je pokaždé kopírovat. Pokud do funkce pouze předáme jejich
adresu, tak dojde ke kopii pouze jednoho čísla s adresou, nezávisle na tom, jak velká je proměnná,
která je na dané adrese uložena. Ukazatele tak můžeme použít ke sdílení hodnot v paměti mezi funkcemi
bez toho, abychom je kopírovali.</p>
</li>
</ul>
<h2><a class="header" href="#konstantní-ukazatele" id="konstantní-ukazatele">Konstantní ukazatele</a></h2>
<p>Pokud použijeme klíčové slovo <a href="c/prace_s_pameti/../promenne/konstanty.html"><code>const</code></a> v kombinaci s ukazateli, je
potřeba si dávat pozor na to, k čemu se tohle klíčové slovo váže. To závisí na tom, zda je <code>const</code>
v datovém typu před nebo za hvězdičkou. Zde jsou možné kombinace, které můžou vzniknout u
jednoduchého ukazatele:</p>
<ul>
<li><code>int*</code> - ukazatel na celé číslo. Adresu v ukazateli lze měnit, hodnotu čísla na adrese v ukazateli
také lze měnit.</li>
<li><code>const int*</code> - ukazatel na konstantní celé číslo. Adresu v ukazateli lze měnit, hodnotu čísla na
adrese v ukazateli nikoliv.</li>
<li><code>int const *</code> - konstantní ukazatel na celé číslo. Adresu v ukazateli nelze měnit, hodnotu čísla na
adrese v ukazateli lze měnit.</li>
<li><code>const int const *</code> - konstantní ukazatel na konstantní celé číslo. Adresu v ukazateli nelze měnit,
hodnotu čísla na adrese v ukazateli také nelze měnit.</li>
</ul>
<h2><a class="header" href="#definice-více-ukazatelů-najednou" id="definice-více-ukazatelů-najednou">Definice více ukazatelů najednou</a></h2>
<p>Pokud byste chtěli vytvořit více ukazatelů
<a href="c/prace_s_pameti/../promenne/promenne.html#definice-v%C3%ADce-prom%C4%9Bnn%C3%BDch-najednou">najednou</a>, musíte si dát pozor na to, že
v tomto případě se hvězdička vztahuje pouze k jednomu následujícímu názvu proměnné. Tento kód tak
vytvoří ukazatel s názvem <code>x</code>, a dvě celá čísla s názvy <code>y</code> a <code>z</code>:</p>
<pre><code class="language-c">int* x, y, z;
</code></pre>
<p>Pokud byste chtěli vytvořit tři ukazatele, musíte dát hvězdičku před každý název proměnné:</p>
<pre><code class="language-c">int* x, *y, *z;
</code></pre>
<hr />
<p><strong>Kvíz</strong> 🤔</p>
<ol>
<li>
<p>Co vypíše následující program?</p>
<pre><code class="language-c editable mainbody">#include &lt;stdio.h&gt;

int main() {
    int a = 2;
    int* p = &amp;a;
    p = 5;

    printf(&quot;%d\n&quot;, a);

    return 0;
}
</code></pre>
<details>
 <summary>Odpověď</summary>
<p>Program vypíše <code>2</code>. Přiřazením <code>p = 5</code> změníme adresu uloženou v ukazateli <code>p</code> na <code>5</code>. Touto
operací se tedy nijak nezmění hodnota proměnné <code>a</code>, jejíž adresu ukazatel před tímto přiřazením
obsahoval. Aby k tomuto došlo, museli bychom napsat <code>*p = 5</code>.</p>
</details>
</li>
<li>
<p>Co vypíše následující program?</p>
<pre><code class="language-c editable mainbody">#include &lt;stdio.h&gt;

int main() {
    int a = 2;
    int b = 3;

    int* p = &amp;a;
    p = &amp;b;

    *p += 1;

    printf(&quot;a = %d, b = %d\n&quot;, a, b);

    return 0;
}
</code></pre>
<details>
 <summary>Odpověď</summary>
<p>Program vypíše <code>a = 2, b = 4</code>. Nejprve jsme sice nastavili ukazatel <code>p</code> na adresu proměnné <code>a</code>,
ale poté jsme do <code>p</code> zapsali adresu proměnné <code>b</code>. Řádek <code>*p += 1;</code> tak zvedne hodnotu v paměti
na adrese, kde leží <code>b</code>, o jedničku, jinak řečeno zvýší hodnotu proměnné <code>b</code> o jedničku.</p>
</details>
</li>
<li>
<p>Co vypíše následující program?</p>
<pre><code class="language-c editable mainbody">#include &lt;stdio.h&gt;

void zmen_ukazatel(int* p, int a) {
    p = &amp;a;
}

int main() {
    int a = 2;
    int b = 3;

    int* p = &amp;b;
    zmen_ukazatel(p, a);

    printf(&quot;%d\n&quot;, *p);

    return 0;
}
</code></pre>
<details>
 <summary>Odpověď</summary>
<p>Program vypíše <code>3</code>. Když předáme argument typu ukazatele do funkce, tak stejně jako u jiných datových
typů dojde k tomu, že se ve funkci vytvoří nová proměnná a do ní se nakopíruje hodnota argumentu.
Změna adresy v ukazateli <code>p</code> uvnitř funkce <code>zmen_ukazatel</code> tak neovlivní adresu v ukazateli <code>p</code>
uvnitř funkce <code>main</code>. A jelikož <code>p</code> v <code>main</code>u ukazuje na proměnnou <code>b</code>, tak dereference tohoto
ukazatele se vyhodnotí jako hodnota <code>3</code>.</p>
</details>
</li>
<li>
<p>Co vypíše následující program?</p>
<pre><code class="language-c editable mainbody">#include &lt;stdio.h&gt;

int main() {
    int a = 2;

    int* p = &amp;a;
    *p = 4;

    int b = *p;
    *p = 8;

    printf(&quot;a = %d, b = %d\n&quot;, a, b);

    return 0;
}
</code></pre>
<details>
 <summary>Odpověď</summary>
<p>Program vypíše <code>a = 8, b = 4</code>. Při vytváření proměnné <code>b</code> se hodnota na adrese uložené v ukazateli
<code>p</code> uloží do <code>b</code>. V danou chvíli je na této adrese uložena hodnota <code>4</code>, proto se do proměnné <code>b</code>
uloží právě hodnota <code>4</code>. Další změny hodnot na adrese uložené v <code>p</code> už proměnnou <code>b</code> neovlivní.</p>
</details>
</li>
<li>
<p>Co vypíše následující program?</p>
<pre><code class="language-c editable mainbody">#include &lt;stdio.h&gt;

int main() {
    int a = 2;
    int* p = &amp;a;

    printf(&quot;%d\n&quot;, p);

    return 0;
}
</code></pre>
<details>
 <summary>Odpověď</summary>
<p>Tento program obsahuje <a href="c/prace_s_pameti/../../ruzne/nedefinovane_chovani.html"><strong>nedefinované chování</strong></a> 💣, protože jsme použili
<a href="c/prace_s_pameti/../prikazy_vyrazy.html#v%C3%BDpis-v%C3%BDraz%C5%AF">zástupný znak</a> <code>%d</code>, který slouží k výpisu celých čísel, ale
předali jsme funkci <code>printf</code> argument <code>p</code>, který je datového typu ukazatel.</p>
<p>Správně můžeme buď použít zástupný znak <code>%p</code>, abychom vypsali adresu uloženou v ukazateli, nebo
můžeme použít dereferenci a vypsat hodnotu uloženou na adrese v ukazateli:</p>
<pre><code class="language-c">printf(&quot;%p\n&quot;, p);
printf(&quot;%d\n&quot;, *p);
</code></pre>
</details>
</li>
<li>
<p>Co vypíše následující program?</p>
<pre><code class="language-c editable mainbody">#include &lt;stdio.h&gt;

int main() {
    int a = 2;
    int b = 3;

    int* p = &amp;a;
    int** px = &amp;p;
    *px = &amp;b;

    *p = 8;

    printf(&quot;a = %d, b = %d\n&quot;, a, b);

    return 0;
}
</code></pre>
<details>
 <summary>Odpověď</summary>
<p>Program vypíše <code>a = 2, b = 8</code>. Proměnná <code>px</code> je ukazatel na ukazatel na <code>int</code>. Obsahuje adresu,
kde v paměti leží proměnná <code>p</code>. Pomocí <code>*px</code> změníme hodnotu na této adrese na <code>&amp;b</code>, tj. adresu
proměnné <code>b</code>. V podstatě je to to stejné, jako kdybychom napsali <code>p = &amp;b</code>.</p>
<p>Zkuste si na papír nakreslit, jak tento program bude vypadat v paměti, jaké adresy/hodnoty budou
v jednotlivých proměnných. Výsledek si můžete ověřit <a href="https://pythontutor.com/render.html#code=%23include%20%3Cstdio.h%3E%0A%0Aint%20main%28%29%20%7B%0A%20%20%20%20int%20a%20%3D%202%3B%0A%20%20%20%20int%20b%20%3D%203%3B%0A%0A%20%20%20%20int*%20p%20%3D%20%26a%3B%0A%20%20%20%20int**%20px%20%3D%20%26p%3B%0A%20%20%20%20*px%20%3D%20%26b%3B%0A%0A%20%20%20%20*p%20%3D%208%3B%0A%0A%20%20%20%20printf%28%22a%20%3D%20%25d,%20b%20%3D%20%25d%5Cn%22,%20a,%20b%29%3B%0A%0A%20%20%20%20return%200%3B%0A%7D&amp;cumulative=false&amp;curInstr=9&amp;heapPrimitives=nevernest&amp;mode=display&amp;origin=opt-frontend.js&amp;py=c_gcc9.3.0&amp;rawInputLstJSON=%5B%5D&amp;textReferences=false">touto</a>
vizualizací.</p>
</details>
</li>
</ol>
<h1><a class="header" href="#ukazatele-na-funkce" id="ukazatele-na-funkce">Ukazatele na funkce</a></h1>
<blockquote>
<p>🤓 Tato sekce obsahuje doplňující učivo. Pokud je toho na vás moc, můžete ji prozatím přeskočit
a vrátit se k ní později.</p>
</blockquote>
<p>Ve funkcionálních jazycích<sup class='margin-toggle sidenote-number'>1</sup> můžeme <a href="c/prace_s_pameti/../funkce/funkce.html">funkce</a> používat jako kterékoliv jiné
hodnoty a provádět tak s nimi operace jako je uložení funkce do proměnné, předání funkce jako
argument jiné funkci, vrácení funkce jako návratové hodnoty z jiné funkce atd. V <em>C</em> tyto operace
s funkcemi přímo provádět nemůžeme, nicméně toto omezení lze alespoň částečně obejít použitím
<strong>ukazatele na funkci</strong> (<em>function pointer</em>).</p>
<span class='sidenote'><p><sup class='number'>1</sup>Jako je např. <a href="https://www.haskell.org/">Haskell</a>.</p>
</span>
<p>Ukazatel na funkci je číslo, které neinterpretujeme jako adresu nějaké hodnoty, ale jako
adresu kódu (tedy přeložených instrukcí) funkce v paměti běžícího programu. Tyto ukazatele se od
běžných ukazatelů liší tím, že používají jinou syntaxi a také umožňují zavolat funkci, jejíž adresa
je v ukazateli uložena.</p>
<h2><a class="header" href="#syntaxe-1" id="syntaxe-1">Syntaxe</a></h2>
<p>Syntaxe datového typu ukazatele na funkci vychází ze syntaxe <a href="c/prace_s_pameti/../funkce/funkce.html#syntaxe">signatury funkce</a>
a vypadá takto:</p>
<pre><code class="language-c">&lt;datový typ&gt; (*)(&lt;parametr 1&gt;, &lt;parametr 2&gt;, ...)
</code></pre>
<p>Zde je několik ukázek:</p>
<ul>
<li>Ukazatel na funkci, která vrací <code>int</code> a bere parametr <code>int</code>: <code>int (*)(int)</code></li>
<li>Ukazatel na funkci, která vrací <code>int</code> a bere parametry <code>int</code> a <code>bool</code>: <code>int (*)(int, bool)</code></li>
<li>Ukazatel na funkci, která nic nevrací a nemá žádné parametry: <code>void (*)()</code></li>
</ul>
<p>Ukazatel na funkci tak v podstatě odpovídá signatuře funkce, na kterou ukazuje, s tím rozdílem,
že místo názvu funkce obsahuje znaky <code>(*)</code>.</p>
<p>Jelikož v definici ukazatele na funkci jsou důležité hlavně datové typy parametrů, nemusíte jednotlivé
parametry pojmenovávat. Pokud ale chcete kód učinit přehlednější, můžete jim dát jména:</p>
<pre><code class="language-c">int (*)(int mocnina, int mocnitel); 
</code></pre>
<h2><a class="header" href="#použití-v-proměnné" id="použití-v-proměnné">Použití v proměnné</a></h2>
<p>Pokud chcete vytvořit proměnnou (či parametr) datového typu ukazatel na funkce, tak musíte použít
speciální syntaxi. Běžně při vytváření proměnné nejprve napíšeme její datový typ a poté její název.
U ukazatele na funkci se však název proměnné nepíše až za datový typ, ale dovnitř závorek s hvězdičkou.
Takto lze vytvořit proměnnou s názvem <code>ukazatel1</code>, do které půjde uložit adresu funkcí, které vrací <code>int</code>
a berou dva parametry, oba typu <code>int</code>:</p>
<pre><code class="language-c">int (*ukazatel1)(int, int);
</code></pre>
<h2><a class="header" href="#inicializace-a-volání-funkce" id="inicializace-a-volání-funkce">Inicializace a volání funkce</a></h2>
<p>Pokud chcete nastavit do ukazatele na funkci nějakou hodnotu, stačí do něj přiřadit název existující
funkce.</p>
<pre><code class="language-c">int funkce(int x) {
    return x + 1;
}

int main() {
    int (*ukazatel)(int) = funkce;

    return 0;
}
</code></pre>
<p>Signatura přiřazené funkce musí odpovídat datovému typu ukazatele, nelze tak například přiřadit
funkci, která nic nevrací, do ukazatele, který má signaturu <code>int (*)()</code>.</p>
<p>Jakmile máme v proměnné ukazatele na funkci uloženou adresu nějaké funkce, můžeme pomocí názvu této
proměnné danou funkci zavolat.</p>
<pre><code class="language-c editable">#include &lt;stdio.h&gt;

int funkce(int x) {
    printf(&quot;Funkce zavolana s parametrem %d\n&quot;, x);
    return x + 1;
}

int main() {
    int (*ukazatel)(int) = funkce;
    
    int ret = ukazatel(1);
    printf(&quot;Funkce vratila %d\n&quot;, ret);

    return 0;
}
</code></pre>
<h2><a class="header" href="#případy-použití" id="případy-použití">Případy použití</a></h2>
<p>K čemu vlastně ukazatel na funkce může sloužit? Už víme, že pomocí funkcí můžeme
<a href="c/prace_s_pameti/../funkce/funkce.html#parametrizace-funkc%C3%AD">parametrizovat</a> kód, což nám umožňuje používat identický
kód nad různými vstupními hodnotami bez toho, abychom tento kód museli neustále duplikovat.</p>
<p>Prozatím jsme pro parametrizaci používali pouze jednoduché hodnoty, jako čísla nebo pravdivostní
hodnoty. Pomocí ukazatelů na funkce však můžeme parametrizovat samotný kód, který se má uvnitř
nějaké funkce provést.</p>
<p>Představte si například, že chcete vytvořit funkci, která provede nějakou operaci (např. přičtení
konstanty, vynásobení konstantou nebo vypsání na výstup) s číslem, ale pouze v případě, že toto číslo
je kladné. V opačném případě by měla funkce toto číslo pouze vrátit, bez jakékoliv změny. Jak byste
tuto funkci napsali, bez toho, abyste ji duplikovali pro každou operaci, která se má s kladným číslem
provést?</p>
<p>První řešení by mohlo vypadat například takto:</p>
<pre><code class="language-c editable">#include &lt;stdio.h&gt;

int proved_pro_kladne(int cislo, int operace) {
    if (cislo &lt;= 0) return cislo;
    
    if (operace == 0) {
        return cislo * 3;
    } else if (operace == 1) {
        return cislo + 1;
    } else {
        printf(&quot;Cislo: %d\n&quot;, cislo);
        return cislo;
    }
}

int main() {
    printf(&quot;%d\n&quot;, proved_pro_kladne(-1, 0));
    printf(&quot;%d\n&quot;, proved_pro_kladne(1, 0));
    printf(&quot;%d\n&quot;, proved_pro_kladne(1, 1));
    printf(&quot;%d\n&quot;, proved_pro_kladne(1, 2));

    return 0;
}
</code></pre>
<p>Toto řešení jistě bude fungovat, nicméně je dost nepraktické, protože musíme ve funkci
<code>proved_pro_kladne</code> dopředu vyjmenovat všechny možné operace, které lze s číslem provést. Pokud
bychom tak chtěli přidat novou operaci, budeme muset tuto funkci upravit. Zároveň je také dost
nepřehledné předávat funkci informaci o tom, jaká operace se má provést, pomocí proměnné typu <code>int</code>
(parametr <code>operace</code>).</p>
<p>Pomocí ukazatele na funkci můžeme funkci <code>proved_pro_kladne</code> předat kód<sup class='margin-toggle sidenote-number'>2</sup>, který se má provést,
pokud je předané číslo kladné. Pomocí toho můžeme od sebe oddělit logiku naší funkce (kontrola,
jestli je číslo kladné či ne) a samotnou operaci, která se má provést s kladným číslem.
Pokud tak vytvoříme novou operaci, nemusíme funkci <code>proved_pro_kladne</code> jakkoliv upravovat, stačí
ji zavolat s jiným argumentem.</p>
<span class='sidenote'><p><sup class='number'>2</sup>Ve formě adresy funkce.</p>
</span>
<pre><code class="language-c editable">#include &lt;stdio.h&gt;

int proved_pro_kladne(int cislo, int(*operace)(int)) {
    if (cislo &lt;= 0) return cislo;
    return operace(cislo);
}

int vynasob_dvema(int cislo) { return cislo * 2; }
int pricti_jednicku(int cislo) { return cislo + 1; }
int vypis(int cislo) {
    printf(&quot;Cislo: %d\n&quot;, cislo);
    return cislo;
}

int main() {
    printf(&quot;%d\n&quot;, proved_pro_kladne(-1, vynasob_dvema));
    printf(&quot;%d\n&quot;, proved_pro_kladne(1, vynasob_dvema));
    printf(&quot;%d\n&quot;, proved_pro_kladne(1, pricti_jednicku));
    printf(&quot;%d\n&quot;, proved_pro_kladne(1, vypis));

    return 0;
}
</code></pre>
<p>Ukazatele na funkce nám umožňují vytvářet kód, který je více <em>composable</em>, jinak řečeno lze jej
skládat jako kostky Lega a nenutí nás zadrátovat všechny možné způsoby použití dopředu (jako tomu
bylo v prvním řešení s parametrem <code>int operace</code>).</p>
<p>Ještě užitečnější jsou ukazatele na funkci v kombinacemi se zpracováním více hodnot pomocí
<a href="c/prace_s_pameti/../pole/pole.html">polí</a>, kdy můžeme napsat obecnou funkci, která nějak zpracovává pole, a předat jí
například ukazatel na funkci, která se má zavolat nad každým prvkem v poli. Hodí se také při práci
se <a href="c/prace_s_pameti/../struktury/struktury.html">strukturami</a>, kdy můžeme do atributu struktury uložit ukazatel na
funkci a přidat tak individuální chování k různým hodnotám stejné struktury.</p>
<h1><a class="header" href="#dynamická-paměť" id="dynamická-paměť">Dynamická paměť</a></h1>
<p>Už víme, že pomocí <a href="c/prace_s_pameti/automaticka_pamet.html">automatické paměti</a> na zásobníku nemůžeme alokovat
velké množství paměti a nemůžeme ani alokovat paměť s dynamickou velikostí (závislou na velikosti
vstupu programu). Abychom tohoto dosáhli, tak musíme použít jiný mechanismus alokace paměti, ve
kterém paměť alokujeme i uvolňujeme manuálně.</p>
<p>Tento mechanismus se nazývá <strong>dynamická alokace paměti</strong> (<em>dynamic memory allocation</em>). Pomocí několika
funkcí standardní knihovny <em>C</em> můžeme naalokovat paměť s libovolnou velikosti. Tato paměť je
alokována v oblasti paměti zvané <strong>halda</strong> (<em>heap</em>). Narozdíl od zásobníku, prvky na haldě neleží
striktně za sebou, a lze je tak uvolňovat v libovolném pořadí. Můžeme tak naalokovat paměť libovolné
velikosti, která přežije i ukončení vykonávání funkce, díky čemuž tak můžeme sdílet (potenciálně velká)
data mezi funkcemi. Nicméně musíme také tuto paměť ručně uvolňovat, protože (narozdíl od zásobníku)
to za nás nikdo neudělá.</p>
<h2><a class="header" href="#alokace-paměti" id="alokace-paměti">Alokace paměti</a></h2>
<p>K naalokování paměti můžeme použít funkci <a href="https://devdocs.io/c/memory/malloc"><code>malloc</code></a> (<em>memory
alloc</em>), která je dostupná v souboru <code>stdlib.h</code> ze <a href="c/prace_s_pameti/../funkce/stdlib.html">standardní knihovny <em>C</em></a>.
Tato funkce má následující signaturu<sup class='margin-toggle sidenote-number'>1</sup>:</p>
<span class='sidenote'><p><sup class='number'>1</sup>Datový typ <a href="https://devdocs.io/c/types/size_t"><code>size_t</code></a> reprezentuje bezznaménkové
celé číslo, do kterého by měla jít uložit velikost největší možné hodnoty libovolného typu. Často
se používá pro indexaci <a href="c/prace_s_pameti/../pole/pole.html">polí</a> nebo právě určování velikosti (např. alokací).</p>
</span>
<pre><code class="language-c">void* malloc(size_t size);
</code></pre>
<h3><a class="header" href="#velikost-alokované-paměti" id="velikost-alokované-paměti">Velikost alokované paměti</a></h3>
<p>Parametr <code>size</code> udává, kolik bytů paměti se má naalokovat. Tuto velikost můžeme &quot;tipnout&quot;
manuálně, nicméně to není moc dobrý nápad, protože bychom si museli pamatovat velikosti datových
typů (přičemž jejich velikost se může lišit v závislosti na použitém operačním systému či
překladači!). Abychom tomu předešli, tak můžeme použít operátor <code>sizeof</code>, kterému můžeme předat datový
typ<sup class='margin-toggle sidenote-number'>2</sup>. Tento výraz se poté vyhodnotí jako velikost daného datového typu:</p>
<span class='sidenote'><p><sup class='number'>2</sup>Případně výraz, v tom případě si <code>sizeof</code> vezme jeho datový typ.</p>
</span>
<pre><code class="language-c editable mainbody">#include &lt;stdio.h&gt;
int main() {
    printf(&quot;Velikost int je: %lu\n&quot;, sizeof(int));
    printf(&quot;Velikost int* je: %lu\n&quot;, sizeof(int*));
    return 0;
}
</code></pre>
<p>Návratový typ <code>void*</code> reprezentuje ukazatel na libovolná data. Funkce <code>malloc</code> musí fungovat pro
alokaci libovolného datového typu, proto musí mít jako návratový typ právě univerzální ukazatel
<code>void*</code>. Při zavolání funkce <code>malloc</code> bychom měli tento návratový typ
<a href="c/prace_s_pameti/../datove_typy/konverze.html">přetypovat</a> na ukazatel na datový typ, který alokujeme.</p>
<p>Při zavolání <code>malloc</code>u dojde k naalokování <code>size</code> bytů na haldě. Adresa prvního bytu této
naalokované paměti se poté vrátí jako návratová hodnota <code>malloc</code>u. Zde je ukázka programu, který
naalokuje paměť pro jeden <code>int</code> ve funkci, adresu naalokované paměti poté vrátí jako návratovou
hodnotu a naalokovaná paměť je poté přečtena ve funkci <code>main</code>:</p>
<pre><code class="language-c editable">#include &lt;stdlib.h&gt;

int* naalokuj_pamet() {
    int* pamet = (int*) malloc(sizeof(int));
    *pamet = 5;
    return pamet; 
}
int main() {
    int* pamet = naalokuj_pamet();
    printf(&quot;%d\n&quot;, *pamet);

    free(pamet); // uvolnění paměti, vysvětleno níže

    return 0;
}
</code></pre>
<details>
  <summary>Interaktivní vizualizace kódu</summary>
<iframe width="750" height="500" frameborder="0" src="https://pythontutor.com/iframe-embed.html#code=%23include%20%3Cstdlib.h%3E%0A%0Aint*%20naalokuj_pamet%28%29%20%7B%0A%20%20%20%20int*%20pamet%20%3D%20%28int*%29%20malloc%28sizeof%28int%29%29%3B%0A%20%20%20%20*pamet%20%3D%205%3B%0A%20%20%20%20return%20pamet%3B%20%0A%7D%0Aint%20main%28%29%20%7B%0A%20%20%20%20int*%20pamet%20%3D%20naalokuj_pamet%28%29%3B%0A%20%20%20%20printf%28%22%25d%5Cn%22,%20*pamet%29%3B%0A%20%20%20%20return%200%3B%0A%7D%0A&codeDivHeight=400&codeDivWidth=350&curInstr=8&origin=opt-frontend.js&py=c_gcc9.3.0&rawInputLstJSON=%5B%5D"> </iframe>
</details>
<h3><a class="header" href="#iniciální-hodnota-paměti" id="iniciální-hodnota-paměti">Iniciální hodnota paměti</a></h3>
<p>Stejně jako u <a href="c/prace_s_pameti/../promenne/promenne.html#v%C5%BEdy-inicializujte-prom%C4%9Bnn%C3%A9">lokálních proměnných</a>, i u
dynamicky naalokované paměti platí, že její hodnota je zpočátku nedefinovaná. Než se tedy hodnotu
dané paměti pokusíte přečíst, musíte jí nainicializovat zápisem nějaké hodnoty! Jinak bude program
obsahovat <a href="c/prace_s_pameti/../../ruzne/nedefinovane_chovani.html">nedefinované chování</a> 💣.</p>
<p>Pokud byste chtěli, aby naalokovaná paměť byla rovnou při alokaci vynulována (všechny byty
nastavené na hodnotu <code>0</code>), můžete místo funkce <code>malloc</code> použít funkci
<a href="https://devdocs.io/c/memory/calloc"><code>calloc</code></a><sup class='margin-toggle sidenote-number'>3</sup>. Případně můžete použít užitečnou funkci
<a href="https://devdocs.io/c/string/byte/memset"><code>memset</code></a>, která vám vyplní blok paměti zadaným bytem.</p>
<span class='sidenote'><p><sup class='number'>3</sup>Pozor však na to, že tato funkce má jiné parametry než <code>malloc</code>. Očekává počet hodnot, které
se mají naalokovat, a velikost každé hodnoty.</p>
</span>
<h2><a class="header" href="#uvolnění-paměti" id="uvolnění-paměti">Uvolnění paměti</a></h2>
<p>S velkou mocí přichází i velká <a href="https://citaty.net/citaty/1957976-stan-lee-s-velkou-moci-prichazi-velka-odpovednost/">zodpovědnost</a>,
takže při použití dynamické paměti sice máme více možností, než při použití automatické paměti
(resp. zásobníku), ale zároveň <strong>MUSÍME</strong> tuto paměť korektně uvolňovat (což se u automatické paměti
provádělo automaticky). Pokud bychom totiž paměť neustále pouze alokovali a neuvolňovali, tak by nám
<a href="c/prace_s_pameti/../../caste_chyby/pametove_chyby.html#memory-leak">brzy došla</a>.</p>
<p>Abychom paměť naalokovanou pomocí funkcí <code>malloc</code> či <code>calloc</code> uvolnili, tak musíme použít funkci
<a href="https://devdocs.io/c/memory/free"><code>free</code></a>:</p>
<pre><code class="language-c editable">#include &lt;stdlib.h&gt;

int main() {
    int* p = (int*) malloc(sizeof(int)); // alokace paměti
    *p = 0;                              // použití paměti
    free(p);                             // uvolnění paměti

    return 0;
}
</code></pre>
<p>Jako argument této funkci musíme předat ukazatel navrácený z volání <code>malloc</code>/<code>calloc</code>. Nic jiného
do této funkce nedávejte, uvolňovat můžeme pouze dynamicky alokovanou paměť! Nevolejte <code>free</code> s
adresami např. lokálních proměnných<sup class='margin-toggle sidenote-number'>4</sup>.</p>
<span class='sidenote'><p><sup class='number'>4</sup>Je však bezpečné uvolnit &quot;nulový ukazatel&quot;, tj. <code>free(NULL)</code> je validní (v tomto případě funkce nic neudělá).</p>
</span>
<p>Jakmile se paměť uvolní, tak už k této paměti nesmíte přistupovat! Pokud byste se pokusili přečíst
nebo zapsat uvolněnou paměť, tak dojde k <a href="c/prace_s_pameti/../../ruzne/nedefinovane_chovani.html">nedefinovanému chování</a> 💣.
Nesmíte ani paměť uvolnit více než jednou.</p>
<p>Při práci s dynamicky alokovanou pamětí tak dbejte zvýšené opatrnosti a ideálně používejte při
vývoji <a href="c/prace_s_pameti/../../prostredi/ladeni.html#address-sanitizer">Address sanitizer</a>. (Neúplný) seznam věcí,
které se můžou pokazit, pokud kombinaci dynamické alokace a uvolňování paměti pokazíte, naleznete
<a href="c/prace_s_pameti/../../caste_chyby/pametove_chyby.html">zde</a>.</p>
<h2><a class="header" href="#alokace-více-hodnot-zároveň" id="alokace-více-hodnot-zároveň">Alokace více hodnot zároveň</a></h2>
<p>Jak jste si mohli všimnout ze signatury funkce <code>malloc</code>, můžete jí dát libovolný počet bytů.
Nemusíte se tak omezovat velikostí základních datových typů, můžete například naalokovat paměť pro
5 <code>int</code>ů zároveň, které poté budou ležet za sebou v paměti a bude tak jednoduché k nim přistupovat
v cyklu. Jak tento koncept funguje se dozvíte v sekci o
<a href="c/prace_s_pameti/../pole/dynamicka_pole.html">dynamických polích</a>.</p>
<h2><a class="header" href="#kdy-použít-dynamicky-alokovanou-paměť" id="kdy-použít-dynamicky-alokovanou-paměť">Kdy použít dynamicky alokovanou paměť?</a></h2>
<p>Řiďte se pravidlem, že pokud lze použít <a href="c/prace_s_pameti/automaticka_pamet.html">automatickou paměť</a> na zásobníku,
tak ji využijte a <code>malloc</code> nepoužívejte. Až v momentě, kdy z nějakého důvodu nebude stačit naalokovat
paměť na zásobníku, tak se obraťe na <code>malloc</code>.</p>
<p>Seznam situací, ve kterých se může dynamická paměť hodit, se
<a href="c/prace_s_pameti/automaticka_pamet.html#nev%C3%BDhody-automatick%C3%A9-pam%C4%9Bti">nachází</a> v sekci o automatické paměti.</p>
<hr />
<p><strong>Kvíz</strong> 🤔</p>
<p>Podívejte se na sekci o <a href="c/prace_s_pameti/../../caste_chyby/pametove_chyby.html">paměťových chybách</a> pro příklad toho,
co všechno se může při práci s dynamickou pamětí a ukazateli pokazit.</p>
<h1><a class="header" href="#globální-paměť" id="globální-paměť">Globální paměť</a></h1>
<p>Posledním základním typem paměti je tzv. globální (nazývaná také statická) paměť. Tato paměť je
specifická tím, že vzniká při spuštění programu a zaniká při jeho ukončení, lze ji tak používat
během celé délky běhu programu.</p>
<p><a href="c/prace_s_pameti/../promenne/globalni_promenne.html">Globální proměnné</a> jsou umístěny v globální paměti. Je dobré si
uvědomit, že tyto proměnné zároveň zabírají místo ve spustitelném souboru na disku, protože v něm
musí být uložena jejich iniciální hodnota<sup class='margin-toggle sidenote-number'>1</sup>.</p>
<span class='sidenote'><p><sup class='number'>1</sup>Pokud tedy nejsou
<a href="c/prace_s_pameti/../promenne/globalni_promenne.html#inici%C3%A1ln%C3%AD-hodnota">inicializované na nulu</a>).</p>
</span>
<p>V globální paměti také leží samotné instrukce programu, který právě běží. Jsou tam umístěné funkce,
které jste napsali a které poté byly přeloženy na strojové instrukce a uloženy ve spustitelném souboru.</p>
<h1><a class="header" href="#pole" id="pole">Pole</a></h1>
<p>Nyní už známe základy alokování paměti v jazyce <em>C</em>, zatím ale stále umíme pracovat pouze
s jednotkami proměnných. Počítače slouží k (rychlému) zpracování velkého objemu dat, a abychom je
tak naplno využili, chtěli bychom zpracovávat mnoho proměnných najednou. Například:</p>
<ul>
<li>V dokumentu otevřeném ve Wordu můžeme mít uložené tisíce různých znaků.</li>
<li>Na server v online hře může v danou chvíli být připojené velké množství hráčů a všem musíme
posílat informace o stavu hry.</li>
<li>Obrázky se běžně v programech reprezentují jako dvourozměrná mřížka pixelů. Například obrázek
ve stupních šedi s rozměry <code>1024x1024</code> vyžaduje držet v paměti <code>1048576</code> bytů (čísel) reprezentujících
jednotlivé pixely.</li>
</ul>
<p>Asi si dovedete představit, že například pro reprezentaci obrázku bychom si s proměnnými, které jsme
používali doposud, nevystačili. Pokud bychom po jedné vytvářeli proměnné <code>pixel1</code>, <code>pixel2</code>,
<code>pixel3</code>, tak by jednak byl náš zdrojový kód obrovský a nedalo by se v něm vyznat, a také bychom
nemohli mít velikost obrázku závislou na vstupu programu, protože počet proměnných (pixelů) by byl
&quot;zadrátovaný&quot; ve zdrojovém kódu programu. Chtěli bychom tak mít možnost napsat kód, který bude umět
zpracovat 1, 2, 100 nebo třeba 1000 hodnot bez toho, abychom tento kód museli jakkoliv měnit.</p>
<p>Asi nejběžnějším a nejjednodušším způsobem, jak v paměti počítače uchovávat větší množství hodnot,
je uložit všechny hodnoty jednu po druhé za sebou v paměti. Tento koncept uložení dat se nazývá
<strong>pole</strong> (<em>array</em>)<sup class='margin-toggle sidenote-number'>1</sup> a je tak běžný, že ho programovací jazyky obvykle přímo podporují ve své syntaxi,
a jazyk <em>C</em> není výjimkou.</p>
<span class='sidenote'><p><sup class='number'>1</sup>Způsoby, jak v paměti počítače uchovávat komplexní a rozsáhlá data, se nazývají
<a href="https://cs.wikipedia.org/wiki/Datov%C3%A1_struktura">datové struktury</a>. Pole je jednou z
nejjednodušších datových struktur.</p>
</span>
<p>V následujících sekcích se dozvíte, jak s poli pracovat, jak je vytvořit v
<a href="c/pole/staticka_pole.html">automatické</a> a <a href="c/pole/dynamicka_pole.html">dynamické paměti</a> a jak lze v počítači
reprezentovat <a href="c/pole/vicerozmerna_pole.html">vícerozměrná pole</a>.</p>
<h1><a class="header" href="#statická-pole" id="statická-pole">Statická pole</a></h1>
<p>Pole v <a href="c/pole/../prace_s_pameti/automaticka_pamet.html">automatické paměti</a><sup class='margin-toggle sidenote-number'>1</sup> (na zásobníku) se označují
jako <strong>statická pole</strong> (<em>static arrays</em>). Můžeme je vytvořit tak, že při definici proměnné za její
název přidáme hranaté závorky s číslem udávajícím počet prvků v poli. Takto například vytvoříme pole
celých čísel s třemi prvky:</p>
<span class='sidenote'><p><sup class='number'>1</sup>Pole můžete tímto způsobem vytvořit také v
<a href="c/pole/../prace_s_pameti/globalni_pamet.html">globální paměti</a>, pokud vytvoříte
<a href="c/pole/../promenne/globalni_promenne.html">globální proměnnou</a> datového typu pole.</p>
</span>
<pre><code class="language-c">int pole[3];
</code></pre>
<p>Takováto proměnná bude obsahovat paměť pro 3 celá čísla (tedy nejspíše na vašem počítači dohromady
12 bytů). Počet prvků v poli se označuje jako jeho <strong>velikost</strong> (<em>size</em>).</p>
<blockquote>
<p>Pozor na to, že hranaté závorky se udávají za název proměnné, a ne za název datového typu.
<code>int[3] pole;</code> je tedy špatně.</p>
</blockquote>
<p>Čísla takového pole budou v paměti uložena jedno za druhým<sup class='margin-toggle sidenote-number'>2</sup>:
<upr-container>
<upr-array array='[0, 0, 0]'></upr-array>
</upr-container></p>
<span class='sidenote'><p><sup class='number'>2</sup>Každý zelený čtverec na tomto obrázku reprezentuje 4 byty v paměti (velikost jednoho <code>int</code>u).</p>
</span>
<p>V jistém smyslu je tak pole pouze zobecněním normální proměnné. Pokud totiž vytvoříte pole o
velikosti jedna (<code>int a[1];</code>), tak v paměti bude reprezentováno úplně stejně jako klasická proměnná
(<code>int a;</code>).</p>
<blockquote>
<p>Pole lze vytvořit také na haldě pomocí <a href="c/pole/dynamicka_pole.html">dynamické alokace paměti</a>. Všechny níže
popsané koncepty jsou platné i pro dynamická pole, nicméně budeme je demonstrovat na statických
polích, protože ty je jednodušší vytvořit.</p>
</blockquote>
<h3><a class="header" href="#konstantní-velikost-statického-pole" id="konstantní-velikost-statického-pole">Konstantní velikost statického pole</a></h3>
<p>Hodnota zadaná v hranatých závorkách by měla být &quot;konstantním výrazem&quot;, tj. buď přímo číselná hodnota anebo
číselná hodnota pocházející z <a href="c/pole/../preprocesor/makra.html">makra</a><sup class='margin-toggle sidenote-number'>3</sup>. Pokud budete potřebovat pole dynamické velikosti,
tak byste měli použít <a href="c/pole/dynamicka_pole.html">dynamickou alokaci paměti</a>.</p>
<span class='sidenote'><p><sup class='number'>3</sup>Dokonce ani <a href="c/pole/../promenne/konstanty.html">konstantní</a> proměnná
<a href="https://stackoverflow.com/questions/62354105/why-is-const-int-x-5-not-a-constant-expression-in-c">není</a>
v C &quot;konstantním výrazem&quot;.</p>
</span>
<p>Jazyk <em>C</em> od verze <a href="https://en.wikipedia.org/wiki/C99"><em>C99</em></a> již sice povoluje dávat do hranatých
závorek i &quot;dynamické&quot; hodnoty, tj. výrazy, jejichž hodnota nemusí být známa v době překladu:</p>
<pre><code class="language-c">int velikost = ...; // velikost se načte např. ze souboru
int pole[velikost];
</code></pre>
<p>Tato funkcionalita zvaná <a href="https://en.wikipedia.org/wiki/Variable-length_array">VLA</a> (variable-length array)
je nicméně určená pro velmi specifické použití a nese s sebou různé nevýhody, proto ji v rámci předmětu
UPR <strong>nepoužívejte</strong>. Pokud si chcete být jisti, že se VLA ve vašem kódu nevyskytuje, překládejte své programy s
<a href="c/pole/../../ruzne/parametry_prekladace.html">parametrem překladače</a> <code style="white-space: nowrap;">-Werror=vla</code>.</p>
<details>
<summary>Proč ne VLA?</summary>
<p>Zásobník má značně <a href="c/pole/../prace_s_pameti/automaticka_pamet.html#nev%C3%BDhody-automatick%C3%A9-pam%C4%9Bti">omezenou velikost</a>
a není určen pro alokaci velkého množství paměti<sup class='margin-toggle sidenote-number'>4</sup>. Pokud velikost takovéhoto pole může ovlivnit
uživatel programu (např. zadáním vstupu), může váš program jednoduše &quot;shodit&quot; (v lepším případě)
nebo způsobit přepsání existující paměti (v horším případě), pokud by zadal velké
číslo a došlo by k pokusu o vytvoření moc velkého pole na zásobníku. VLA má také různé problémy s
kompatibilitou mezi překladači a jeho implementace překladači není zdaleka triviální.</p>
<span class='sidenote'><p><sup class='number'>4</sup>Můžete si například zkusit přeložit následující program:</p>
<pre><code class="language-c">int main() {
    int pole[10000000];
    return 0;
}
</code></pre>
<p>Při spuštění by měl program selhat na
<a href="c/pole/../../caste_chyby/pametove_chyby.html#segmentation-fault">paměťovou chybu</a>, i když váš počítač má
pravděpodobně více než <code>10000000 * 4</code> (cca <code>38</code> MiB) paměti. Pokud chcete alokovat více než několik
stovek bytů, použijte raději <a href="c/pole/dynamicka_pole.html">dynamickou alokaci</a> na haldě.</p>
</span>
<p>Alokace paměti s dynamickou velikostí na zásobníku se může hodit ve velmi specifických případech,
např. při vývoji embedded zařízení nebo při vysoce efektivní práci s I/O (vstup/výstup). Nicméně pro
účely běžného programování v <em>C</em> a předmětu UPR rozhodně není potřeba, proto se VLA prosíme zkuste
vyhnout.</p>
</details>
<h2><a class="header" href="#počítání-od-nuly" id="počítání-od-nuly">Počítání od nuly</a></h2>
<p>Pozice jednotlivých prvků v poli se označují jako jejich <strong>indexy</strong> (<em>array indices</em>). Tyto pozice
se číslují od hodnoty <code>0</code> (tedy ne od jedničky, jak můžete být jinak zvyklí). První prvek pole je
tedy ve skutečnosti na nulté pozici (indexu), druhý na první pozici atd. (viz obrázek nahoře).
<strong>Počítání od nuly</strong> (<em>zero-based indexing</em>) je ve světě programování běžné a budete si na něj
muset zvyknout. Jeden z důvodů, proč se prvky počítají právě od nuly, se dozvíte
<a href="c/pole/staticka_pole.html#p%C5%99%C3%ADstup-k-prvk%C5%AFm-pole">níže</a>.</p>
<p>Z tohoto vyplývá jedna důležitá vlastnost - poslední prvek pole je vždy na indexu
<code>&lt;velikost pole&gt; - 1</code>! Pokud byste se pokusili přistoupit k prvku na indexu <code>&lt;velikost pole&gt;</code>,
budete přistupovat mimo paměť pole, což způsobí
<a href="c/pole/../../caste_chyby/pametove_chyby.html">paměťovou chybu</a>.</p>
<h2><a class="header" href="#inicializace-pole" id="inicializace-pole">Inicializace pole</a></h2>
<p>Stejně jako u normálních lokálních proměnných
<a href="c/pole/../promenne/promenne.html#v%C5%BEdy-inicializujte-prom%C4%9Bnn%C3%A9">platí</a>, že pokud pole nenainicializujete,
tak bude obsahovat nedefinované hodnoty. V takovém případě nesmíte hodnoty v poli jakkoliv číst,
jinak by došlo k <a href="c/pole/../../ruzne/nedefinovane_chovani.html">nedefinovanému chování</a> 💣! K inicializaci pole můžete
použít složené závorky se seznamem hodnot oddělených čárkou, které budou do pole uloženy. Pokud
nezadáte dostatek hodnot pro vyplnění celého pole, tak zbytek hodnot bude nastaveno na nulu.</p>
<pre><code class="language-c">int a[3];               // pole bez definované hodnoty, nepoužívat!
int b[3] = {};          // pole s hodnotami 0, 0, 0
int c[4] = { 1 };       // pole s hodnotami 1, 0, 0, 0
int d[2] = { 2, 3 };    // pole s hodnotami 2, 3
</code></pre>
<p>Hodnot samozřemě nemůžete zadat více, než je velikost pole.</p>
<p>Pokud využijete inicializaci statického pole, můžete vynechat velikost pole v hranatých závorkách.
Překladač v tomto případě dopočítá velikost za vás:</p>
<pre><code class="language-c">int p[] = { 1, 2, 3 }; // p je pole s třemi čísly, překladač si odvodí int p[3]
</code></pre>
<h2><a class="header" href="#přístup-k-prvkům-pole" id="přístup-k-prvkům-pole">Přístup k prvkům pole</a></h2>
<p>Abychom využili toho, že nám pole umožňují vytvořit větší množství paměti najednou, musíme mít
možnost přistupovat k jednotlivým prvkům v poli. K tomu můžeme využít
<a href="c/pole/../prace_s_pameti/ukazatele.html">ukazatelů</a>. Proměnná pole se totiž chová jako ukazatel na první
prvek (prvek na nultém indexu!) daného pole, pomocí operátoru
<a href="c/pole/../prace_s_pameti/ukazatele.html#p%C5%99%C3%ADstup-k-pam%C4%9Bti-pomoc%C3%AD-ukazatele">dereference</a> tak k tomutu prvku
můžeme jednoduše přistoupit:</p>
<pre><code class="language-c editable mainbody">#include &lt;stdio.h&gt;

int main() {
    int pole[3] = { 1, 2, 3 };
    printf(&quot;%d\n&quot;, *pole);
    return 0;
}
</code></pre>
<p>Abychom přistoupili i k dalším prvkům v poli, tak můžeme využít
<a href="c/pole/../prace_s_pameti/ukazatele.html#aritmetika-s-ukazateli">aritmetiky s ukazateli</a>. Pokud chceme
získat adresu prvku na <code>i</code>-tém indexu, stačí k ukazateli na první prvek přičíst <code>i</code><sup class='margin-toggle sidenote-number'>5</sup>:</p>
<span class='sidenote'><p><sup class='number'>5</sup>Všimněte si, že při použití operátoru dereference zde používáme závorky. Je to z důvodu
<a href="https://en.cppreference.com/w/c/language/operator_precedence">priority operátorů</a>. Výraz <code>*pole + 2</code>
by se vyhodnotil jako první prvek z pole <code>pole</code> plus <code>2</code>, protože <code>*</code> (dereference) má větší
prioritu než sčítání. </p>
</span>
<pre><code class="language-c editable mainbody">#include &lt;stdio.h&gt;

int main() {
    int pole[3] = { 1, 2, 3 };
    printf(&quot;%d\n&quot;, *(pole + 0));   // první prvek pole
    printf(&quot;%d\n&quot;, *(pole + 1));   // druhý prvek pole
    printf(&quot;%d\n&quot;, *(pole + 2));   // třetí prvek pole
    return 0;
}
</code></pre>
<p>Nyní už možná tušíte, proč se při práci s poli vyplatí počítat od nuly. Prvek na nultém indexu je
totiž vzdálen nula prvků od začátku pole. Prvek na prvním indexu je vzdálen jeden prvek od začátku
pole atd. Pokud bychom indexovali od jedničky, museli bychom při výpočtu adresy relativně k ukazateli
na začátek pole vždy odečíst jedničku, což by bylo nepraktické.</p>
<blockquote>
<p>Přistupování k prvkům pole se běžně označuje pojmem <strong>indexování pole</strong>.</p>
</blockquote>
<h2><a class="header" href="#operátor-přístupu-k-poli" id="operátor-přístupu-k-poli">Operátor přístupu k poli</a></h2>
<p>Jelikož je operace přístupu k poli (&quot;posunutí&quot; ukazatele a jeho dereference) velmi
běžná (a zároveň relativně krkolomná), <em>C</em> obsahuje speciální operátor, který ji zjednodušuje.
Tento operátor se nazývá <em>array subscription operator</em> a má syntaxi</p>
<pre><code>&lt;výraz a&gt;[&lt;výraz b&gt;]
</code></pre>
<p>Slouží jako zkratka<sup class='margin-toggle sidenote-number'>6</sup> za výraz</p>
<span class='sidenote'><p><sup class='number'>6</sup>Takovéto &quot;zkratky&quot;, které v programovacím jazyku nepřináší novou funkcionalitu, pouze zkracují
či zjednoduššují často používané kombinace příkazů, se označují jako
<a href="https://en.wikipedia.org/wiki/Syntactic_sugar"><strong>syntactic sugar</strong></a>.</p>
</span>
<pre><code>*(&lt;výraz a&gt; + &lt;výraz b&gt;)
</code></pre>
<p>Příklad:</p>
<ul>
<li><code>pole[0]</code> je ekvivalentní výrazu <code>*(pole + 0)</code></li>
<li><code>pole[5]</code> je ekvivalentní výrazu <code>*(pole + 5)</code></li>
</ul>
<pre><code class="language-c">int pole[3] = { 1, 2, 3 };
pole[0] = 5;       // nastavili jsme první prvek pole na hodnotu `5`
int c = pole[2];   // nastavili jsme `c` na hodnotu posledního (třetího) prvku pole
</code></pre>
<p>Jelikož je používání hranatých závorek přehlednější než používání závorek a hvězdiček, doporučujeme
je používat pro přistupování k prvkům pole, pokud to půjde.</p>
<blockquote>
<p>Pozor na rozdíl mezi tímto operátorem a definicí pole. Obojí sice používá hranaté závorky, ale
jinak spolu tyto dvě věci nesouvisejí. Podobně jako se <code>*</code> používá pro definici datového typu
ukazatele a <a href="c/pole/../prace_s_pameti/ukazatele.html#p%C5%99%C3%ADstup-k-pam%C4%9Bti-pomoc%C3%AD-ukazatele">zároveň</a>
jako operátor dereference (navíc i jako operátor pro násobení). Vždy záleží na kontextu, kde jsou
tyto znaky použity.</p>
</blockquote>
<h2><a class="header" href="#použití-polí-s-cykly" id="použití-polí-s-cykly">Použití polí s cykly</a></h2>
<p>Pokud bychom k polím přistupovali po individuálních prvcích, tak bychom nemohli využít jejich plný
potenciál. I když umíme jedním řádkem kódu vytvořit například 100 různých hodnot (<code>int pole[100];</code>),
pokud bychom museli psát <code>pole[0]</code>, <code>pole[1]</code> atd. pro přístup k jednotlivým prvkům, tak bychom
nemohli s polem efektivně pracovat. Smyslem polí je umožnit zpracování velkého množství dat jednotným
způsobem pomocí krátkého kusu kódu. Jinak řečeno, chtěli bychom mít stejný kód, který umí zpracovat
pole o velikosti <code>2</code> i <code>1000</code>. K tomu můžeme efektivně využít <a href="c/pole/../rizeni_toku/cykly.html">cykly</a>.</p>
<p>Často je praktické použít <a href="c/pole/../rizeni_toku/while.html#%C5%98%C3%ADd%C3%ADc%C3%AD-prom%C4%9Bnn%C3%A1">řídící proměnnou</a> cyklu k tomu,
abychom pomocí ní indexovali pole. Například, pokud bychom měli pole s velikostí <code>10</code>, tak ho můžeme
&quot;projít&quot;<sup class='margin-toggle sidenote-number'>7</sup> pomocí cyklu <code>for</code>:</p>
<span class='sidenote'><p><sup class='number'>7</sup>Používá se také pojem <em>proiterovat</em>.</p>
</span>
<pre><code class="language-c editable mainbody">#include &lt;stdio.h&gt;

int main() {
    int pole[10] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };
    for (int i = 0; i &lt; 10; i++) {
        printf(&quot;%d &quot;, pole[i]);
    }
    return 0;
}
</code></pre>
<p>Situace, kdy pomocí cyklu projdeme pole, je velmi častá a určitě se s ní mnohokrát setkáte a
využijete ji. Zkuste si to procvičit například pomocí
<a href="c/pole/../../ulohy/pole.html#minim%C3%A1ln%C3%AD-hodnota-v-poli">těchto úloh</a>.</p>
<h2><a class="header" href="#předávání-pole-do-funkcí" id="předávání-pole-do-funkcí">Předávání pole do funkcí</a></h2>
<p>Pole můžeme (stejně jako hodnoty jiných datových typů) předávat jako argumenty do funkcí.
Musíme si při tom však dávat pozor zejména na dvě věci.</p>
<h3><a class="header" href="#převod-pole-na-ukazatel" id="převod-pole-na-ukazatel">Převod pole na ukazatel</a></h3>
<p>Už víme, že když předáváme <a href="c/pole/../funkce/funkce.html#parametrizace-funkc%C3%AD">argumenty</a> do funkcí, tak se
jejich hodnota zkopíruje. U statických polí tomu tak ovšem není, protože pole můžou být potenciálně
velmi velká a provádění kopií polí by tak potenciálně mohlo brzdit provádění programu. Když tak
použijeme proměnnou pole jako argument při volání funkce, dojde k tzv. <strong>konverzi pole na ukazatel</strong>
(<em>array to pointer decay</em>). Pole se tak vždy předá jako ukazatel na jeho první prvek:</p>
<pre><code class="language-c editable">#include &lt;stdio.h&gt;

void vypis_pole(int* pole) {
    printf(&quot;%d\n&quot;, pole[0]);
}

int main() {
    int pole[3] = { 1, 2, 3 };
    vypis_pole(pole);
    return 0;
}
</code></pre>
<p>Pro parametry sice můžete použít datový typ pole:</p>
<pre><code class="language-c">void vypis_pole(int pole[3]) { ... }
</code></pre>
<p>nicméně i v tomto případě se bude takovýto parametr chovat stejně jako ukazatel (v tomto případě
tedy <code>int*</code>). Navíc překladač ani nebude kontrolovat, jestli do takového parametru opravdu dáváme
pole se správnou velikostí. Pro parametry reprezentující pole tak raději rovnou používejte ukazatel,
abychom čtenáře kódu nemátli.</p>
<h3><a class="header" href="#předávání-velikosti-pole" id="předávání-velikosti-pole">Předávání velikosti pole</a></h3>
<p>Když ve funkci přijmeme jako parametr ukazatel na pole, tak nevíme, kolik prvků v tomto poli je.
Tato informace je ale stěžejní, bez ní totiž nevíme, ke kolika prvkům pole si můžeme dovolit
přistupovat. Pokud tedy ukazatel na pole předáváme do funkce, je obvykle potřeba zároveň s ním
předat i délku daného pole:</p>
<pre><code class="language-c">int secti_pole(int* pole, int velikost) {
    int soucet = 0;
    for (int i = 0; i &lt; velikost; i++) {
        soucet += pole[i];
    }
    return soucet;
}
</code></pre>
<h4><a class="header" href="#výpočet-velikosti-pole" id="výpočet-velikosti-pole">Výpočet velikosti pole</a></h4>
<p>Abyste při změně velikosti statického pole nemuseli ručně jeho velikost upravovat na více místech v
kódu, tak můžete ve funkci, kde definujete statické pole, vypočítat jeho velikost pomocí operátoru
<code>sizeof</code>:</p>
<pre><code class="language-c">int pole[3] = { 1, 2, 3 };
printf(&quot;Velikost pole v bytech: %lu\n&quot;, sizeof(pole));
</code></pre>
<p>Abyste zjistili počet prvků ve statickém poli, můžete velikost v bytech vydělit velikostí každého
prvku v poli:</p>
<pre><code class="language-c">int pole[3] = { 1, 2, 3 };
printf(&quot;Pocet prvku v poli: %lu\n&quot;, sizeof(pole) / sizeof(pole[0]));
</code></pre>
<blockquote>
<p>Operátor <code>sizeof</code> bude pro toto použití fungovat pouze pro statické pole a pouze ve funkci, ve které
statické pole vytváříte! Pokud pole pošlete do jiné funkce, už z něj bude pouze ukazatel, pro který
<code>sizeof</code> vrátí velikost ukazatele (což bude na vašem PC nejspíše <code>8</code> bytů). Více v kvízech níže.</p>
</blockquote>
<hr />
<p><strong>Kvíz</strong> 🤔</p>
<ol>
<li>
<p>Co vypíše následující program?</p>
<pre><code class="language-c editable mainbody">#include &lt;stdio.h&gt;

int main() {
    int pole[3] = { 1, 4, 7 };
    int a = *pole + 1;
    int b = *(pole + 1);

    printf(&quot;a = %d, b = %d\n&quot;, a, b);

    return 0;
}
</code></pre>
<details>
 <summary>Odpověď</summary>
<p>Program vypíše <code>a = 2, b = 4</code>. Jelikož má operátor dereference (<code>*</code>) větší
<a href="https://en.cppreference.com/w/c/language/operator_precedence">prioritu</a> než operátor sečtení
(<code>+</code>), tak se do proměnné <code>a</code> uloží hodnota (<code>2</code>). Nejprve se totiž provede výraz <code>*pole</code>, kde
dojde k dereferenci ukazatele na první prvek pole, čímž vznikne hodnota <code>1</code>, a k ní se poté přičte
jednička.</p>
<p>V případě proměnné <code>b</code> se nejprve ukazatel na první prvek pole posune o jeden prvek dopředu, tj.
na adresu druhého prvku pole, který má hodnotu <code>4</code>. Poté dojde k dereferenci adresy tohoto prvku,
do proměnné <code>b</code> se tak uloží hodnota <code>4</code>.</p>
</details>
</li>
<li>
<p>Co vypíše následující program?</p>
<pre><code class="language-c editable mainbody">#include &lt;stdio.h&gt;

void prijmi_pole(int p[3]) {
    p[2] += 1;
}

int main() {
    int pole[3] = { 1, 2, 3 };

    prijmi_pole(pole); 

    printf(&quot;{ %d, %d, %d }\n&quot;, pole[0], pole[1], pole[2]);

    return 0;
}
</code></pre>
<details>
 <summary>Odpověď</summary>
<p>Program vypíše <code>{ 1, 2, 4 }</code>. Při předávání statického pole do funkce dojde pouze k předání
ukazatele na jeho první prvek (i když má parametr typ <code>int p[3]</code>). Pokud tedy pomocí ukazatele
<code>p</code> změníme hodnotu třetího prvku pole, tato změna se nám projeví i ve funkci <code>main</code>, protože
stále pracujeme s tou stejnou pamětí.</p>
</details>
</li>
<li>
<p>Co vypíše následující program?</p>
<pre><code class="language-c editable mainbody">#include &lt;stdio.h&gt;

int main() {
    int pole[3] = { 1, 2, 3 };
    int *p = pole;

    p[1] = 5;
    pole[0] = 8;

    printf(&quot;%d, %d\n&quot;, *p, pole[1]);

    return 0;
}
</code></pre>
<details>
 <summary>Odpověď</summary>
<p>Program vypíše <code>8, 5</code>. Do ukazatele <code>p</code> jsme si uložili adresu prvního prvku v poli. Pomocí
<code>p[1]</code> posuneme ukazatel o jeden prvek v paměti &quot;dopředu&quot; (bude tedy ukazovat na druhý prvek pole)
a rovnou na tuto adresu v paměti zapíšeme hodnotu <code>5</code>. Poté změníme hodnotu prvního prvku pole
na <code>8</code>. Jelikož <code>p</code> ukazuje na první prvek v poli, tak při jeho dereferenci získáme právě hodnotu
<code>8</code>. A jelikož jsme předtím pomocí ukazatele <code>p</code> změnili druhý prvek pole na <code>5</code>, tak <code>pole[1]</code>
také vrátí hodnotu <code>5</code>.</p>
</details>
</li>
<li>
<p>Co vypíše následující program?</p>
<pre><code class="language-c editable mainbody">#include &lt;stdio.h&gt;

int main() {
    int pole[3] = { 1, 2, 3 };
    printf(&quot;%d\n&quot;, pole);

    return 0;
}
</code></pre>
<details>
 <summary>Odpověď</summary>
<p>Tento program obsahuje <a href="c/pole/../../ruzne/nedefinovane_chovani.html"><strong>nedefinované chování</strong></a> 💣, protože jsme použili
<a href="c/pole/../prikazy_vyrazy.html#v%C3%BDpis-v%C3%BDraz%C5%AF">zástupný znak</a> <code>%d</code>, který slouží k výpisu celých čísel, ale
předali jsme funkci <code>printf</code> argument <code>pole</code>, který je datového typu pole (resp. ukazatel na první
prvek tohoto pole).</p>
</details>
</li>
<li>
<p>Co vypíše následující program?</p>
<pre><code class="language-c editable mainbody">#include &lt;stdio.h&gt;

int main() {
    int p[3] = { 1, 2, 3 };
    for (int i = 0; i &lt;= 3; i++) {
        printf(&quot;%d\n&quot;, p[i]);
    }

    return 0;
}
</code></pre>
<details>
 <summary>Odpověď</summary>
<p>Tento program obsahuje <a href="c/pole/../../ruzne/nedefinovane_chovani.html"><strong>nedefinované chování</strong></a> 💣, protože jsme přistoupili (dereferencovali)
paměť mimo rozsah pole! Pole <code>p</code> má pouze tři prvky, nesmíme tedy přistoupit k indexu <code>3</code> či vyššímu,
což se však v tomto programu stane, protože proměnná <code>i</code> nabývá hodnot <code>0</code>, <code>1</code>, <code>2</code> a <code>3</code>.</p>
<p>Ať už tento program při konkrétním spuštění vypíše cokoliv, nemá cenu se tím zaobírat. Tento program
obsahuje paměťovou chybu, která může způsobit pád programu, libovolnou změnu hodnot v paměti nebo
cokoliv jiného. Chybu musíte nejprve odstranit, jinak program nebude správně fungovat.</p>
</details>
</li>
<li>
<p>Co vypíše následující program?</p>
<pre><code class="language-c editable mainbody">#include &lt;stdio.h&gt;

int main() {
    int pole[3] = { 1, 2, 3 };
    2[pole] = 5;

    printf(&quot;%d\n&quot;, pole[2]);

    return 0;
}
</code></pre>
<details>
 <summary>Odpověď</summary>
<p>Program vypíše <code>5</code>. I když to vypadá zvláštně, tak jelikož je sčítání komutativní, a operátor
<code>a[b]</code> je definován jako <code>*(a + b)</code>, tak je jedno, jestli napíšete <code>a[b]</code> nebo <code>b[a]</code>. Takovýto
zápis je nicméně nestandardní a nepoužívá se, tato úloha pouze měla demonstrovat, že jej takto
teoreticky použít lze, a že <code>a[b]</code> opravdu není nic jiného, než zkratka za <code>*(a + b)</code>.</p>
</details>
</li>
<li>
<p>Co vypíše následující program?</p>
<pre><code class="language-c editable mainbody">#include &lt;stdio.h&gt;

int main() {
    char pole[3];
    char* ptr = pole;

    printf(&quot;%d\n&quot;, (int) sizeof(pole));
    printf(&quot;%d\n&quot;, (int) sizeof(ptr));

    return 0;
}
</code></pre>
<details>
 <summary>Odpověď</summary>
 Program vypíše toto (na 32-bitovém systému by druhé číslo bylo pravděpodobně 4):
<pre><code>3
8
</code></pre>
<p>Operátor <code>sizeof</code> vrátí velikost celého statického pole, pokud jej do něj předáme. Pokud však
do něj dáme pouze ukazatel, tak <code>sizeof</code> neví, jak velká paměť leží na adrese uložené v tomto
ukazateli, proto nám místo toho vrátí pouze velikost daného ukazatele, což bude na 64-bitovém
systému pravděpodobně <code>8</code> bytů.</p>
</details>
</li>
<li>
<p>Co vypíše následující program?</p>
<pre><code class="language-c editable">#include &lt;stdio.h&gt;

void print_size(char pole[3]) {
    printf(&quot;%d\n&quot;, (int) sizeof(pole));
}

int main() {
    char pole[3];
    print_size(pole);

    return 0;
}
</code></pre>
<details>
 <summary>Odpověď</summary>
 Program pravděpodobně vypíše řádek s hodnotou 8 (na 64-bitovém systému) či 4 (na 32-bitovém
 systému). Pokud použijeme datový typ pole jako parametr funkce, tak se k němu překladač bude
 víceméně chovat jako k běžnému ukazateli. Je to z toho důvodu, že překladač neví, jak velkou paměť
 do funkce předáváme (můžeme tuto funkci zavolat
 s ukazatelem na různě velká pole!). Z toho důvodu je tak lepší pro parametry funkcí vždy používat
 rovnou ukazatel a ne pole, abychom zamezili nejasnostem.
<p>Tyto následující tři signatury funkce jsou tedy v podstatě totožné:</p>
<pre><code class="language-c">void print_size(char pole[3]);
void print_size(char pole[]);
void print_size(char* pole);
</code></pre>
</details>
</li>
</ol>
<h1><a class="header" href="#dynamická-pole" id="dynamická-pole">Dynamická pole</a></h1>
<p>Pole alokovaná na zásobníku by měly mít velikost danou při překladu programu, často ale potřebujeme
vytvářet pole v závislosti na vstupu programu. Například, pokud bychom chtěli vytvořit pole, které
by obsahovalo všechny řádky souboru, tak dopředu nevíme, kolik těch řádků bude nějaký konkrétní
soubor mít.</p>
<p>Ze sekce o <a href="c/pole/../prace_s_pameti/dynamicka_pamet.html">dynamické paměti</a> již víme,
jak alokovat libovolné množství paměti na haldě pomocí funkce <code>malloc</code>. Pro vytvoření
<strong>dynamického pole</strong> (<em>dynamic array</em>) tak stačí použít funkci <code>malloc</code>. Například pro vytvoření
dynamického pole pro <code>5</code> celých čísel potřebujeme naalokovat <code>5 * sizeof(int)</code> bytů:</p>
<pre><code class="language-c">int* pole = (int*) malloc(5 * sizeof(int));
</code></pre>
<p>S takovouto pamětí pak můžeme pracovat jako s polem <code>int</code>ů o velikosti <code>5</code>. Jakmile již takovéto
pole nepotřebujeme, nesmíme jej samozřejmě zapomenout
<a href="c/pole/../prace_s_pameti/dynamicka_pamet.html#uvoln%C4%9Bn%C3%AD-pam%C4%9Bti">uvolnit</a>.</p>
<h2><a class="header" href="#změna-velikosti-pole" id="změna-velikosti-pole">Změna velikosti pole</a></h2>
<p>Občas potřebujeme velikost dynamického pole změnit (obvykle zvětšit). Například pokud vám
uživatel zadává na vstupu seznam čísel, na začátku můžete vytvořit paměť pro 10 čísel, ale při
zadání 11. čísla musíte tuto paměť zvětšit, jinak byste neměli nové číslo kam zapsat. Tento proces
se nazývá <strong>realokace</strong> (<em>reallocation</em>) a lze jej provést například následujícím způsobem:</p>
<ol>
<li>Naalokujeme nové dynamické pole o požadované velikosti</li>
<li>Zkopírujeme obsah původního pole do nového pole </li>
<li>Uvolníme paměť původního pole</li>
<li>Upravíme odpovídající ukazatel(e) v programu, aby ukazoval(y) na nově naalokované pole</li>
</ol>
<p>Pokud se vám toto nechce programovat ručně, tak můžete také použít funkci
<a href="https://devdocs.io/c/memory/realloc"><code>realloc</code></a> ze standardní knihovny <em>C</em>, která to udělá za vás.
Tato funkce očekává původní adresu alokace z <code>malloc</code>/<code>calloc</code> a počet bytů nové alokace.</p>
<hr />
<p><strong>Cvičení</strong> 🏋</p>
<p>Zkuste naprogramovat funkci <code>realokace</code>, která obdrží dynamicky naalokované pole
(tedy ukazatel), jeho původní velikost a novou velikost. Funkce realokuje pole na novou velikost a
vrátí ukazatel na nově naalokované pole.</p>
<hr />
<h1><a class="header" href="#vícerozměrná-pole" id="vícerozměrná-pole">Vícerozměrná pole</a></h1>
<p>Někdy potřebujeme v programech reprezentovat věci, které jsou přirozeně vícerozměrné. Typickým
příkladem jsou obrázky, které lze reprezentovat jako dvourozměrnou mřížku pixelů (jeden rozměr udává
řádky a druhý sloupce).</p>
<p><a href="c/pole/../../uvod/pamet.html">Paměťové adresy</a> však mají pouze jeden rozměr, jelikož jsou reprezentovány
jedním číslem. Jak tedy můžeme do jednorozměrné paměti uložit vícerozměrnou hodnotu? Způsobů je více,
nicméně asi nejjednodušší je prostě &quot;vyskládat&quot; jednotlivé rozměry (dimenze) v paměti za sebou,
jeden rozměr za druhým. Pokud bychom například měli dvojrozměrnou mřížku<sup class='margin-toggle sidenote-number'>1</sup> s rozměry <code>5x5</code>,
můžeme ji reprezentovat tak, že nejprve do paměti uložíme první řádek, poté druhý řádek atd.: </p>
<span class='sidenote'><p><sup class='number'>1</sup>Reprezentující například obrázek či <a href="https://matematika.cz/matice">matici</a>.</p>
</span>
<p><img src="c/pole/../../static/img/2d_array.svg" alt="2D pole" /></p>
<p>Tento koncept se označuje jako <strong>vícerozměrné pole</strong> (<em>multidimensional array</em>).</p>
<h2><a class="header" href="#způsob-vyskládání-dimenzí" id="způsob-vyskládání-dimenzí">Způsob vyskládání dimenzí</a></h2>
<p>Je na nás, v jakém pořadí jednotlivé dimenze do paměti uložíme. Pokud bychom se bavili o 2D poli,
tak můžeme do paměti uložit řádek po řádku (viz obrázek výše), což se označuje jako
<strong>row major ordering</strong>. Můžeme ale také do paměti vyskládat sloupec po sloupci, což se nazývá
<strong>column major ordering</strong>. Je víceméně jedno, který způsob použijeme, je ale důležité se držet
jednoho přístupu, jinak může dojít k záměně indexů. Indexování totiž záleží na tom, jaký způsob
vyskládání použijeme. Níže předpokládáme pořadí <em>row major</em>.</p>
<h2><a class="header" href="#indexování" id="indexování">Indexování</a></h2>
<p>Při práci s dvourozměrným polem bychom chtěli pracovat s dvourozměrným indexem (řádek <code>i</code>, sloupec
<code>j</code>), nicméně při samotném přístupu do paměti pak musíme tento vícerozměrný index převést na 1D
index. A naopak, z 1D indexu bychom chtěli mít možnost získat zpět 2D index. Pro výpočet indexů 2D
pole s <code>vyska</code> řádky a <code>sirka</code> sloupci můžeme použít tyto jednoduché vzorce:</p>
<ul>
<li><strong>Převod z 2D do 1D</strong> - abychom se dostali na cílovou pozici, musíme přeskočit <code>radek</code> řádků, kde
každý řádek má <code>sirka</code> prvků, a poté ještě musíme přičíst pozici sloupce (<code>sloupec</code>).
<pre><code class="language-c">int index_2d_na_1d(int radek, int sloupec, int sirka) {
    return radek * sirka + sloupec;
}
</code></pre>
</li>
<li><strong>Převod z 1D do 2D</strong> - pro převod z 1D indexu zpět na 2D index stačí aplikovat opačný postup.
Nejprve vydělíme 1D index počtem sloupců, abychom zjistili, na jakém jsme řádku, a poté použijeme
zbytek po dělení, abychom zjistili, na jakém jsme sloupci.
<pre><code class="language-c">void index_1d_na_2d(int index, int sirka, int* radek, int* sloupec) {
    *radek = index / sirka;
    *sloupec = index % sirka;
}
</code></pre>
</li>
</ul>
<p>Tento koncept lze zobecnit na libovolně rozměrné pole (3D, 4D, …).</p>
<h2><a class="header" href="#vícerozměrné-pole-na-zásobníku" id="vícerozměrné-pole-na-zásobníku">Vícerozměrné pole na zásobníku</a></h2>
<p>Pokud známe v době překladu velikost a rozměry vícerozměrného pole, tak můžeme využít vícerozměrných <a href="c/pole/staticka_pole.html">statických polí</a>. Při
vytváření pole stačí použít hranaté závorky pro každou dimenzi pole. Například takto lze vytvořit
2D pole s rozměry <code>3x3</code> na zásobníku:</p>
<pre><code class="language-c">int pole[3][3];
</code></pre>
<p>Výhoda takovýchto polí je, že překladač provede převod z 2D indexu na 1D index za vás, a můžete tak
toto pole přímo indexovat vícerozměrným indexem. Například první prvek pole z kódu výše lze nalézt
na pozici <code>pole[0][0]</code>, poslední na pozici <code>pole[2][2]</code>.</p>
<p>Takováto pole jsou v paměti vyskládána postupně dle jednotlivých dimenzí zleva. Nejprve tedy v
paměti leží prvek <code>pole[0][0]</code>, poté <code>pole[0][1]</code>, …, <code>pole[1][1]</code>, <code>pole[1][2]</code> atd. Pokud
bychom měli 2D pole a první index bychom pokládali za index řádku, tak toto vyskládání odpovídá
<em>row major</em> pořadí.</p>
<p>Vícerozměrná pole v <em>C</em> lze zobecnit do vyšších dimenzí (můžete tak použít například
<code>int pole[3][3][3]</code> atd.), nicméně je dobré to nepřehánět, aby kód zůstal přehledný.</p>
<h3><a class="header" href="#inicializace-vícerozměrných-polí" id="inicializace-vícerozměrných-polí">Inicializace vícerozměrných polí</a></h3>
<p>Vícerozměrné pole můžete nainicializovat <a href="c/pole/staticka_pole.html#inicializace-pole">stejně</a> jako klasické
pole. Pro zpřehlednění kódu však také můžete použít složené závorky pro oddělení jednotlivých
dimenzí:</p>
<pre><code class="language-c">int pole_2d[3][4] = {  
   {0, 1, 2, 3},    // hodnoty pro první řádek
   {4, 5, 6, 7},    // hodnoty pro druhý řádek
   {8, 9, 10, 11}   // hodnoty pro třetí řádek
};
</code></pre>
<h2><a class="header" href="#vícerozměrné-pole-na-haldě" id="vícerozměrné-pole-na-haldě">Vícerozměrné pole na haldě</a></h2>
<p>Pokud potřebujeme vícerozměrné pole s <a href="c/pole/dynamicka_pole.html">dynamickou velikostí</a>, stačí při volání
funkce <code>malloc</code> vytvořit dostatek paměti pro všechny rozměry. Pokud bychom například chtěli
naalokovat paměť pro 2D obrázek s <code>vyska</code> řádky a <code>sirka</code> sloupci, můžeme použít následující volání
funkce <code>malloc</code>:</p>
<pre><code class="language-c">int* pamet_obrazku = (int*) malloc(vyska * sirka * sizeof(int));
</code></pre>
<p>Nezapomeňte, že pro indexování takového pole budeme muset používat <a href="c/pole/vicerozmerna_pole.html#indexov%C3%A1n%C3%AD">přepočet 1D/2D indexů</a>!</p>
<h1><a class="header" href="#zubatá-pole" id="zubatá-pole">Zubatá pole</a></h1>
<blockquote>
<p>🤓 Tato sekce obsahuje doplňující učivo. Pokud je toho na vás moc, můžete ji prozatím přeskočit
a vrátit se k ní později.</p>
</blockquote>
<p>Občas můžete narazit na situaci, kdy potřebujete vytvořit vícerozměrné pole, kde některá z dimenzí
nemá fixní velikost. Například první řádek může mít dva sloupce, druhý řádek tři sloupce, třetí řádek
žádný sloupec atd.</p>
<p>V takovém případě můžete vytvořit tzv. <strong>zubaté pole</strong> (<em>jagged array</em> nebo také <em>ragged array</em>).
Zubaté pole je v podstatě &quot;pole polí&quot; - vytvoříte (dynamické)<sup class='margin-toggle sidenote-number'>1</sup> pole řádků, a každý řádek bude opět
dynamické pole sloupců. Kvůli tomuto vnoření polí je nutné jako datový typ použít ukazatel na ukazatel.
Následující kód vytvoří pole pěti studentů, a každému studentovi vytvoří pole s různým počtem ID předmětů,
které studuje:</p>
<span class='sidenote'><p><sup class='number'>1</sup>Vnější pole řádků teoreticky nemusí být dynamické, ale pokud už potřebujete dynamické
počty sloupců, obvykle budete chtít i dynamický počet řádků. </p>
</span>
<pre><code class="language-c editable mainbody">#include &lt;stdlib.h&gt;

int main() {
    // Vytvoření pole studentů
    int** studenti = (int**) malloc(5 * sizeof(int*));

    for (int i = 0; i &lt; 5; i++) {
        // Vytvoření pole předmětů pro konkrétního studenta
        studenti[i] = (int*) malloc((i + 1) * sizeof(int));
    }

    // Druhý předmět třetího studenta bude mít ID 5
    studenti[2][1] = 5;

    for (int i = 0; i &lt; 5; i++) {
        // Uvolnění pole předmětů pro konkrétního studenta
        free(studenti[i]);
    }

    // Uvolnění pole studentů
    free(studenti);
    return 0;
}
</code></pre>
<p>Při přístupu k prvkům pole můžeme klasicky využít hranatých závorek. <code>studenti[2]</code> vrátí adresu
pole předmětů třetího studenta, a nad tímto polem (resp. ukazatelem) můžeme opět použít hranaté
závorky pro přístup k druhému předmětu. Zde se tak neprovádí žádný převod 2D na 1D indexy ani naopak,
protože jednotlivá pole v paměti nejsou uložena za sebou.</p>
<p>Všimněte si, že jednotlivé pole předmětů (&quot;řádky&quot; našeho vícerozměrného pole) musíme uvolňovat
zvlášť, a musíme je uvolnit dříve, než uvolníme samotné pole studentů (řádků), jinak bychom už k
adresám polí předmětů nesměli přistupovat.</p>
<blockquote>
<p>Pokud by zubaté pole mělo tři dimenze, typ &quot;vnějšího&quot; pole by byl <code>int***</code>, pokud čtyři dimenze,
tak <code>int****</code> atd.</p>
</blockquote>
<p>Vytváření a uvolňování zubatého pole je o dost náročnější než u klasického vícerozměrného pole. To
je totiž v paměti uloženo jako klasické 1D pole, které akorát indexujeme vícerozměrným indexem, kdežto
zubaté pole je opravdu pole polí (polí polí...). Někdy je ovšem nutné mít různou velikost jednotlivých
řádků, a tehdy zubatá pole přijdou vhod.</p>
<h1><a class="header" href="#text" id="text">Text</a></h1>
<p>Doposud jsme pracovali zejména s čísly, nyní se podíváme na to, jak můžeme v počítači reprezentovat
znaky a jak obecně pracovat s textem. Zpracování textu je obsaženo téměř v každém programu –
načítání konfiguračních souborů, zadávání příkazů z terminálu, práce s dokumenty či tabulkami,
komunikace po síti a mnoho dalších činností vyžaduje práci s textem.</p>
<p>Nejprve si ukážeme, jak v počítači reprezentovat jednotlivé <a href="c/text/znaky.html">znaky</a>, dále jak z nich
vytvořit delší <a href="c/text/retezce.html">sekvence textu</a> a poté jak text <a href="c/text/vstupavystup.html">načítat a vypisovat</a>.</p>
<h1><a class="header" href="#znaky" id="znaky">Znaky</a></h1>
<p>Už víme, že v paměti počítače je nakonec vše reprezentováno číslem, a ani textové znaky
nejsou výjimkou. Přirozeným způsobem, jak od sebe znaky odlišit, je přiřadit každému znaku jiné číslo,
například znak <code>A</code> můžeme reprezentovat číslem <code>0</code>, znak <code>B</code> číslem <code>1</code> atd. Kdyby si však každý
program(átor) definoval vlastní způsob, jak převádět znaky na čísla, tak by mezi sebou programy
nemohly rozumně komunikovat, protože by si nerozuměly.</p>
<p>Z toho důvodu vzniklo za poslední desítky let mnoho <strong>textových kódování</strong>
(<em>character encoding</em>), které definují, jaká čísla přiřadit jednotlivým znakům. Dnešním de-facto
standardem je kódování <a href="https://en.wikipedia.org/wiki/Unicode">Unicode</a>, které obsahuje přes sto tisíc
různých znaků, od dávných hieroglyfů, přes českou či anglickou abecedu, až po všelijaké emoji.
Práce s kódováním Unicode však není v jazyce <em>C</em> přímočará, navíc pro naše potřeby vůbec není potřeba<sup class='margin-toggle sidenote-number'>1</sup>.</p>
<span class='sidenote'><p><sup class='number'>1</sup>Pokud byste se o kódování znaků a Unicode chtěli dozvědět více, přečtěte si tento
<a href="https://kunststube.net/encoding/">článek</a>. </p>
</span>
<p>V rámci předmětu UPR si tak vystačíme s kódováním <a href="https://en.wikipedia.org/wiki/ASCII">ASCII</a>
(American Standard Code for Information Interchange). Toto kódování sice obsahuje pouze 128 znaků
(číslice, malá a velká písmena anglické abecedy, interpunkce apod.), nicméně práce s ním je díky tomu
velmi jednoduchá. Je navíc podmnožinou Unicode, takže programy, které podporují Unicode kódování, si
s ASCII hravě poradí. Tabulku, která uvádí, jak ASCII mapuje jednotlivé znaky na čísla, naleznete např.
<a href="https://www.asciitable.com/">zde</a><sup class='margin-toggle sidenote-number'>2</sup>.</p>
<span class='sidenote'><p><sup class='number'>2</sup>V tabulce si můžete všimnout, že čísla nejsou znakům přiřazena
zcela náhodně, například znaky reprezentující číslice <code>0</code> až <code>9</code> mají přiřazena čísla ležící za sebou
(<code>48</code> - <code>57</code>), a stejně je tomu i u písmen anglické abecedy. Této vlastnosti můžeme využít pro
usnadnění některých textových <a href="c/text/../../ulohy/text.html#p%C5%99evod-textu-na-%C4%8D%C3%ADslo">operací</a>.</p>
</span>
<h2><a class="header" href="#ascii-znaky-v-c" id="ascii-znaky-v-c">ASCII znaky v <em>C</em></a></h2>
<p>Jelikož ASCII &quot;kóduje&quot; pouze 128 znaků, tak pro reprezentaci ASCII znaku by nám stačilo 7 bitů.
Nicméně pracovat se sedmibitovými hodnotami by bylo poněkud nepraktické, proto se běžně ASCII znak
ukládá do jednobytového (osmibitového) čísla. V <em>C</em> se pro reprezentaci jednoho ASCII znaku používá
datový typ <code>char</code><sup class='margin-toggle sidenote-number'>3</sup>, s kterým jsme se
<a href="c/text/../datove_typy/celociselne_typy.html">již setkali</a>.</p>
<span class='sidenote'><p><sup class='number'>3</sup><em>C</em> neobsahuje specializovaný typ pro jednobytové celé číslo, <code>char</code> tak reprezentuje jak
ASCII znak, tak i celé číslo s jedním bytem. Záleží pak na nás, jak budeme hodnotu v <code>char</code>u
interpretovat - jestli jako celé číslo nebo jako ASCII znak.</p>
</span>
<p>Pokud bychom chtěli do proměnné s typem <code>char</code> nějaký znak uložit, tak bychom mohli použít přímo
jeho číslo z ASCII <a href="https://www.asciitable.com/">tabulky</a>:</p>
<pre><code class="language-c">char znak = 65; // tento znak bude reprezentovat písmeno A
</code></pre>
<p>Nicméně takto by si každý programátor musel nazpaměť pamatovat ASCII tabulku, což je dost nepraktické.
<em>C</em> tak nabízí zkratku v podobě <strong>znakového literálu</strong> (<em>char literal</em>). Pokud napíšete jeden ASCII
znak do apostrofů (<code>'</code>), tento výraz se vyhodnotí jako ASCII číselná hodnota daného znaku s datovým
typem <code>char</code>. Obvykle tak znaky v programech zadáváme v apostrofech pro zjednodušení:</p>
<pre><code class="language-c">char znak = 'A'; // tento znak bude reprezentovat písmeno A
</code></pre>
<p>Pokud bychom si chtěli ověřit, že hodnota tohoto znaku je opravdu <code>65</code>, jak udává ASCII, můžeme
si ho vypsat na výstup programu jako číslo:</p>
<pre><code class="language-c editable mainbody">#include &lt;stdio.h&gt;

int main() {
    char znak = 'A';
    printf(&quot;%d\n&quot;, (int) znak);
    return 0;
}
</code></pre>
<p>Do apostrofů nikdy nedávejte více než jeden znak! Překladač by se snažil takovýto zápis interpretovat
jako vícebytový znak, což téměř jistě není to, čeho chcete dosáhnout. Pro práci s textem (více znaky
najednou) slouží <a href="c/text/retezce.html">řetězce</a>. Jedinou výjimkou jsou speciální znaky, které se zapisují
pomocí zpětného lomítka, například:</p>
<ul>
<li><code>'\n'</code> reprezentuje znak <code>LF</code>, který udává, že má dojít k přechodu kurzoru na nový řádek.<sup class='margin-toggle sidenote-number'>4</sup><span class='sidenote'><p><sup class='number'>4</sup>Nepleťte si ho se znakem <code>'n'</code>, který reprezentuje klasické písmeno <code>n</code> z abecedy.</p>
</span></li>
<li><code>'\t'</code> reprezentuje znak <code>TAB</code>, který udává, že má dojít k výpisu delší mezery.</li>
<li><code>'\0'</code> reprezentuje znak <code>NUL</code> s číselnou hodnotou <code>0</code>.</li>
</ul>
<h3><a class="header" href="#Čísla-vs-znaky" id="Čísla-vs-znaky">Čísla vs znaky</a></h3>
<p>Při používání apostrofů je mimo jiné třeba si dávat pozor na to, jestli pracujeme s číselnou
hodnotou nebo se znakem, který reprezentuje nějakou číslici. Například zde:</p>
<pre><code class="language-c">char znak = 9;
</code></pre>
<p>Nedojde k uložení znaku <code>9</code> do proměnné. Bude do ní uložen znak <code>TAB</code>, který má v ASCII hodnotu <code>9</code>
a pomocí apostrofů ho lze zapsat jako <code>'\t'</code>. Pokud bychom do znaku chtěli zapsat znak reprezentující
číslici <code>9</code>, musíme použít buď literál <code>'9'</code> nebo číselnou hodnotu <code>57</code>, která devítku v ASCII
reprezentuje.</p>
<p>Pokud byste chtěli převést ASCII znak číslice na její číselnou hodnotu, stačí od něj odečíst hodnotu
<code>48</code>, neboli znak <code>'0'</code>. <code>'0' - '0'</code> je <code>0</code>, <code>'5' - '0'</code> je <code>5</code> atd. To je způsobeno tím, že číslice
mají v ASCII kódování přiřazeny sekvenční číselné hodnoty.</p>
<h1><a class="header" href="#Řetězce" id="Řetězce">Řetězce</a></h1>
<p>Nyní už víme, jak můžeme v <em>C</em> pracovat s jednotlivými (ASCII) znaky. Obvykle však chceme pracovat
s delšími sekvencemi textu - řádky, větami, odstavci atd. Sekvence textu se v programovacích jazycích
obvykle označují jako <strong>řetězce</strong> (<em>strings</em>).</p>
<p>Dobrá zpráva je, že pro použití řetězců v <em>C</em> už
známe vše potřebné – řetězce nejsou nic jiného než <a href="c/text/../pole/pole.html">pole</a> <a href="c/text/znaky.html">znaků</a>!</p>
<h2><a class="header" href="#Řetězce-v-c" id="Řetězce-v-c">Řetězce v <em>C</em></a></h2>
<p>Teoreticky bychom si mohli navrhnout vlastní způsob, jak řetězce v paměti reprezentovat a jak s nimi
pracovat. Nicméně zaběhlým způsobem, jak s ASCII textem v <em>C</em> pracovat, a pro který <em>C</em> nabízí různé
funkce a základní syntaktickou podporu, je použití takzvaných <strong>řetězců zakončených nulou</strong>
(<em>null-terminated strings</em>). Takto reprezentovaný řetězec není nic jiného než <a href="c/text/../pole/pole.html">pole</a>
<a href="c/text/znaky.html">znaků</a>, které obsahuje na svém posledním indexu znak <code>'\0'</code> (s číselnou hodnotou <code>0</code>),
který značí konec řetězce. Například řetězec <code>UPR</code> by tedy v paměti počítače byl reprezentovaný takto:
<upr-array array='["U", "P", "R", "\\0"]'></upr-array></p>
<h3><a class="header" href="#vytvoření-řetězce" id="vytvoření-řetězce">Vytvoření řetězce</a></h3>
<p>Pokud bychom chtěli vytvořit řetězec na zásobníku, můžeme vytvořit statické pole, umístit do něj
jednotlivé znaky řetězce a za ně přidat znak <code>'\0</code><sup class='margin-toggle sidenote-number'>1</sup>:</p>
<span class='sidenote'><p><sup class='number'>1</sup>Pro <a href="c/text/vystup.html">výpis</a> řetězce pomocí funkce <code>printf</code> můžeme použít zástupný znak <code>%s</code>.</p>
</span>
<pre><code class="language-c editable mainbody">#include &lt;stdio.h&gt;

int main() {
    char text[4] = {'U', 'P', 'R', '\0'};
    printf(&quot;%s\n&quot;, text);
    return 0;
}
</code></pre>
<p>Pokud bychom potřebovali řetězec s dynamickou nebo velkou délkou, můžeme pro vytvoření řetězce
samozřejmě použít také <a href="c/text/../pole/dynamicka_pole.html">dynamickou paměť</a>.</p>
<h3><a class="header" href="#Řetězcový-literál" id="Řetězcový-literál">Řetězcový literál</a></h3>
<p>Vytváření řetězců tímto způsobem je nicméně celkem zdlouhavé a nepřehledné. Často chceme v programu
jednoduše a rychle zapsat krátký textový řetězec tak, aby šel přehledně přečíst. K tomu můžeme využít
tzv. <strong>řetězcový literál</strong> (<em>string literal</em>), který lze vytvořit tak, že napíšeme text do dvojitých
uvozovek (<code>&quot;</code>). Pokud tedy v našem programu vytvoříme například literál <code>&quot;UPR&quot;</code>, tak se stane následující:</p>
<ol>
<li>Překladač při překladu uloží do výsledného spustitelného souboru pole reprezentující daný řetězec.
V tomto případě půjde o pole velikosti 4 s hodnotami <code>'U'</code>, <code>'P'</code>, <code>'R'</code> a <code>'\0'</code>. Při spuštění
programu se toto pole načte do <a href="c/text/../prace_s_pameti/globalni_pamet.html">globální paměti</a> v sekci
adresního prostoru, která je určena pouze pro čtení. Do takto vytvořeného řetězce tak nelze
zapisovat, lze jej pouze číst<sup class='margin-toggle sidenote-number'>2</sup>.<span class='sidenote'><p><sup class='number'>2</sup>Tyto řetězce jsou pouze pro čtení zejména z toho důvodu, aby je šlo sdílet. Pokud například
v programu použijete třikrát stejný řetězcový literál, překladač může v paměti pole pro tento
literál vytvořit pouze jednou, aby ušetřil paměť. Kvůli toho ale musí být řetězce pouze pro čtení,
pokud bychom totiž takto sdílený řetězec změnili, změnilo by to i hodnotu všech ostatních literálů,
které se vyhodnotí na jeho adresu, což by bylo dost neintuitivní.</p>
</span></li>
<li>Samotný výraz literálu se při běhu programu vyhodnotí jako adresa prvního znaku řetězce
uloženého v globální paměti.</li>
<li>Datový typ literálu bude
<a href="c/text/../prace_s_pameti/ukazatele.html#konstantn%C3%AD-ukazatele">ukazatel na konstantní znak</a>, tedy
<code>const char*</code>. Tento datový typ říká, že hodnotu znaku na dané adrese nelze měnit.</li>
</ol>
<p>Pomocí řetězcového literálu si tak můžeme značne usnadnit zápis řetězců v programech, jelikož
nemusíme přemýšlet nad délkou pole, nemusíme pamatovat na umístění znaku <code>'\0'</code> na konec řetězce
a ani nemusíme obalovat jednotlivé znaky do apostrofů:</p>
<pre><code class="language-c editable mainbody">#include &lt;stdio.h&gt;

int main() {
    const char* text = &quot;UPR&quot;;
    printf(&quot;%s\n&quot;, text);
    return 0;
}
</code></pre>
<p>Je však třeba pamatovat na to, že takto vytvořené řetězce jsou opravdu pouze pro čtení, a nesmíme
tak do nich zapisovat. Pokud je budete ukládat do proměnné, tak použijte datový typ <code>const char*</code>,
díky kterému vás překladač bude hlídat, abyste se do takovéhoto řetězce omylem nesnažili něco zapsat.</p>
<p>Pokud byste chtěli použít řetězcový literál pro vytvoření řetězce, který lze měnit, můžete ho uložit
do proměnné typu <code>char[]</code> (tj. pole znaků):</p>
<pre><code class="language-c editable mainbody">#include &lt;stdio.h&gt;

int main() {
    char text[] = &quot;UPR&quot;;
    text[0] = 'A';
    printf(&quot;%s\n&quot;, text);
    return 0;
}
</code></pre>
<p>V takovémto případě se hodnota z literálu překopíruje do proměnné pole znaků na zásobníku, který již
lze měnit.</p>
<blockquote>
<p>Pokud jsou vám řetězcové literály povědomé, je to kvůli toho, že jsme je již mnohokrát
využili při volání funkce <code>printf</code>.</p>
</blockquote>
<h4><a class="header" href="#víceřádkové-řetězcové-literály" id="víceřádkové-řetězcové-literály">Víceřádkové řetězcové literály</a></h4>
<p>Pokud budete chtít zapsat řetězcový literál na více řádků kódu, můžete buď na konci každého
neukončeného řádku použít znak <code>\</code>:</p>
<pre><code class="language-c">const char* veta = &quot;Ahoj \
jmenuji \
se \
Karel&quot;;
</code></pre>
<p>nebo každý řádek samostatně obalit uvozovkami:</p>
<pre><code class="language-c">const char* veta = &quot;Ahoj&quot;
&quot;jmenuji&quot;
&quot;se&quot;
&quot;Karel&quot;;
</code></pre>
<p>Pozor však na to, že v ani jednom ze zmíněných případů nebude součástí řetězce znak odřádkování.
Ten musíte vždy přidat explicitně:</p>
<pre><code class="language-c">const char* radky = &quot;radek1\n\
radek2\n\
radek3\n&quot;;

// nebo
const char* radky = &quot;radek1\n&quot;
&quot;radek2\n&quot;
&quot;radek3\n&quot;;
</code></pre>
<h3><a class="header" href="#k-čemu-slouží-nulový-znak-na-konci" id="k-čemu-slouží-nulový-znak-na-konci">K čemu slouží nulový znak na konci?</a></h3>
<p>U polí je trochu nepraktické to, že pokud je chceme poslat do nějaké funkce, musíme spolu s
ukazatelem na první prvek pole předat také jeho
<a href="c/text/../pole/staticka_pole.html#p%C5%99ed%C3%A1v%C3%A1n%C3%AD-velikosti-pole">velikost</a>, aby funkce věděla, ke kolika prvkům
si může dovolit přistoupit. Jiným způsobem, jak určit velikost pole, je zvolit si speciální hodnotu,
která bude značit konec pole. Když kód, který s takovýmto polem bude pracovat, na tuto speciální
hodnotu narazí, tak bude vědět, že dále v paměti již pole nepokračuje.</p>
<p>Tento mechanismus je využit právě u řetězců zakončených nulou, kde onou speciální hodnotou je právě
tzv. <code>NUL</code> znak, který má číselnou hodnotu <code>0</code>. Například při procházení řetězce v cyklu tak nemusíme
dopředu znát jeho délku, stačí cyklus ukončit, jakmile narazíme na znak <code>'\0'</code>. Například funkce
pro spočtení délky řetězce by mohla vypadat takto<sup class='margin-toggle sidenote-number'>3</sup>:</p>
<span class='sidenote'><p><sup class='number'>3</sup>Všimněte si, že tato funkce bere ukazatel na konstantní pole znaků.
Pokud ve funkci nepotřebujete měnit hodnoty pole, je obvykle dobrý nápad použít klíčové slovo
<code>const</code> před datovým typem obsaženým v poli, aby vás překladač ohlídal, že se pole nesnažíte měnit.
Do takovéto funkce pak klidně můžete poslat i pole, které ve skutečnosti měnit lze, jinak řečeno
např. <code>char*</code> lze bez problému převést na <code>const char*</code>. V opačném směru konverze není korektní.</p>
</span>
<pre><code class="language-c">int delka_retezce(const char* retezec) {
    int delka = 0;

    // dokud není znak na adrese v ukazateli roven znaku NUL
    while (*retezec != '\0') {
        delka = delka + 1;
        retezec = retezec + 1;  // posuň ukazatel o jeden znak dále
    }
    return delka;
}
</code></pre>
<p>Tato funkce postupně projde všechny znaky řetězce a počítá, kolik jich je, dokud nenarazí na
znak <code>'\0</code>. Pro procházení řetězce je zde použita
<a href="c/text/../prace_s_pameti/ukazatele.html#aritmetika-s-ukazateli">aritmetika s ukazateli</a>.</p>
<p>Z toho vyplývá mimo jiné to, že znak <code>NUL</code> nemůže být použit &quot;uprostřed&quot; řetězce. Pokud by tomu tak
bylo, tak funkce, které by s takovýmto řetězcem pracovaly, by při nalezení tohoto znaku přestaly
řetězec zpracovávat, a jakékoliv další znaky za <code>NUL</code> by byly ignorovány. Uhodnete tak, co vypíše
následující program?</p>
<pre><code class="language-c editable mainbody">#include &lt;stdio.h&gt;

int main() {
    char text[] = {'U', '\0', 'P', 'R', '\0'};
    printf(&quot;%s\n&quot;, text);
    return 0;
}
</code></pre>
<h3><a class="header" href="#Řetězce-jako-pole" id="Řetězce-jako-pole">Řetězce jako pole</a></h3>
<p>S řetězci pracujeme jako s klasickými poli znaků. Například pro získání prvního znaku řetězce můžeme
použít operátor hranatých závorek:</p>
<pre><code class="language-c">char vrat_prvni_znak(const char* retezec) {
    return retezec[0];
}
</code></pre>
<h2><a class="header" href="#funkce-pro-práci-s-řetězci" id="funkce-pro-práci-s-řetězci">Funkce pro práci s řetězci</a></h2>
<p>Standardní knihovna <em>C</em> obsahuje <a href="https://devdocs.io/c/string/byte">řadu funkcí</a>, které umí s
řetězci zakončenými nulou pracovat. Zde je seznam několika vybraných funkcí, které pro vás můžou
být užitečné:</p>
<ul>
<li>
<p><strong>Zjištění délky řetězce</strong>: funkce <a href="https://devdocs.io/c/string/byte/strlen"><code>strlen</code></a> bere jako
parametr řetězec a vrací jeho délku. Jedná se o jednu z nejčastěji používaných funkcí při práci s
řetězci a vyplatí se ji tak znát.</p>
<p>Při jejím použití je ovšem nutné si dát pozor na to, že délka provádění této funkce závisí na tom, jak je
řetězec dlouhý. Pokud bude mít řetězec milion znaků, tak bude tato funkce muset projít všech milion
znaků, dokud nenarazí na znak <code>NUL</code>. Dávejte si tak pozor, abyste tuto funkci nevolali zbytečně často.
Například pokud použijete funkci <code>strlen</code> v podmínce cyklu <code>for</code>:</p>
<pre><code class="language-c">for (int i = 0; i &lt; strlen(retezec); i++) {
    ...
}
</code></pre>
<p>Tak se délka řetězce vypočte při každé iteraci cyklu. Pokud by tak řetězec měl milion znaků,
musel by program provést bilion<sup class='margin-toggle sidenote-number'>4</sup> (!) operací pouze pro zjištění délky řetězce.
Lepší volbou (pokud se tedy délka řetězce nemění) je tak předpočítat si jeho délku dopředu a
uložit si ji do proměnné:</p>
<span class='sidenote'><p><sup class='number'>4</sup>1 000 000 000 000</p>
</span>
<pre><code class="language-c">int delka = strlen(retezec);
for (int i = 0; i &lt; delka; i++) {
    ...
}
</code></pre>
</li>
</ul>
<ul>
<li>
<p><strong>Porovnání dvou řetězců</strong>: běžnou operací, kterou bychom s řetězci chtěli udělat, je porovnat,
zdali jsou dva řetězce stejné, popřípadě který z nich je menší<sup class='margin-toggle sidenote-number'>5</sup>. Funkce
<a href="https://devdocs.io/c/string/byte/strcmp"><code>strcmp</code></a> bere dva řetězce a vrací nulu, pokud se řetězce
rovnají, zápornou hodnotu, pokud je první řetězec menší než ten druhý, a kladnou hodnotu, pokud je
druhý řetězec menší než první.</p>
<span class='sidenote'><p><sup class='number'>5</sup>Pro porovnávání řetězců se používá <a href="https://cs.wikipedia.org/wiki/Lexikografick%C3%A9_uspo%C5%99%C3%A1d%C3%A1n%C3%AD">lexikografické uspořádání</a>.
Nalezne se první dvojice znaků (zleva), ve kterém se řetězce liší, a tyto dva znaky se porovnají
pomocí jejich číselné (ASCII) hodnoty.</p>
</span>
<blockquote>
<p>Pro porovnávání dvou řetězců nikdy nepoužívejte operátor <code>==</code>! Nebude to
<a href="c/text/../../caste_chyby/caste_chyby.html#porovn%C3%A1v%C3%A1n%C3%AD-%C5%99et%C4%9Bzc%C5%AF-pomoc%C3%AD-">fungovat</a>.</p>
</blockquote>
</li>
</ul>
<ul>
<li>
<p><strong>Vyhledání řetězce v řetězci</strong>: pokud chcete zjistit, jestli se v nějakém řetězci vyskytuje jiný
řetězec, můžete použít funkci <a href="https://devdocs.io/c/string/byte/strstr"><code>strstr</code></a>.</p>
</li>
<li>
<p><strong>Převod textu na číslo</strong>: často můžete potřebovat převést textový zápis čísla na jeho číselnou
hodnotu. K tomu můžete použít například funkci <a href="https://devdocs.io/c/string/byte/strtol"><code>strtol</code></a>
(<em>string to long</em>). První parametr funkce je řetězec, který chcete převést, do druhého parametru
můžete předat ukazatel na ukazatel na znak, do kterého se uloží pozice ve vstupním řetězci těsně za
načteným číslem. Posledním parametrem je soustava, ve které se má číslo načíst (obvykle to bude
desítková soustava, tedy hodnota <code>10</code>). Návratovou hodnotou funkce je pak načtené číslo.</p>
<p>Můžete použít také funkci <a href="https://devdocs.io/c/string/byte/atoi"><code>atoi</code></a>, která je trochu
jednodušší na použití, ale při jejím použití nelze zjistit, zdali při konverzi nedošlo k chybě
(například pokud vstupní řetězec nereprezentoval číslo).</p>
</li>
</ul>
<hr />
<p><strong>Cvičení</strong> 🏋</p>
<p>Pro procvičení práce s řetězci si můžete zkusit některé z těchto funkcí sami
naprogramovat. Další úlohy pro práci s řetězci můžete nalézt <a href="c/text/../../ulohy/text.html">zde</a>.</p>
<hr />
<p><strong>Kvíz</strong> 🤔</p>
<ol>
<li>
<p>Co vypíše následující program?</p>
<pre><code class="language-c editable mainbody">#include &lt;stdio.h&gt;

int main() {
    const char* str = &quot;hello&quot;;

    printf(&quot;%c\n&quot;, str[3]);
    printf(&quot;%c\n&quot;, str[2]);
    printf(&quot;%c\n&quot;, str[1]);

    return 0;
}
</code></pre>
<details>
 <summary>Odpověď</summary>
<p>Program vypíše:</p>
<pre><code>l
l
e
</code></pre>
<p>Jelikož jsou řetězce poli znaků, tak při přistoupení na nějaký index řetězce získáme hodnotu
datového typu znak.</p>
</details>
</li>
<li>
<p>Co vypíše následující program?</p>
<pre><code class="language-c editable mainbody">#include &lt;stdio.h&gt;

int main() {
    const char* str = &quot;hello&quot;;
    
    for (int i = 0; i &lt; 5; i++) {
        printf(&quot;%c&quot;, str[i] - 32);
    }
    printf(&quot;\n&quot;);

    return 0;
}
</code></pre>
<details>
 <summary>Odpověď</summary>
<p>Program vypíše <code>HELLO</code>. Když se podíváte na <a href="https://www.asciitable.com/">ASCII tabulku</a>, tak
zjistíte, že rozdíl mezi čísly reprezentujícími jednotlivé znaky malé a velké anglické abecedy
je <code>32</code>, a že znaky malé abecedy jsou reprezentovány vyššími čísly. Když tak např. od <code>'h'</code>
odečteme hodnotu <code>32</code>, získáme znak <code>'H'</code>. Přehlednější by bylo napsat tuto konverzi jako
<code>str[i] - ('a' - 'A')</code> nebo použít funkci <a href="https://devdocs.io/c/string/byte/tolower"><code>tolower</code></a>
ze standardní knihovny jazyka <em>C</em>.</p>
</details>
</li>
</ol>
<h1><a class="header" href="#vstup-a-výstup" id="vstup-a-výstup">Vstup a výstup</a></h1>
<p>Už víme, jak v paměti počítače pracovat s (ASCII) znaky a řetězci. Nyní si ukážeme, jak můžou naše
programy komunikovat s okolním světem – se <a href="c/text/../soubory/soubory.html">soubory</a> na disku, s terminálem, s
ostatními programy běžícími na vašem počítači či s úplně jiným počítačem přes síť. Komunikace programů
se obecně označuje jako <strong>I/O</strong> (<em>input/output</em>).</p>
<p>Komunikace s terminálem, souborem, tiskárnou či přes síť má samozřejmě rozlišná pravidla. Abychom v
každém programu nemuseli programovat podporu pro každý vstupní/výstupní kanál od nuly, z velké části
se o toto stará operační systém. Ten nám umožňuje komunikovat s okolním světem pomocí tzv.
<strong>souborových deskriptorů</strong> (<em>file descriptors</em>). Při vytvoření nového komunikačního kanálu
(například při otevření souboru) našemu programu operační systém předá nový souborový deskriptor
identifikovaný číslem. Když poté náš program chce vypsat nebo načíst data, tak musí předat operačnímu
systému číslo deskriptoru, se kterým chceme komunikovat. Můžeme například říct <code>Vypiš text &quot;ahoj&quot; do souborového deskriptoru s číslem 5</code>. Ať už je na tento deskriptor připojen soubor, terminál či něco
jiného, operační systém se postará o to, aby k němu data z našeho programu korektně dorazila.</p>
<h2><a class="header" href="#standardní-souborové-deskriptory" id="standardní-souborové-deskriptory">Standardní souborové deskriptory</a></h2>
<p>Každému programu při spuštění přiřadí operační systém tři základní souborové deskriptory:</p>
<ul>
<li>
<p><strong>Standardní vstup</strong> (<code>stdin</code>): tento deskriptor má číslo <code>0</code> a používá se pro čtení vstupu.
Pokud váš program spustíte z terminálu, tak do <code>stdin</code>u bude přesměrován text, který napíšete v
terminálu. Nemusí tomu tak však být vždy. Váš program můžete například spustit z jiného programu, a
předat mu vstup přímo z paměti. Nebo můžete například na vstup vašeho programu přesměrovat soubor z
disku:</p>
<pre><code class="language-bash">$ ./program &lt; soubor.txt
</code></pre>
</li>
<li>
<p><strong>Standardní výstup</strong> (<code>stdout</code>): tento deskriptor má číslo <code>1</code> a používá se pro výpis dat. Pokud
váš program spustíte z terminálu, tak data odeslaná do <code>stdout</code>u se objeví na obrazovce terminálu.
Opět to ale není jediná možnost, <code>stdout</code> může být například přesměrovaný do souboru na disku:</p>
<pre><code class="language-bash">$ ./program &gt; soubor.txt
</code></pre>
<p>Funkce <code>printf</code> posílá svůj výstup právě do deskriptoru <code>stdout</code>.</p>
<p>Pokud to <a href="https://devdocs.io/c/io/setvbuf">nezměníte</a>, tak <code>stdout</code> implicitně používá 
tzv. <strong>bufferování po řádcích</strong> (<em>line buffering</em>). To znamená, že pokud zapíšete do <code>stdout</code>
pomocí některé z funkcí standardní knihovny <em>C</em> nějaký text, tak tento text se nejprve zapíše
do dočasného pole (tzv. <em>bufferu</em>) v paměti. Až jakmile na výstup zapíšete znak odřádkování <code>'\n'</code><sup class='margin-toggle sidenote-number'>1</sup>,
tak dojde k vyprázdnění (<em>flush</em>) bufferu, kdy je jeho obsah odeslán na výstup. Jinak řečeno,
dokud nevypíšete znak odřádkování, váš výstup se neobjeví např. v terminálu. Bufferování po
řádcích se provádí jako optimalizace, výstup (i vstup) totiž dost často brzdí vykonávání programů.</p>
<span class='sidenote'><p><sup class='number'>1</sup>Nebo jakmile v bufferu dojde paměť.</p>
</span></li>
<li>
<p><strong>Standardní chybový výstup</strong> (<code>stderr</code>): tento deskriptor má číslo <code>2</code> a používá se pro výpis
chyb a logovacích záznamů. Narozdíl od <code>stdout</code> nepoužívá <code>stderr</code> implicitně line buffering, takže
cokoliv, co do něj zapíšete, se okamžite odešle na výstup deskriptoru.</p>
</li>
</ul>
<p>Mimo těchto standardních deskriptorů můžete ve svých programech vytvářet i další deskriptory,
například pomocí otevírání <a href="c/text/../soubory/soubory.html">souborů</a>. Více o tom, jak fungují souborové deskriptory
a vstup a výstup programu se dozvíte v předmětu
<a href="http://poli.cs.vsb.cz/edu/osy/osnova.html">Operační systémy</a>.</p>
<h3><a class="header" href="#interpretace-vstupních-a-výstupních-dat" id="interpretace-vstupních-a-výstupních-dat">Interpretace vstupních a výstupních dat</a></h3>
<p>Je dobré si uvědomit, že stejně jako v <a href="c/text/../../uvod/pamet.html">operační paměti</a>, i při komunikaci vždy
pracujeme pouze s čísly (byty), jejichž význam je dán čistě tím, jak je jejich příjemce bude interpretovat.
Pokud náš program do souboru zapíše byty <code>85</code>, <code>80</code>, <code>82</code>, a my tento soubor otevřeme v textovém
editoru, který jej bude pokládat za ASCII soubor, zobrazí se nám text <code>UPR</code>. Pokud jej však otevřeme
v binárním editoru, budou to pro něj pouze tři celá čísla. Pro prohlížeč obrázků by tato čísla zase
mohla reprezentovat barevné složky RGB pixelu.</p>
<p>Aby tak komunikace dvou stran dávala smysl, musí se obě strany dohodnout na tom, jak budou
interpretovat přenášená data. Například u souborů se způsob interpretace obvykle udává tím, jakou
dáme souboru příponu (<code>.txt</code> je pokládán za textový soubor, <code>.jpg</code> za JPEG obrázek atd.).</p>
<h2><a class="header" href="#ošetření-chyb" id="ošetření-chyb">Ošetření chyb</a></h2>
<p>Zatím jsme předpokládali, že operace, které provádíme v programu, vždy uspějí. Například při zápisu
hodnoty do proměnné jsme předpokládali, že se hodnota v paměti na adrese dané proměnné opravdu objeví
a když ji pak zpátky načteme, tak se při přenosu nijak neznehodnotí.</p>
<p>Při načítání vstupu či vypisování dat ovšem může velmi často dojít k různým chybovým situacím.
Během zápisu souboru na USB &quot;flashku&quot; ji můžeme omylem vytáhnout, při posílání dat přes síť nám může
vypadnout připojení k internetu nebo při načítání čísla z terminálu nám může zákeřný uživatel zadat
něco, co číslo ani zdaleka nepřipomíná.</p>
<p>Pokud tedy chceme psát robustní programy, které zvládnou korektně reagovat i na nevalidní vstup a
na různé chybové situace, které mohou nastat, musíme do našich programů přidat tzv.
<strong>ošetření chyb</strong> (<em>error handling</em>). Jedná se o obslužný kód, který reaguje na možné problémové
situace a snaží se je vyřešit. Jak ošetřovat chyby při komunikaci si ukážeme v jednotlivých sekcích
o <a href="c/text/vstup.html">vstupu</a> a <a href="c/text/vystup.html">výstupu</a>.</p>
<h1><a class="header" href="#vstup" id="vstup">Vstup</a></h1>
<p>Abychom mohli našim programům dávat příkazy nebo parametrizovat jejich chování, téměř vždy v nich
potřebujeme přečíst nějaké informace ze vstupu programu. V této sekci si ukážeme několik užitečných
funkcí ze <a href="c/text/../funkce/stdlib.html">standardní knihovny <em>C</em></a>, které nám to umožňují. Pro použití těchto
funkcí musíte ve svém programu <a href="c/text/../preprocesor/vkladani_souboru.html">vložit</a> soubor <code>&lt;stdio.h&gt;</code>.</p>
<h2><a class="header" href="#načtení-jednoho-znaku" id="načtení-jednoho-znaku">Načtení jednoho znaku</a></h2>
<p>Pro načtení jednoho znaku ze standardního vstupu (<code>stdin</code>) můžeme použít funkci
<a href="https://devdocs.io/c/io/getchar"><code>getchar</code></a>. Ta nám vrátí jeden znak ze vstupu, popřípadě hodnotu
makra <code>EOF</code><sup class='margin-toggle sidenote-number'>1</sup>, pokud již je vstup uzavřený a nelze z něj nic dalšího načíst nebo pokud došlo při
načítání k nějaké chybě.</p>
<span class='sidenote'><p><sup class='number'>1</sup><em>End-of-file</em></p>
</span>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int main() {
    char x = getchar();
    printf(&quot;Zadaný znak: %c\n&quot;, x);

    return 0;
}
</code></pre>
<h2><a class="header" href="#načtení-řádku" id="načtení-řádku">Načtení řádku</a></h2>
<p>Načítat vstup po jednotlivých znacích je poměrně zdlouhavé. Velmi často chceme ze vstupu načíst
delší úsek textu najednou, například celý řádek. Toho můžeme dosáhnout například použitím funkce
<a href="https://devdocs.io/c/io/fgets"><code>fgets</code></a>. Ta jako parametry přijímá ukazatel na řetězec, do kterého
zapíše načítaný řádek a maximální počet znaků, který lze načíst<sup class='margin-toggle sidenote-number'>2</sup>. Třetí parametr je
<a href="c/text/../soubory/soubory.html">soubor</a>, ze kterého se má vstup načíst. O souborech se dozvíte více později,
pokud chcete načítat data ze standardního vstupu, tak použijte jako třetí parametr globální proměnnou
<code>stdin</code>, která je nadefinována v souboru <code>&lt;stdio.h&gt;</code>. Pro jednoduché zjištění délky řetězce, do
kterého zapisujete, můžete použít operátor <code>sizeof</code>:</p>
<span class='sidenote'><p><sup class='number'>2</sup>Tato velikost je včetně znaku <code>'\0'</code>, který je vždy zapsán na konec vstupního řetězce. Pokud
tak máte řetězec (pole) o délce <code>10</code>, předejte do <code>fgets</code> hodnotu <code>10</code>. Funkce načte maximálně <code>9</code>
znaků a na konec řetězce umístí znak <code>'\0'</code>.</p>
</span>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int main() {
    char buf[80];
    // načti řádek textu ze vstupu do řetězce `buf`
    fgets(buf, sizeof(buf), stdin);

    return 0;
}
</code></pre>
<p>Pokud tato funkce vrátí návratovou hodnotu <code>NULL</code>, tak při načítání došlo k chybě. Tuto chybu byste
tak ideálně měli nějak ošetřit:</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int main() {
    char buf[80];
    if (fgets(buf, sizeof(buf), stdin) == NULL) {
        printf(&quot;Nacteni dat nevyslo. Ukoncuji program\n&quot;);
        return 1;
    }

    return 0;
}
</code></pre>
<blockquote>
<p>Pokud byl na vstupu řádek ukončený odřádkováním (<code>\n</code>), tak se toto odřádkování bude nacházet i v
načteném řetězci po zavolání <code>fgets</code>! Pokud tedy takto načtený řetězec chcete například porovnat s
jiným řetězcem, měli byste nejprve znak odřádkování odstranit. Více se můžete dozvědět
<a href="c/text/../../caste_chyby/caste_chyby.html#porovn%C3%A1v%C3%A1n%C3%AD-%C5%99et%C4%9Bzce-na%C4%8Dten%C3%A9ho-funkc%C3%AD-fgets">zde</a>.</p>
</blockquote>
<h2><a class="header" href="#načtení-formátovaného-textu" id="načtení-formátovaného-textu">Načtení formátovaného textu</a></h2>
<p>Pokud chceme načítat text, u kterého očekáváme, že bude mít nějaký specifický formát, popřípadě chceme
text rovnou nějak zpracovat, například jej převést na číslo, můžeme použít formátované načítání vstupu
pomocí funkce <a href="https://devdocs.io/c/io/fscanf"><code>scanf</code></a>. Této funkci předáme tzv.
<strong>formátovací řetězec</strong> (<em>format string</em>), který udává, jak má vypadat vstupní text. V tomto řetězci
můžeme používat různé zástupné znaky. Za každý zástupný znak ve formátovacím řetězci <code>scanf</code> očekává
jeden argument s adresou, do které se má uložit načtená hodnota popsaná zástupným znakem ze vstupu.
Například tento kód načte ze vstupu dvě celá čísla:</p>
<pre><code class="language-c">int x, y;
scanf(&quot;%d%d&quot;, &amp;x, &amp;y);
</code></pre>
<p>Pomocí formátovacího řetězce můžeme také vyžadovat, co musí v textu být. Například <code>scanf(&quot;x%d&quot;, …)</code>
načte vstup pouze, pokud v něm nalezne znak <code>'x'</code> následovaný číslem.</p>
<p>Seznam všech těchto zástupných znaků naleznete v <a href="https://devdocs.io/c/io/fscanf">dokumentaci</a>.
Načítat můžeme například celá čísla (<code>%d</code>), desetinná čísla (<code>%f</code>) či znaky (<code>%c</code>).</p>
<blockquote>
<p>Funkce <code>scanf</code> načítá data ze standardního vstupu programu (<code>stdin</code>). Obsahuje ovšem několik dalších
variant, pomocí kterých může načítat formátovaná data z libovolného souboru (<code>fscanf</code>) nebo třeba i
z řetězce v paměti (<code>sscanf</code>).</p>
</blockquote>
<p>Funkce <code>scanf</code> je jistě užitečná, zejména u krátkých a jednoduchých programů, nicméně má také určité
problémy, které jsou popsány níže. Pokud to je tedy možné, pro načítání vstupu raději používejte
funkci <code>fgets</code>.</p>
<h3><a class="header" href="#načítání-řetězců-pomocí-scanf" id="načítání-řetězců-pomocí-scanf">Načítání řetězců pomocí <code>scanf</code></a></h3>
<p>Pomocí <code>scanf</code> můžeme načítat také celé řetězce pomocí zástupného znaku <code>%s</code>. Zde si ovšem musíme
dávat pozor, abychom u něj uvedli i maximální délku řetězce, do kterého chceme text načíst<sup class='margin-toggle sidenote-number'>3</sup>:</p>
<span class='sidenote'><p><sup class='number'>3</sup>Narozdíl od funkce <code>fgets</code> se zde musí uvést délka o jedna menší, než je délka cílového řetězce,
do kterého znaky zapisujeme.</p>
</span>
<pre><code class="language-c">char buf[21];
scanf(&quot;%20s&quot;, buf);
</code></pre>
<p>Pokud bychom použili zástupný znak <code>%s</code> bez uvedené velikosti cílového řetězce, snadno by se mohlo
stát, že nám uživatel zadá moc dat, které by funkce <code>scanf</code> začala vesele zapisovat i za paměť předaného
řetězce, což může vést buď k pádu programu (v tom lepším případě) nebo ke vzniku bezpečnostní
zranitelnosti, pomocí které by uživatel našeho programu mohl například získat přístup k počítači,
na kterém program běží (v tom horším případě):</p>
<pre><code class="language-c">char buf[21];
// pokud uživatel zadá více než 20 znaků, může svým vstupem začít přepisovat paměť
// běžícího programu
scanf(&quot;%s&quot;, buf);
</code></pre>
<h3><a class="header" href="#zpracování-bílých-znaků" id="zpracování-bílých-znaků">Zpracování bílých znaků</a></h3>
<p>Funkce <code>scanf</code> ignoruje bílé znaky (mezery, odřádkování, tabulátory atd.) mezi jednotlivými
zástupnými znaky ve formátovacím řetězci. Například v následujícím kódu je validním vstupem <code>x8</code>,
<code>x 8</code> i <code>x   8</code>:</p>
<pre><code class="language-c">int a;
scanf(&quot;x%d&quot;, &amp;a);
</code></pre>
<p>I když může toto chování být užitečné, někdy je také celkem neintuitivní. Problém může způsobovat
zejména, pokud se pro načítání vstupu kombinuje formátované načítání (<code>scanf</code>) s neformátovaným
načítáním (např. <code>fgets</code>). Funkce <code>scanf</code> totiž bílé znaky nechá ve vstupu ležet, pokud je
nepotřebuje zpracovat.</p>
<p>Následující program načítá číslo pomocí funkce <code>scanf</code> a poté se snaží načíst následující
řádek textu pomocí funkce <code>fgets</code>:</p>
<pre><code class="language-c">int cislo;
scanf(&quot;%d&quot;, &amp;cislo);

char radek[80];
fgets(radek, sizeof(radek), stdin);
</code></pre>
<p>Pokud tomuto programu předáme text <code>5\nahoj</code>, očekávali bychom, že se v řetězci <code>radek</code> objeví
<code>ahoj</code>. Nicméně funkce <code>scanf</code> načte číslo <code>5</code> a nechá ve vstupu ležet znak odřádkování, protože
nic dalšího načíst nepotřebuje. Funkce <code>fgets</code> poté uvidí znak odřádkování, načte jej a skončí
své provádění (načte prázdný řádek), což zřejmě není chování, které bychom od programu čekali.</p>
<h3><a class="header" href="#ošetření-chyb-1" id="ošetření-chyb-1">Ošetření chyb</a></h3>
<p>Funkce <code>scanf</code> je problematická i co se týče ošetření chyb. Její návratová hodnota sice udává, kolik
zástupných znaků ze vstupu se jí podařilo načíst, problémem však je, že pokud funkce načte třeba
pouze polovinu vstupu, tak ji už nemůžeme zavolat znovu se stejným formátovacím řetězcem, jinak by se
snažila načíst data, která již načetla. Například pokud bychom tomuto programu:</p>
<pre><code class="language-c">int x, y;
scanf(&quot;%d%d&quot;, &amp;x, &amp;y);
</code></pre>
<p>předali text <code>5 asd</code>, tak funkce vrátí hodnotu <code>1</code>, tj. načetla ze vstupu jedno číslo. Nyní ovšem už
funkci nemůžeme zavolat znovu se stejnými parametry (jakmile bychom např. ve vstupu přeskočili nevalidní
text), protože v tuto chvíli už bychom chtěli načíst pouze jedno číslo. </p>
<h2><a class="header" href="#parametry-příkazového-řádku" id="parametry-příkazového-řádku">Parametry příkazového řádku</a></h2>
<p>Další možností, jak předat nějaký vstup vašemu programu, je předat mu parametry při spuštění v
terminálu:</p>
<pre><code class="language-bash">$ ./program arg1 arg2 arg3
</code></pre>
<p>K těmto předaným řetězcům poté lze přistoupit ve funkci
<a href="c/text/../../ruzne/funkce_main.html#vstupn%C3%AD-parametry-funkce-main"><code>main</code></a>.</p>
<hr />
<p><strong>Kvíz</strong> 🤔</p>
<ol>
<li>
<p>Co vypíše následující program, pokud na vstup zadáme <code>5</code>?</p>
<pre><code class="language-c editable mainbody">#include &lt;stdio.h&gt;

int main() {
    int a;
    scanf(&quot;%d&quot;, a);

    printf(&quot;Hodnota: %d\n&quot;, a);

    return 0;
}
</code></pre>
<details>
 <summary>Odpověď</summary>
<p>Tento program obsahuje <a href="c/text/../../ruzne/nedefinovane_chovani.html"><strong>nedefinované chování</strong></a> 💣. Funkce <code>scanf</code>
očekává pro každý zástupný znak ve svém formátovacím řetězci další argument, který musí obsahovat <strong>adresu</strong>,
do které se daná hodnota ze vstupu uloží. Zde místo adresy předáváme do <code>scanf</code> hodnotu číselné proměnné,
která navíc ani není inicializovaná, takže její předání do funkce je samo o sobě také nedefinovaným
chováním.</p>
</details>
</li>
<li>
<p>Co vypíše následující program, pokud na vstup zadáme <code>5</code>?</p>
<pre><code class="language-c editable mainbody">#include &lt;stdio.h&gt;

int main() {
    int* p;
    scanf(&quot;%d&quot;, p);

    printf(&quot;Hodnota: %d\n&quot;, p);

    return 0;
}
</code></pre>
<details>
 <summary>Odpověď</summary>
<p>Tento program obsahuje <a href="c/text/../../ruzne/nedefinovane_chovani.html"><strong>nedefinované chování</strong></a> 💣. Sice správně do
funkce <code>scanf</code> předává adresu celého čísla, ale tato adresa je neinicializovaná! Adresy předané funkci
<code>scanf</code> po formátovacím řetězci jsou výstupnímu argumenty, jinak řečeno do předaných adres budou zapsány
hodnoty načtené ze vstupu. Musíme tak do funkce předat validní adresu na kus paměti, kde je opravdu uloženo celé
číslo, což v tomto případě neplatí.</p>
</details>
</li>
<li>
<p>Co vypíše následující program, pokud na vstup zadáme <code>5</code>?</p>
<pre><code class="language-c editable mainbody">#include &lt;stdio.h&gt;

int main() {
    int a;
    scanf(&quot;%s&quot;, &amp;a);

    printf(&quot;Hodnota: %d\n&quot;, a);

    return 0;
}
</code></pre>
<details>
 <summary>Odpověď</summary>
<p>Tento program obsahuje <a href="c/text/../../ruzne/nedefinovane_chovani.html"><strong>nedefinované chování</strong></a> 💣. Sice správně do
funkce <code>scanf</code> předává adresu proměnné, ale špatného typu. Zástupný znak <code>%s</code> vyžaduje adresu (pole) znaků,
zatímco zde předáváme adresu celého čísla.</p>
</details>
</li>
<li>
<p>Co vypíše následující program, pokud na vstup zadáme <code>Martin\nNovak</code>?</p>
<pre><code class="language-c editable mainbody">#include &lt;stdio.h&gt;

int main() {
    char radek[100];
    fgets(radek, sizeof(radek), stdin);

    const char* jmeno = radek;

    fgets(radek, sizeof(radek), stdin);

    const char* prijmeni = radek;

    printf(&quot;%s&quot;, jmeno);
    printf(&quot;%s&quot;, prijmeni);

    return 0;
}
</code></pre>
<details>
 <summary>Odpověď</summary>
<p>Vypíše se tohle:</p>
<pre><code>Novak
Novak
</code></pre>
<p>Je důležité si uvědomit, co znamená <code>const char* jmeno = radek;</code>. <code>char*</code> je ukazatel, tedy číslo
obsahující adresu. Tímto řádkem pouze říkáme, že do ukazatele s názvem <code>jmeno</code> ukládáme adresu
pole znaků <code>radek</code>. Řádkem <code>const char* prijmeni = radek;</code> říkáme, že tuto adresu ukládáme do
proměnné s názvem <code>prijmeni</code>. Obě dvě proměnné (<code>jmeno</code> a <code>prijmeni</code>) tedy obsahují stejnou adresu.
No a jelikož si druhým voláním funkce <code>fgets</code> přepíšeme původní obsah pole <code>radek</code>, a obě proměnné
ukazují na pole <code>radek</code>, tak se vypíše dvakrát poslední načtený řádek.</p>
<p>Poznámka: ve formátovacím řetězci funkce <code>printf</code> jsme zde nepoužili znak odřádkování (<code>\n</code>),
protože funkce <code>fgets</code> jej uloží do pole <code>radek</code> a náš kód ho zde neodstranil. Takže pokud bychom
ho měli i v <code>printf</code>, tak by se vypsaly dva znaky odřádkování za sebou.</p>
</details>
</li>
</ol>
<h1><a class="header" href="#výstup" id="výstup">Výstup</a></h1>
<p>Stejně jako pro načítání vstupu, i pro výpis textu na výstup nabízí standardní knihovna <em>C</em> sadu
užitečných funkcí, opět umístěných v souboru <code>&lt;stdio.h&gt;</code>. Stejně jako u načítání <a href="c/text/vstup.html">vstupu</a>
bychom i u výstupu měli řešit <a href="c/text/vstupavystup.html#o%C5%A1et%C5%99en%C3%AD-chyb">ošetření chyb</a>. Nicméně, u zápisu to
(alespoň u malých programů) není až tak nezbytné, protože chyby zápisu jsou vzácnější než chyby při
vstupu. Zdrojem dat je totiž náš program, a nemusíme tedy tak striktně kontrolovat, jestli jsou
vypsaná data validní. Tato povinnost v jistém smyslu přechází na druhou stranu, s kterou náš program
komunikuje, protože ta bude námi vypsaná data číst.</p>
<h2><a class="header" href="#vypsání-znaku" id="vypsání-znaku">Vypsání znaku</a></h2>
<p>Pro vypsání jednoho znaku na standardní výstup (<code>stdout</code>) můžeme použít funkci
<a href="https://devdocs.io/c/io/putchar"><code>putchar</code></a>.</p>
<pre><code class="language-c editable mainbody">#include &lt;stdio.h&gt;

int main() {
    putchar('x');
    return 0;
}
</code></pre>
<h2><a class="header" href="#vypsání-řetězce" id="vypsání-řetězce">Vypsání řetězce</a></h2>
<p>Pro vypsání celého řetězce na <code>stdout</code> můžete použít funkci <a href="https://devdocs.io/c/io/puts"><code>puts</code></a>,
která zároveň za řetězcem vypíše znak odřádkování <code>\n</code>:</p>
<pre><code class="language-c editable mainbody">#include &lt;stdio.h&gt;

int main() {
    puts(&quot;Ahoj&quot;);
    puts(&quot;UPR&quot;);
    return 0;
}
</code></pre>
<p>Dávejte si pozor na to, že v předaném řetězci musí být obsažen ukončovací <code>NUL</code> znak! Funkce <code>puts</code>
se bude snažit číst a vypisovat znaky ze zadané adresy, až dokud na takovýto znak nenarazí. Pokud
by tento znak v předaném řetězci nebyl, tak se bude funkce pokoušet číst nevalidní paměť za koncem
řetězce, dokud na <code>NUL</code> nenarazí, což by vedlo k
<a href="c/text/../../caste_chyby/pametove_chyby.html">paměťové chybě</a> 💣.</p>
<h2><a class="header" href="#vypsání-formátovaného-textu" id="vypsání-formátovaného-textu">Vypsání formátovaného textu</a></h2>
<p>K výpisu formátovaného textu na <code>stdout</code> můžeme použít funkci <code>printf</code>, s kterou jsme se již
mnohokrát setkali. Prvním parametrem funkce je formátovací řetězec, do kterého můžete dávat
zástupné znaky začínající procentem (např. <code>%d</code> nebo <code>%s</code>). Pro každý takovýto zástupný znak funkce bude očekávat jednu
hodnotu (argument) za formátovacím řetězcem, která bude zformátována na výstup. Například takto můžeme vytisknout číslo
a po něm řetězec:</p>
<pre><code class="language-c">const char* text = &quot;Cislo&quot;;
int cislo = 5;
printf(&quot;Cislo %d, retezec %s: \n&quot;, cislo, text);
</code></pre>
<p>Jelikož jsme ve formátovacím řetězci předali dva zástupné znaky (<code>%d</code> - číslo a <code>%s</code> - řetězec), tak po řetězci musíme
do funkce <code>printf</code> předat jeden argument číselného typu, a poté jeden řetězec.</p>
<p>Zástupné znaky funkcí <code>printf</code> i <code>scanf</code> jsou obdobné, jejich seznam a různé možnosti nastavení
můžete najít v <a href="https://devdocs.io/c/io/fprintf">dokumentaci</a>. Nejčastěji budeme používat tyto zástupné znaky:</p>
<ul>
<li><code>%d</code> - výpis celého čísla se znaménkem, nejčastěji datový typ <code>int</code></li>
<li><code>%f</code> - výpis desetinného čísla, datový typ <code>float</code></li>
<li><code>%s</code> - výpis řetězce, datový typ <code>char*</code> (ukazatel na znak)
<ul>
<li>Na předané adrese musí ležet řetězec, tj. pole znaků <strong>ukončené znakem <code>'\0'</code></strong>!</li>
</ul>
</li>
</ul>
<blockquote>
<p>Stejně jako <code>scanf</code> má i funkce <code>printf</code> různé varianty pro formátovaný výpis do souborů
(<code>fprintf</code>) či do řetězce v paměti (<code>sprintf</code>).</p>
</blockquote>
<hr />
<p><strong>Kvíz</strong> 🤔</p>
<ol>
<li>
<p>Co vypíše následující program?</p>
<pre><code class="language-c editable mainbody">#include &lt;stdio.h&gt;

int main() {
    int a = 1;

    printf(&quot;Hodnota: %f&quot;, a);

    return 0;
}
</code></pre>
<details>
 <summary>Odpověď</summary>
<p>Tento program obsahuje <a href="c/text/../../ruzne/nedefinovane_chovani.html"><strong>nedefinované chování</strong></a> 💣. Říkáme funkci <code>printf</code>,
že chceme vypsat desetinné číslo (zástupný znak <code>%f</code>), ale jako argument předáváme výraz typu celé číslo (<code>int</code>).
Tento program tedy není validní.</p>
</details>
</li>
<li>
<p>Co vypíše následující program?</p>
<pre><code class="language-c editable mainbody">#include &lt;stdio.h&gt;

int main() {
    int a = 1;

    printf(&quot;Hodnota: %d (a=%d)&quot;, a);

    return 0;
}
</code></pre>
<details>
<summary>Odpověď</summary>
<p>Tento program obsahuje <a href="c/text/../../ruzne/nedefinovane_chovani.html"><strong>nedefinované chování</strong></a> 💣. Říkáme funkci <code>printf</code>, že
jí předáme dvě hodnoty (dva výrazy) typu celého čísla (zástupný znak <code>%d</code>), ale předáváme pouze jednu hodnotu (<code>a</code>).
Tento program tedy není validní.</p>
</details>
</li>
<li>
<p>Co vypíše následující program?</p>
<pre><code class="language-c editable mainbody">#include &lt;stdio.h&gt;

int main() {
    int a = 1;

    printf(&quot;Hodnota: %s&quot;, a);

    return 0;
}
</code></pre>
<details>
<summary>Odpověď</summary>
<p>Tento program obsahuje <a href="c/text/../../ruzne/nedefinovane_chovani.html"><strong>nedefinované chování</strong></a> 💣. Říkáme funkci <code>printf</code>, že
jí předáme hodnotu typu řetězec (zástupný znak <code>%s</code>), ale předáváme pouze hodnotu typu celé číslo (<code>int</code>). Tento
program tedy není validní.</p>
</details>
</li>
</ol>
<h1><a class="header" href="#vlastní-datové-typy" id="vlastní-datové-typy">Vlastní datové typy</a></h1>
<p>Nyní už umíme pracovat se základními datovými typy v <em>C</em>
(<a href="c/struktury/../datove_typy/celociselne_typy.html">celá čísla</a>, <a href="c/struktury/../datove_typy/desetinne_typy.html">desetinná čísla</a>,
<a href="c/struktury/../datove_typy/pravdivostni_typy.html">pravdivostní hodnoty</a>, <a href="c/struktury/../text/znaky.html">znaky</a>) a také
umíme pracovat s jejich <a href="c/struktury/../prace_s_pameti/ukazatele.html">adresami</a> a vytvářet jich
<a href="c/struktury/../pole/pole.html">více najednou</a>. Doposud jsme však vždy pracovali s každým datovým typem zvlášť.</p>
<p>Představte si, že byste chtěli naprogramovat hru, ve které budete mít nějaké počítačem ovládané
příšery<sup class='margin-toggle sidenote-number'>1</sup>. Každá příšera může mít spoustu vlastností – jméno, počet životů, zranění, které uděluje,
umístění na mapě, kořist atd. Zároveň bude takových příšer v naší hře určitě více. Mohli bychom tak
příšery reprezentovat pomocí pole pro každou jeho vlastnost:</p>
<span class='sidenote'><p><sup class='number'>1</sup><em>Non-player character</em> (NPC)</p>
</span>
<pre><code class="language-c">const char* prisera_jmeno[100];
int prisera_zivot[100];
int prisera_zraneni[100];
float prisera_poloha_x[100];
float prisera_poloha_y[100];
...
</code></pre>
<p>I když by jistě šlo programy tvořit tímto způsobem, asi sami uznáte, že to není ideální, protože to
má spoustu nevýhod:</p>
<ul>
<li>Pokud bychom například změnili (maximální) počet příšer, museli bychom synchronizovat tuto velikost
mezi všemi poli, která reprezentují jednotlivé vlastnosti příšer.</li>
<li>K názvům proměnných musíme přidávat nějakou předponu (např. <code>prisera</code>), abychom dali najevo, že
tyto proměnné vlastně patří k jednomu logickému prvku (příšeře).</li>
<li>Pokud bychom chtěli jednu takovou příšeru poslat do funkce, tak by to vyžadovalo spoustu parametrů:
<pre><code class="language-c">int vypocti_pocet_zkusenosti(
    const char* prisera_jmeno,
    int prisera_zivot,
    int prisera_zraneni,
    float prisera_poloha_x,
    float prisera_poloha_y,
    ...
) { }
</code></pre>
Celou příšeru bychom ani nemohli z funkce přímočaře vrátit, protože funkce mohou vracet pouze
jednu hodnotu.</li>
<li>Pokud bychom chtěli příšeře přidat novou vlastnost, museli bychom přidat novou proměnnou nebo pole
na všechna místa, kde s příšerami pracujeme. Například by se musely změnit parametry každé funkce,
která by přijímala příšeru.</li>
</ul>
<p>Co bychom ve skutečnosti chtěli překladači říct, je něco ve smyslu <code>Příšera je něco, co má jméno, počet životů, zranění, pozici a kořist</code>, a poté bychom chtěli ve funkci například říct <code>Vytvoř pole 100 příšer</code>:</p>
<pre><code class="language-c">Prisera prisery[100];
</code></pre>
<p>Takto bychom zlepšili úroveň abstrakce našeho kódu – v tomto konkrétním případě bychom se mohli začít
v kódu bavit o <code>příšeře</code> místo pouze o sadě atributů <code>jméno, počet životů, zranění, …</code>.</p>
<p>Jinak řečeno, chtěli bychom si vytvořit náš vlastní datový typ. A právě to můžeme v <em>C</em> udělat pomocí
<a href="c/struktury/struktury.html">struktur</a>.</p>
<blockquote>
<p>Struktury jsou posledním syntaktickým prvkem <em>C</em>, o kterém se budeme v předmětu UPR bavit. Jazyk
<em>C</em> sice obsahuje i několik dalších <a href="c/struktury/../co_dal.html">syntaktických prvků</a>, které jsme si neukázali,
ty však nejsou nutné pro tvorbu jednoduchých programů. Dále se už pouze budeme bavit o konkrétních
aplikacích toho, co jsme se naučili, pro tvorbu různých typů programů.</p>
</blockquote>
<h1><a class="header" href="#struktury" id="struktury">Struktury</a></h1>
<p><strong>Struktury</strong> (<em>structures</em>) nám umožňují popsat nový datový typ, který se bude skládat z
jednoho či více tzv. <strong>členů</strong> (<em>members</em>)<sup class='margin-toggle sidenote-number'>1</sup>. Každému členu musíme určit jeho jméno a datový typ.
Novou strukturu můžeme popsat pomocí tzv. <em>deklarace struktury</em>:</p>
<span class='sidenote'><p><sup class='number'>1</sup>Můžete se setkat také s názvy <strong>atribut</strong> (<em>attribute</em>), <strong>vlastnost</strong> (<em>property</em>) nebo
<em>field</em>. V kontextu struktur <em>C</em> označují všechny tyto názvy jedno a to samé - člena struktury.</p>
</span>
<pre><code class="language-c">struct &lt;název struktury&gt; {
    &lt;datový typ prvního členu&gt; &lt;název prvního členu&gt;;
    &lt;datový typ druhého členu&gt; &lt;název druhého členu&gt;;
    &lt;datový typ třetího členu&gt; &lt;název třetího členu&gt;;
    ...
};
</code></pre>
<blockquote>
<p>Při deklaraci struktury nezapomínejte na finální středník za složenými závorkami, je povinný.</p>
</blockquote>
<p>Například, pokud bychom chtěli vytvořit datový typ reprezentující <code>příšeru</code>, která má své jméno
a počet životů, můžeme deklarovat následující strukturu:</p>
<pre><code class="language-c">struct Prisera {
    const char* jmeno;
    int pocet_zivotu;
};
</code></pre>
<p>Tento kód sám o sobě <strong>nic neprovádí</strong>! Pouze pomocí něj říkáme překladači, že vytváříme nový datový
typ s názvem <code>struct Prisera</code>. Poté nám překladač umožní dále v programu vytvořit například lokální
proměnnou tohoto datového typu:</p>
<pre><code class="language-c">// lokální proměnná s názvem `karel` a datovým typem `struct Prisera`
struct Prisera karel;
</code></pre>
<p>Pro pojmenovávání struktur používejte v rámci předmětu UPR jmennou konvenci
<a href="c/struktury/../promenne/pojmenovavani.html#v%C3%ADceslovn%C3%A9-n%C3%A1zvy"><code>PascalCase</code></a>.</p>
<blockquote>
<p>Struktury jsou plnohodnotnými datovými typy. Můžete tak vytvářet ukazatele na struktury, pole
struktur, můžete použít struktury jako <a href="c/struktury/struktury.html#pou%C5%BEit%C3%AD-struktur-ve-struktur%C3%A1ch">členy jiné struktury</a>
atd.</p>
</blockquote>
<h2><a class="header" href="#reprezentace-struktury-v-paměti" id="reprezentace-struktury-v-paměti">Reprezentace struktury v paměti</a></h2>
<p>Pokud vytvoříme proměnnou datového typu struktury, tak překladač naalokuje paměť pro všechny
členy této struktury. V případě výše by proměnná <code>karel</code> obsahovala nejprve byty pro ukazatel
<code>const char*</code> a poté byty pro <code>int</code>. Členové struktury budou v paměti uloženi ve stejném pořadí,
v jakém byli popsáni při deklaraci struktury. Neznamená to ovšem, že musí ležet hned za sebou!
Překladač se může rozhodnout mezi členy struktury v paměti vložit mezery (tzv. <em>padding</em>) kvůli
urychlení provádění programu. Více detailů se můžete dozvědět v podkapitole
<a href="c/struktury/pametova_reprezentace.html">Reprezentace struktur v paměti</a>.</p>
<p>Prozatím si zapamatujte, že pro zjištění velikosti struktury v bytech (například při dynamické
alokaci paměti) vždy používejte operátor
<a href="c/struktury/../prace_s_pameti/dynamicka_pamet.html#velikost-alokovan%C3%A9-pam%C4%9Bti"><code>sizeof</code></a> a nesnažte se velikost
&quot;tipovat&quot; ručně.</p>
<h3><a class="header" href="#umístění-a-platnost-struktur" id="umístění-a-platnost-struktur">Umístění a platnost struktur</a></h3>
<p>Stejně jako u <a href="c/struktury/../promenne/promenne.html#platnost">proměnných</a> platí, že strukturu lze
používat pouze v oblasti, ve které je platná (v jejím tzv. <em>scopu</em>). Narozdíl od
<a href="c/struktury/../funkce/funkce.html#um%C3%ADst%C4%9Bn%C3%AD-funkc%C3%AD">funkcí</a> lze struktury deklarovat i uvnitř funkcí, nicméně
nejčastěji se struktury deklarují na nejvyšší úrovni souboru (tzv. <em>global scope</em>), stejně jako
funkce.</p>
<h2><a class="header" href="#inicializace-struktury" id="inicializace-struktury">Inicializace struktury</a></h2>
<p>Stejně jako u <a href="c/struktury/../promenne/promenne.html#v%C5%BEdy-inicializujte-prom%C4%9Bnn%C3%A9">základních datových typů</a> a
<a href="c/struktury/../pole/staticka_pole.html#inicializace-pole">polí</a> platí, že pokud lokální proměnné s datovým typem
nějaké struktury nedáte počáteční hodnotu, tak bude její hodnota nedefinovaná 💣. Strukturu můžete
nainicializovat pomocí složených závorek se seznamem hodnot pro jednotlivé členy struktury:</p>
<pre><code class="language-c">struct Prisera karel = { &quot;Karel&quot;, 100 };
</code></pre>
<p>Stejně jako u polí platí, že hodnoty, které nezadáte, se nainicializují na nulu:</p>
<pre><code class="language-c">struct Prisera karel = {}; // `jmeno` i `pocet_zivotu` bude `0`
struct Prisera karel = { &quot;Karel&quot; }; // `jmeno` bude &quot;Karel&quot;, `pocet_zivotu` bude `0`
</code></pre>
<p>Abyste si nemuseli pamatovat pořadí členů struktury při její inicializaci, můžete jednotlivé členy
nainicializovat explicitně pomocí tečky a názvu daného členu:</p>
<pre><code class="language-c">struct Prisera karel = { .pocet_zivotu = 100, .jmeno = &quot;Karel&quot; };
</code></pre>
<p>Jednotlivé hodnoty členům se přiřazují zleva doprava, takže pokud použijete název nějakého členu
více než jednou, &quot;zvítězí&quot; poslední zadaná hodnota. Tomuto se však vyhněte, a ani nekombinujte
inicializaci pomocí pořadí a pomocí názvů členů. Takovýto kód by totiž byl značně nepřehledný.</p>
<h2><a class="header" href="#přístup-ke-členům-struktur" id="přístup-ke-členům-struktur">Přístup ke členům struktur</a></h2>
<p>Abychom mohli číst a zapisovat jednotlivé členy struktur, můžeme použít operátor
<strong>přístupu ke členu</strong> (<em>member access operator</em>), který má syntaxi <code>&lt;výraz typu struktura&gt;.&lt;název členu&gt;</code>:</p>
<pre><code class="language-c editable">#include &lt;stdio.h&gt;

struct Osoba {
    int vek;
    int pocet_pratel;
};

int main() {
    struct Osoba martina = { .vek = 18, .pocet_pratel = 10 };
    martina.vek += 1;           // přístup k členu `vek`
    martina.pocet_pratel += 20; // přístup k členu `pocet_pratel`
    printf(&quot;Martina ma %d let a ma %d pratel\n&quot;, martina.vek, martina.pocet_pratel);

    return 0;
}
</code></pre>
<p>Pokud máme k dispozici pouze ukazatel na strukturu, tak je přístup k jejím členům trochu nepraktický
kvůli <a href="https://en.cppreference.com/w/c/language/operator_precedence">prioritě operátorů</a>. Operátor
dereference (<code>*</code>) má totiž menší prioritu než operátor přístupu ke členu (<code>.</code>). Abychom tak nejprve
z ukazatele na strukturu načetli její hodnotu a až poté přistoupili k jejímu členu, museli bychom
použít závorky:</p>
<pre><code class="language-c">void pridej_pratele(struct Osoba* osoba) {
    (*osoba).pocet_pratel++;
}
</code></pre>
<p>Jelikož ukazatele na struktury jsou využívány velmi často, <em>C</em> nabízí pro tuto situaci zkratku v
podobě operátoru <strong>přístupu k členu přes ukazatel</strong> (<em>member access through pointer</em>), který má
syntaxi <code>&lt;ukazatel na strukturu&gt;-&gt;&lt;název členu&gt;</code>:</p>
<pre><code class="language-c">void pridej_pratele(struct Osoba* osoba) {
   osoba-&gt;pocet_pratel++;
}
</code></pre>
<p>Operátor <code>-&gt;</code> je čistě syntaktickou zkratkou, tj. platí <code>*(ukazatel).clen == ukazatel-&gt;clen</code>.</p>
<h2><a class="header" href="#vytváření-nových-jmen-pro-datové-typy" id="vytváření-nových-jmen-pro-datové-typy">Vytváření nových jmen pro datové typy</a></h2>
<p>Možná vás napadlo, že psát při každém použití struktury klíčové slovo <code>struct</code> před jejím názvem je
zdlouhavé. <em>C</em> umožňuje dávat datovým typům nové názvy, aby se nám s nimi lépe pracovalo. Lze toho
dosáhnout pomocí syntaxe <code>typedef &lt;datový typ&gt; &lt;jméno&gt;;</code>:</p>
<pre><code class="language-c">typedef int teplota;

int main() {
    teplota venkovni = 24;
    return 0;
}
</code></pre>
<p>Pomocí <code>typedef</code> vytvoříme nové jméno pro datový typ, pomocí kterého se pak na tento typ můžeme
odkazovat (původní název datového typu to však nijak neovlivní a můžeme ho stále používat). Opět
platí, že takto vytvořené jméno lze použít pouze v oblasti (<em>scopu</em>), kde byl <code>typedef</code> použit.
Obvykle se používá na nejvyšší úrovni souboru. </p>
<p>U struktur si pomocí <code>typedef</code> můžeme zkrátit jejich název, typicky ze <code>struct &lt;nazev&gt;</code> na <code>&lt;nazev&gt;</code>:</p>
<pre><code class="language-c">struct Osoba {
    int vek;
};

typedef struct Osoba Osoba;

int main() {
    Osoba jiri;
    return 0;
}
</code></pre>
<p>Toto lze ještě více zkrátit, pokud deklaraci struktury použijeme přímo na místě datového typu v
<code>typedef</code>:</p>
<pre><code class="language-c">typedef struct Osoba {
    int vek;
} Osoba;
</code></pre>
<p>A konečně, abychom nemuseli jméno struktury opakovat dvakrát, můžeme vytvořit tzv. <strong>anonymní
strukturu</strong> (<em>anonymous structure</em>) bez názvu, a jméno jí přiřadit až pomocí <code>typedef</code>.</p>
<pre><code class="language-c">typedef struct {
    int vek;
} Osoba;
</code></pre>
<p>Právě takto se obvykle deklarují struktury v <em>C</em>.</p>
<h2><a class="header" href="#použití-struktur-ve-strukturách" id="použití-struktur-ve-strukturách">Použití struktur ve strukturách</a></h2>
<p>Jelikož deklarace struktury vytvoří nový datový typ, nic vám nebrání v tom používat struktury jako
členy jiných struktur<sup class='margin-toggle sidenote-number'>3</sup>:</p>
<span class='sidenote'><p><sup class='number'>3</sup>Lze si můžete všimnout, že vnořené struktury lze inicializovat stejně jako proměnné struktur,
tj. pomocí složených závorek <code>{}</code>.</p>
</span>
<pre><code class="language-c">typedef struct {
    float x;
    float y;
} Poloha;

typedef struct {
    const char* jmeno;
    int cena;
} Vec;

typedef struct {
    int pocet_zivotu;
    Poloha poloha;
    Vec korist[10];
} Prisera;

int main() {
    Prisera prisera = { .pocet_zivotu = 100, .poloha = { .x = 0, .y = 0 } };

    return 0;
}
</code></pre>
<p>Díky tomu můžeme vytvářet celé hierarchie datových typů, což může značně zpřehlednit náš program,
protože můžeme pracovat s kódem na vyšší úrovni abstrakce.</p>
<h3><a class="header" href="#rekurzivní-struktury" id="rekurzivní-struktury">Rekurzivní struktury</a></h3>
<p>Pokud bychom chtěli použít jako člena struktury tu stejnou strukturu (například struktura
<code>Osoba</code> může mít člen <code>matka</code> opět s datovým typem <code>Osoba</code>), nemůžeme takovýto člen uložit ve
struktuře přímo, můžeme tam uložit pouze jeho adresu<sup class='margin-toggle sidenote-number'>4</sup>:</p>
<span class='sidenote'><p><sup class='number'>4</sup>Zde si můžete všimnout, že musíme použít <code>struct Osoba</code> pro datový typ členu <code>matka</code>. Je to z
toho důvodu, že v momentě, kdy tento člen definujeme, tak ještě není platný <code>typedef</code>, ve kterém se
struktura nachází, takže datový typ <code>Osoba</code> zatím neexistuje. Nové jméno pro datový typ lze používat
až za středníkem daného <code>typedef</code>u. V tomto případě také nemůžeme vytvořit strukturu jako anonymní,
ale musíme ji rovnou pojmenovat (<code>typedef struct Osoba ...</code>).</p>
</span>
<pre><code class="language-c">typedef struct Osoba {
    int vek;
    struct Osoba* matka;
} Osoba;
</code></pre>
<p>Je to proto, že pokud by <code>Osoba</code> byla definována pomocí <code>Osoby</code>, tak by došlo k rekurzivní definici,
kterou nelze vyřešit. Nešlo by totiž určit velikost <code>Osoby</code> - její velikost by závisela na velikosti
jejího členu <code>matka</code>, jehož velikost by závisela na velikosti jeho členu <code>matka</code> atd. Proto tedy musíme
v tomto případě použít ukazatel, který má fixní velikost, ať už ukazuje na jakýkoliv typ.</p>
<h1><a class="header" href="#paměťová-reprezentace-struktur" id="paměťová-reprezentace-struktur">Paměťová reprezentace struktur</a></h1>
<blockquote>
<p>🤓 Tato sekce obsahuje doplňující učivo. Pokud je toho na vás moc, můžete ji prozatím přeskočit
a vrátit se k ní později.</p>
</blockquote>
<p>V této kapitole si popíšeme, jak se překladač rozhoduje o tom, kolik bytů budou v paměti zabírat
proměnné struktur, které vytváříme v našich programech.</p>
<p>Když vytvoříme proměnnou struktury v paměti, tak bychom si intuitivně mohli myslet, že překladač
jednotlivé členy struktury &quot;vysází&quot; v paměti jeden za druhým. Nicméně není tomu tak vždy. Z důvodu
dodržení tzv. <strong>zarovnání</strong> (<em>alignment</em>) jednotlivých datových typů členů struktury se totiž
překladač může rozhodnout mezi tyto členy vložit nějaké byty navíc.</p>
<h2><a class="header" href="#zarovnání" id="zarovnání">Zarovnání</a></h2>
<p>Každý datový typ v jazyce <em>C</em> má kromě své velikosti (počet bytů, které zabírá v paměti) také tzv.
<strong>zarovnání</strong>. Jedná se o číslo, které říká, na jakých adresách v paměti by ideálně měly být umístěny
hodnoty tohoto datového typu. Zarovnání <code>n</code> říká, že daný datový typ může ležet na adresách, které
jsou dělitelné číslem <code>n</code>. Takže např. datový typ se zarovnáním <code>4</code> může ležet na adresách <code>4</code>, <code>8</code>,
<code>12</code>, <code>200</code> nebo <code>512</code>, neměl by však ležet např. na adresách <code>1</code>, <code>3</code> nebo <code>134</code>, protože ty nejsou
dělitelné čtyřkou. Mohli bychom říct, že pro zarovnání <code>4</code> jsou adresy <code>4</code> nebo <code>8</code> <strong>zarovnané</strong>
(<em>aligned</em>), zatímco adresy <code>3</code> nebo <code>134</code> jsou <strong>nezarovnané</strong> (<em>unaligned</em>).</p>
<p>Zarovnání existuje z toho důvodu, že některé typy procesorů jsou navrženy tak, že jednoduše
nezvládnou načítat hodnoty z adres, které nesplňují zarovnání daného datového typu. Některé jiné
procesory to zase sice zvládnou, ale mnohem méně efektivněji, než kdybychom načítali hodnoty ze
zarovnaných adres.</p>
<p>Pokud to v našem programu neupravíme, tak primitivní datové typy mají zarovnání stejné, jako je
jejich velikost, a struktury mají zarovnání nastavené na nejvyšší zarovnání ze všech datových členů
typů dané struktury.</p>
<p>Zde jsou ukázky zarovnání pro několik základních datových typů:</p>
<ul>
<li><code>char</code>: zarovnání <code>1</code></li>
<li><code>int</code>: zarovnání je stejné velikost (tedy typicky <code>4</code>)</li>
<li><code>float</code>: zarovnání <code>4</code></li>
<li><code>char*</code>: zarovnání je stejné velikost (tedy typicky <code>8</code>)</li>
</ul>
<h2><a class="header" href="#struktury-a-zarovnání" id="struktury-a-zarovnání">Struktury a zarovnání</a></h2>
<p>Zarovnání jednotlivých datových typů ovlivňuje to, jak překladač rozmístí jednotlivé členy struktur
v paměti. Bude se totiž snažit o to, aby každý člen struktury ležel na adrese, která bude zarovnaná
vzhledem k datovému typu daného členu. Vezměme si například následující strukturu:</p>
<blockquote>
<p>Poznámka: ve všech případech níže budeme předpokládat, že <code>short</code> zabírá <code>2</code> byty,
<code>int</code> zabírá <code>4</code> byty, a ukazatel zabírá <code>8</code> bytů.</p>
</blockquote>
<pre><code class="language-c">typedef struct {
    char a;
    int b;
} Str1;
</code></pre>
<p>Jelikož <code>char</code> zabírá <code>1</code> byte a <code>int</code> zabírá <code>4</code> byty, mohli bychom si myslet, že <code>sizeof(Str1)</code>
bude <code>5</code>. Nicméně překladač musí zajistit, že člen <code>b</code> bude ležet na adrese, která bude zarovnaná
na <code>4</code> byty, protože zarovnání datového typu <code>int</code> je <code>4</code>. Dejme tomu, že by proměnná typu <code>Str1</code>
ležela třeba na adrese <code>16</code>, tj. i člen <code>a</code> by ležel na adrese <code>16</code>. Pokud by překladač umístil člen
<code>b</code> na adresu <code>17</code>, tak by tento člen ležel na nezarovnané adrese<sup class='margin-toggle sidenote-number'>1</sup>:</p>
<span class='sidenote'><p><sup class='number'>1</sup>Každá čtvercová buňka reprezentuje jeden byte. V pravém horním rohu buňky je znázorněna adresa buňky. Šedé buňky označují byty <em>paddingu</em>. Čerchované buňky obsahují nezarovnaná data.</p>
</span>
<p><img src="c/struktury/../../static/img/padding/padding1-packed.png" alt="str1-packed" /></p>
<p>Z tohoto důvodu překladač vloží za <code>a</code> tři byty tzv. <strong>výplně</strong> (<em>padding</em>). Tyto byty nebudou k
ničemu využívány, budou sloužit pouze k tomu, aby byl člen <code>b</code> správně zarovnaný. Struktura tedy bude
v paměti uložena takto, její velikost bude <code>8</code> bytů a její zarovnání budou <code>4</code> byty:</p>
<p><img src="c/struktury/../../static/img/padding/padding1-unpacked.png" alt="str1-unpacked" /></p>
<p>Překladač ovšem nevkládá výplň pouze mezi jednotlivé členy struktur. Někdy musí vložit výplň i na
samotný konec struktury. Podívejme se na následující strukturu <code>Str2</code>:</p>
<pre><code class="language-c">typedef struct {
    int b;
    char a;
} Str2;
</code></pre>
<p>Mohlo by se zdát, že zde být výplň být nemusí, protože <code>int</code> může ležet &quot;na začátku&quot; struktury,
a <code>char</code> má zarovnání <code>1</code>, takže může ležet kdekoliv. Co by se ovšem stalo, kdybychom tyto struktury
uložili za sebe do paměti v poli?</p>
<p><img src="c/struktury/../../static/img/padding/padding2-packed.png" alt="str2-packed" /></p>
<p>První struktura v poli by byla zarovnaná správně, ale druhá (případně ty další) už ne! Z toho důvodu
musí překladač zajistit, že budou správně zarovnaní nejenom všichni členové struktury, ale i struktura
samotná. Zarovnání struktury se rovná nejvyššímu zarovnání ze všech členů struktury, v tomto případě
to bude <code>4</code>. Překladač tak musí zajistit, aby všechny struktury <code>Str2</code> (i když budou ležet v poli za
sebou) ležely na adresách, které budou násobky <code>4</code>. Z tohoto důvodu zde překladač vloží <code>3</code> byty výplně
i na konec struktury, aby byly proměnné této struktury správně zarovnané:</p>
<p><img src="c/struktury/../../static/img/padding/padding2-unpacked.png" alt="str2-unpacked" /></p>
<h2><a class="header" href="#minimalizace-velikosti-struktury" id="minimalizace-velikosti-struktury">Minimalizace velikosti struktury</a></h2>
<p>Obecně bychom se měli snažit velikosti struktur minimalizovat, abychom v našich programech neplýtvali
pamětí. Existují různé <a href="https://stackoverflow.com/a/8568441/1107768">atributy</a>, kterými můžeme např.
překladači říct, aby zarovnání ignoroval, to ovšem nemusí být dobrý nápad, protože poté náš program
na určitých procesorech nemusí vůbec fungovat.</p>
<p>Univerzálnějším a bezpečnějším řešením je seřadit členy struktury tak, abychom minimalizovali
výplň. Obecná poučka zní řadit členy podle jejich velikosti, od největšího po nejmenší. Porovnejte
například následující dvě struktury:</p>
<ul>
<li>
<p>Neseřazené členy, velikost <code>24</code> bytů, <code>10</code> bytů výplně:</p>
<pre><code class="language-c">typedef struct {
    char a;
    int b;
    char c;
    const char* d;
} Str3;
</code></pre>
<p><img src="c/struktury/../../static/img/padding/padding3.png" alt="str3" /></p>
</li>
<li>
<p>Seřazené členy, velikost <code>16</code> bytů, <code>2</code> byty výplně:</p>
<pre><code class="language-c">typedef struct {
    const char* a;
    int b;
    char c;
    char d;
} Str4;
</code></pre>
<p><img src="c/struktury/../../static/img/padding/padding4.png" alt="str4" /></p>
</li>
</ul>
<h2><a class="header" href="#kvíz-" id="kvíz-">Kvíz 🤔</a></h2>
<p>Zde je několik ukázek struktur, na kterých si můžete otestovat své znalosti zarovnání a výplně.</p>
<ul>
<li>
<p><code>S1</code></p>
<pre><code class="language-c">typedef struct {
    int a;
    const char* b;
} S1;
</code></pre>
<details>
  <summary>Velikost a zarovnání</summary>
<p>Velikost <code>16</code> bytů, zarovnání <code>8</code> bytů, výplň <code>4</code> byty.</p>
<p><img src="c/struktury/../../static/img/padding/padding5.png" alt="str5" /></p>
</details>
</li>
<li>
<p><code>S2</code></p>
<pre><code class="language-c">typedef struct {
    char a[4];
    char b;
} S2;
</code></pre>
<details>
  <summary>Velikost a zarovnání</summary>
<p>Velikost <code>5</code> bytů, zarovnání <code>1</code> byte, výplň <code>0</code> bytů. Člen <code>a</code> má sice také <code>4</code> byty, jako <code>int</code>,
nicméně jelikož je zarovnání datového typu <code>char</code> pouze <code>1</code>, tak i zarovnání tohoto pole je <code>1</code>.
A jelikož člen <code>b</code> může taktéž ležet na libovolné adrese, tak zde není přidána žádná výplň. </p>
<p><img src="c/struktury/../../static/img/padding/padding6.png" alt="str6" /></p>
</details>
</li>
<li>
<p><code>S3</code></p>
<pre><code class="language-c">typedef struct {
    short a;
    char b;
    char c;
    int d;
} S3;
</code></pre>
<details>
  <summary>Velikost a zarovnání</summary>
<p>Velikost <code>8</code> bytů, zarovnání <code>4</code> byty, výplň <code>0</code> bytů.</p>
<p><img src="c/struktury/../../static/img/padding/padding7.png" alt="str7" /></p>
</details>
</li>
</ul>
<h1><a class="header" href="#struktury-a-funkce" id="struktury-a-funkce">Struktury a funkce</a></h1>
<p>Pomocí struktur si můžeme vytvořit nový datový typ, což pomáhá přehlednosti programů, protože se
díky tomu můžeme v programech vyjadřovat pomocí pojmů z oblasti (tzv. domény), kterou se náš program
zabývá (<code>Student</code>, <code>Příšera</code>, <code>Munice</code>, <code>Letadlo</code>, <code>Volant</code> atd.) a ne pouze pomocí pojmů, kterým
rozumí počítač (číslo, znak, pravdivostní hodnota).</p>
<p>Abychom pracovali s ještě vyšší úrovní abstrakce, bylo by užitečné, pokud bychom mohli k
vlastním datovým typům nadefinovat také vlastní operace, které by s nimi uměly pracovat. Některé
programovací jazyky umožňují provádět tzv.
<a href="https://en.wikipedia.org/wiki/Operator_overloading">přetěžování operátorů</a> (<em>operator overloading</em>),
pomocí kterého můžeme například umožnit používání operátorů jako je <code>+</code> s vlastními datovými typy.
<em>C</em> toto sice neumožňuje, nicméně chování můžeme k námi vytvořeným strukturám přidat pomocí funkcí.</p>
<p>Často tak k naší struktuře chceme vytvořit sadu funkcí, které s ní budou pracovat. V <em>C</em> pro tento
koncept neexistuje žádná syntaktická podpora. Obvykle se tak prostě takovéto funkce pojmenují tak,
aby začínaly názvem struktury, ke které jsou přidružené, a přebírají ukazatel na tuto strukturu jako
svůj první parametr<sup class='margin-toggle sidenote-number'>1</sup>:</p>
<span class='sidenote'><p><sup class='number'>1</sup>Ukazatel se používá, abychom nemuseli struktury při předávání do funkcí kopírovat (mohou být
relativně velké) a abychom je mohli případně zevnitř funkcí modifikovat.</p>
</span>
<pre><code class="language-c editable">#include &lt;stdbool.h&gt;
#include &lt;stdio.h&gt;

typedef struct {
    float x;
    float y;
} Poloha;

typedef struct {
    const char* jmeno;
    int skore;
    Poloha poloha;
} Hrac;

void hrac_posun(Hrac* hrac, int x, int y) {
    hrac-&gt;poloha.x += x;
    hrac-&gt;poloha.y += y;
}
void hrac_pridej_skore(Hrac* hrac, int skore) {
    hrac-&gt;skore += skore;
    if (hrac-&gt;skore &gt; 100) {
        hrac-&gt;skore = 100;
    }
}
bool hrac_vyhral(Hrac* hrac) {
    return hrac-&gt;skore == 100;
}

int main() {
    Hrac hrac = { .jmeno = &quot;Jindrich&quot;, .skore = 40, .poloha = { .x = 10, .y = 20 } };
    hrac_posun(&amp;hrac, 5, -8);
    hrac_pridej_skore(&amp;hrac, 70);

    printf(&quot;Hrac vyhral: %d\n&quot;, hrac_vyhral(&amp;hrac));

    return 0;
}
</code></pre>
<p>Pokud vytvoříme vhodné datové typy (struktury) a budeme s nimi pracovat pomocí funkcí, tak by se naše
programy měly přibližovat k tomu, aby je šlo číst jako plynulý a přehledný text. </p>
<blockquote>
<p>Vytváření vlastních datových typů, které mají přidružené chování, je jedním z rysů tzv.
<a href="https://edison.sso.vsb.cz/cz.vsb.edison.edu.study.prepare.web/SubjectVersion.faces?version=460-2055/01&amp;subjectBlockAssignmentId=375759&amp;studyFormId=2&amp;studyPlanId=22001&amp;locale=cs&amp;back=true">Objektově orientovaného programování</a>.</p>
</blockquote>
<h2><a class="header" href="#struktury-jako-návratový-typ-funkce" id="struktury-jako-návratový-typ-funkce">Struktury jako návratový typ funkce</a></h2>
<p>Jelikož struktury mohou obsahovat více datových typů, můžete pomocí nich také obejít fakt, že
funkce mohou vracet pouze jednu hodnotu:</p>
<pre><code class="language-c">typedef struct {
    float x;
    float y;
} Poloha;

Poloha vrat_pocatecni_polohu() { ... }
</code></pre>
<hr />
<p><strong>Cvičení</strong> 🏋</p>
<p>Vyzkoušejte si práci se strukturami a funkcemi <a href="c/struktury/../../ulohy/struktury.html">zde</a>.</p>
<hr />
<p><strong>Kvíz</strong> 🤔</p>
<ol>
<li>
<p>Co vypíše následující program?</p>
<pre><code class="language-c editable mainbody">#include &lt;stdio.h&gt;

typedef struct {
    int vek;
} Osoba;

void oslav_narozeniny(Osoba osoba) {
    osoba.vek += 1;
}

int main() {
    Osoba milan = { .vek = 17 };
    oslav_narozeniny(milan);
    printf(&quot;Vek Milana: %d\n&quot;, milan.vek);

    return 0;
}
</code></pre>
<details>
 <summary>Odpověď</summary>
<p>Program vypíše <code>Vek Milana: 17</code>. Stejně jako u ostatních datových typů, tak i u struktur platí,
že při předávání hodnot struktur do funkcí dojde ke kopii předávané hodnoty. Když tedy změníme
hodnotu členu <code>vek</code> uvntř funkce <code>oslav_narozeniny</code>, nijak se to neprojeví v proměnné <code>milan</code>
ve funkci <code>main</code>. Abychom strukturu mohli upravit, museli bychom do funkce předat její adresu
a změnit typ parametru na <code>Osoba* osoba</code>.</p>
</details>
</li>
<li>
<p>Co vypíše následující program?</p>
<pre><code class="language-c editable mainbody">#include &lt;stdio.h&gt;

typedef struct {
    char* jmeno;
} Osoba;

void uprav_jmeno(Osoba osoba) {
    osoba.jmeno[0] = 'k';
}

int main() {
    char jmeno[] = &quot;Karel&quot;;

    Osoba karel = { .jmeno = jmeno };
    uprav_jmeno(karel);
    printf(&quot;Jmeno Karla: %s\n&quot;, karel.jmeno);

    return 0;
}
</code></pre>
<details>
 <summary>Odpověď</summary>
<p>Program vypíše <code>Jmeno Karla: karel</code>. Do funkce <code>uprav_jmeno</code> se sice předá struktura pomocí kopie,
nicméně uvnitř funkce přistoupíme na adresu uloženou v členu <code>jmeno</code> a změníme hodnotu v paměti
na této adrese. Jelikož na této adrese leží pole <code>jmeno</code> uvnitř funkce <code>main</code>, a proměnná <code>karel</code>
obsahuje ukazatel na tu stejnou adresu v paměti, tak se tato změna projeví při výpisu jména proměnné
<code>karel</code>.</p>
</details>
</li>
</ol>
<h1><a class="header" href="#soubory" id="soubory">Soubory</a></h1>
<p>V sekci o <a href="c/soubory/../text/vstupavystup.html">vstupu a výstupu</a> jsme si ukázali, jak pracovat se souborovými
deskriptory <code>stdin</code> a <code>stdout</code> pro základní komunikaci s okolním světem (obvykle s terminálem).
Nyní si ukážeme, jak si vytvořit vlastní souborové deskriptory pomocí otevírání souborů na disku.
Použijeme k tomu funkce ze standardní knihovny <em>C</em>, které se opět nachází v souboru <code>&lt;stdio.h&gt;</code>.</p>
<p>Stejně jako u obecného vstupu a výstupu platí, že soubor na disku je pouze seznamem čísel (bytů).
Jejich význam je dán čistě tím, jak je budeme interpretovat. Stejný soubor může být například:</p>
<ul>
<li>Textovým editorem pokládán za textový dokument</li>
<li>Prohlížečem obrázků pokládán za obrázek</li>
<li>Hudebním přehrávačem pokládan za zvukovou nahrávku</li>
</ul>
<p>Obvykle souborům dáváme přípony (<code>.txt</code>, <code>.jpg</code>, <code>.mp3</code> atd.), abychom dali najevo, jak by se
daný soubor měl interpretovat. Samotná přípona však sama o sobě nic neznamená. Změnou přípony z
<code>.txt</code> na <code>.jpg</code> sice můžeme změnit způsob interpretace souboru, samotná data v něm však zůstanou
stále stejná – pokud v souboru předtím nebyla data ve formátu <a href="https://en.wikipedia.org/wiki/JPEG">JPEG</a>,
změna přípony tento stav nijak nezmění a soubor se nám tak nejspíše jako obrázek nepodaří otevřít.</p>
<p>Nejprve si ukážeme, jak můžeme <a href="c/soubory/otevirani_souboru.html">otevírat</a> soubory na disku, a poté jak do
otevřených souborů <a href="c/soubory/prace_se_soubory.html">zapisovat nebo z nich číst</a> data.</p>
<h1><a class="header" href="#otevírání-souborů" id="otevírání-souborů">Otevírání souborů</a></h1>
<p>Abychom mohli s nějakým souborem začít pracovat, musíme ho nejprve v našem programu otevřít, aby
byl vytvořen souborový deskriptor, do kterého pak můžeme zapisovat či z něj číst data. K tomu slouží
funkce <a href="https://devdocs.io/c/io/fopen"><code>fopen</code></a>, která má následující
<a href="c/soubory/../funkce/funkce.html#syntaxe">signaturu</a>:</p>
<pre><code class="language-c">FILE* fopen(const char* filename, const char* mode);
</code></pre>
<h2><a class="header" href="#cesta-k-souboru" id="cesta-k-souboru">Cesta k souboru</a></h2>
<p>Jako svůj první parametr funkce <code>fopen</code> očekává řetězec s cestou k souboru, který má být otevřen.
Cestu můžete zadat dvěma způsoby:</p>
<ul>
<li><strong>Absolutní cesta</strong> (<em>absolute path</em>) je cesta, která začíná kořenovým adresářem souborového
systému, například <code>/home/student/upr/soubor.txt</code><sup class='margin-toggle sidenote-number'>1</sup>. Aby byla cesta absolutní, musí na Linuxu
začínat dopředným lomítkem.<span class='sidenote'><p><sup class='number'>1</sup>Na Windows by podobná cesta mohla vypadat například takto: <code>C:\Users\student\upr\soubor.txt</code>.</p>
</span></li>
<li><strong>Relativní cesta</strong> (<em>relative path</em>) se vyhodnotí relativně k tzv. <strong>pracovnímu adresáři</strong>
(<em>working directory</em>) běžícího programu. Pokud spustíte váš program z terminálu, tak se pracovní
adresář implicitně nastaví na adresář, ze kterého jste program spustili. Pokud tedy například spustíte
váš program z adresáře <code>/home/student/upr</code> a funkci <code>fopen</code> předáte cestu <code>soubor.txt</code>, tak se funkce
pokusí otevřít soubor na cestě <code>/home/student/upr/soubor.txt</code>.</li>
</ul>
<p>Při zadávání cesty můžete využít speciální odkazy <code>.</code> a <code>..</code>, které jsou užitečné zejména u relativních
cest:</p>
<ul>
<li>Odkaz <code>.</code> se odkazuje na současný adresář, <code>./soubor.txt</code> je tedy to samé jako <code>soubor.txt</code>.</li>
<li>Odkaz <code>..</code> se odkazuje na rodičovský adresář, <code>../data/abc.txt</code> tedy říká:
<code>Podívej se do rodičovského adresáře, tam vyhledej adresář data a v něm soubor abc.txt</code>.</li>
</ul>
<p>Nepokoušejte se však zadávat cesty k neexistujícím adresářům. <code>fopen</code> sice umí vytvořit nový soubor
(pokud použijete odpovídající <a href="c/soubory/otevirani_souboru.html#m%C3%B3d-otev%C5%99en%C3%AD">mód</a>), neexistující adresář za vás nicméně nevytvoří.</p>
<blockquote>
<p>Doposud jsme používali prvky <em>C</em>, které byly vesměs nezávislé na použitém operačním systému. Jakmile
ale naše programy začnou interagovat se <strong>souborovým systémem</strong> (<em>file system</em>), budeme muset začít
respektovat zákonitosti operačního systému, na kterém náš program poběží. Proto například u cesty
k souborům vždy používejte dopředná lomítka (<code>/</code>) pro oddělování adresářů, pokud program budete
spouštět na Linuxu. </p>
</blockquote>
<h2><a class="header" href="#mód-otevření" id="mód-otevření">Mód otevření</a></h2>
<p>Druhým parametrem funkce <code>fopen</code> je řetězec, jehož obsah určuje, v jakém <strong>módu</strong> (<em>mode</em>) se má
soubor otevřít. Kompletní seznam všech kombinací módů naleznete v
<a href="https://devdocs.io/c/io/fopen">dokumentaci</a>, zde je seznam běžných variant:</p>
<table><thead><tr><th align="center">Mód</th><th align="center">Možné operace</th><th align="center">Co se stane, když už soubor existuje?</th><th align="center">Co se stane, když soubor neexistuje?</th></tr></thead><tbody>
<tr><td align="center"><code>&quot;r&quot;</code></td><td align="center">Čtení</td><td align="center"></td><td align="center">chyba</td></tr>
<tr><td align="center"><code>&quot;w&quot;</code></td><td align="center">Zápis</td><td align="center">obsah souboru je smazán</td><td align="center">soubor je vytvořen</td></tr>
<tr><td align="center"><code>&quot;a&quot;</code></td><td align="center">Zápis na konci</td><td align="center"></td><td align="center">soubor je vytvořen</td></tr>
<tr><td align="center"><code>&quot;r+&quot;</code></td><td align="center">Čtení, zápis</td><td align="center"></td><td align="center">chyba</td></tr>
<tr><td align="center"><code>&quot;w+&quot;</code></td><td align="center">Čtení, zápis</td><td align="center">obsah souboru je smazán</td><td align="center">soubor je vytvořen</td></tr>
<tr><td align="center"><code>&quot;a+&quot;</code></td><td align="center">Čtení, zápis na konci</td><td align="center"></td><td align="center">soubor je vytvořen</td></tr>
</tbody></table>
<p>Při otevírání souboru si musíte rozmyslet, jestli z něj chcete číst, zapisovat do něj nebo provádět
obojí. Zároveň si musíte určit, jestli chcete soubor vytvořit v případě, že neexistuje, popřípadě
jestli má být jeho obsah smazán, pokud už existuje. Podle těchto vlastností si pak zvolte odpovídající
mód otevření souboru. Nejběžněji používanými módy jsou <code>&quot;r&quot;</code> pro čtení ze souboru a <code>&quot;w&quot;</code> pro zápis
do souboru.</p>
<h3><a class="header" href="#textový-vs-binární-režim" id="textový-vs-binární-režim">Textový vs binární režim</a></h3>
<p>Pokud použijete jeden ze základních módů, soubor se otevře v tzv. <strong>textovém režimu</strong>. V tomto režimu
dochází ke konverzi určitých bytů při čtení a zápisu ze souboru. Asi nejdůležitějším znakem, který
je takto konvertován, je <code>'\n'</code>, neboli <strong>odřádkování</strong> (<em>newline</em>). Různé operační systémy totiž
při interpretaci souborů používají různé znaky pro odlišení situace, kdy má dojít k přesunu kurzoru
na nový řádek:</p>
<ul>
<li><code>LF</code>: Linux a macOS<sup class='margin-toggle sidenote-number'>2</sup> používají pro konec řádku přímo ASCII znak <code>LF (line feed)</code>, který lze v
<em>C</em> zapsat jako <code>'\n'</code>.<span class='sidenote'><p><sup class='number'>2</sup>V <a href="https://en.wikipedia.org/wiki/Classic_Mac_OS">dávných dobách</a> používal Mac OS pro odřádkování
pouze znak <code>CR</code>.</p>
</span></li>
<li><code>CRLF</code>: Windows používá pro konec řádku dvojici ASCII znaků <code>CR (carriage return)</code> a <code>LF</code>
(v tomto pořadí). <code>CR</code> lze v <em>C</em> zapsat jako <code>'\r'</code>.</li>
</ul>
<p>Na Windows tak při zápisu do souborů otevřených v textovém módu dojde ke konverzi znaku odřádkování
<code>\n</code> na dvojici znaků <code>\r\n</code>. Stejně tak při načítání dat ze souboru se dvojice znaků <code>\r\n</code> převedou
na <code>\n</code>. Na Linuxu textový mód v podstatě nic nedělá, protože se zde pro odřádkování používá přímo
znak <code>\n</code>.</p>
<p>Pokud byste však chtěli mít jistotu, že opravdu k žádné konverzi nedojde, a budete zapisovat data,
která nemají být interpretována jako text, můžete na konec módu přidat znak <code>b</code>. Poté se soubor
otevře v tzv. <strong>binární režimu</strong>, kde k žádné konverzi nedochází. Mód <code>&quot;rb&quot;</code> tak například říká
<code>Otevři soubor pro čtení v binárním režimu</code>.</p>
<blockquote>
<p>Pokud byste chtěli explicitně říct, že se má použít textový režim, můžete na konec módu přidat
znak <code>t</code>. Například mód <code>&quot;rt&quot;</code> je ekvivalentní s módem <code>&quot;r&quot;</code> a označuje otevření souboru pro
textové čtení.</p>
</blockquote>
<h3><a class="header" href="#ošetření-chyb-2" id="ošetření-chyb-2">Ošetření chyb</a></h3>
<p>Jakmile řeknete funkci <code>fopen</code> jaký soubor (a v jakém módu) má otevřít, funkce jej otevře a vrátí
vám ukazatel na strukturu <code>FILE</code>, pomocí které můžete se souborem dále pracovat<sup class='margin-toggle sidenote-number'>3</sup>. Stejně jako
u jakékoliv práce se vstupem a výstupem i při práci se soubory však může často docházet k různým
chybám.</p>
<span class='sidenote'><p><sup class='number'>3</sup><code>FILE</code> je tzv. <strong>neprůhledná</strong> (<em>opaque</em>) struktura deklarovaná ve standardní knihovně <em>C</em>.
Nebudete přistupovat k žádným jejím členům, pouze budete ukazatel na ni posílat do různých funkcí
pro práci se soubory, abyste určili, s jakým (otevřeným) souborem chcete pracovat.</p>
</span>
<p>Pokud byste se například pokoušeli otevřít neexistující soubor v módu pro čtení <code>&quot;r&quot;</code>, dojde k chybě.
V takovém případě vám funkce <code>fopen</code> vrátí adresu nula (tzv. <code>NULL</code> ukazatel). Po každém pokusu o
otevření souboru byste tak měli ověřit, zdali se otevření opravdu podařilo nebo ne. Pokud při otevření
došlo k chybě, tak se do <a href="c/soubory/../promenne/globalni_promenne.html">globální proměnné</a>
<a href="https://devdocs.io/c/error/errno"><code>errno</code></a> uloží číslo, které identifikuje, o jaký typ chyby šlo<sup class='margin-toggle sidenote-number'>4</sup>.
K proměnné budete mít přístup, pokud do svého programu <a href="c/soubory/../preprocesor/vkladani_souboru.html">vložíte</a>
soubor <code>&lt;errno.h&gt;</code>. Pomocí funkce <a href="https://devdocs.io/c/string/byte/strerror"><code>strerror</code></a> ze souboru
<code>&lt;string.h&gt;</code> pak můžete získat řetězec, který danou chybu popisuje:</p>
<span class='sidenote'><p><sup class='number'>4</sup>Seznam různých chybových hodnot, které se můžou v <code>errno</code> objevit na operačním systému Linux,
můžete naleznout například <a href="https://www.thegeekstuff.com/2010/10/linux-error-codes/#optiontable">zde</a>.</p>
</span>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;errno.h&gt;
#include &lt;string.h&gt;

int main() {
    FILE* soubor = fopen(&quot;soubor.txt&quot;, &quot;r&quot;);
    if (soubor == NULL) {
        printf(&quot;Doslo k chybe pri otevirani souboru: %s\n&quot;, strerror(errno));
        return 1; // došlo k chybě, vrátíme 1 jako chybový stav programu
    }

    return 0;
}
</code></pre>
<h3><a class="header" href="#použití-assert" id="použití-assert">Použití <code>assert</code></a></h3>
<p>Pokud píšete malý program a nechce se vám ručně každou chybu ošetřovat, můžete využít
<a href="c/soubory/../preprocesor/makra.html">makro</a> <a href="https://devdocs.io/c/error/assert"><code>assert</code></a> ze souboru <code>&lt;assert.h&gt;</code>.
Toto makro očekává pravdivostní hodnotu a kontroluje, zdali platí (<code>assert</code> znamená
<code>ujisti se, že platí …</code>). Pokud hodnota neplatí, tj. vyhodnotí se na <code>0</code> či <code>false</code>, tak dojde k
okamžitému ukončení vašeho programu. Nebudete tak sice moct ovlivnit vypsanou chybovou hlášku, ale
ošetření chyby se značně zjednodušší:</p>
<pre><code class="language-c">FILE* soubor = fopen(&quot;soubor.txt&quot;, &quot;r&quot;);
assert(soubor); // pokud je `soubor` roven `NULL`, program se zde ukončí
</code></pre>
<p>Ošetření chyb je dobré nepodceňovat. Pokud chybu ošetříte okamžitě po jejím možném vzniku (i kdyby
to mělo být okamžitým vypnutím programu), tak bude mnohem jednodušší zjistit, kde v kódu a proč vznikla.
Jinak se může jednoduše stát, že k chybě sice dojde, ale program bude pokračovat vesele dál. Tato
chyba pak může v průběhu programu způsobit kaskádu dalších chyb, které nakonec dříve či později povedou
k &quot;spadnutí&quot; nebo špatnému fungování programu. V takové situaci bude mnohem náročnější zjistit, kde
vznikla původní chyba, která vše způsobila, protože program může spadnout na úplně jiném místě v kódu. </p>
<h2><a class="header" href="#zavření-souboru" id="zavření-souboru">Zavření souboru</a></h2>
<p>Jakmile se souborem přestanete pracovat, je <strong>nutné</strong> ho zavřít. K tomu slouží funkce
<a href="https://devdocs.io/c/io/fclose"><code>fclose</code></a>:</p>
<pre><code class="language-c">FILE* soubor = fopen(&quot;soubor.txt&quot;, &quot;w&quot;);
// zápis/čtení ze souboru…
fclose(soubor);
</code></pre>
<p>Funkce <code>fclose</code> vrací číselnou hodnotu, která oznamuje, zdali funkce proběhla v pořádku nebo ne.
Pokud funkce vrátí <code>0</code>, tak se soubor úspěšně uzavřel. I u zavírání souborů bychom tedy měli mít
alespoň základní ošetření chyb<sup class='margin-toggle sidenote-number'>5</sup>:</p>
<span class='sidenote'><p><sup class='number'>5</sup>Operátor <code>!</code> provede logickou negaci. Pokud jej použijeme s hodnotou <code>0</code>, vrátí hodnotu <code>1</code>.
Pokud jej použijeme s jakoukoliv jinou hodnotou, vrátí hodnotu <code>0</code>. Pokud tedy funkce <code>fclose</code> vrátí
cokoliv jiného než <code>0</code>, <code>assert</code> ukončí program.</p>
</span>
<pre><code class="language-c">assert(!fclose(soubor));
</code></pre>
<p>Pokud bychom soubor nezavřeli, tak se například může stát, že kvůli použitému
<a href="c/soubory/../text/vstupavystup.html#standardn%C3%AD-souborov%C3%A9-deskriptory"><em>bufferování</em></a> by se data, která jsme do
souboru zapsali, nemusela objevit na souborovém systému.</p>
<h1><a class="header" href="#práce-se-soubory" id="práce-se-soubory">Práce se soubory</a></h1>
<p>Jakmile jsme se pokusili o otevření souboru, ujistili jsme se, že se to opravdu povedlo a získali
jsme ukazatel <code>FILE*</code>, můžeme začít do programu zapisovat nebo z něj číst data (podle toho, v jakém
módu jsme ho otevřeli).</p>
<h2><a class="header" href="#pozice-v-souboru" id="pozice-v-souboru">Pozice v souboru</a></h2>
<p>Struktura <code>FILE</code> má vnitřně uloženou <strong>pozici</strong> v souboru, na které probíhají veškeré operace čtení
a zápisu. Pro zjednodušení práce se soubory se pozice automaticky posouvá dopředu o odpovídající
počet bytů po každém čtení či zápisu. Jakmile tedy přečtete ze souboru <code>n</code> bytů, tak se pozice posune
o <code>n</code> pozic dopředu. Pokud byste tedy dvakrát po sobě přečetli jeden byte ze souboru obsahující text
<code>ABC</code>, nejprve získáte znak <code>A</code>, a podruhé už znak <code>B</code>, protože po prvním čtení se pozice posunula
dopředu o jeden byte.</p>
<blockquote>
<p>Tím, že je pozice sdílená pro čtení a zápis, tak se raději vyvarujte současnému čtení i zápisu
nad stejným otevřeným souborem. V opačném případě budete muset být opatrní, abyste si omylem
nepřepsali data nebo nečetli data ze špatné pozice.</p>
</blockquote>
<p>Současnou pozici v souboru můžete zjistit pomocí funkce <a href="https://devdocs.io/c/io/ftell"><code>ftell</code></a>.
Pokud byste chtěli pozici ručně změnit, můžete použít funkci <a href="https://devdocs.io/c/io/fseek"><code>fseek</code></a>,
pomocí které se také například můžete v souboru přesunout na začátek (např. abyste ho přečetli
podruhé) nebo na konec (např. abyste zjistili, kolik soubor celkově obsahuje bytů)<sup class='margin-toggle sidenote-number'>1</sup>.</p>
<span class='sidenote'><p><sup class='number'>1</sup>Toho můžete dosáhnout tak, že pomocí <code>fseek(file, 0, SEEK_END)</code> přesunete pozici na konec
souboru, a dále pomocí <code>ftell(file)</code> zjistíte, na jaké pozici jste. To vám řekne, kolik má soubor
celkově bytů.</p>
</span>
<blockquote>
<p>Při použití módu <code>&quot;a&quot;</code> budou veškeré zápisy probíhat vždy na konci souboru. Tento mód se hodí
například při zápisu do tzv. <strong>logovacích souborů</strong>, které chronologicky zaznamenávají události v
programu (události tak vždy pouze přibývají). Zároveň se však po každém zápisu v tomto módu
pozice posune na jeho konec. Raději tak nepoužívejte mód <code>&quot;a+&quot;</code>, který umožňuje zápis na konec i
čtení. Práce s pozicí při současném zapisování i čtení je v takovémto módu totiž poněkud náročná.</p>
</blockquote>
<p>Všimněte si, že při práci se <code>stdout</code> a <code>stdin</code> jsme s pozicí manipulovat nemohli. Je to proto, že
tyto dva deskriptory jsou z jistého pohledu &quot;obecnější&quot; než soubory. Můžou být přesměrované na
terminál, do souboru, ale klidně také i do jiného počítače přes síť. Tím, že nevíme, &quot;co jsou zač&quot;,
tak si s nimi nemůžeme dovolit provádět některé operace, jako je právě manipulace s pozicí. Pokud
například odešleme data přes síť, už je nemůžeme &quot;vrátit zpátky&quot; změnou pozice. U souborů však
víme, že opravdu pracujeme se souborem, takže pozici pro zápis a čtení měnit můžeme.</p>
<h2><a class="header" href="#zápis-a-čtení-souborů" id="zápis-a-čtení-souborů">Zápis a čtení souborů</a></h2>
<p>V následujících sekcích se dozvíte, jak <a href="c/soubory/zapis_do_souboru.html">zapisovat</a> a <a href="c/soubory/cteni_ze_souboru.html">číst</a>
ze souborů.</p>
<h1><a class="header" href="#zápis-do-souboru" id="zápis-do-souboru">Zápis do souboru</a></h1>
<p>Pokud chceme do otevřeného souboru zapsat nějaké byty, můžeme použít funkci
<a href="https://devdocs.io/c/io/fwrite"><code>fwrite</code></a>:</p>
<pre><code class="language-c">size_t fwrite(
    const void* buffer, // adresa, ze které načteme data do souboru
    size_t size,        // velikost prvku, který zapisujeme
    size_t count,       // počet prvků, které zapisujeme
    FILE* stream        // soubor, do kterého zapisujeme
);
</code></pre>
<p>Funkce <code>fwrite</code> předpokládá, že budeme do souboru zapisovat více hodnot stejného datového typu.
Parametr <code>size</code> udává velikost tohoto datového typu a parametr <code>count</code> počet hodnot, které chceme
zapsat. Pokud tuto funkci zavoláme, tak dojde k zápisu <code>size * count</code> bytů z adresy <code>buffer</code> do
souboru <code>stream</code>. Návratová hodnota <code>fwrite</code> značí, kolik prvků bylo do souboru úspěšně zapsáno.
Pokud je tato hodnota menší než <code>count</code>, tak došlo k nějaké chybě. Například zápis pěti celých
čísel do souboru by mohl vypadat následovně:</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;assert.h&gt;

int main() {
    int pole[5] = { 1, 2, 3, 4, 5 };

    // otevření souboru
    FILE* soubor = fopen(&quot;soubor&quot;, &quot;wb&quot;);
    assert(soubor);

    // binární zápis do souboru
    int zapsano = fwrite(pole, sizeof(int), 5, soubor);
    assert(zapsano == 5);

    // zavření souboru
    fclose(soubor);    

    return 0;
}
</code></pre>
<blockquote>
<p>Při takovémto použití <code>fwrite</code> může dojít k zapsání například pouze <code>3</code> čísel, pokud během zápisu
dojde k chybě<sup class='margin-toggle sidenote-number'>1</sup>. Pokud bychom chtěli zapsat buď vše nebo nic, můžeme říct, že zapisujeme pouze
jeden prvek a parameter <code>count</code> nastavit na celkovou velikost všech dat, které chceme zapsat:</p>
<span class='sidenote'><p><sup class='number'>1</sup>V takovémto případě by funkce <code>fwrite</code> vrátila hodnotu <code>3</code>.</p>
</span>
<pre><code class="language-c">int pole[5] = { 1, 2, 3, 4, 5 };
fwrite(pole, sizeof(pole), 1, soubor);
</code></pre>
</blockquote>
<p>Pokud bychom zapsali <code>pole</code> do souboru takto, uloží se do něj celkem <code>20</code> (<code>5</code> * <code>4</code>) bytů (čísel),
které později můžeme v programu zase <a href="c/soubory/cteni_ze_souboru.html">načíst zpátky</a>. Pokud bychom se podívali,
co v souboru je, nalezli bychom seznam čísel <code>1 0 0 0 2 0 0 0 3 0 0 0 4 0 0 0 5 0 0 0</code>, což odpovídá
paměťové reprezentaci pole pěti <code>int</code>ů, které bylo vytvořeno výše.</p>
<h2><a class="header" href="#textový-zápis" id="textový-zápis">Textový zápis</a></h2>
<p>Pokud bychom chtěli tato data zapsat do souboru v textové podobě (a ne pouze jako jejich binární
reprezentaci), můžeme čísla z výše zmíněného pole zapsat pomocí nějakého textového kódování,
například <a href="c/soubory/../text/znaky.html">ASCII</a>. K tomu můžeme využít funkci
<a href="https://devdocs.io/c/io/fprintf"><code>fprintf</code></a>, která funguje stejně jako <code>printf</code>, s tím rozdílem,
že text nevypisuje na <code>stdout</code>, ale do předaného souboru<sup class='margin-toggle sidenote-number'>2</sup>:</p>
<span class='sidenote'><p><sup class='number'>2</sup>Všimněte si, že zde jsme použili <a href="c/soubory/otevirani_souboru.html#M%C3%B3d-otev%C5%99en%C3%AD">mód otevření</a> pro textový
zápis (<code>&quot;wt&quot;</code>), namísto binárního zápisu <code>&quot;wb&quot;</code> použitého výše.</p>
</span>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;assert.h&gt;

int main() {
    int pole[5] = { 1, 2, 3, 4, 5 };

    // otevření souboru
    FILE* soubor = fopen(&quot;soubor.txt&quot;, &quot;wt&quot;);
    assert(soubor);

    // textový zápis do souboru
    for (int i = 0; i &lt; 5; i++) {
        fprintf(soubor, &quot;%d &quot;, pole[i]);
    }

    // zavření souboru
    fclose(soubor);    

    return 0;
}
</code></pre>
<p>V tomto případě by se do souboru zapsalo deset bytů (čísel) <code>49 32 50 32 51 32 52 32 53 32</code>, protože
číslice jsou v <a href="https://www.asciitable.com/">ASCII</a> reprezentovány čísly <code>48</code> až <code>57</code> a mezera je
reprezentována číslem <code>32</code>. Pokud bychom tento soubor otevřeli v textovém editoru, tak by se nám
zobrazil text <code>1 2 3 4 5 </code>.</p>
<h2><a class="header" href="#bufferování" id="bufferování">Bufferování</a></h2>
<p>Stejně jako při zápisu do <code>stdout</code> se i při zápisu do souborů uplatňuje
<a href="c/soubory/../text/vstupavystup.html#standardn%C3%AD-souborov%C3%A9-deskriptory"><em>bufferování</em></a>. Data, která do souboru
zapíšeme, se tak v něm neobjeví hned. Pokud bychom chtěli donutit náš program, aby data uložená
v bufferu opravdu vypsal do souboru, můžeme použít funkci <a href="https://devdocs.io/c/io/fflush"><code>fflush</code></a>
<sup class='margin-toggle sidenote-number'>3</sup>.</p>
<span class='sidenote'><p><sup class='number'>3</sup>Ani zavolání funkce <code>fflush</code> však nezajistí, že se data opravdu zapíšou na fyzické médium
(například harddisk). To je ve skutečnosti velmi obtížný <a href="https://lwn.net/Articles/457667/">problém</a>.</p>
</span><h1><a class="header" href="#Čtení-ze-souboru" id="Čtení-ze-souboru">Čtení ze souboru</a></h1>
<p>Pro čtení ze souboru můžeme použít funkci <a href="https://devdocs.io/c/io/fread"><code>fread</code></a>, která je
protikladem funkce <code>fwrite</code>:</p>
<pre><code class="language-c">size_t fread(
    void* buffer,   // adresa, na kterou zapíšeme data ze souboru
    size_t size,    // velikost prvku, který načítáme
    size_t count,   // počet prvků, které načítáme
    FILE* stream    // soubor, ze kterého čteme
);
</code></pre>
<p>Tato funkce opět předpokládá, že budeme ze souboru načítat několik hodnot stejného datového typu.
Například načtení pěti celých čísel, které jsme zapsali v kódu <a href="c/soubory/zapis_do_souboru.html">zde</a>, by mohlo
vypadat následovně:</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;assert.h&gt;

int main() {
    int pole[5] = { 1, 2, 3, 4, 5 };

    // otevření souboru
    FILE* soubor = fopen(&quot;soubor&quot;, &quot;rb&quot;);
    assert(soubor);

    // čtení ze souboru
    int precteno = fread(pole, sizeof(int), 5, soubor);
    assert(precteno == 5);

    // zavření souboru
    fclose(soubor);    

    return 0;
}
</code></pre>
<p>Funkce <code>fread</code> vrací počet prvků, které úspěšně načetla ze souboru.</p>
<h2><a class="header" href="#textové-čtení" id="textové-čtení">Textové čtení</a></h2>
<p>Pokud bychom chtěli načítat ze souboru ASCII text, můžeme použít již známé funkce pro načítání textu,
například <a href="https://devdocs.io/c/io/fgets"><code>fgets</code></a><sup class='margin-toggle sidenote-number'>1</sup> nebo <a href="https://devdocs.io/c/io/fscanf"><code>fscanf</code></a>,
což je varianta funkce <code>scanf</code> určená pro formátované čtení ze souborů.</p>
<span class='sidenote'><p><sup class='number'>1</sup>S funkcí <code>fgets</code> jsme se setkali již <a href="c/soubory/../text/vstup.html#na%C4%8Dten%C3%AD-%C5%99%C3%A1dku">dříve</a>, kdy jsme jí
jako poslední parametr globální proměnnou <code>stdin</code>. Datový typ proměnné <code>stdin</code> je právě <code>FILE*</code> –
při spuštění programu standardní knihovna <em>C</em> vytvoří proměnné <code>stdin</code>, <code>stdout</code> a <code>stderr</code> a uloží
do nich standardní vstup, výstup a chybový výstup.</p>
</span>
<blockquote>
<p>U načítání dat si vždy dejte pozor na to, abyste na adrese, kterou předáváte do <code>fread</code> nebo
<code>fgets</code>, měli dostatek naalokované validní paměti. Jinak by se mohlo stát, že data ze souboru
přepíšou adresy v paměti, kde leží nějaké nesouvisející hodnoty, což by vedlo k
<a href="c/soubory/../../caste_chyby/pametove_chyby.html#segmentation-fault">paměťové chybě</a> 💣.</p>
</blockquote>
<h3><a class="header" href="#rozpoznání-konce-souboru" id="rozpoznání-konce-souboru">Rozpoznání konce souboru</a></h3>
<p>Při čtení ze souboru je třeba vyřešit jednu dodatečnou věc – jak rozpoznáme, že už jsme soubor
přečetli celý a už v něm nic dalšího nezbývá? Pokud načítáme data ze souboru &quot;binárně&quot;, tj.
interpretujeme je jako byty a ne jako (ASCII) text, obvykle stačí si velikost souboru
<a href="c/soubory/prace_se_soubory.html#pozice-v-souboru">předpočítat</a> po jeho otevření pomocí funkcí
<a href="https://devdocs.io/c/io/ftell"><code>ftell</code></a> a <a href="https://devdocs.io/c/io/fseek"><code>fseek</code></a> nebo si ji
přečíst přímo ze samotného souboru<sup class='margin-toggle sidenote-number'>2</sup>.</p>
<span class='sidenote'><p><sup class='number'>2</sup>Spousta binárních formátů (např. <code>JPEG</code>) jsou tzv. <strong>samo-popisné</strong> (<em>self-describing</em>), což
znamená, že typicky na začátku souboru je v pevně stanoveném formátu (tzv. <em>hlavičce</em>) uvedeno,
jak je daný soubor velký. Využijeme toho například při práci s obrázkovým formátem
<a href="c/soubory/../aplikovane_ulohy/tga.html"><code>TGA</code></a>.</p>
</span>
<p>Co ale dělat, když načítáme textové soubory, jejichž formát obvykle není ani zdaleka pevně daný?
Předpočítat si velikost souboru a pak muset po každém načtení např. řádku počítat, kolik znaků jsme
vlastně načetli, by bylo relativně komplikované. Při čtení textových souborů se tak obvykle využívá
jiná strategie – čteme ze souboru tak dlouho, dokud nedojde k chybě. Způsob detekce chyby záleží na
použité funkci:</p>
<ul>
<li><a href="https://devdocs.io/c/io/fscanf"><code>fscanf</code></a> vrátí číslo <code>&lt;= 0</code>, pokud se jí nepodaří načíst žádný
zástupný znak ze vstupu.</li>
<li><a href="https://devdocs.io/c/io/fgets"><code>fgets</code></a> vrátí ukazatel s hodnotou <code>0</code>, pokud dojde k chybě při
čtení.</li>
</ul>
<p>Jakmile dojde k chybě, tak bychom ještě měli ověřit, jestli jsme opravdu na konci souboru, anebo
byla chyba způsobena něčím jiným<sup class='margin-toggle sidenote-number'>3</sup>. To můžeme zjistit pomocí funkcí
<a href="https://devdocs.io/c/io/feof"><code>feof</code></a>, která vrátí nenulovou hodnotu, pokud jsme se <strong>před jejím
zavoláním</strong> pokusili o čtení a <a href="c/soubory/prace_se_soubory.html#pozice-v-souboru">pozice</a> již byla na konci souboru,
a <a href="https://devdocs.io/c/io/ferror"><code>ferror</code></a>, která vrátí nenulovou hodnotu, pokud došlo k nějaké
jiné chybě při práci se souborem. </p>
<span class='sidenote'><p><sup class='number'>3</sup>Například pokud čteme soubor z USB flashky, který je během čtení odpojen od počítače.</p>
</span>
<p>Program, který by načítal a rovnou vypisoval řádky textu ze vstupního souboru, dokud nedojde na
jeho konec, by tedy mohl vypadat například takto:</p>
<pre><code class="language-c">#include &lt;assert.h&gt;
#include &lt;errno.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

int main() {
    FILE* soubor = fopen(&quot;soubor.txt&quot;, &quot;rt&quot;);
    assert(soubor);

    char radek[80];
    while (1) {
        if (fgets(radek, sizeof(radek), soubor)) {
            // radek byl uspesne nacten
            printf(&quot;Nacteny radek: %s&quot;, radek);
        }
        else {
            if (feof(soubor)) {
                printf(&quot;Dosli jsme na konec souboru\n&quot;);
            } else if (ferror(soubor)) {
                printf(&quot;Pri cteni ze souboru doslo k chybe: %s\n&quot;, strerror(errno));
            }

            break;
        }
    }

    fclose(soubor);

    return 0;
}
</code></pre>
<hr />
<p><strong>Kvíz</strong> 🤔</p>
<ol>
<li>
<p>Co vypíše následující program za předpokladu, že v souboru <code>soubor.txt</code> je tento obsah?</p>
<pre><code>radek1
radek2
radek3
</code></pre>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;assert.h&gt;

int main() {
    FILE* soubor = fopen(&quot;soubor.txt&quot;, &quot;r&quot;);
    assert(soubor);

    char radek[80];
    while (feof(soubor) == false) {
        fgets(radek, sizeof(radek), soubor);
        printf(&quot;Nacteny radek: %s&quot;, radek);
    }

    fclose(soubor);
    return 0;
}
</code></pre>
<details>
 <summary>Odpověď</summary>
<p>Program vypíše:</p>
<pre><code>radek1
radek2
radek3
radek3
</code></pre>
<p>Funkce <code>feof</code> vrátí pravdivou hodnotu pouze tehdy, kdy před jejím zavoláním na daném souborovém
deskriptoru došlo k pokusu o čtení, který selhal z důvodu konce vstupního souboru. Po načtení
prvních tří řádků tedy <code>feof</code> vrátí <code>false</code>, protože poslední pokus o čtení uspěl. Až v momentě,
kdy se pokusíme načíst čtvrtý řádek, tak funkce <code>fgets</code> selže a poté <code>feof</code> vrátí <code>true</code>. Jelikož
ale tento kód nekontroluje návratovou hodnotu funkce <code>fgets</code> a vždy po pokusu o načtení řádku vypíše
proměnnou <code>radek</code>, tak se poslední řádek souboru vypíše dvakrát.</p>
</details>
</li>
</ol>
<h1><a class="header" href="#modularizace" id="modularizace">Modularizace</a></h1>
<p>Prozatím byly naše programy tvořeny pouze jedním zdrojovým souborem. Pro krátké programy do pár
stovek řádků to stačí, nicméně asi si dovedete představit, že programy s tisíce či miliony řádků kódu
už se do jednoho souboru rozumně &quot;nevlezou&quot;. V této sekci si tak ukážeme, jak programy v <em>C</em> rozdělit
do více zdrojových souborů.</p>
<p>Rozdělení programu do více souborů má spoustu výhod:</p>
<ul>
<li>
<p><strong>Větší přehlednost</strong> Pokud by byl veškerý kód v jednom zdrojovém souboru, tak by se v takovém souboru
dalo u větších programů jen těžko vyznat. Pokud budou jednotlivé logické části programu umístěny
v samostatných souborech či adresářích, bude např. mnohem jednodušší najít část programu, kterou
chceme upravit.</p>
<p>Například u hry bychom mohli rozdělit program do souborů <code>zvuk.c</code>, <code>grafika.c</code>, <code>ovladani_priser.c</code>,
<code>zbrane.c</code>, <code>klavesnice.c</code>, <code>mys.c</code> atd. Pokud by některý z těchto souborů byl opět moc velký
nebo složitý, můžeme jeho funkcionalitu dále rozdělit do více souborů.</p>
</li>
<li>
<p><strong>Menší provázanost</strong> Pokud je vše v jednom souboru, znamená to, že z libovolné funkce lze volat
všechny ostatní funkce (popř. používat všechny ostatní struktury atd.). Toto vede k situaci, kdy jsou
jednotlivé části programu na sobě vzájemně závislé a propojené. To možná zní nevinně, nicméně ve
skutečnosti to téměř nevyhnutelně vede k programu, který je velmi obtížné upravit. Pokud totiž
změníte jednu věc, často se musí změnit i všechny další věci (funkce, struktury), které na dané věci
závisí. Pokud závisí vše na všem, tak i malá změna v jedné části kódu může kaskádově vyvolat nutnost
upravit celý zbytek programu, což je náročné.</p>
<p>Abychom tomu předešli, je vhodné učinit jednotlivé části programu samostatné, sdílet z nich se
zbytkem kódu pouze to, co je opravdu potřeba, a zbytek funkcionality učinit &quot;soukromou&quot; pro daný
soubor. Změny v těchto soukromých částech pak nemohou ovlivnit zbytek kódu, protože ten na nich
nebude záviset.</p>
</li>
<li>
<p><strong>Efektivnější spolupráce v týmu</strong> Rozdělení na více souborů také usnadní týmovou spolupráci.
Pokud budou jednotliví programátoři upravovat jiné soubory, bude mnohem menší riziko tzv. &quot;souběhu&quot;,
kdy by jejich změny ve stejném souboru mohly kolidovat. Tyto problémy pak dále řeší tzv.
<a href="https://cs.wikipedia.org/wiki/Verzov%C3%A1n%C3%AD">verzování</a>, o kterém se dozvíte v navazujících
předmětech.</p>
</li>
<li>
<p><strong>Znovuvyužití kódu</strong> Pokud by každý program musel implementovat veškerou funkcionalitu od nuly,
tak by bylo programování i jednoduchého programu nesmírně náročné.<sup class='margin-toggle sidenote-number'>1</sup> V rámci jednoho programu si
můžeme nějakou ucelenou funkcionalitu (např. sadu funkcí spolu se strukturami) vyčlenit do
samostatného souboru, což nám umožní ji opakovaně používat z ostatních souborů v našem programu.
Napříč programy pak můžeme sdílet kód pomocí tzv. <strong>knihoven</strong> (<em>libraries</em>). Pro obojí musíme umět
používat kód, který se nenachází ve zdrojovém souboru, ze kterého ho chceme využít.</p>
<span class='sidenote'><p><sup class='number'>1</sup>Ostatně například bez <a href="c/modularizace/../funkce/stdlib.html">standardní knihovny <em>C</em></a> bychom v našem programu
ani nebyli schopni něco vypsat do terminálu.</p>
</span></li>
</ul>
<p>V programovacích jazycích se obecně různé samostatné části kódu, které jsou typicky umístěny v
adresářích či souborech, a starají se o konkrétní funkcionalitu v programu, nazývají <em>moduly</em>.
Proto je tato sekce nazvána <em>modularizace</em>. Jedná se však spíše o obecný pojem, v jazyce <em>C</em> se přímo
s pojmem modul zase tak běžně nesetkáte.</p>
<p>Postupně si ukážeme:</p>
<ul>
<li>Jak funguje překlad programů <a href="c/modularizace/linker.html">s více zdrojovými soubory</a></li>
<li>Jak používat funkce a proměnné <a href="c/modularizace/pouzivani_kodu_z_jinych_souboru.html">z jiných souborů</a></li>
<li>Jaké jsou konvence pro používání <a href="c/modularizace/hlavickove_soubory.html">více zdrojových souborů v C</a></li>
<li>Jak používat kód, který napsal někdo jiný, a nasdílel ho v podobě <a href="c/modularizace/knihovny.html">knihovny</a></li>
</ul>
<h1><a class="header" href="#linker" id="linker">Linker</a></h1>
<p>V této sekci si vysvětlíme detailněji, jak probíhá překlad <em>C</em> programů, jehož základní fungování
již bylo stručně popsáno v sekci o <a href="c/modularizace/../../prostredi/preklad_programu.html">překladu</a>. Díky tomu pak
budeme schopni vytvářet programy skládající se z více než jednoho zdrojového souboru.</p>
<p>Prozatím jsme naše programy (skládající se z jediného zdrojového souboru) překládali pomocí
příkazu podobnému tomuto:</p>
<pre><code class="language-bash">$ gcc soubor.c -o program
</code></pre>
<p>Tímto příkazem jsme ve skutečnosti prováděli dvě věci najednou: <strong>překlad</strong> (<em>translation</em>) a
<strong>linkování</strong> (<em>linking</em>). Níže si vysvětlíme obě dvě tyto části detailněji.</p>
<blockquote>
<p>Překlad a linkování se dohromady nazývá <strong>kompilace</strong> programu.</p>
</blockquote>
<h2><a class="header" href="#překlad-programu-1" id="překlad-programu-1">Překlad programu</a></h2>
<p>Programy v <em>C</em> se skládají z jedné či více tzv. <strong>jednotek překladu</strong> (<em>translation unit</em>). Jedná se
o nezávislé komponenty, ze kterých je nakonec vytvořen cílový program. Každá jednotka je obvykle
tvořena jedním zdrojovým souborem (obvykle s příponou <code>.c</code>). Při překladu <strong>překladač</strong> převede
jednotku ze zdrojového kódu v <em>C</em> do instrukcí procesoru, tzv. <strong>objektového kódu</strong> (<em>object code</em>).</p>
<p>Pokud chceme překladačem GCC (pouze) přeložit zdrojový soubor do objektového kódu (resp.
objektového souboru), můžeme použít přepínač <code>-c</code>:</p>
<pre><code class="language-bash">$ gcc -c soubor.c
</code></pre>
<p>Pokud nezadáme název výstupu pomocí přepínače <code>-o</code>, tak GCC implicitně vytvoří objektový soubor
<code>&lt;nazev-vstupu&gt;.o</code> (tj. zde <code>soubor.o</code>).</p>
<p>Jednotky překladu jsou na sobě nezávislé, můžeme tedy každou jednotku (zdrojový soubor) přeložit
zvlášť:</p>
<pre><code class="language-bash">$ gcc -c a.c
$ gcc -c b.c
...
</code></pre>
<p>Jak ale nyní jednotlivé soubory propojíme? Aby vůbec mělo rozdělení do více jednotek (souborů) smysl,
tak musíme mít možnost v jednom souboru používat kód (např. funkce nebo globální proměnné), který je
nadefinovaný v jiném souboru. V <em>C</em> toto propojení jednotek neprobíhá při překladu, ale až v následné
fázi nazývané linkování.</p>
<h2><a class="header" href="#linkování-programu" id="linkování-programu">Linkování programu</a></h2>
<p>Jakmile přeložíme všechny naše zdrojové soubory postupně do objektových souborů, potřebujeme z nich
vytvořit finální spustitelný soubor, což je práce programu nazývaného <strong>linker</strong>. Linker obdrží
seznam všech (již přeložených) objektových souborů, ze kterých se má program skládat, propojí je
dohromady a vytvoří z nich spustitelný soubor.</p>
<p>Jak propojení jednotlivých souborů probíhá? Představme si například, že v souboru <code>a.c</code> voláme
funkci <code>foo</code>, která v tomto souboru neexistuje. Při překladu tohoto souboru překladač vytvoří
objektový soubor <code>a.o</code>, ve kterém bude uložena informace, že voláme funkci <code>foo</code>. Dejme tomu, že
tato funkce existuje v souboru <code>b.c</code>, který je přeložen do objektového souboru <code>b.o</code>. Při linkování
linker obdrží seznam všech objektových souborů, tedy <code>a.o</code> i <code>b.o</code>. Když narazí na informaci, že z
<code>a.o</code> chceme volat funkci <code>foo</code>, pokusí se tuto funkci naleznout v některém z předaných objektových
souborů:</p>
<ul>
<li>Pokud jej nenalezne, tak vypíše chybu a program se nepřeloží<sup class='margin-toggle sidenote-number'>1</sup>.<span class='sidenote'><p><sup class='number'>1</sup>V takovém případě byste se setkali s chybou <code>undefined reference to 'foo'</code>.</p>
</span></li>
<li>Pokud jej nalezne (v tomto případě v <code>b.o</code>), tak volání funkce &quot;propojí&quot; tak, aby se volala správná
funkce původně vytvořená v <code>b.c</code>.</li>
</ul>
<p>Manuální použití linkeru<sup class='margin-toggle sidenote-number'>2</sup> je relativně složité, proto i linker budeme používat přes <code>gcc</code>. Tomu
můžeme předat sadu objektových souborů a on se postará o správné zavolání linkeru, který je spojí
a vytvoří finální spustitelný soubor:</p>
<span class='sidenote'><p><sup class='number'>2</sup>Na Linuxu lze použít například linker <code>ld</code>.</p>
</span>
<pre><code class="language-bash">$ gcc a.o b.o -o program
</code></pre>
<p>Při finálním linkování programu také dochází ke kontrole toho, jestli je v některém z objektových
souborů obsažena funkce <code>main</code>, aby program věděl, kde má začít své vykonávání.</p>
<h4><a class="header" href="#proč-takto-složitě" id="proč-takto-složitě">Proč takto složitě?</a></h4>
<p>Možná vás napadlo, proč kompilace <em>C</em> programů probíhá takto komplikovaně a nestačí prostě překladači
dát všechny zdrojové soubory našeho programu tak, jak jsme to dělali doposud:</p>
<pre><code class="language-bash">$ gcc soubor1.c soubor2.c soubor3.c ...
</code></pre>
<p>Ve skutečnosti i to lze provést (tento postup se nazývá tzv. <strong>unity build</strong>). Nicméně má velkou
nevýhodu. Pokud bychom překládali celý náš program najednou, při sebemenší změně kódu bychom museli
přeložit všechny soubory znovu. Pokud bychom tak měli obrovský program s tisícem zdrojových souborů
a změnili jeden znak v jednom souboru, muselo by se všech tisíc souborů přeložit znovu, což může být
dost pomalé<sup class='margin-toggle sidenote-number'>3</sup>.</p>
<span class='sidenote'><p><sup class='number'>3</sup>Velké programy v <em>C</em> může trvat přeložit klidně i několik hodin!</p>
</span>
<p>Pokud překládáme každý soubor zvlášť, tak po změně v jednom souboru stačí přeložit daný soubor a znovu
slinkovat všechny objektové soubory (ty původní můžeme znovuvyužít, protože se nezměnily). To je u
velkých programů mnohem rychlejší než překládat vše od nuly.</p>
<p>Navíc pokud bychom se nenaučili používat zvlášť překladač a linker, nemohli bychom používat
<a href="c/modularizace/knihovny.html">knihovny</a>, u kterých obvykle nemáme přístup k samotnému zdrojovému kódu, ale pouze k
již přeloženému objektovému kódu<sup class='margin-toggle sidenote-number'>4</sup>.</p>
<span class='sidenote'><p><sup class='number'>4</sup>Například proto, aby autor knihovny &quot;zatajil&quot; původní zdrojový kód, který je jeho duševním
vlastnictvím.</p>
</span><h1><a class="header" href="#používání-kódu-z-jiných-souborů" id="používání-kódu-z-jiných-souborů">Používání kódu z jiných souborů</a></h1>
<p>Nyní už víme, jak přeložit program skládající se z více jednotek překladu (zdrojových souborů) a
následně tyto jednotky spojit dohromady pomocí linkeru. V této sekci si ukážeme, jak můžeme použít
kód, který existuje v jiném zdrojovém souboru.</p>
<p>Pokud chceme zavolat funkci, kterou jsme napsali v jiném souboru, můžeme ji prostě zavolat a linker
se postará o zbytek:</p>
<pre><code class="language-c">// soubor1.c
int main() {
    moje_funkce();
    return 0;
}

// soubor2.c
void moje_funkce() {}
</code></pre>
<p>Pokud tyto dva soubory přeložíme a poté slinkujeme, tak se zavolá správná funkce:</p>
<pre><code class="language-bash">$ gcc -c soubor1.c
$ gcc -c soubor2.c
$ gcc soubor1.o soubor2.o -o program
</code></pre>
<p>Nicméně, pokud bychom používali kód z jiných souborů takto &quot;naslepo&quot;, narazili bychom na několik
problémů. Tím, že překladač v souboru <code>soubor1.c</code> nemá přístup k <a href="c/modularizace/../funkce/funkce.html#syntaxe">signatuře</a>
funkce <code>moje_funkce</code>, tak nemůže ověřit, jestli jsme jí předali správný počet argumentů se správnými
datovými typy, a ani neví, jaký je datový typ návratové hodnoty této funkce.</p>
<p>Kód &quot;naslepo&quot; navíc nebude vůbec fungovat pro použití (globálních) proměnných. Při pokusu o
použití neexistující proměnné by překladač totiž rovnou ohlásil chybu.</p>
<h2><a class="header" href="#deklarace-vs-definice" id="deklarace-vs-definice">Deklarace vs definice</a></h2>
<p>Ideálně bychom potřebovali překladači říct, jak bude kód, který chceme použít, vypadat – jaký bude
datový typ a název globální proměnné, popř. jaké budou parametry, návratový typ a název funkce.
Toho můžeme dosáhnout pomocí tzv. <strong>deklarace</strong> (<em>declaration</em>).</p>
<p>Deklarace &quot;slibuje&quot;, že bude v programu existovat nějaká proměnná či funkce s konkrétním názvem a
typem, ale neříká, kde bude tato proměnná či funkce vytvořena (může to být například v jiném
zdrojovém souboru). Samotné vytvoření funkce či proměnné se nazývá <strong>definice</strong> (<em>definition</em>).
Zatím jsme tedy prováděli vždy definice funkcí i proměnných, nyní si ukážeme, jak vytvořit pouze
deklaraci.</p>
<p>Deklaraci funkce provedeme tak, že zadáme její <a href="c/modularizace/../funkce/funkce.html#syntaxe">signaturu</a>, ale ne její
tělo:</p>
<pre><code class="language-c">int funkce(int a, int b);           // deklarace funkce
int funkce(int a, int b) { ... }    // definice funkce
</code></pre>
<p>Deklaraci globální proměnné lze provést tak, že před ní dáme klíčové slovo <code>extern</code><sup class='margin-toggle sidenote-number'>1</sup>:</p>
<span class='sidenote'><p><sup class='number'>1</sup>Toto klíčové slovo můžeme použít i před deklarací funkce, nicméně není to potřeba, <code>extern</code> je
na tomto místě předpokládáno implicitně.</p>
</span>
<pre><code class="language-c">extern int promenna;    // deklarace proměnné
int promenna;           // definice proměnné
</code></pre>
<blockquote>
<p>Při sdílení kódu napříč soubory má smysl se bavit pouze o
<a href="c/modularizace/../promenne/globalni_promenne.html">globálních proměnných</a>. Lokální proměnné lze totiž používat vždy
pouze v rámci jedné funkce.</p>
</blockquote>
<p>Díky deklaracím tak můžeme v jednom zdrojovém souboru určit, jak mají vypadat funkce a proměnné, které
chceme používat, aby překladač mohl provádět kontrolu datových typů. Linker pak během linkování použije
správné proměnné/funkce z odpovídajících zdrojových souborů. Více o tom, kde a jak deklarace vytvářet,
se dozvíme v příští sekci o <a href="c/modularizace/hlavickove_soubory.html">hlavičkových souborech</a>.</p>
<h2><a class="header" href="#jednoprůchodový-překlad" id="jednoprůchodový-překlad">Jednoprůchodový překlad</a></h2>
<p>Z historických důvodů překladače <em>C</em> fungují v tzv. jednoprůchodovém režimu (<em>one-pass compilation</em>).
Znamená to, že překladač &quot;čte&quot; náš zdrojový kód shora dolů, a v momentě, kdy chceme například použít
nějakou funkci nebo proměnnou, tak již překladač dříve musel vidět (alespoň) její deklaraci, popř.
rovnou i definici.</p>
<p>Například v následujícím programu:</p>
<pre><code class="language-c">void funkce1() {
    funkce2();
}
void funkce2() {}
</code></pre>
<p>si překladač bude stěžovat na to, že na řádku 2 nezná funkci <code>funkce2</code>, protože tato funkce je v
souboru nadefinovaná až po funkci <code>funkce1</code>, která ji používá:</p>
<pre><code>test.c: In function ‘funkce’:
test.c:2:5: warning: implicit declaration of function ‘funkce2’;
    2 |     funkce2();
</code></pre>
<p>Pokud tedy potřebujeme nadefinovat funkci na pozdějším místě, než je její první použití, můžeme
nejprve vytvořit její deklaraci a až později (popř. v úplně jiném souboru) vytvořit její definici:</p>
<pre><code class="language-c">void funkce2();     // deklarace

void funkce1() {
    funkce2();      // použití
}
void funkce2() {}   // definice
</code></pre>
<p>Takovýto program už se přeloží bez varování. Koncept deklarování funkcí či proměnných v
jednoprůchodových překladačích se nazývá <strong>dopředná deklarace</strong> (<em>forward declaration</em>).</p>
<h2><a class="header" href="#pravidlo-jedné-definice" id="pravidlo-jedné-definice">Pravidlo jedné definice</a></h2>
<p>V <em>C</em> platí tzv. <strong>pravidlo jedné definice</strong> (<em>one definition rule</em>). Každá proměnná i funkce musí
být v programu <em>nadefinována</em> právě jednou (deklarována může být vícekrát). To platí jak v rámci
jednoho souboru, tak v rámci celého programu (tj. napříč všemi zdrojovými soubory).</p>
<ul>
<li>
<p>Pokud bychom proměnnou či funkci pouze nadeklarovali a/nebo použili bez definice:</p>
<pre><code class="language-c">// soubor.c
void funkce();

int main() {
    funkce();
    return 0;
}
</code></pre>
<p>Tak by kompilace selhala v době linkování, protože by nenašel žádnou funkci/proměnnou, kterou
by mohl použít:</p>
<pre><code class="language-bash">$ gcc -c soubor.c
$ gcc soubor.o
/usr/bin/ld: test.o: in function `main':
test.c:(.text+0xe): undefined reference to `funkce'
collect2: error: ld returned 1 exit status
</code></pre>
</li>
<li>
<p>Pokud bychom naopak nadefinovali proměnnou či funkci více než jednou:</p>
<pre><code class="language-c">// soubor1.c
void funkce() {}

int main() {
    funkce();
    return 0;
}
// soubor2.c
void funkce() {}
</code></pre>
<p>Tak by linkování opět selhalo, protože by linker nevěděl, kterou definici použít:</p>
<pre><code class="language-bash">$ gcc -c soubor1.c
$ gcc -c soubor2.c
$ gcc soubor1.o soubor2.o
/usr/bin/ld: soubor2.o: in function `funkce':
soubor2.c:(.text+0x0): multiple definition of `funkce'; test.o:test.c:(.text+0x0): first defined here
collect2: error: ld returned 1 exit status
</code></pre>
</li>
</ul>
<h2><a class="header" href="#viditelnost-funkcí-a-proměnných" id="viditelnost-funkcí-a-proměnných">Viditelnost funkcí a proměnných</a></h2>
<p>Z jiných souborů lze používat pouze funkce a proměnné, které jsou <em>veřejné</em>. Implicitně jsou
všechny funkce i všechny globální proměnné veřejné. Pokud byste chtěli zamezit tomu, aby mohly
ostatní soubory používat nějakou funkci nebo globální proměnnou, můžete ji označit klíčovým slovem
<code>static</code>, abyste z nich udělali <em>soukromé</em> funkce či proměnné:</p>
<pre><code class="language-c">static void soukroma_funkce() {}
static int soukroma_promenna;
</code></pre>
<p>Takovéto funkce a proměnné půjde používat pouze v souboru, ve kterém byly nadefinovány. Doporučujeme
<code>static</code> používat pro označení proměnných a funkcí, které nechcete sdílet se zbytkem programu. Půjde
tak na první pohled poznat, které funkce jsou určeny k použití z jiných souborů a které ne<sup class='margin-toggle sidenote-number'>2</sup>.</p>
<span class='sidenote'><p><sup class='number'>2</sup>Použití <code>static</code> také může v určitých případech vést k vygenerování efektivnějšího kódu a
menší velikosti výsledného spustitelného souboru.</p>
</span>
<blockquote>
<p>Klíčové slovo <code>static</code> lze také použít u lokálních proměnných, zde má ovšem úplně jiný význam než
u globálních proměnných! Použití <code>static</code> u lokální proměnné z ní udělá proměnnou uloženou v
<a href="c/modularizace/../prace_s_pameti/globalni_pamet.html">globální paměti</a>. Takováto proměnná se nainicializuje, když
se program poprvé dostane k řádku s její definicí. Proměnná bude existovat po celou dobu běhu
programu a udrží si svou hodnotu i po skončení volání funkce:</p>
<pre><code class="language-c editable">#include &lt;stdio.h&gt;

void test() {
  static int x = 0;
  x += 1;
  printf(&quot;%d\n&quot;, x);
}

int main() {
  test();
  test();
  return 0;
}
</code></pre>
</blockquote>
<h1><a class="header" href="#hlavičkové-soubory" id="hlavičkové-soubory">Hlavičkové soubory</a></h1>
<p>Nyní už víme, že pro použití kódu z jiných souborů bychom nejprve měli dané funkce a proměnné
<a href="c/modularizace/pouzivani_kodu_z_jinych_souboru.html#deklarace-vs-definice">deklarovat</a>. Pokud bychom však museli
v každém souboru, ve kterém chceme použít kód z jiného souboru, museli vytvářet deklarace pro
každou funkci či proměnnou, kterou chceme použít, bylo by to docela zdlouhavé. Pokud by navíc došlo
ke změně datového typu či názvu takovéto sdílené funkce či proměnné, museli bychom deklarace upravit
ve všech souborech, kde funkci či proměnnou používáme.</p>
<p>Pro vyřešení tohoto problému se v <em>C</em> často využívá koncept tzv. <strong>hlavičkových souborů</strong>
(<em>header files</em>). Pro každý zdrojový soubor, jehož kód chceme sdílet, vytvoříme hlavičkový soubor,
který bude obsahovat deklarace všech sdílených veřejných funkcí a globálních proměnných z daného
zdrojového souboru. Ve zdrojovém souboru pak budou jejich definice. Dle jmenné konvence se hlavičkový
soubor pojmenovává jako <code>&lt;název zdrojového souboru&gt;.h</code>:</p>
<pre><code class="language-c">// soubor.h (deklarace)
int moje_funkce();
extern int moje_promenna;

// soubor.c (definice)
int moje_funkce() {}
int moje_promenna;
</code></pre>
<p>Hlavičkový soubor tak udává tzv. <strong>rozhraní</strong> (<em>interface</em>) odpovídajícího zdrojového souboru –
obsahuje seznam funkcí a proměnných, které jsou sdílené a zbytek programu je může používat.</p>
<p>Ostatní soubory, které chtějí funkce z nějakého zdrojového souboru použít, pak
<a href="c/modularizace/../preprocesor/vkladani_souboru.html">vloží</a> jeho hlavičkový soubor pomocí preprocesoru, aby mohly
používat sdílené funkce a globální proměnné s korektní kontrolou datových typů:</p>
<pre><code class="language-c">// main.c
#include &quot;soubor.h&quot;

int main() {
    moje_funkce();
    int x = moje_promenna;

    return 0;
}
</code></pre>
<p>Pokud dojde ke změně signatury funkce či typu/názvu proměnné, tak stačí změnu udělat v hlavičkovém
(a odpovídajícím zdrojovém) souboru. Všechny ostatní soubory, které danou funkci nebo proměnnou
používají, pak budou okamžitě využívat upravenou deklaraci díky použití <code>#include</code>.</p>
<p>S hlavičkovými soubory jsme již setkali při použití <a href="c/modularizace/../funkce/stdlib.html">standardní knihovny</a>. V
souborech jako je <code>stdio.h</code> se nacházejí deklarace funkcí jako je například <code>printf</code>, jejichž definice
je poté obsažena v objektových souborech standardní knihovny.</p>
<h2><a class="header" href="#obsah-hlavičkového-souboru" id="obsah-hlavičkového-souboru">Obsah hlavičkového souboru</a></h2>
<p>Jelikož hlavičkové soubory jsou určeny k tomu, aby byly využívány (vkládány) v různých zdrojových
souborech, tak se jejich obsah přirozeně může vyskytnout ve více jednotkách překladu. Aby tak nebylo
porušeno <a href="c/modularizace/pouzivani_kodu_z_jinych_souboru.html#pravidlo-jedn%C3%A9-definice">pravidlo jedné definice</a>, je
důležité do hlavičkových souborů dávat <strong>pouze deklarace, a ne definice</strong> funkcí a proměnných!</p>
<p>Pokud byste do hlavičkového souboru dali například definici funkce, a tento soubor by se vyskytnul
ve více jednotkách překladu, tak by linkování selhalo kvůli vícenásobné definici. Pokud byste
přecejenom opravdu chtěli definici nějaké funkce &quot;propašovat&quot; do hlavičkového souboru, můžete před
ní použít klíčové slovo <code>inline</code>:</p>
<pre><code class="language-c">// soubor.h
inline void moje_funkce() { ... }
</code></pre>
<p>Tímto klíčovým slovem slibujete linkeru, že všechny definice funkce s tímto názvem jsou stejné.
Pokud tak linker narazí na definici této funkce vícekrát (což nastane, když tento hlavičkový soubor
bude vložen ve více jednotkách překladu), tak nebude hlásit chybu, ale prostě si jednu z těchto
definicí vybere. Pokud by definice stejné nebyly, může to vést k <a href="c/modularizace/../../ruzne/nedefinovane_chovani.html">nedefinovanému chování</a>
💣. Pokuste se tak <code>inline</code> raději nevyužívat.</p>
<blockquote>
<p>U (globálních) proměnných nemá smysl <code>inline</code> používat.</p>
</blockquote>
<p>Kromě deklarací funkcí a proměnných se do hlavičkových souborů také běžně vkládají struktury, které
jsou součástí typů sdílených proměnných či parametrů a návratových hodnot sdílených funkcí.</p>
<p>Aby mohly zdrojové soubory používat sdílené struktury i sdílené funkce v
<a href="c/modularizace/pouzivani_kodu_z_jinych_souboru.html#jednopr%C5%AFchodov%C3%BD-p%C5%99eklad">libovolném pořadí</a>, tak obvykle zdrojové
soubory vkládají svůj vlastní hlavičkový soubor:</p>
<pre><code class="language-c">// soubor.h
typedef struct {
    int vek;
} Osoba;

int zpracuj_osobu(Osoba osoba);

// soubor.c
#include &quot;soubor.h&quot;
int zpracuj_osobu(Osoba osoba) { ... }
</code></pre>
<p>Pro použití struktur nebo např.
<a href="c/modularizace/../struktury/struktury.html#vytv%C3%A1%C5%99en%C3%AD-nov%C3%BDch-jmen-pro-datov%C3%A9-typy"><code>typedefů</code></a> z ostatních souborů
je také běžné, že hlavičkové soubory vkládají jiné hlavičkové soubory.</p>
<h2><a class="header" href="#ochrana-vkládání" id="ochrana-vkládání">Ochrana vkládání</a></h2>
<p>U hlavičkových souborů je nutné řešit ještě jednu další věc. Jelikož se běžně používají v kombinaci
s <code>#include</code>, může se stát, že i v rámci jedné jednotky překladu se jeden hlavičkový soubor vloží do
výsledného zdrojového souboru více než jednou. To může způsobovat různé typy problémů:</p>
<ul>
<li>Pokud se budou hlavičkové soubory vkládat navzájem, mohlo by dojít k cyklické závislosti. Například
zde by překlad selhal, protože by se hlavičkové soubory snažili vložit se navzájem donekonečna:
<pre><code class="language-c">// a.h
#include &quot;b.h&quot;

// b.h
#include &quot;a.h&quot;
</code></pre>
</li>
<li>Hlavičkový soubor se zbytečně vícekrát načítá překladačem, což prodlužuje dobu překladu.</li>
<li>Pokud by hlavičkový soubor obsahoval nějakou definici, tak i kdyby byl použit pouze v jedné
jednotce překladu, došlo by k chybě při linkování, protože by definice byla zduplikovaná. </li>
</ul>
<p>Abychom těmto situacím zamezili, tak u hlavičkových souborů budeme používat tzv. <strong>ochranu vkládání</strong>
(<em>include guard</em>). Pomocí ochrany vkládání zajistíme, že jeden hlavičkový soubor se v rámci jedné
jednotky překladu vloží maximálně jednou.</p>
<p>Zamezení vícenásobného vložení můžeme dosáhnout pomocí
<a href="c/modularizace/../preprocesor/makra.html#podm%C3%ADn%C4%9Bn%C3%BD-p%C5%99eklad">podmíněného překladu</a>:</p>
<pre><code class="language-c">// soubor.h
#ifndef SOUBOR_H
#define SOUBOR_H

void moje_funkce();

#endif
</code></pre>
<p>Tohle je nicméně trochu zdlouhavé. Moderní překladače obsahují mnohem jednodušší způsob. Na začátek
hlavičkového souboru stačí vždy vložit řádek <code>#pragma once</code> a dál nemusíte nic řešit:</p>
<pre><code class="language-c">// soubor.h
#pragma once

void moje_funkce();
</code></pre>
<h1><a class="header" href="#knihovny" id="knihovny">Knihovny</a></h1>
<p>Nyní už známe vše potřebné na to, abychom si rozdělili náš vlastní program do libovolného množství
zdrojových souborů. Často také ale budeme chtít používat kód, který už před námi napsal někdo jiný.
Pokud bychom si totiž museli vše psát od nuly, tak bychom se daleko nedostali<sup class='margin-toggle sidenote-number'>1</sup>, respektive trvalo
by nám to dlouho.</p>
<span class='sidenote'><p><sup class='number'>1</sup>I když napsat si nějaký systém &quot;od nuly&quot; je dobrý způsob, jak se
<a href="c/modularizace/../co_dal.html#co-se-d%C3%A1le-nau%C4%8Dit">zlepšit v programování</a>.</p>
</span>
<p>Aby programátoři mohli sdílet svůj kód s ostatními programátory, tak využívají tzv. <strong>knihovny</strong>
(<em>libraries</em>). Knihovna je kód, který řeší nějakou ucelenou funkcionalitu (např.
<a href="https://www.libsdl.org/">vykreslování grafiky</a>, <a href="https://www.freetype.org/">sazbu fontů</a> nebo
<a href="http://zlib.net/">kompresi dat</a>) a obsahuje návod (dokumentaci), jak tento kód používat. Klíčové
vlastnosti knihoven jsou znovupoužitelnost (můžeme je použít v různých programech) a abstrakce
(nemusíme rozumět, jak knihovna funguje, pouze ji využijeme k vyřešení konkrétního problému).</p>
<blockquote>
<p>Knihovna není program – neobsahuje žádnou funkci <code>main</code> a nelze ji ani přímo spustit. V kontextu
jazyka <em>C</em> je knihovna typicky sada funkcí, struktur a globálních proměnných.</p>
</blockquote>
<p>Například pokud bychom programovali hru, můžeme využít knihovny na vykreslení grafiky, na přehrávání
zvuku, na snímání vstupu z klávesnice nebo myši atd. Náš kód se pak může zabývat zejména logikou hry
a nemusí tolik řešit problémy, které již vyřešila spousta programátorů před námi.</p>
<p>Na internetu můžete naleznout <a href="https://github.com/kozross/awesome-c">tisice různých knihoven</a>,
které řeší rozlišné problémy.</p>
<h2><a class="header" href="#sdílení-knihoven" id="sdílení-knihoven">Sdílení knihoven</a></h2>
<p>Teoreticky bychom mohli knihovny používat prostě tak, že si nějakou najdeme na internetu, stáhneme
její hlavičkové a zdrojové soubory k našemu programu a začneme je využívat. I když i tak to lze někdy
udělat, není to obvyklé, protože tento přístup má spoustu nevýhod:</p>
<ul>
<li>Jelikož obvykle nebudeme autory knihovny, kterou chceme použít, tak nemusíme ani být schopní
danou knihovnu přeložit. Potřebuje daná knihovna konkrétní překladač nebo jeho specifické nastavení?
Má závislosti na dalších knihovnách? Přeložit &quot;cizí&quot; knihovnu ze zdrojových souborů nemusí být
zdaleka přímočaré.</li>
<li>Pokud dojde k vydání nové verze knihovny, která může přinášet opravy chyb a novou funkcionalitu,
museli bychom (kromě potenciální úpravy našeho kódu) také překopírovat nebo správně upravit nové a
změněné soubory knihovny, což by bylo náročné a náchylné na chyby.</li>
<li>Zdrojový kód knihoven není vždy zveřejněn, například aby si jejich autoři uchránili duševní
vlastnictví. Často se tak setkáme se situací, že máme k dispozici pouze objektový kód (např. <code>.so</code>
nebo <code>.dll</code>) a nemůžeme tak získat zdrojové soubory knihovny.</li>
</ul>
<p>Z tohoto důvodu jsou knihovny obvykle sdíleny ve formě objektových souborů (ty obsahují implementaci
funkcí) a odpovídajících hlavičkových souborů (ty obsahují
<a href="c/modularizace/pouzivani_kodu_z_jinych_souboru.html#deklarace-vs-definice">deklarace</a>, aby šlo knihovnu jednoduše
používat).</p>
<h2><a class="header" href="#statické-vs-dynamické-knihovny" id="statické-vs-dynamické-knihovny">Statické vs dynamické knihovny</a></h2>
<p>Předávat překladači desítky či stovky objektových souborů by bylo docela nepraktické, proto se tyto
soubory při distribuci knihovny balí do jednoho či více archivů, které mají standardizovaný formát
a překladače s nimi umí přímo pracovat. Knihovna může být distribuována v jednom ze dvou typů archivů,
které určují to, jak bude daná knihovna &quot;přilinkována&quot; (připojena) k našemu programu:</p>
<ul>
<li>
<p><strong>Dynamická knihovna</strong> (<em>dynamic library</em>) - objektové soubory takovéto knihovny nebudou součástí
našeho programu (tj. nebudou obsaženy ve spustitelném souboru, který bude vytvořen překladačem).
K jejich načtení dojde až &quot;dynamicky&quot; při spuštění programu<sup class='margin-toggle sidenote-number'>2</sup>.</p>
<span class='sidenote'><p><sup class='number'>2</sup>O toto načítání se stará tzv. <a href="https://man7.org/linux/man-pages/man8/ld.so.8.html">dynamický linker</a>.</p>
</span>
<p>Výhody tohoto přístupu jsou, že bude mít náš spustitelný soubor menší velikost, a to jak na disku,
tak v operační paměti. Operační systémy totiž dokážou stejnou dynamickou knihovnu částečně sdílet
mezi více běžícími programy najednou. Dynamickou knihovnu také půjde aktualizovat bez nutnosti
překládat znovu náš program a můžeme také při spuštění programu knihovnu
<a href="https://stackoverflow.com/questions/426230/what-is-the-ld-preload-trick">nahradit jinou implementací</a>.</p>
<p>Nevýhodou je, že při spuštění našeho programu musíme zajistit, že knihovna bude na daném systému
k dispozici (pokud by nebyla nalezena, tak program nepůjde spustit). To může způsobovat problémy
zejména při distribuci našeho programu na jiné počítače. Kvůli tomu, že se knihovna načítá
dynamicky, také může v určitých případech být její použití méně efektivní než v případě statické
knihovny.</p>
<p>Archivy s objektovými soubory dynamických knihoven mají příponu <code>.so</code>.</p>
</li>
<li>
<p><strong>Statická knihovna</strong> (<em>static library</em>) - objektové soubory takovéto knihovny budou přímo přibaleny
k našemu programu (jako bychom je přímo jeden po druhém předali překladači).</p>
<p>Výhody tohoto přístupu jsou, že náš program bude &quot;samostatný&quot; – knihovnu bude obsahovat uvnitř
svého spustitelného souboru, takže nebude nutné ji mít dostupnou na cílovém systému (narozdíl
od dynamické knihovny).</p>
<p>Nevýhodou je, že výsledný spustitelný soubor bude větší a knihovnu nepůjde aktualizovat bez
opětovného překladu celého programu.</p>
<p>Archivy s objektovými soubory statických knihoven mají příponu <code>.a</code>.</p>
</li>
</ul>
<blockquote>
<p>Názvy přípon statických a dynamických knihoven závisí na operačním systému. Například na Windows
se můžete setkat s příponami <code>.lib</code> pro statické knihovny a <code>.dll</code> pro dynamické knihovny.</p>
</blockquote>
<h2><a class="header" href="#použití-knihoven-s-gcc" id="použití-knihoven-s-gcc">Použití knihoven s GCC</a></h2>
<p>Nyní si ukážeme, jak říct překladači GCC, aby připojil nějakou knihovnu k našemu programu. Pro to
musíme mít k dispozici archiv s objektovými soubory knihovny (s příponou <code>.a</code> nebo <code>.so</code>, v
závislosti na typu knihovny) a obvykle také i adresář s hlavičkovými soubory knihovny.</p>
<p>Nejprve si ukážeme, jak překladači předat cestu k hlavičkovým souborům knihovny. Ty obvykle nebudou
součástí našich zdrojových kódů, ale budou nainstalovány v nějakém systémovém adresáři (jako tomu je
např. u <code>stdio.h</code>). Budeme je tedy chtít <a href="c/modularizace/../preprocesor/vkladani_souboru.html">vkládat</a> pomocí syntaxe
<code>#include &lt;&gt;</code>. Překladači můžeme předat dodatečné adresáře, ve kterých má hledat (hlavičkové) soubory
pro vkládání, pomocí přepínače <code>-I</code>. Pokud bychom tak měli hlavičkové soubory knihovny např. v
adresáři <code>/usr/foo/include</code>, tak překladači při překladu předáme přepínač <code>-I/usr/foo/include</code>.</p>
<p>Dále je třeba překladači říct, které archivy s objektovými soubory knihovny má k našemu programu
přilinkovat. K tomu slouží dva přepínače. <code>-L</code> udává adresář, ve kterém se budou vyhledávat knihovny
a <code>-l</code> poté specifikuje konkrétní knihovnu, která má být přilinkována k našemu programu. Pokud bychom
tak měli například archiv knihovny v souboru <code>/usr/foo/lib/libknihovna.so</code>, tak překladači předáme
parametry<code>-L/usr/foo/lib</code> a <code>-lknihovna</code>. Při použití přepínače <code>-l</code> je třeba si dávat pozor na dvě
věci:</p>
<ul>
<li>Všimněte si, že se použila zkrácená konvence pro pojmenování knihovny. Obecně se knihovny
pojmenovávají <code>lib&lt;název&gt;.so</code> (nebo <code>lib&lt;název&gt;.a</code>) a překladači se poté předává pouze jejich název,
tj. <code>-l&lt;název&gt;</code>.</li>
<li>Přepínač <code>-l</code> se aplikuje na zdrojové/objektové soubory, které byly v příkazové řádce zadány před
ním. Používejte jej tedy až po předání vašich zdrojových souborů:
<pre><code class="language-bash"># správně
$ gcc main.c -lknihovna

# špatně
$ gcc -lknihovna main.c
</code></pre>
</li>
</ul>
<p>Celý příkaz pro připojení knihovny k vašemu programu by tak mohl vypadat např. takto:</p>
<pre><code class="language-bash">$ gcc -o program main.c -L/usr/foo/lib/ -lfoo -I/usr/foo/include
</code></pre>
<h3><a class="header" href="#předání-cesty-k-dynamické-knihovně" id="předání-cesty-k-dynamické-knihovně">Předání cesty k dynamické knihovně</a></h3>
<p>Pokud přeložíte program s dynamickou knihovnou, může se stát, že při jeho spuštění nebude schopen
danou knihovnu najít. V takovém případě při spuštění programu můžete pomocí
<a href="https://cs.wikipedia.org/wiki/Prom%C4%9Bnn%C3%A1_prost%C5%99ed%C3%AD"><strong>proměnné prostředí</strong></a><sup class='margin-toggle sidenote-number'>3</sup>
(<em>environment variable</em>) <code>LD_LIBRARY_PATH</code> předat cestu k adresáři, ve které se daná knihovna nachází:</p>
<span class='sidenote'><p><sup class='number'>3</sup>Proměnné prostředí jsou způsobem, jak předávat parametry programům (podobně jako
například <a href="c/modularizace/../../ruzne/funkce_main.html#vstupn%C3%AD-parametry-funkce-main">parametry příkazového řádku</a>).
V programu si můžete přečíst hodnotu konkrétní proměnné prostředí pomocí funkce
<a href="https://devdocs.io/c/program/getenv"><code>getenv</code></a>.</p>
</span>
<pre><code class="language-bash">$ LD_LIBRARY_PATH=/usr/foo/lib ./program
</code></pre>
<h3><a class="header" href="#zobrazení-vyžadovaných-dynamických-knihoven" id="zobrazení-vyžadovaných-dynamických-knihoven">Zobrazení vyžadovaných dynamických knihoven</a></h3>
<p>Pokud si přeložíte nějaký program a použijete na něj program <code>ldd</code>, dozvíte se, které dynamické
knihovny vyžaduje ke svému běhu. Měli byste mezi nimi naleznout mj. i
<a href="c/modularizace/../funkce/stdlib.html">standardní knihovnu <em>C</em></a> (<code>libc</code>) a dozvědět se tak její umístění na disku:</p>
<pre><code class="language-bash">$ ldd ./program
libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007f0d3a328000)
</code></pre>
<blockquote>
<p><a href="c/modularizace/../funkce/stdlib.html">Standardní knihovna jazyka <em>C</em></a> je používána téměř každým programem a i z
tohoto důvodu je obvykle linkována dynamicky, aby její paměť šla sdílet mezi programy.</p>
</blockquote>
<h2><a class="header" href="#vytvoření-knihovny" id="vytvoření-knihovny">Vytvoření knihovny</a></h2>
<p>Pokud byste si chtěli vytvořit vlastní knihovnu, můžete toho jednoduše dosáhnout pomocí GCC. Dejme
tomu, že máte soubory <code>a.c</code> a <code>b.c</code>, které chcete zabalit do knihovny. Nejprve každý zdrojový soubor
přeložíme do objektového souboru<sup class='margin-toggle sidenote-number'>4</sup>:</p>
<span class='sidenote'><p><sup class='number'>4</sup>Parametr <code>-fPIC</code> je nutný při překladu zdrojových souborů, které poté chceme umístit do
knihovny. Více se můžete dozvědět např. <a href="https://stackoverflow.com/a/5311538/1107768">zde</a>.</p>
</span>
<pre><code class="language-bash">$ gcc -c -fPIC a.c
$ gcc -c -fPIC b.c
</code></pre>
<p>Další postup závisí na tom, jaký typ knihovny chceme vytvořit:</p>
<ul>
<li><strong>Vytvoření statické knihovny</strong> - použijeme program <code>ar</code> (archiver):
<pre><code class="language-bash">$ ar rcs libknihovna.a a.o b.o
</code></pre>
</li>
<li><strong>Vytvoření dynamické knihovny</strong> - použijeme program <code>gcc</code> s přepínačem <code>-shared</code>:
<pre><code class="language-bash">$ gcc -shared a.o b.o -o libknihovna.so
</code></pre>
</li>
</ul>
<h1><a class="header" href="#automatizace-překladu" id="automatizace-překladu">Automatizace překladu</a></h1>
<p>Možná vás napadlo, že v případě rozdělení programu do více zdrojových souborů a při použití knihoven
začne být docela namáhavé náš program vůbec přeložit. Musíme přeložit zvlášť každou
<a href="c/modularizace/linker.html#p%C5%99eklad-programu">jednotku překladu</a>, nakonec je všechny slinkovat dohromady
a případně ještě předat potřebné cesty k použitým knihovnám. A toto je třeba po jakékoliv změně v
kódu našeho programu, pokud ji budeme chtít otestovat.</p>
<p>Tento problém se dá řešit různými způsoby, od vytvoření <a href="https://en.wikipedia.org/wiki/Shell_script">shell skriptu</a>,
pomocí kterého můžeme všechny tyto úkony provést pomocí jediného příkazu v terminálu, až po pokročilé
<strong>sestavovací systémy</strong> (<em>build systems</em>), které umí automaticky vyhledávat cesty ke knihovnám a
překládat pouze změněné soubory pro urychlení opakovaných překladů programu.</p>
<p>Bohužel neexistuje jednotný standardní sestavovací systém pro programy napsané v <em>C</em>. Různé projekty
či knihovny tak používají různé sestavovací systémy, což může někdy představovat problém při jejich
integraci do našich programů. Sestavovací systémy se navíc obvykle nastavují pomocí konfiguračních
souborů, které jsou psány v proprietárních jazycích, které se musíte naučit a pochopit, abyste daný
sestavovací systém mohli používat. Situaci nepomáhá ani to, že se od sebe jednotlivé systémy značně
liší a bývají velmi komplikované. </p>
<h2><a class="header" href="#a-hrefhttpsenwikipediaorgwikimake_softwaremakea" id="a-hrefhttpsenwikipediaorgwikimake_softwaremakea"><a href="https://en.wikipedia.org/wiki/Make_(software)">make</a></a></h2>
<p>Asi stále nejpoužívanějším sestavovacím systémem pro programy v jazyce <em>C</em> je <code>make</code>, který existuje již od roku 1976.
Pro jeho použití musíte vytvořit soubor <code>Makefile</code>, ve kterém popíšete, jak se má váš program přeložit, a poté
spustíte program <code>make</code>, který jej dle konfiguračního souboru přeloží.</p>
<p>Návod pro vytvoření konfiguračního souboru <code>Makefile</code> a použití <code>make</code> naleznete například
<a href="https://www.itnetwork.cz/cecko/linux/tutorial-c-linux-makefile">zde</a>.</p>
<h2><a class="header" href="#cmake" id="cmake"><code>CMake</code></a></h2>
<p>Poněkud modernější alternativou je <a href="https://cmake.org/"><code>CMake</code></a>. Jedná se o tzv. meta systém, ve
skutečnosti totiž neřídí překlad vašeho programu, ale pouze generuje potřebné soubory pro nějaký
jiný sestavovací systém, který váš program teprve přeloží. Výhodou pak je, že z jednoho <code>CMake</code>
konfiguračního souboru tak můžete vygenerovat např. <code>Makefile</code> pro přeložení na Linuxu anebo jiné
konfigurační soubory pro přeložení stejného programu pod Windows.</p>
<p>Další výhodou <code>CMake</code> je, že některá vývojová prostředí (např.
<a href="c/../prostredi/editor/vscode.html">Visual Studio Code</a> nebo <a href="c/../prostredi/editor/clion.html">CLion</a>)
mu rozumí a dokáží díky němu usnadnit analýzu a ladění vašich programů.</p>
<h3><a class="header" href="#instalace" id="instalace">Instalace</a></h3>
<p><code>CMake</code> můžete na Ubuntu nainstalovat následujícím příkazem v terminálu:</p>
<pre><code class="language-bash">$ sudo apt update
$ sudo apt install cmake
</code></pre>
<h3><a class="header" href="#použití" id="použití">Použití</a></h3>
<p>Pro použití <code>CMake</code> musíte vytvořit konfigurační soubor <code>CMakeLists.txt</code>, ve kterém popíšete jednotlivé
zdrojové soubory vašeho programu, a také zadáte knihovny, které chcete k vašemu programu připojit.</p>
<p>Minimální soubor <code>CMakeLists.txt</code> může vypadat např. takto:</p>
<pre><code class="language-cmake"># Minimální požadovaná verze CMaku
cmake_minimum_required(VERSION 3.12)

# Název projektu
project(projektupr C)

# Vytvoření programu s názvem `du1`
# Program se bude skládat ze dvou zadaných zdrojových souborů (jednotek překladu).
# Pokud chcete do programu přidat více zdrojových souborů,
# přidejte je do tohoto seznamu.
add_executable(du1 main.c funkce.c)
</code></pre>
<p>Zde je ukázka trochu komplexnějšího souboru pro sestavení <a href="c/aplikovane_ulohy/sdl.html#nastaven%C3%AD-sdl-pomoc%C3%AD-cmake">SDL</a> aplikace:</p>
<pre><code class="language-cmake">cmake_minimum_required(VERSION 3.12)

project(hra C)

# Přidání přepínačů překladače
set(CMAKE_C_FLAGS &quot;${CMAKE_C_FLAGS} -fsanitize=address&quot;)

# Vyhledání knihovny SDL
find_package(SDL2)

# Vytvoření programu s názvem `hra`
add_executable(hra hra.c grafika.c)

# Přidání adresářů s hlavičkovými soubory k programu (obdoba -I)
target_include_directories(hra PRIVATE ${SDL2_INCLUDE_DIRS})

# Přilinkování knihoven k programu (obdoba -l)
target_link_libraries(hra ${SDL2_LIBRARIES} m)
</code></pre>
<p>Jakmile tento soubor vytvoříte, můžete pomocí příkazu <code>cmake</code> vytvořit <code>Makefile</code>:</p>
<pre><code class="language-bash"># Jsme ve složce s CMakeLists.txt
# Vytvoříme složku pro sestavení projektu
$ mkdir build
# Přepneme se do složky
$ cd build
# Sestavíme Makefile
$ cmake ..
</code></pre>
<p>a poté pomocí <code>make</code> program finálně přeložit:</p>
<pre><code class="language-bash">$ make
</code></pre>
<p>Dobrá zpráva je, že pokud používáte kompatibilní vývojové prostředí, tak tyto úkony typicky provádí
za vás a vám tak stačí správně nastavit soubor <code>CMakeLists.txt</code>.</p>
<p>Návod k použití <code>CMake</code> naleznete například <a href="https://cmake.org/cmake/help/latest/guide/tutorial/index.html">zde</a>.</p>
<h3><a class="header" href="#použití-ve-visual-studio-code" id="použití-ve-visual-studio-code">Použití ve Visual Studio Code</a></h3>
<p>Pokud chcete spustit či ladit <code>CMake</code> projekt ve VS Code, tak proveďte tyto kroky:</p>
<ol>
<li>Nainstalujte si <a href="https://marketplace.visualstudio.com/items?itemName=ms-vscode.cmake-tools">toto</a> rozšíření do VS Code</li>
<li>Otevřete ve VS Code adresář, který bude obsahovat soubor <code>CMakeLists.txt</code></li>
<li>Spusťte program pomocí <code>Ctrl + F5</code></li>
</ol>
<h1><a class="header" href="#Úlohy" id="Úlohy">Úlohy</a></h1>
<p>V této sekci si ukážeme několik jednoduchých aplikovaných přístupů a knihoven, které můžete použít
například na:</p>
<ul>
<li>Práci s obrázky pomocí formátu <a href="c/aplikovane_ulohy/tga.html">TGA</a>.</li>
<li>Práci s animacemi pomocí formátu <a href="c/aplikovane_ulohy/gif.html">GIF</a>.</li>
<li>Tvorbě interaktivních aplikací a her pomocí knihovny <a href="c/aplikovane_ulohy/sdl.html">SDL</a>.</li>
<li>Simulaci fyzikálních procesů pomocí knihovny <a href="c/aplikovane_ulohy/chipmunk.html">Chipmunk</a>.</li>
</ul>
<h1><a class="header" href="#tga" id="tga">TGA</a></h1>
<p><a href="https://en.wikipedia.org/wiki/Truevision_TGA">TGA</a> je formát pro ukládání rastrových obrázků na
disk. Slouží tedy ke stejnému účelu jako známější formáty <code>JPEG</code> nebo <code>PNG</code>, ale oproti nim je
mnohem jednodušší. Díky tomu můžeme načíst i zapsat <code>TGA</code> soubor pomocí několika řádků kódu, zatímco
např. u <code>JPEG</code> nebo <code>PNG</code> bychom potřebovali buď použít již existující knihovnu anebo naimplementovat
jejich relativně komplikované standardy, které čítají stovky stránek.</p>
<p>TGA soubory jsou uloženy v binárním formátu, což znamená, že do nich budeme číselné hodnoty ukládat ve formátu,
v jakém jsou uloženy v paměti programu, a nebudeme je formátovat pomocí textových kódování, např. ASCII. To sice
znamená, že obsah TGA souboru nebude v &quot;lidsky čitelném formátu&quot;, nicméně zároveň nám to i částečně usnadní programatické
čtení a zápis těchto souborů.</p>
<h2><a class="header" href="#hlavička-tga" id="hlavička-tga">Hlavička <code>TGA</code></a></h2>
<p>Soubory ve formátu <code>TGA</code> obsahují na svém začátku tzv. <strong>hlavičku</strong> (<em>header</em>), která obsahuje informace
popisující daný obrázek. Tyto informace jsou reprezentovány byty, které jsou umístěny na pevně
daných pozicích. Zde je seznam jednotlivých částí hlavičky TGA:</p>
<table><thead><tr><th align="center">Název</th><th align="center">Pozice prvního bytu</th><th align="center">Počet bytů</th></tr></thead><tbody>
<tr><td align="center">ID</td><td align="center">0</td><td align="center">1</td></tr>
<tr><td align="center">Typ barevné mapy</td><td align="center">1</td><td align="center">1</td></tr>
<tr><td align="center"><strong>Typ obrázku</strong></td><td align="center">2</td><td align="center">1</td></tr>
<tr><td align="center">Barevná mapa</td><td align="center">3</td><td align="center">5</td></tr>
<tr><td align="center">Počátek X</td><td align="center">8</td><td align="center">2</td></tr>
<tr><td align="center">Počátek Y</td><td align="center">10</td><td align="center">2</td></tr>
<tr><td align="center"><strong>Šířka</strong></td><td align="center">12</td><td align="center">2</td></tr>
<tr><td align="center"><strong>Výška</strong></td><td align="center">14</td><td align="center">2</td></tr>
<tr><td align="center"><strong>Barevná hloubka</strong></td><td align="center">16</td><td align="center">1</td></tr>
<tr><td align="center">Popisovač</td><td align="center">17</td><td align="center">1</td></tr>
</tbody></table>
<p>Tato tabulka udává, jak máme interpretovat jednotlivé byty na začátku <code>TGA</code> souboru. Pokud bychom tedy
například otevřeli <code>TGA</code> soubor a přečteli si jeho 12. a 13. byte, tak se dozvíme šířku tohoto obrázku. 
Nás budou zajímat zejména tučně vyznačené části:</p>
<ul>
<li><strong>Typ obrázku</strong>: Hodnota <code>2</code> udává nekomprimovaný RGB obrázek, hodnota <code>3</code> udává nekomprimovaný
obrázek ve stupních šedi (&quot;černobílý&quot; obrázek). Ostatní platné hodnoty typu obrázku můžete nalézt
např. na <a href="https://en.wikipedia.org/wiki/Truevision_TGA">Wikipedii</a>.</li>
<li><strong>Rozměry</strong>: Tato část hlavičky určuje rozměry obrázku. Každý rozměr (<strong>šířka</strong> i <strong>výška</strong>) zabírá
dva byty (aby formát podporoval i obrázky s rozměry většími než 255 pixelů).</li>
<li><strong>Barevná hloubka</strong>: Udává, kolik bitů bude zabírat každý pixel obrázku. Pokud použijeme typ obrázku
RGB (typ <code>2</code>), měli bychom použít hloubku 24 bitů (8 bitů na každou barevnou složku), pokud použijeme typ
obrázku ve stupních šedi (typ <code>3</code>), tak použijeme hloubku 8 bitů.</li>
</ul>
<blockquote>
<p>Při načítání binárních dat ze souborů musíme dávat pozor na to, jestli jsou hodnoty uloženy v
<strong>little-endian</strong> nebo <strong>big-endian</strong> formátu. U <code>TGA</code> je určeno, že musí být v little-endian, což je
zároveň s velkou pravděpodobností i formát, který používá vás počítač, nemusíme tedy provádět žádnou
konverzi. Více o tzv. <strong>endianness</strong> můžete nalézt např. <a href="https://en.wikipedia.org/wiki/Endianness">zde</a>.</p>
</blockquote>
<h2><a class="header" href="#načtení-hlavičky-ze-souboru" id="načtení-hlavičky-ze-souboru">Načtení hlavičky ze souboru</a></h2>
<p>Jednotlivé části z hlavičky bychom mohli načítat byte po bytu, nicméně to by bylo dosti nepraktické.
V případě, že formát, který chceme načíst, má pevně dané rozložení bytů, je mnohem jednodušší
nadefinovat si <a href="c/aplikovane_ulohy/../struktury/struktury.html">strukturu</a>, která bude danému rozložení odpovídat, a poté
celou strukturu načíst ze souboru najednou.</p>
<p>Jednotlivé hodnoty v hlavičce jsou reprezentovány byty bez znaménka. Jelikož tento datový typ v <em>C</em>
má trochu zdlouhavý název, vytvořme si pro něj nejprve nové jméno <code>byte</code>:</p>
<pre><code class="language-c">typedef unsigned char byte;
</code></pre>
<p>Nyní si vytvořme strukturu, která bude reprezentovat <code>TGA</code> hlavičku. Jednotlivé atributy struktury
musí přesně odpovídat hodnotám v hlavičce a musí být také uvedeny ve stejném pořadí:</p>
<pre><code class="language-c">typedef struct {
    byte id_length;
    byte color_map_type;
    byte image_type;
    byte color_map[5];
    byte x_origin[2];
    byte y_origin[2];
    byte width[2];
    byte height[2];
    byte depth;
    byte descriptor;
} TGAHeader;
</code></pre>
<blockquote>
<p>Možná vám přijde zvláštní, proč např. šířku definujeme jako pole dvou bytů namísto použití
&quot;dvou-bajtového celého čísla&quot;, např. datového typu <code>uint16_t</code>. Děláme to, aby do této struktury překladač
nevložil žádné <a href="c/aplikovane_ulohy/../struktury/pametova_reprezentace.html#struktury-a-zarovn%C3%A1n%C3%AD">mezery</a>. Pokud by je tam
vložil, tak by naše struktura v paměti už neodpovídala hlavičce <code>TGA</code> v souboru a četli bychom tak
neplatné hodnoty. Když použijeme pro všechny atributy datový typ s velikostí 1 byte, tak překladač
žádné mezery vkládat nebude.</p>
<p>Alternativním řešením by bylo říct překladači, ať do dané struktury žádné mezery
<a href="https://stackoverflow.com/a/40642888/1107768">nevkládá</a>.</p>
</blockquote>
<p>Nyní už stačí pouze otevřít nějaký <code>TGA</code> soubor (např. <a href="c/aplikovane_ulohy/../../static/img/carmack.tga">tento</a>),
<a href="c/aplikovane_ulohy/../soubory/cteni_ze_souboru.html">načíst</a> z něj počet bytů odpovídající naší struktuře
a poté si z ní můžeme přečíst informace o daném obrázku:</p>
<pre><code class="language-c mainbody">#include &lt;stdio.h&gt;
#include &lt;assert.h&gt;

int main() {
    FILE* file = fopen(&quot;carmack.tga&quot;, &quot;rb&quot;);
    assert(file);

    TGAHeader header = {};
    assert(fread(&amp;header, sizeof(TGAHeader), 1, file) == 1);

    printf(&quot;Image type: %d, pixel depth: %d\n&quot;, header.image_type, header.depth);

    return 0;
}
</code></pre>
<p>Pokud budeme chtít pracovat s hodnotami rozměrů, musíme je nejprve převést z pole bytů
na celé číslo. Toho můžeme dosáhnout pomocí funkce <a href="https://devdocs.io/c/string/byte/memcpy"><code>memcpy</code></a>:</p>
<pre><code class="language-c">int width = 0;
int height = 0;

memcpy(&amp;width, header-&gt;width, 2);
memcpy(&amp;height, header-&gt;height, 2);
</code></pre>
<blockquote>
<p>Datový typ <code>int</code> sice velmi pravděpodobně bude mít více bytů, než <code>2</code> (pravděpodobně bude mít <code>4</code> byty), ale jelikož
v paměti i v souboru jsou data uložena ve formátu &quot;little-endian&quot;, tak stačí do <code>int</code>u načíst dva byty, a bude to fungovat
tak, jak očekáváme. <strong>Musíme však nejprve proměnnou <code>int</code>u inicializovat na nulu, jinak by vyšší dva byty měly nedefinovanou
hodnotu!</strong></p>
</blockquote>
<h2><a class="header" href="#načtení-pixelů-ze-souboru" id="načtení-pixelů-ze-souboru">Načtení pixelů ze souboru</a></h2>
<p>Jakmile jsme načetli hlavičku, můžeme načíst ze souboru i samotné pixely. Ty jsou umístěny v souboru
hned za hlavičkou, řádek po řádku, zleva doprava a shora dolů. To znamená, že pixel v levém horním rohu obrázku je v souboru
uložen jako první, tj. hned za hlavičkou, zatímco pixel v pravém dolním rohu obrázku je v souboru uložen jako poslední,
na úplném konci souboru. Každý pixel má odpovídající počet bytů podle typu obrázku (u RGB obrázků 3 byty<sup class='margin-toggle sidenote-number'>1</sup>,
u obrázků ve stupních šedi 1 byte) a celkový počet pixelů je poté dán rozměry obrázku (<code>šířka * výška</code>).</p>
<span class='sidenote'><p><sup class='number'>1</sup>V <code>TGA</code> jsou jednotlivé barevné složky uložené v pořadí <code>blue</code>, <code>green</code>, <code>red</code>. Jedná se tedy
vlastně o formát BGR.</p>
</span>
<p>Můžeme si tak vytvořit pole pro pixely a načíst je z obrázku. Pro RGB obrázky by načtení pixelů
mohlo vypadat např. takto: </p>
<pre><code class="language-c">typedef struct {
    byte blue;
    byte green;
    byte red;
} Pixel;

Pixel* load_pixels(TGAHeader header, FILE* file) {
    int width = 0;
    int height = 0;

    memcpy(&amp;width, header.width, 2);
    memcpy(&amp;height, header.height, 2);

    Pixel* pixels = (Pixel*) malloc(sizeof(Pixel) * width * height);
    assert(fread(pixels, sizeof(Pixel) * width * height, 1, file) == 1);
    return pixels;
}
</code></pre>
<h2><a class="header" href="#práce-s-pixely" id="práce-s-pixely">Práce s pixely</a></h2>
<p>Jakmile máme načtené pixely v mřížce (poli pixelů) v paměti, tak s nimi můžeme pracovat jako s
<a href="c/aplikovane_ulohy/../pole/vicerozmerna_pole.html">vícerozměrným polem</a>. Pokud bychom například prošli všechny hodnoty pixelů, a nastavili
jejich barevnou složku <code>red</code> (reprezentující červenou barvu) na hodnotu <code>0</code>, tak z obrázku zcela odstraníme červenou barvu:</p>
<pre><code class="language-c">Pixel* pixels = load_pixels(header, file);
for (int row = 0; row &lt; height; row++) {
    for (int col = 0; col &lt; width; col++) {
        Pixel* pixel = pixels + (row * width + col);
        pixel-&gt;red = 0;
    }
}
</code></pre>
<h2><a class="header" href="#zapsání-tga-do-souboru" id="zapsání-tga-do-souboru">Zapsání <code>TGA</code> do souboru</a></h2>
<p>Jakmile jsme nějakým způsobem upravili obsah načteného TGA obrázku (nebo si vytvořili prázdný TGA obrázek v paměti a něco
do něj nakreslili), tak musíme pixely z paměti zapsat zpět do <code>TGA</code> souboru na disku, abychom si obrázek mohli prohlédnout
v nějakém prohlížeči či editoru obrázků. Zápis bude probíhat v podstatě úplně stejně, jako načtení obrázku. Otevřeme
soubor pro zápis, uložíme do něj binárně (pomocí funkce <a href="c/aplikovane_ulohy/../soubory/zapis_do_souboru.html#z%C3%A1pis-do-souboru"><code>fwrite</code></a>)
TGA hlavičku, a hned za ní do něj opět binárně zapíšeme všechny pixely obrázku z paměti, řádek po řádku.</p>
<h1><a class="header" href="#gif" id="gif">GIF</a></h1>
<p><a href="https://en.wikipedia.org/wiki/GIF">GIF</a> je velmi populární formát pro sdílení animací. <code>GIF</code> animace
se skládá z jednoho nebo více tzv. <strong>snímků</strong> (<em>frames</em>), které mají určenou délku, po kterou se mají
zobrazit. Při přehrání animace se pak jednotlivé snímky zobrazují postupně jeden za druhým, což
vytváří dojem animace.</p>
<p>Pořád se jedná o relativně jednoduchý formát, nicméně je už trošku složitější než např. <a href="c/aplikovane_ulohy/tga.html">TGA</a>,
protože používá kompresi a pixely nejsou uloženy v souboru přímo, místo toho je každý pixel reprezentován
indexem do tabulky (palety) předpřipravených barev.</p>
<p>Pro vytvoření <code>GIF</code> animace tak použijeme kód, který už pro nás připravil někdo jiný. Konkrétně se
bude jednat o <a href="https://github.com/lecram/gifenc">knihovnu <code>gifenc</code></a><sup class='margin-toggle sidenote-number'>1</sup>. Stáhněte si soubory
<code>gifenc.c</code> a <code>gifenc.h</code> a použijte je při <a href="c/aplikovane_ulohy/../modularizace/pouzivani_kodu_z_jinych_souboru.html">překladu</a>
svého programu.</p>
<span class='sidenote'><p><sup class='number'>1</sup>I když jsme se předtím bavili o tom, že sdílet knihovny ve formě zdrojových kódů není
<a href="c/aplikovane_ulohy/../modularizace/knihovny.html#sd%C3%ADlen%C3%AD-knihoven">úplně běžné</a>, tato knihovna je velmi malá a
jednoduchá a zároveň je open-source, takže zkopírovat její zdrojové kódy do našeho programu je asi
nejjednodušší způsob, jak ji použít.</p>
</span>
<h2><a class="header" href="#vytvoření-gif-animace" id="vytvoření-gif-animace">Vytvoření <code>GIF</code> animace</a></h2>
<p>Pro práci s <code>GIF</code> souborem si nejprve musíme nadefinovat tzv. <strong>paletu</strong> (<em>palette</em>). Paleta není
nic jiného než pole barev, které můžeme v naší animaci používat. Jednotlivým pixelům každého snímku
pak pouze řekneme, jaký index z této palety se má použít pro jejich vykreslení. Například tato paleta
definuje čtyři barvy:</p>
<pre><code class="language-c">typedef unsigned char byte;

byte palette[] = {
    0x00, 0x00, 0x00, /* 0 -&gt; černá   (R=0, G=0, B=0)   */
    0xFF, 0x00, 0x00, /* 1 -&gt; červená (R=255, G=0, B=0) */
    0x00, 0xFF, 0x00, /* 2 -&gt; zelená  (R=0, G=255, B=0) */
    0x00, 0x00, 0xFF, /* 3 -&gt; modrá   (R=0, G=0, B=255) */
};
</code></pre>
<p>Pokud použijeme pro pixel index <code>1</code>, bude vykreslen červenou barvou, protože v této paletě se na
pozici <code>1</code> nachází červená barva.</p>
<p>Jakmile máme nadefinovanou paletu, můžeme použít funkci <code>ge_new_gif</code>, která umožňuje vytvořit nový
<code>GIF</code> soubor. Funkci musíme předat cestu k výstupnímu souboru, jeho rozměry, informace o paletě a o
tom, kolikrát se má animace přehrát<sup class='margin-toggle sidenote-number'>2</sup>:</p>
<span class='sidenote'><p><sup class='number'>2</sup>Pro použití hlavičkového souboru knihovny nezapomeňte na začátku svého programu
<a href="c/aplikovane_ulohy/../preprocesor/vkladani_souboru.html">vložit</a> <a href="c/aplikovane_ulohy/../modularizace/hlavickove_soubory.html">hlavičkový soubor</a>
<code>gifenc.h</code>.</p>
</span>
<pre><code class="language-c">int width = 300;
int height = 300;

ge_GIF* gif = ge_new_gif(
    &quot;output.gif&quot;,
    width,
    height,
    palette,
    2,  /* hloubka palety */
    0   /* opakovat neustále dokola */
);
</code></pre>
<p>Parametr hloubky palety by měl být nastaven na dvojkový logaritmus počtu baret v paletě. V naší
paletě jsou 4 barvy, takže jsme zde předali hodnotu parametru <code>2</code>. Poslední parametr udává, kolikrát
se má animace přehrát. Hodnota <code>0</code> udává, že se má animace opakovat neustále dokola<sup class='margin-toggle sidenote-number'>3</sup>.</p>
<span class='sidenote'><p><sup class='number'>3</sup>Všechny tyto údaje lze vyčíst z <a href="https://github.com/lecram/gifenc/blob/master/README#L25">dokumentace</a>
knihovny.</p>
</span>
<h3><a class="header" href="#zápis-snímků" id="zápis-snímků">Zápis snímků</a></h3>
<p>Když nyní máme vytvořenou animaci, můžeme do ní postupně zapisovat snímky. Zápis probíhá následovně:</p>
<ol>
<li>Do pole uloženého v atributu <code>gif-&gt;frame</code> zapíšeme hodnoty všech pixelů jednoho snímku.
Každá hodnota by měla být indexem odpovídající barvy z námi zvolené palety. Pro adresování použijeme
klasický převod z <a href="c/aplikovane_ulohy/../pole/vicerozmerna_pole.html#indexov%C3%A1n%C3%AD">2D na 1D index</a>.</li>
<li>Zavoláme funkci <code>ge_add_frame</code>, které řekneme, na jak dlouhou dobu se má tento snímek zobrazit.
Tato doba je v setinách vteřiny.</li>
</ol>
<p>Jakmile zapíšeme jeden snímek, můžeme celý proces opakovat pro zápis dalších snímků.</p>
<p>Uhodnete, jakou animaci vygeneruje následující kód<sup class='margin-toggle sidenote-number'>4</sup>?</p>
<span class='sidenote'><p><sup class='number'>4</sup>Pro ověření tipu si program přeložte a podívejte se na výslednou animaci. Zakomentujte řádek
s <code>memset</code> a zkuste odhadnout, jak a proč to změní výslednou animaci.</p>
</span>
<pre><code class="language-c">for (int i = 0; i &lt; 100; i++) {
    memset(gif-&gt;frame, 0, sizeof(uint8_t) * width * height);

    for (int row = 0; row &lt; height; row++) {
        gif-&gt;frame[row * height + i] = ((i * 10) / 30) % 3 + 1;
    }
    for (int col = 0; col &lt; width; col++) {
        gif-&gt;frame[i * height + col] = ((i * 10) / 30) % 3 + 1;
    }

    ge_add_frame(gif, 8);
}
</code></pre>
<details>
<summary>Výsledek animace</summary>
<p><img src="c/aplikovane_ulohy/../../static/img/animace.gif" alt="" /></p>
</details>
<h3><a class="header" href="#dokončení-práce-s-animací" id="dokončení-práce-s-animací">Dokončení práce s animací</a></h3>
<p>Jakmile zapíšeme všechny snímky, které chceme v animaci mít, nesmíme zapomenout animaci uložit do
souboru a uvolnit její paměť pomocí funkce <code>ge_close_gif</code>:</p>
<pre><code class="language-c">ge_close_gif(gif);
</code></pre>
<h2><a class="header" href="#načtení-gif-animace" id="načtení-gif-animace">Načtení <code>GIF</code> animace</a></h2>
<p>Pokud byste naopak chtěli nějakou <code>GIF</code> animaci načíst ze souboru a něco s ní dále provést, můžete
použít knihovnu <a href="https://github.com/lecram/gifdec"><code>gifdec</code></a> od stejného autora, která slouží k
načítání <code>GIF</code> souborů.</p>
<hr />
<p><strong>Cvičení</strong> 🏋</p>
<p>Zkuste použít knihovnu <code>gifdef</code> pro převod animace z <code>GIF</code> do <code>TGA</code>:</p>
<ol>
<li>Načtěte <code>GIF</code> animaci z disku.</li>
<li>Projděte všechny snímky animace.</li>
<li>Pro každý snímek převeďte pixely snímku z indexované palety do klasické mřížky pixelů používané
ve formátu <code>TGA</code>.</li>
<li>Zapište každý snímek na disk jako individuální <code>TGA</code> obrázek. Můžete na kraj obrázku vykreslit
informaci o pořadí snímku.</li>
</ol>
<hr />
<h1><a class="header" href="#sdl" id="sdl">SDL</a></h1>
<blockquote>
<p>📹 K tématu SDL byly pořízeny následující záznamy z doučování UPR:</p>
<ul>
<li><a href="https://www.youtube.com/watch?v=jUktXOH5o1I">Základy SDL</a> [01:23:06]</li>
<li><a href="https://www.youtube.com/watch?v=umuMcTKhm0w">Flappy Bird v SDL</a> [01:22:29]</li>
</ul>
</blockquote>
<p><a href="https://www.libsdl.org/"><code>SDL</code></a> je knihovna pro tvorbu interaktivních grafických aplikací a her.
Umožňuje nám vytvářet okna, vykreslovat do nich jednotlivé pixely, obrázky či text, snímat vstup z
myši a klávesnice či třeba přehrávat zvuk. Jedná se tak v podstatě o tzv. <strong>herní engine</strong>, i když
ve srovnání např. s enginy <a href="https://unity.com/">Unity</a> nebo <a href="https://www.unrealengine.com/">Unreal</a>
je tento engine velmi jednoduchý.</p>
<p>V této kapitole naleznete informace o tom, jak SDL nainstalovat, jak přeložit program využívající SDL funkcí
a jak může vypadat základní SDL program, který něco vykresluje na obrazovku. V následujících podkapitolách se poté můžete
dozvědět více o konceptech SDL užitečných pro tvorbu her:</p>
<ul>
<li><a href="c/aplikovane_ulohy/sdl/herni_smycka.html">Herní smyčka</a></li>
<li><a href="c/aplikovane_ulohy/sdl/kresleni.html">Kreslení</a></li>
<li><a href="c/aplikovane_ulohy/sdl/vstup.html">Zpracování vstupu</a></li>
</ul>
<h2><a class="header" href="#instalace-sdl" id="instalace-sdl">Instalace <code>SDL</code></a></h2>
<p>Narozdíl od knihovny, kterou jsme si ukazovali pro vytváření <a href="c/aplikovane_ulohy/gif.html"><code>GIF</code> animací</a>, <code>SDL</code> obsahuje
spoustu zdrojových i hlavičkových souborů, a nebylo by tak ideální ji kopírovat k našemu programu.
Připojíme ji tedy k našemu programu jako klasickou
<a href="c/aplikovane_ulohy/../modularizace/knihovny.html#pou%C5%BEit%C3%AD-knihoven-s-gcc">knihovnu</a> ve formě archivu. Abychom knihovnu
mohli použít, nejprve si ji musíme stáhnout. To můžeme udělat dvěma způsoby:</p>
<ul>
<li><strong>Instalace pomocí správce balíčků</strong> (<em>doporučeno</em>): Jelikož je <code>SDL</code> velmi známá a používaná
knihovna, ve většině distribucí Linuxu není problém ji nainstalovat přímo pomocí správce balíčků.
V Ubuntu to můžete provést pomocí následujícího příkazu v terminálu, který nainstaluje kromě základní SDL knihovny
také dvě další pomocné knihovny potřebné pro vykreslování obrázků a textu<sup class='margin-toggle sidenote-number'>1</sup>:
<pre><code class="language-bash">$ sudo apt update
$ sudo apt install libsdl2-dev libsdl2-image-dev libsdl2-ttf-dev
</code></pre>
Výhodou tohoto způsobu je, že knihovna bude nainstalována v systémových cestách, a překladač GCC ji tak
bude umět naleznout i bez toho, abychom mu museli zadat explicitní cestu. Nevýhodou může být, že verze
knihoven nabízené správci balíčků bývají typicky docela zastaralé.<span class='sidenote'><p><sup class='number'>1</sup>Pokud by vás zajímalo, které všechny soubory a kam se nainstalovaly, můžete po instalaci balíčků
použít příkaz</p>
<pre><code class="language-bash">$ dpkg -L libsdl2-dev
</code></pre>
</span></li>
</ul>
<ul>
<li><strong>Manuální stažení knihovny</strong>: Knihovnu si můžete také stáhnout manuálně, např. z
<a href="https://github.com/libsdl-org/SDL/releases/download/release-2.28.3/SDL2-2.28.3.zip">GitHubu SDL</a>. Některé knihovny
můžete naleznout na internetu už přeložené, nicméně <code>SDL</code> oficiálně pro Linux přeložené knihovní soubory (<code>.so</code>)
nenabízí. V tomto případě tak musíte knihovnu nejenom stáhnout, ale také ručně přeložit, než ji budete moct použít ve
svém programu.</li>
</ul>
<h2><a class="header" href="#přilinkování-knihovny-sdl" id="přilinkování-knihovny-sdl">Přilinkování knihovny <code>SDL</code></a></h2>
<p>Pokud jste nainstalovali <code>SDL</code> pomocí systémových balíčků, stačí při překladu programu přilinkovat
knihovnu <code>SDL2</code>:</p>
<pre><code class="language-bash">$ gcc main.c -omain -lSDL2
</code></pre>
<p>Pokud jste knihovnu překládali manuálně, musíte ještě použít parametry <code>-I</code> pro předání cesty k
hlavičkovým souborům a <code>-L</code> pro předání cesty k adresáři s přeloženou knihovnou, jak již bylo
vysvětleno <a href="c/aplikovane_ulohy/../modularizace/knihovny.html#pou%C5%BEit%C3%AD-knihoven-s-gcc">zde</a>.</p>
<p>Pro práci s obrázky bude dále nutné přilinkovat knihovnu <code>SDL2_image</code> a pro práci s textem knihovnu
<code>SDL2_ttf</code>.</p>
<p>Pokud byste chtěli používat SDL v kombinaci s <a href="c/aplikovane_ulohy/../automatizace_prekladu.html#cmake">CMake</a>, můžete použít
tento vzorový <code>CMakeLists.txt</code> soubor:</p>
<h3><a class="header" href="#nastavení-sdl-pomocí-cmake" id="nastavení-sdl-pomocí-cmake">Nastavení SDL pomocí CMake</a></h3>
<p>Aplikace využívající SDL již budou typicky trochu komplikovanější, takže se vyplatí použít
pro jejich překladu nějaký sestavovací systém, ideálně <a href="c/aplikovane_ulohy/../automatizace_prekladu.html#cmake">CMake</a>.</p>
<ol>
<li>
<p>Najděte SDL2 baliček, který jste stáhli <a href="c/aplikovane_ulohy/sdl.html#instalace-sdl">výše</a></p>
<pre><code class="language-cmake">find_package(SDL2 REQUIRED)
</code></pre>
</li>
<li>
<p>Přidejte cestu ke hlavičkovým souborům SDL2</p>
<pre><code class="language-cmake">target_include_directories(&lt;název programu&gt; PRIVATE ${SDL2_INCLUDE_DIRS})
</code></pre>
</li>
<li>
<p>Přilinkujte ke svému programu knihovnu SDL2</p>
<pre><code class="language-cmake">target_link_libraries(&lt;název programu&gt; SDL2 SDL2_image SDL2_ttf)
</code></pre>
</li>
</ol>
<p>Finální soubor poté může vypadat např. takto:</p>
<pre><code class="language-cmake">cmake_minimum_required(VERSION 3.12)
project(sdlapp C)

set(CMAKE_C_STANDARD 11)

add_executable(sdlgame main.c)

find_package(SDL2 REQUIRED)

target_include_directories(sdlgame PRIVATE ${SDL2_INCLUDE_DIRS})
target_link_libraries(sdlgame SDL2 SDL2_image SDL2_ttf)
</code></pre>
<h2><a class="header" href="#zprovoznění-sdl-pod-wsl" id="zprovoznění-sdl-pod-wsl">Zprovoznění SDL pod WSL</a></h2>
<p>Pokud chcete použít knihovnu SDL v kombinaci s použitím systému <a href="c/aplikovane_ulohy/../../prostredi/os/linux.html">WSL</a>,
budete si muset nastavit zobrazování grafických Linux aplikací na Windows.</p>
<p>Pokud máte aktuální verzi Windows 11 a WSL, tak by mělo stačit spustit grafický program (např. C program
využívající SDL). Více detailů se můžete dozvědět <a href="https://learn.microsoft.com/en-us/windows/wsl/tutorials/gui-apps">zde</a>.
Pokud nemáte Windows 11 nebo se vám grafický výstup aplikace nezobrazuje, tak budete muset použít tzv. &quot;Emulaci X serveru&quot;,
popsanou níže.</p>
<details>
<summary>Emulace X serveru</summary>
<p>Jedním ze způsobů, který se na Linuxu používá pro vykreslování grafiky, je tzv.
<a href="https://en.wikipedia.org/wiki/X_Window_System">X server</a>. Funguje tak, že aplikace, které chtějí něco
vykreslit, komunikují s X serverem, který poté grafiku vykreslí v nějakém okně.</p>
<p>Aby toto fungovalo pod Windows, tak musíte na Windows spustit X server, ke kterému se poté připojí
klient (vaše C SDL aplikace) spuštěná pod systémem WSL.</p>
<p>Návod, jak tento X server na Windows nainstalovat, naleznete např. <a href="https://techcommunity.microsoft.com/t5/windows-dev-appconsult/running-wsl-gui-apps-on-windows-10/ba-p/1493242">zde</a>.</p>
<p>Zkrácená verze návodu:</p>
<ol>
<li>
<p>Stáhněte a nainstalujte si program <a href="https://sourceforge.net/projects/vcxsrv/">VcXsrv</a>.</p>
</li>
<li>
<p>Zapněte na Windows program <code>XLaunch</code> a v nastavení zaškrtněte volbu <code>Disable access control</code>.</p>
<p>Tento program musí běžet na pozadí, aby fungovalo spouštění grafických aplikací pod WSL (pokud
restartujete počítač, budete ho muset spustit znovu).</p>
</li>
<li>
<p>Ve WSL terminálu poté musíte nastavit proměnnou prostředí <code>DISPLAY</code> na správnou hodnotu, aby
spuštěný program komunikoval s X serverem spuštěným pod Windows. Dosáhnout toho můžete např. následujícím
příkazem:</p>
<pre><code class="language-console">$ export DISPLAY=&quot;`grep nameserver /etc/resolv.conf | sed 's/nameserver //'`:0&quot;
</code></pre>
<p>Tento příkaz musíte spustit v terminálu, odkud budete vaši SDL aplikaci spouštět. Pokud spustíte
nový terminál, musíte příkaz spustit znovu.</p>
</li>
<li>
<p>Dále by mělo stačit spustit SDL aplikaci a její grafický výstup by se měl objevit v novém okně
pod Windows.</p>
</li>
</ol>
</details>
<h2><a class="header" href="#dokumentace" id="dokumentace">Dokumentace</a></h2>
<p>Abyste mohli používat nějakou složitější knihovnu, je nutné se zorientovat v její dokumentaci. V té
naleznete jednak deklarace a popis fungování jednotlivých funkcí, které knihovna nabízí, ale také
různé návody pro to, jak s knihovnou pracovat.</p>
<p>Dokumentaci funkcí <code>SDL</code> naleznete <a href="https://wiki.libsdl.org/APIByCategory">zde</a>, návody pro jeho
použití například <a href="https://www.willusher.io/pages/sdl2/">tady</a>. V předmětu <code>UPR</code> budeme používat
pouze <code>SDL</code> verze 2, které se značně liší od předchozí verze. Dávejte si tedy u návodů na internetu
pozor na to, jestli se týkají správné verze <code>SDL</code>.</p>
<blockquote>
<p><code>SDL</code> je relativně rozsáhlá knihovna a není v silách tohoto textu, abychom ji plně popsali.
Níže naleznete stručný &quot;Hello world&quot; a seznam věcí, které vám SDL umožňuje, a v následujících podkapitolách
poté základní informace o použití SDL ke tvorbě her. Zbytek naleznete v dokumentaci a návodech na internetu.</p>
</blockquote>
<h2><a class="header" href="#sdl-hello-world" id="sdl-hello-world"><code>SDL</code> hello world</a></h2>
<p>Abychom něco vykreslili, tak jako první věc musíme nainicializovat SDL a vytvořit okno<sup class='margin-toggle sidenote-number'>2</sup>:</p>
<span class='sidenote'><p><sup class='number'>2</sup>Pro zpřehlednění kódu bude v ukázkách níže vynechána kontrola chyb. Celý program i s kontrolou
chyb naleznete na konci této sekce.</p>
</span>
<pre><code class="language-c">// Vložení hlavního hlavičkového souboru SDL
#include &lt;SDL2/SDL.h&gt;

int main(int argc, char *argv[])
{
    // Inicializace SDL
    SDL_Init(SDL_INIT_VIDEO);

    // Vytvoření okna
    SDL_Window* window = SDL_CreateWindow(
        &quot;SDL experiments&quot;,  // Titulek okna
        100,                // Souřadnice x
        100,                // Souřadnice y
        800,                // Šířka
        600,                // Výška
        SDL_WINDOW_SHOWN    // Okno se má po vytvoření rovnou zobrazit
    );
</code></pre>
<p>Jakmile máme otevřené okno, můžeme do něj něco začít vykreslovat. K tomu musíme nejprve vytvořit
<code>SDL_Renderer</code>, neboli kreslítko:</p>
<pre><code class="language-c">    // Vytvoření kreslítka
    SDL_Renderer* renderer = SDL_CreateRenderer(
        window,
        -1,
        SDL_RENDERER_ACCELERATED | SDL_RENDERER_PRESENTVSYNC
    );
</code></pre>
<p>S kreslítkem už můžeme něco nakreslit na obrazovku. Musíme vytvořit tzv.
<a href="https://en.wikipedia.org/wiki/Video_game_programming#Game_structure"><strong>herní smyčku</strong></a> (<em>game
loop</em>), která se bude provádět neustále dokola. Ve smyčce nejprve získáme události, které nastaly
(např. došlo ke stisknutí klávesy nebo pohybu myši), poté je zpracujeme, vykreslíme nový obsah
okna a odešleme jej k vykreslení (za použití tzv.
<a href="https://en.wikipedia.org/wiki/Multiple_buffering#Double_buffering_in_computer_graphics"><strong>double bufferingu</strong></a>).</p>
<p>Konkrétně budeme vykreslovat jednoduchou posouvající se čáru, dokud uživatel nezavře otevřené okno:</p>
<pre><code class="language-c">    SDL_Event event;
    int running = 1;
    int line_x = 100;

    while (running == 1)
    {
        // Dokud jsou k dispozici nějaké události, ukládej je do proměnné `event`
        while (SDL_PollEvent(&amp;event))
        {
            // Pokud došlo k uzavření okna, nastav proměnnou `running` na `0`
            if (event.type == SDL_QUIT)
            {
                running = 0;
            }
        }

        // Posuň pozici čáry doprava
        line_x++;

        // Nastav barvu vykreslování na černou
        SDL_SetRenderDrawColor(renderer, 0, 0, 0, 255);

        // Vykresli pozadí
        SDL_RenderClear(renderer);

        // Nastav barvu vykreslování na červenou
        SDL_SetRenderDrawColor(renderer, 255, 0, 0, 255);

        // Vykresli čáru
        SDL_RenderDrawLine(renderer, line_x, 50, line_x, 250);

        // Zobraz vykreslené prvky na obrazovku
        SDL_RenderPresent(renderer);
    }
</code></pre>
<p>A na konci už akorát vše uvolníme:</p>
<pre><code class="language-c">    // Uvolnění prostředků
    SDL_DestroyRenderer(renderer);
    SDL_DestroyWindow(window);
    SDL_Quit();

    return 0;
}
</code></pre>
<blockquote>
<p>Pokud spustíte program využívající <code>SDL</code> s Address sanitizerem, může se stát, že vám sanitizer
zobrazí nějakou <a href="c/aplikovane_ulohy/../../caste_chyby/pametove_chyby.html#memory-leak">neuvolněnou paměť</a>. Pokud zdroj
alokace nepochází z vašeho kódu, můžete tyto chyby ignorovat. Tyto chyby pochází přímo z SDL a nemáte
se jich jak zbavit.</p>
</blockquote>
<details>
<summary>Celý kód i s ošetřením chyb</summary>
<pre><code class="language-c">#include &lt;SDL2/SDL.h&gt;

int main(int argc, char *argv[])
{
    if (SDL_Init(SDL_INIT_VIDEO)) {
        fprintf(stderr, &quot;SDL_Init Error: %s\n&quot;, SDL_GetError());
        return 1;
    }
    SDL_Window* window = SDL_CreateWindow(&quot;SDL experiments&quot;, 100, 100, 800, 600, SDL_WINDOW_SHOWN);
    if (!window) {
        fprintf(stderr, &quot;SDL_CreateWindow Error: %s\n&quot;, SDL_GetError());
        SDL_Quit();
        return 1;
    }

    SDL_Renderer* renderer = SDL_CreateRenderer(window, -1, SDL_RENDERER_ACCELERATED | SDL_RENDERER_PRESENTVSYNC);
    if (!renderer) {
        SDL_DestroyWindow(window);
        fprintf(stderr, &quot;SDL_CreateRenderer Error: %s&quot;, SDL_GetError());
        SDL_Quit();
        return 1;
    }

    int line_x = 100;

    SDL_Event event;
    int running = 1;

    while (running == 1)
    {
        while (SDL_PollEvent(&amp;event))
        {
            if (event.type == SDL_QUIT)
            {
                running = 0;
            }
        }

        line_x++;
    
        SDL_SetRenderDrawColor(renderer, 0, 0, 0, 255); // Nastavení barvy na černou
        SDL_RenderClear(renderer);                      // Vykreslení pozadí

        SDL_SetRenderDrawColor(renderer, 255, 0, 0, 255); // Nastavení barvy na červenou
        SDL_RenderDrawLine(renderer, line_x, 50, line_x, 250); // Vykreslení čáry

        SDL_RenderPresent(renderer);  // Prezentace kreslítka
    }

    SDL_DestroyRenderer(renderer);
    SDL_DestroyWindow(window);
    SDL_Quit();

    return 0;
}
</code></pre>
</details>
<h2><a class="header" href="#co-lze-všechno-dělat-pomocí-sdl" id="co-lze-všechno-dělat-pomocí-sdl">Co lze všechno dělat pomocí <code>SDL</code>?</a></h2>
<p>Knihovna <code>SDL</code> nabízí spoustu funkcionality k tvorbě interaktivních aplikací a her. Můžete s ní
například:</p>
<ul>
<li><a href="https://wiki.libsdl.org/CategoryRender">Vykreslovat</a> body, čáry či obdélníky.</li>
<li>Reprezentovat <a href="https://wiki.libsdl.org/CategoryRect">obdélníky</a> a počítat jejich průniky (např.
pro detekci kolizí herních objektů).</li>
<li><a href="https://wiki.libsdl.org/CategoryEvents">Reagovat</a> na vstup uživatele, ať už z klávesnice nebo z myši.</li>
<li>Načítat a vykreslovat <a href="https://wiki.libsdl.org/SDL_image/FrontPage">obrázky</a>.</li>
<li>Načítat a vykreslovat <a href="https://wiki.libsdl.org/SDL_ttf/FrontPage">text</a>.</li>
<li>Přehrávat <a href="https://wiki.libsdl.org/CategoryAudio">zvuk</a>.</li>
</ul>
<h1><a class="header" href="#herní-smyčka" id="herní-smyčka">Herní smyčka</a></h1>
<p>Základem víceméně všech &quot;real-time&quot; počítačových her je tzv. herní smyčka. Jedná se o cyklus v programu,
který se stará o aktualizaci stavu hry, a vykreslení jednoho tzv. <strong>snímku</strong> (<em>frame</em>) na obrazovku. Hry typicky fungují
tak, že běží donekonečna v tomto cyklu (herní smyčce), a např. 60x za vteřinu aktualizují stav hry a poté jej vykreslí.
Z toho také pochází pojem <strong>Snímků za vteřinu</strong> (<em>Frame per second</em>, <em>FPS</em>), který udává, jak často je hra schopná se
vykreslit za vteřinu.</p>
<p>Herní smyčku vytvoříme jednoduše jako cyklus, který poběží až do doby, než bude potřeba naši hru vypnout:</p>
<pre><code class="language-c">int running = 1;
while (running == 1) {
    // Tělo herní smyčky
}
</code></pre>
<p>V každé iteraci herní smyčky bychom měli provést následující činnosti (ideálně v tomto pořadí):</p>
<ol>
<li>Přečíst a zareagovat na události operačního systému
<ul>
<li>Např. žádost o vypnutí aplikace, stisk klávesy, pohyb myši</li>
</ul>
</li>
<li>Aktualizovat stav hry v paměti
<ul>
<li>Např. pohnout postavou či projektilem, aktualizovat čas cooldownu atd.</li>
</ul>
</li>
<li>Vykreslit aktuální stav hry na obrazovku</li>
</ol>
<h2><a class="header" href="#reakce-na-události" id="reakce-na-události">Reakce na události</a></h2>
<p>Jako úplný základ bychom měli mít v herní smyčce čtení událostí operačního systému, které si můžeme přečíst pomocí
volání funkce <a href="https://wiki.libsdl.org/SDL2/SDL_PollEvent"><code>SDL_PollEvent</code></a>. Do této funkce předáme adresu struktury
<a href="https://wiki.libsdl.org/SDL2/SDL_Event"><code>SDL_Event</code></a>, a pokud funkce vrátí hodnotu <code>1</code>, tak došlo k nějaké události,
a my si můžeme informaci o této události z předané struktury <code>SDL_Event</code> přečíst:</p>
<pre><code class="language-c">SDL_Event event;
while (SDL_PollEvent(&amp;event)) {
    // Pokud došlo k uzavření okna, nastav proměnnou `running` na `0`
    if (event.type == SDL_QUIT) {
        running = 0;
    }
}
</code></pre>
<p>Pokud dojde k události <code>SQL_QUIT</code>, tak se uživatel snaží naši aplikaci vypnout (např. kliknutím na ikonku křížku v rohu
okna aplikace). Na tuto událost bychom měli zareagovat tak, že náš program (hru) vypneme.<sup class='margin-toggle sidenote-number'>1</sup></p>
<span class='sidenote'><p><sup class='number'>1</sup>Pokud bychom tak neudělali, tak se aplikace &quot;zasekne&quot;, a zobrazí se nechvalně známý dialog operačního systému o
neresponzivní aplikaci.</p>
</span>
<p>Při kontrole událostí budeme chtít typicky reagovat na vstup uživatele z klávesnice či myši. Více o zpracování vstupu
se můžete dozvědět <a href="c/aplikovane_ulohy/sdl/vstup.html">zde</a>.</p>
<h2><a class="header" href="#kompenzace-fps" id="kompenzace-fps">Kompenzace FPS</a></h2>
<p>Při aktualizaci stavu hry a provádění jakéhokoliv pohybu, rotace apod. bychom měli vždy brát v potaz <strong>kompenzaci FPS</strong>
(snímků za vteřinu). Představte si, že v naší hře máme nějaký pohybující se objekt, který chceme posouvat v
každém snímku hry o nějaký počet pixelů daným směrem:</p>
<pre><code class="language-c">int position = 0;
while (running == 1) {
    // ...

    position += 1;
    SDL_RenderDrawLine(renderer, position, 100, position, 200);

    // ...
}
</code></pre>
<p>V kódu výše posouváme v každé iteraci pozici čáry o jeden pixel. Co se v tomto případě stane, když naše aplikace bude mít
60 FPS? Čára se za jednu vteřinu posune o 60 pixelů. Pokud by naše aplikace měla ale např. pouze 20 FPS, tak se čára posune
pouze o 20 pixelů! A kdyby měla 1000 FPS, tak se naopak posune o celých 1000 pixelů.</p>
<p>Pokud by logika her závisela na počtu FPS, tak by to jistě způsobovalo problémy. Představte si například, že v hrách,
jako je Call of Duty nebo Counter-Strike, by počet FPS ovlivňoval, jak rychle postava poběží nebo jak rychle se budou
pohybovat projektily, které postava vystřelí. S takovýmto řešením by hráči ani autoři hry určitě nebyli spokojeni.</p>
<p>Ideálně bychom chtěli, aby se v naší hře vše pohybovalo stanovenou rychlostí, nezávisle na současné hodnotě FPS.
Toho můžeme dosáhnout pomocí tzv. <strong>delta času</strong> (<em>delta time</em>). Delta je označení pro čas vykonání jedné iterace herní
smyčky. Čím více bude mít naše hra FPS, tím menší bude delta:</p>
<ul>
<li>Při <code>60 FPS</code> je delta <code>~0.016 s</code>, neboli <code>~16 ms</code></li>
<li>Při <code>10 FPS</code> je delta <code>~0.1 s</code>, neboli <code>~100 ms</code></li>
<li>Při <code>1 FPS</code> je delta <code>~1 s</code>, neboli <code>~1000 ms</code></li>
</ul>
<p>Deltu můžeme vypočítat pomocí funkcí na měření času nabízených knihovnou SDL:</p>
<pre><code class="language-c">// Uložení poslední hodnoty čítače
Uint64 last = SDL_GetPerformanceCounter();

while (running == 1) {
    // Zjištění současné hodnoty čítače
    Uint64 now = SDL_GetPerformanceCounter();
    
    // Výpočet delty, času od posledního provedení tohoto řádku (tj. délky iterace herní smyčky)
    double deltaTime = (double)((now - last) / (double)SDL_GetPerformanceFrequency());

    // Uložení poslední hodnoty čítače
    last = now;

    // ...
}
</code></pre>
<blockquote>
<p>Pokud si chcete naměřit a vypisovat hodnotu FPS své hry, stačí vypsat převrácenou hodnotu delty, tj. platí
<code>FPS = 1 / deltaTime</code>.</p>
</blockquote>
<p>Jakmile máme k dispozici hodnotu delty, můžeme ji využít k tomu, abychom pohyb ve hře přizpůsobili počtu FPS. Toho dosáhneme
tak, že budeme každý pohyb ve hře &quot;škálovat&quot; (neboli násobit) hodnotou delty:</p>
<pre><code class="language-c">position += 100 * deltaTime;
</code></pre>
<p>Když budeme mít hodně FPS (tj. malou hodnotu delty), tak budeme hýbat (a vykreslovat) objekty spoustakrát za vteřinu, takže
chceme, aby objekty dělaly malé kroky, a hýbaly se plynule. V tomto případě bude delta mít malou hodnotu, takže pohyb
se bude provádět po malých krocích. Pokud budeme mít naopak málo FPS (tj. velkou hodnotu delty), tak budeme hýbat
objekty pouze několikrát za vteřinu, takže poté musí objekty udělat větší krok, aby urazily stejnou vzdálenost za stejnou
časovou jednotku. V tomto případě bude delta mít velkou hodnotu, takže pohyb se bude provádět po velkých krocích.</p>
<p>Tento princip si můžeme demonstrovat na následujících animaci, které zobrazují pohyb tří obdélníků s různým počtem
snímků za vteřinu. První obdélník se pohybuje s 60 FPS, druhý obdélník s 10 FPS, a třetí obdélník s 1 FPS.
Všimněte si, že za stejnou dobu všechny obdélníky urazí cca stejnou vzdálenost. Díky kompenzaci pohybu pomocí
delta času jsou tak rychlosti obdélníků nezávislé na FPS.</p>
<img src="c/aplikovane_ulohy/sdl/../../../static/img/sdl/fps-compensation.gif" width="300" height="200" alt="FPS compensation demonstration" />
<p><strong>Nezapomeňte tak ve svých hrách všechny pohyby, rotace, animace, aktualizace času, cooldownů atd. násobit deltou!</strong></p>
<p>U násobení hodnot deltou je potřeba dát si pozor na jednu věc, a to jsou desetinná čísla. Pokud budeme mít např. pozici
nějakého objektu ve hře reprezentovanou celým číslem (<code>int</code>), tak může dojít k problému se zaokrouhlováním. Pokud např.
budeme chtít tento objekt posunout rychlostí 10, a budeme mít 60 FPS, tak <code>10 * 0.016</code> je <code>0.16</code>, což se při převodu
na <code>int</code> zaokrouhlí na hodnotu <code>0</code>! Při násobení deltou bychom se tedy mohli dostat do situace, kdy se naše objekty
vůbec nebudou hýbat, protože jednotlivé kroky budou moc malé na to, aby se vůbec na hodnotě celého čísla projevily. Proto
se snažte reprezentovat veškeré pozice a podobné hodnoty, které musíte násobit deltou, pomocí desetinných čísel, tj.
datových typů <code>float</code> nebo <code>double</code>.</p>
<h2><a class="header" href="#v-sync" id="v-sync">V-sync</a></h2>
<p>Pokud spustíte svou hru a naměříte si počet FPS, tak možná zjistíte, že počet snímků je &quot;zamknutý&quot; na nějaké pevné hodnotě,
např. 60 FPS, a nestoupá výše. Toto je pravděpodobně způsobeno tím, že jste si nastavili při vytváření kreslítka (tj.
volání funkce <a href="https://wiki.libsdl.org/SDL2/SDL_CreateRenderer"><code>SDL_CreateRenderer</code></a>) vlastnost (&quot;flag&quot;)
<a href="https://wiki.libsdl.org/SDL2/SDL_RendererFlags"><code>SDL_RENDERER_PRESENTVSYNC</code></a>. Tento parametr zapíná tzv. V-sync, což je
mechanismus pro synchronizaci FPS vaší hry a vykreslovací frekvence vašeho monitoru. Váš monitor má pravděpodobně nějakou
omezenou maximální vykreslovací frekvenci, typicky např. 60, 120, 144 FPS. Pokud by vaše hra měla více snímků za vteřinu,
např. 1000 FPS, tak by se vykreslovala výrazně jinou frekvenci, než váš monitor, což by mohlo způsobovat nepříjemné
vizuální artefakty.</p>
<p>Mechanismus V-sync tomuto zabraňuje tím, že vytvoří maximální limit pro FPS vaší hry, který bude odpovídat vykreslovací
frekvenci vašeho monitoru. Z toho důvodu při zapnutém V-syncu vaše hra bude typicky mít maximálně třeba 60 FPS. Pro
jednoduché SDL hry v UPR doporučujeme nechat V-sync zapnutý, aby vaše hra neměla zbytečně moc FPS. Pokud byste totiž
dlouhodobě vykreslovali vaši hru bez omezení FPS, může to mít negativní vliv na váš hardware (např. grafickou kartu),
která se tím může přetížit, začít pískat nebo se i dokonce zničit. Proto raději používejte V-sync a ujistěte se, že vaše
hra nemá nesmyslně vysokou hodnotu (např. 1000+) FPS.</p>
<h2><a class="header" href="#double-buffering" id="double-buffering">Double buffering</a></h2>
<p>Při vykreslování stavu hry do &quot;kreslítka&quot; (<code>SDL_Renderer</code>) vždy vykreslujeme věci postupně - nejprve nakreslíme pozadí,
poté např. hráčovu postavu, poté letící projektily atd. Pokud by se ihned po vykreslení nakreslené objekty zobrazovaly
na monitoru, nepůsobilo by to graficky pěkně, protože by hráč viděl částečně vykreslený stav, který by vůbec nemusel dávat
smysl.</p>
<p>Z toho důvodu se při vykreslování her využívá princip tzv. <a href="https://en.wikipedia.org/wiki/Multiple_buffering#Double_buffering_in_computer_graphics"><strong>double bufferingu</strong></a>,
který je zabudovaný přímo v SDL. Myšlenka double bufferingu je taková, že v paměti budeme mít dvě plátna. Do jednoho plátna
budeme vždy postupně kreslit současný stav hry, a druhé plátno se bude ukazovat hráčovi na monitoru. V momentě, kdy
nakreslíme celý stav hry, tak pouze řekneme, že se mají plátna prohodit, tj. naše nakreslené plátno se zobrazí na monitoru,
a dále budeme kreslit na plátno z minulé iterace herní smyčky. Díky tomu, že prohození je velmi rychlá operace, tak při
tomto přístupu hráč vždy uvidí pouze kompletně vykreslené snímky, a ne žádný částečně vykreslený stav. V SDL dosáhneme
prohození těchto dvou pláten pomocí zavolání funkce <a href="https://wiki.libsdl.org/SDL2/SDL_RenderPresent"><code>SDL_RenderPresent</code></a>.
Volání této funkce by se mělo vyskytovat na úplném konci naší herní smyčky, a mělo by ukončit vykreslování stavu naší hry.</p>
<p>Jelikož při použití double bufferingu neustále pracujeme se stejnými dvěmi plátny, a plátno, do kterého kreslíme, může
obsahovat libovolné pixely (např. ty, které jsme vykreslili v minulé iteraci herní smyčky), měli bychom vždy na začátku
vykreslování toto plátno celé překreslit barvou pozadí, ideálně pomocí funkce <a href="https://wiki.libsdl.org/SDL2/SDL_RenderClear"><code>SDL_RenderClear</code></a>.
Pokud tak neučiníte, můžou na plátně být vizuální artefakty, obsah plátna z minulé iterace, případně cokoliv jiného,
což určitě není žádoucí.</p>
<h1><a class="header" href="#kreslení" id="kreslení">Kreslení</a></h1>
<p>Hlavním důvodem, proč používáme knihovnu SDL, je samozřejmě to, abychom mohli vykreslovat grafické prvky na obrazovku.
K tomu nám SDL nabízí spoustu užitečných funkcí. V podstatě všechny funkce pro vykreslování berou jako svůj (první)
parametr hodnotu typu <code>SDL_Renderer*</code>, která reprezentuje &quot;kreslítko&quot;, do kterého se má něco vykreslit.</p>
<h2><a class="header" href="#souřadný-systém" id="souřadný-systém">Souřadný systém</a></h2>
<p>Pro vykreslování je nejprve nutné vzít v potaz, jaký má SDL souřadný systém. Ten je znázorněný na následujícím obrázku:</p>
<p><img src="c/aplikovane_ulohy/sdl/../../../static/img/sdl/sdl-coordinates.png" alt="SDL systém koordinátů" /></p>
<p>Začátek souřadné soustavy je v bodě <code>(0, 0)</code>, který je umístěn v levém horním rohu okna. První souřadnice (<code>x</code>) určuje
sloupec, a roste zleva doprava. Druhá souřadnice (<code>y</code>) určuje řádek, a roste shora dolů. Takže např. v okně s šířkou <code>800</code>
a výškou <code>600</code> pixelů jsou souřadnice rohů následující:</p>
<ul>
<li>Levý horní roh: <code>(0, 0)</code></li>
<li>Pravý horní roh: <code>(799, 0)</code></li>
<li>Levý dolní roh: <code>(0, 599)</code></li>
<li>Pravý dolní roh: <code>(799, 599)</code></li>
</ul>
<p>Pokud je pro vás neintuitivní, že souřadnice <code>y</code> roste shora dolů (a ne zdola nahoru), můžete si ve vaší hře tuto souřadnici
virtuálně upravit a změnit si tak souřadný systém. V paměťové reprezentaci vaší hry můžete klidně používat souřadný systém,
kde <code>y</code> roste nahoru, a při vykreslování pomocí funkcí SDL pak akorát souřadnici <code>y</code> přepočítáte, aby odpovídala souřadnému
systému SDL. Tento přepočet lze provést jednoduše, stačí odečíst souřadnici <code>y</code> od výšky okna.</p>
<h2><a class="header" href="#nastavení-barvy-štětce" id="nastavení-barvy-štětce">Nastavení barvy štětce</a></h2>
<p>Pokud chceme v SDL něco vykreslit, tak musíme nejprve nastavit barvu, kterou se má kreslit. To můžeme udělat zavoláním
funkce <a href="https://wiki.libsdl.org/SDL2/SDL_SetRenderDrawColor"><code>SDL_SetRenderDrawColor</code></a>, která bere (kromě kreslítka)
čtyři parametry (<code>r</code>, <code>g</code>, <code>b</code>, <code>a</code>). Parametry <code>r</code>, <code>g</code> a <code>b</code> odpovídají červené, zelené a modré komponentě barvy, kterou
chceme nastavit pro kreslení. Hodnoty těchto komponent lze nastavovat v rozsahu <code>0</code> až <code>255</code>. Hodnota <code>a</code> odpovídá tzv.
alfa kanálu, který určuje průhlednost zvolené barvy. Obvykle průhlednost nemusíte řešit, a stačí tento parametr nastavit
na hodnotu <code>255</code>.</p>
<p>Nastavená barva zůstane aktivní, dokud ji nezměníme. Pokud tedy chceme vykreslit např. pět různých věcí stejnou barvou,
stačí barvu nastavit jednou, a poté vykreslit všechny požadované objekty.</p>
<h2><a class="header" href="#Čáry" id="Čáry">Čáry</a></h2>
<p>Čáru můžete nakreslit pomocí funkce <a href="https://wiki.libsdl.org/SDL2/SDL_RenderDrawLine"><code>SDL_RenderDrawLine</code></a>. Ta bere
(kromě kreslítka) čtyři parametry (<code>x1</code>, <code>y1</code>, <code>x2</code> a <code>y2</code>), které reprezentují souřadnice začátku a konce čáry.</p>
<pre><code class="language-c">SDL_RenderDrawLine(renderer, 100, 100, 200, 200);
</code></pre>
<h2><a class="header" href="#obdélníky" id="obdélníky">Obdélníky</a></h2>
<p>Nevyplněný obdélník můžete vykreslit pomocí funkce <a href="https://wiki.libsdl.org/SDL2/SDL_RenderDrawRect"><code>SDL_RenderDrawRect</code></a>,
vyplněný obdélník poté pomocí funkce <a href="https://wiki.libsdl.org/SDL2/SDL_RenderFillRect"><code>SDL_RenderFillRect</code></a>. Tyto funkce
vyžadují předání adresy na hodnotu struktury <a href="https://wiki.libsdl.org/SDL2/SDL_Rect"><code>SDL_Rect</code></a>, která reprezentuje
obdélník. Pro vykreslení obdélníku tedy nejprve musíme vytvořit proměnnou typu <code>SDL_Rect</code>, nastavit jí pozici a rozměry,
a poté zavolat jednu z těchto dvou funkcí.</p>
<pre><code class="language-c">SDL_Rect rect = {
    .x = 100,
    .y = 200,
    .w = 500,
    .h = 200
};
SDL_RenderFillRect(renderer, &amp;rect);
</code></pre>
<p>Datový typ <code>SDL_Rect</code> se hodí nejenom pro vykreslování obdélníků. Můžete jej použít také na reprezentaci pozice a rozměru
různých objektů ve své hře. SDL také nabízí funkce pro kontrolu toho, jestli se dva obdélníky protínají, např. pomocí
funkce <a href="https://wiki.libsdl.org/SDL2/SDL_HasIntersection"><code>SDL_HasIntersection</code></a>. Díky tomu můžete použít tyto obdélníky
také na detekci kolizí (např. na zjištění, jestli projektil trefil hráče).</p>
<p>Datový typ <code>SDL_Rect</code> ukládá pozici a rozměry obdélníku pomocí datového typu <code>int</code>. Pokud byste potřebovali obdélník,
kde tyto atributy budou reprezentované desetinnými čísly, můžete použít <a href="https://wiki.libsdl.org/SDL2/SDL_FRect"><code>SDL_FRect</code></a>.</p>
<h2><a class="header" href="#obrázky" id="obrázky">Obrázky</a></h2>
<p>SDL má také samozřejmě podporu nejenom pro kreslení čar či obdélníků, ale také pro kreslení (bitmapových) obrázků
(které můžeme načíst např. ze souborů ve formátu PNG nebo JPEG). Ke kreslení však budeme muset využít dodatečnou knihovnu
zvanou <code>SDL2_image</code>, kterou poté musíme přilinkovat k našemu programu při překladu:</p>
<pre><code class="language-bash">$ gcc main.c -omain -lSDL2 -lSDL2_image
</code></pre>
<p>Poté musíme na začátku souboru, kde chceme funkce pro načítání obrázků použít, vložit odpovídající hlavičkový soubor:</p>
<pre><code class="language-c">#include &lt;SDL2/SDL_image.h&gt;
</code></pre>
<p>Jakmile tohle uděláme, tak můžeme použít funkci <a href="https://wiki.libsdl.org/SDL2_image/IMG_LoadTexture"><code>IMG_LoadTexture</code></a>,
která bere jako parametr kreslítko, a cestu k souboru na disku, ze kterého se má načíst obrázek, který poté budeme
vykreslovat:</p>
<pre><code class="language-c">SDL_Texture* image = IMG_LoadTexture(renderer, &quot;image.png&quot;);
</code></pre>
<p>Z funkce se nám vrátí ukazatel na strukturu <a href="https://wiki.libsdl.org/SDL2/SDL_Texture"><code>SDL_Texture</code></a>, která reprezentuje
obrázek načtený v paměti grafické kartě, který je připravený k vykreslení.</p>
<blockquote>
<p>Při načítání obrázků (stejně jako jakýchkoliv jiných souborů) bychom si měli dát pozor na to, abychom k němu udali
<a href="c/aplikovane_ulohy/sdl/../../soubory/otevirani_souboru.html#cesta-k-souboru">správnou cestu</a>. Měli bychom také zkontrolovat, jestli se obrázek
správně načetl, tj. jestli funkce nevrátila hodnotu <code>NULL</code><sup class='margin-toggle sidenote-number'>1</sup>. Kontrolu si můžeme usnadnit pomocí makra <a href="c/aplikovane_ulohy/sdl/../../soubory/otevirani_souboru.html#pou%C5%BEit%C3%AD-assert"><code>assert</code></a>.</p>
<span class='sidenote'><p><sup class='number'>1</sup>Pokud by funkce vrátila <code>NULL</code>, a my bychom se poté snažili tuto hodnotu vykreslit jako obrázek, tak může dojít
k <a href="c/aplikovane_ulohy/sdl/../../../ruzne/nedefinovane_chovani.html"><strong>nedefinovanému chování</strong></a> 💣. Proto bychom měli vždy kontrolovat návratovou hodnotu této funkce.</p>
</span></blockquote>
<p>Jakmile máme obrázek správně načtený, tak jej můžeme vykreslit pomocí funkce <a href="https://wiki.libsdl.org/SDL2/SDL_RenderCopy"><code>SDL_RenderCopy</code></a>.
Této funkci musíme předat kreslítko, obrázek, který chceme vykreslit a dva obdélníky (<code>srcrect</code> a <code>dstrect</code>).
Parametr <code>srcrect</code> určuje výřez z obrázku, který chceme kreslit. Pokud chceme obrázek vykreslit celý, tak pro parametr
<code>srcrect</code> předáme hodnotu <code>NULL</code>. Parametr <code>dstrect</code> určuje, do jakého výřezu (obdélníku v plátnu) se má obrázek vykreslit.
Zde bychom si měli dát pozor, aby cílový obdélník měl stejný poměr stran, jako náš obrázek, jinak po vykreslení může být
obrázek značně zdeformovaný.</p>
<pre><code class="language-c">SDL_Rect rect = {
    .x = 100,
    .y = 100,
    .w = 400,
    .h = 400
};
SDL_RenderCopy(renderer, image, NULL, &amp;rect);
</code></pre>
<p>Užitečná je také funkce <a href="https://wiki.libsdl.org/SDL2/SDL_RenderCopyEx"><code>SDL_RenderCopyEx</code></a>, která nám umožňuje vykreslit
obrázek, který je zarotovaný, případně zrcadlený podél vertikální či horizontální osy.</p>
<p>Jakmile přestaneme obrázek potřebovat, měli bychom jeho texturu uvolnit pomocí volání funkce <a href="https://wiki.libsdl.org/SDL2/SDL_DestroyTexture"><code>SDL_DestroyTexture</code></a>:</p>
<pre><code class="language-c">SDL_DestroyTexture(image);
</code></pre>
<h2><a class="header" href="#text-1" id="text-1">Text</a></h2>
<p>Další užitečnou funkcionalitou, kterou nám SDL nabízí, a která je potřeba pro většinu her či grafických aplikací, je
vykreslování textu. K tomu budeme opět vyžadovat dodatečnou knihovnu, která se jmenuje <code>SDL2_ttf</code>:</p>
<pre><code class="language-bash">$ gcc main.c -omain -lSDL2 -lSDL2_ttf
</code></pre>
<p>Pro práci s touto knihovnou budeme opět muset vložit odpovídající hlavičkový soubor:</p>
<pre><code class="language-c">#include &lt;SDL2/SDL_ttf.h&gt;
</code></pre>
<p>a dále také zavolat inicializační funkci <a href="https://wiki.libsdl.org/SDL2_ttf/TTF_Init"><code>TTF_Init</code></a>, kterou bychom měli
zavolat v programu někdy po zavolání funkce <a href="https://wiki.libsdl.org/SDL2/SDL_Init"><code>SDL_Init</code></a>:</p>
<pre><code class="language-c">SDL_Init(SDL_INIT_VIDEO);
TTF_Init();
</code></pre>
<p>Abychom mohli při vykreslování znaků používat průhlednost, a aby byly vykreslované obrázky jednotlivých znaků pěknější,
je vhodné na kreslítku (<code>SDL_Renderer</code>) zapnout takzvaný <code>Alpha blending</code>, a také povolit lineární vzorkování pixelů.
Na začátek programu (těsně po vytvoření kreslítka) si tedy přidejte tyto dva řádky:</p>
<pre><code class="language-c">SDL_SetRenderDrawBlendMode(renderer, SDL_BLENDMODE_BLEND);
SDL_SetHint(SDL_HINT_RENDER_SCALE_QUALITY, &quot;1&quot;);
</code></pre>
<p>Na konci programu bychom poté měli prostředky této knihovny opět uvolnit pomocí zavolání funkce <a href="https://wiki.libsdl.org/SDL2_ttf/TTF_Quit"><code>TTF_Quit</code></a>:</p>
<pre><code class="language-c">TTF_Quit();
</code></pre>
<p>Pro vykreslení nějakého textu budeme nejprve potřebovat nějaký (bitmapový) <a href="https://en.wikipedia.org/wiki/Typeface">font</a>,
ideálně ve formátu TTF. Můžete použít např. <a href="c/aplikovane_ulohy/sdl/../../../static/Arial.ttf">tento</a> font nebo si nějaký font stáhnout z internetu.
Font určuje, jak budou vypadat jednotlivé znaky textu, který se bude vykreslovat na obrazovku. Jakmile máte připravený
soubor s fontem, můžete ho ve svém programu načíst pomocí funkce <a href="https://wiki.libsdl.org/SDL2_ttf/TTF_OpenFont"><code>TTF_OpenFont</code></a>:</p>
<pre><code class="language-c">TTF_Font* font = TTF_OpenFont(&quot;Arial.ttf&quot;, 20);
</code></pre>
<p>První parametr udává cestu k souboru s fontem, druhý parametr udává velikost, ve které se má font načíst.
Až s fontem přestaneme pracovat (na konci programu), tak bychom jej měli opět uvolnit:</p>
<pre><code class="language-c">TTF_CloseFont(font);
</code></pre>
<p>Jakmile máme načtený font, tak můžeme do kreslítka vykreslit nějaký text. Můžeme k tomu využít následující funkci,
která vyžaduje kreslítko, načtený font, barvu v podobě struktury <a href="https://wiki.libsdl.org/SDL2/SDL_Color"><code>SDL_Color</code></a>,
obdélník označující pozici, kam se má text vykreslit, a poté samotný text, který se má vykreslit, ve formě řetězce:</p>
<pre><code class="language-c">void sdl_draw_text(SDL_Renderer* renderer, TTF_Font* font, SDL_Color color, SDL_Rect location, const char* text)
{
    // Vykreslení textu se zadaným fontem a barvou do obrázku (surface)
    SDL_Surface* surface = TTF_RenderText_Blended(font, text, color);
    // Převod surface na hardwarovou texturu
    SDL_Texture* texture = SDL_CreateTextureFromSurface(renderer, surface);

    // Vykreslení obrázku
    SDL_RenderCopy(renderer, texture, NULL, &amp;location);

    // Uvolnění textury a surface
    SDL_DestroyTexture(texture);
    SDL_FreeSurface(surface);
}
</code></pre>
<p>Tato funkce nejprve vytvoří obrázek s vykresleným textem, a poté obrázek vykreslí do kreslítka, stejně jako kdybychom
<a href="c/aplikovane_ulohy/sdl/kresleni.html#obr%C3%A1zky">kreslili</a> jakýkoliv jiný obrázek.</p>
<blockquote>
<p>Tento kód je relativně neefektivní, neboť při každém vykreslení vytváří dva nové obrázky (surface a texture), a poté
je hned uvolňuje. Pro jednoduché hry by to však neměl být výkonnostní problém.</p>
</blockquote>
<h1><a class="header" href="#vstup-1" id="vstup-1">Vstup</a></h1>
<p>Aby naše hry či jiné SDL programy byly interaktivní, tak budeme muset reagovat na vstup od uživatele. Zejména se bude
jednat o vstup z klávesnice (zmáčknutí klávesy) či myši (pohyb, zmáčknutí tlačítka, otočení kolečka).</p>
<h2><a class="header" href="#reakce-na-události-operačního-systému" id="reakce-na-události-operačního-systému">Reakce na události operačního systému</a></h2>
<p>V kapitole o <a href="c/aplikovane_ulohy/sdl/herni_smycka.html#reakce-na-ud%C3%A1losti">herní smyčce</a> už jsme si ukázali, jak můžeme číst události operačního
systému. Jelikož se čtení událostí výrazně dotýká i vstupu od uživatele, tak si jej zde popíšeme více do detailu. Pro
připomenutí, takto můžeme vyčíst všechny události, které nastaly od poslední iterace herní smyčky:</p>
<pre><code class="language-c">SDL_Event event;
while (SDL_PollEvent(&amp;event)) {
    // Zde můžeme pracovat s proměnnou `event`
}
</code></pre>
<p>Když se podíváte na dokumentaci struktury <a href="https://wiki.libsdl.org/SDL2/SDL_Event"><code>SDL_Event</code></a>, tak tam najdete
různé typy událostí, ke kterým může dojít. Abyste zjistili, k jakému typu události došlo, musíte se podívat na
atribut <code>type</code> struktury <code>SDL_Event</code>. Tento atribut může nabývat hodnot, které jsou znázorněny v prvním sloupci
<a href="https://wiki.libsdl.org/SDL2/SDL_Event#table"><strong>této tabulky</strong></a>. Jedná se například o následující typy událostí:</p>
<ul>
<li>Žádost o vypnutí aplikace <code>SDL_QUIT</code></li>
<li>Pohnutí myši <code>SDL_MOUSEMOTION</code></li>
<li>Zmáčknutí tlačítka myši <code>SDL_MOUSEBUTTONDOWN</code></li>
<li>Zmáčknutí tlačítka klávesnice <code>SDL_KEYDOWN</code></li>
</ul>
<p>V programu byste poté měli mít podmínku, kterou zkontrolujete, jestli došlo k události, na kterou chcete zareagovat.
Uvnitř podmínky poté můžete přistupovat k atributu struktury <code>SDL_Event</code>, který odpovídá danému typu události. Název
tohoto atributu se dozvíte ve třetím sloupci zmíněné tabulky, a datový typ tohoto atributu poté najdete ve druhém sloupci.</p>
<p>Pokud by tedy např. došlo k události otočení kolečka myši (<code>SDL_MOUSEWHEEL</code>), tak poté můžete přistoupit k atributu
<code>event.wheel</code>, který bude mít typ <a href="https://wiki.libsdl.org/SDL2/SDL_MouseWheelEvent"><code>SDL_MouseWheelEvent</code></a>, a z tohoto
atributu si poté můžete vyčíst dodatečné informace o události:</p>
<pre><code class="language-c">if (event.type == SDL_MOUSEWHEEL) {
    SDL_MouseWheelEvent wheel_event = event.wheel;
    printf(
        &quot;Kolecko mysi se pohnulo o %d vertikalne a %d horizontalne\n&quot;,
        wheel_event.y,
        wheel_event.x
    );
}
</code></pre>
<p>Kromě čtení událostí pomocí smyčky využívající funkce <code>SDL_PollEvent</code> můžeme také pomocí různých SDL funkcí kdykoliv v
programu získat současný stav myši či klávesnice. Oba dva přístupy nám přijdou vhod. Například, ve hře se můžeme kdykoliv
zeptat, jestli je zrovna zmáčknuté tlačítko myši. Pokud ale budeme chtít zareagovat na pohyb myši, tak spíše budeme chtít
dostat upozornění na to, že došlo k pohybu (pomocí čtení událostí), protože pohyb není vyjádřen současným stavem, ale spíše
změnou stavu (tedy událostí). Při popisu klávesnice i myši níže si tedy vždy ukážeme oba dva způsoby, jak vstup získat,
pomocí událostí i pomocí získání současného stavu.</p>
<h2><a class="header" href="#myš" id="myš">Myš</a></h2>
<p>U myši nás bude zajímat primárně její pozice, případně stav tlačítek. Můžeme ale také zjistit např. jestli uživatel otočil
kolečkem.</p>
<h3><a class="header" href="#události" id="události">Události</a></h3>
<p>Následující události jsou užitečné pro práci s myší:</p>
<ul>
<li><a href="https://wiki.libsdl.org/SDL2/SDL_MouseMotionEvent"><code>SDL_MOUSEMOTION</code></a> Hráč pohnul s myší.
<ul>
<li>V atributech <code>event.motion.x</code> a <code>event.motion.y</code> poté naleznete současnou pozici myši.</li>
</ul>
</li>
<li><a href="https://wiki.libsdl.org/SDL2/SDL_MouseButtonEvent"><code>SDL_MOUSEBUTTONDOWN</code></a>, <a href="https://wiki.libsdl.org/SDL2/SDL_MouseButtonEvent"><code>SDL_MOUSEBUTTONUP</code></a>
Hráč stisknul (<code>DOWN</code>) či uvolnil (<code>UP</code>) tlačítko myši.
<ul>
<li>V atributu <code>event.button.button</code> naleznete informace o tlačítku, které bylo zmáčknuto či uvolněno (např. <code>SDL_BUTTON_LEFT</code> nebo <code>SDL_BUTTON_RIGHT</code>).</li>
</ul>
</li>
<li><a href="https://wiki.libsdl.org/SDL2/SDL_MouseWheelEvent"><code>SDL_MOUSEWHEEL</code></a> Hráč otočil kolečkem myši.
<ul>
<li>V atributu <code>event.wheel.y</code> naleznete hodnotu vertikálního posunu, v atributu <code>event.wheel.x</code> poté hodnotu horizontálního posunu.</li>
</ul>
</li>
</ul>
<p>Můžete si všimnout, že &quot;kliknutí myši&quot; je rozděleno na dvě události - stisknutí a povolení tlačítka. Pokud byste tedy
chtěli ve své hře reagovat na opravdové &quot;kliknutí&quot; (třeba na nějaký herní objekt), a ne pouze na stisknutí tlačítka, tak
si nejprve musíte zapamatovat, že uživatel tlačítko stisknul, a poté jej upustil (a obojí provedl nad stejným objektem).</p>
<h3><a class="header" href="#současný-stav" id="současný-stav">Současný stav</a></h3>
<p>Pokud bychom chtěli získat současný stav pozice a tlačítek myši, můžeme využít funkci <a href="https://wiki.libsdl.org/SDL2/SDL_GetMouseState"><code>SDL_GetMouseState</code></a>.
Ta jako parametry bere ukazatele na čísla (souřadnice <code>x</code> a <code>y</code>), do kterých uloží současnou pozici myši. Souřadnice budou
relativní vzhledem k oknu, nad kterým se zrovna myš nachází, což je obvykle to, co chceme. Návratová hodnota této funkce
poté obsahuje číslo, jehož jednotlivé bity označují, která tlačítka myši jsou zrovna stisknuta. Stav tlačítek poté můžeme
zjistit pomocí makra <code>SDL_BUTTON</code>:</p>
<pre><code class="language-c">int x = 0;
int y = 0;
Uint32 buttons = SDL_GetMouseState(&amp;x, &amp;y);
int left = (buttons &amp; SDL_BUTTON(SDL_BUTTON_LEFT)) != 0;
int right = (buttons &amp; SDL_BUTTON(SDL_BUTTON_RIGHT)) != 0;

printf(&quot;Mouse is at (%d, %d). Left button: %d, right button: %d\n&quot;, x, y, left, right);
</code></pre>
<h2><a class="header" href="#klávesnice" id="klávesnice">Klávesnice</a></h2>
<p>U klávesnice nás bude zajímat zejména to, zda došlo ke stisknutí či uvolnění nějaké klávesy.</p>
<h3><a class="header" href="#události-1" id="události-1">Události</a></h3>
<p>U klávesnice jsou k dispozici události <a href="https://wiki.libsdl.org/SDL2/SDL_KeyboardEvent"><code>SDL_KEYDOWN</code></a> (stisk klávesy)
a <a href="https://wiki.libsdl.org/SDL2/SDL_KeyboardEvent"><code>SDL_KEYUP</code></a> (uvolnění klávesy). U obou událostí můžete přistoupit k
atributu <code>event.key.keysym.sym</code>, který obsahuje hodnotu datového typu <a href="https://wiki.libsdl.org/SDL2/SDL_Keycode"><code>SDL_Keycode</code></a>,
která reprezentuje stisknutou klávesu. Seznam možných hodnot kláves, na které můžete reagovat, je k dispozici v třetím
sloupci <a href="https://wiki.libsdl.org/SDL2/SDL_Scancode">této tabulky</a>. Např. mezerník je reprezentován hodnotou <code>SDLK_SPACE</code>,
klávesa <code>a</code> hodnotou <code>SDLK_a</code> a šipka doprava hodnotou <code>SDLK_RIGHT</code>.</p>
<p>Zde je ukázka toho, jak můžeme zareagovat na stisk jednotlivých kláves:</p>
<pre><code class="language-c">if (event.type == SDL_KEYDOWN) {
    SDL_Keycode code = event.key.keysym.sym;
    if (code == SDLK_SPACE) {
        printf(&quot;Uzivatel stisknul mezernik\n&quot;);
    } else if (code == SDLK_RIGHT) {
        printf(&quot;Uzivatel stisknul sipku doprava\n&quot;);
    }
}
</code></pre>
<p>Reakce na události klávesnice se hodí pro případy, kdy chceme zareagovat na nějakou jednorázovou událost, např. když hráč
stiskne klávesu, která způsobuje vystřelení projektilu. Není však vhodné přímo využívat reakce na
události klávesnice pro zpracování kláves, které hráč bude typicky &quot;držet&quot;, např. šipky pro pohyb postavy.
Pokud hráč klávesu bude držet stisknutou, operační systém sice vaší hře bude předávat pravidelně nové události typu
<code>SDL_KEYDOWN</code>, nicméně bude to dělat dost pomalu, v řádu jednotek událostí za vteřinu. To by znamenalo, že pokud byste
ve své hře přímo vyvolávali např. pohyb hráčovy postavy v reakci na událost stisknutí klávesy, tak by se postava pohybovala
trhaně.</p>
<pre><code class="language-c">if (event.type == SDL_KEYDOWN) {
    // Toto je špatné řešení pohybu!
    if (event.key.keysym.sym == SDLK_RIGHT) {
        hrac.pozice.x += 10 * deltaTime;
    }
}
</code></pre>
<p>Mnohem lepší řešení je použít následující přístup:</p>
<ol>
<li>Mít v paměti uložený současný stav stisknutých kláves. To můžete udělat buď pomocí funkce na
<a href="c/aplikovane_ulohy/sdl/vstup.html#sou%C4%8Dasn%C3%BD-stav-1">získání stavu klávesnice</a>, nebo si můžete vytvořit proměnné, které si budou pamatovat stav kláves,
které vás zajímají, a poté aktualizovat jejich stav při čtení událostí. Pokud obdržíte událost <code>SDL_KEYDOWN</code>, tak nastavíte
stav klávesy na <code>stisknuto</code>, pokud obdržíte událost <code>SDL_KEYUP</code>, tak nastavíte stav na <code>uvolněno</code>.</li>
<li>V části herní smyčky, kde aktualizujete stav hry, se podíváte, jaký je stav kláves, a podle tohoto stavu uděláte danou
akci (např. posunete postavou hráče). Díky tomu se bude pohyb provádět plynule (např. 60 za vteřinu). Zároveň bude také
tento pohyb synchronizovaný s pohybem ostatních objektů hry, které nejsou ovládány klávesami.</li>
</ol>
<p>Pokud použijete tento přístup, tak si musíte dát pozor na to, aby se některé akce neopakovaly vícekrát. Například, pokud
budete při zmáčknutí klávesy vyvolávat nějakou jednorázovou akci (např. vystřelení projektilu), tak byste měli přidat do
hry kontrolu, jestli od posledního vyvolání této akce uběhl dostatečný čas (&quot;cooldown&quot;). I když totiž uživatel zmáčkne
klávesu velmi krátce, tak bude klávesa zmáčknutá pravděpodobně alespoň po dobu několika snímků! Pokud bychom tedy
nekontrolovali čas od posledního vyvolání akce, tak by se akce provedla opakovaně, což nemusí být žádoucí. Pro počítání
času, který ve hře uběhl, můžete použít <a href="c/aplikovane_ulohy/sdl/herni_smycka.html#kompenzace-fps">delta čas</a>, který si stačí v každé iteraci
přičítat do nějaké proměnné, která si bude pamatovat, kolik už uběhlo ve hře času.</p>
<h3><a class="header" href="#současný-stav-1" id="současný-stav-1">Současný stav</a></h3>
<p>Pokud bychom chtěli získat současný stav všech kláves, můžeme využít funkci <a href="https://wiki.libsdl.org/SDL2/SDL_GetKeyboardState"><code>SDL_GetKeyboardState</code></a>.
Tato funkce vrátí adresu pole, které můžeme indexovat pomocí hodnot datového typu <a href="https://wiki.libsdl.org/SDL2/SDL_Scancode"><code>SDL_Scancode</code></a>.
Jednotlivé hodnoty můžeme naleznout v druhém sloupci <a href="https://wiki.libsdl.org/SDL2/SDL_Scancode">této tabulky</a>. Např.
mezerník je reprezentován hodnotou <code>SDL_SCANCODE_SPACE</code>, klávesa <code>a</code> hodnotou <code>SDL_SCANCODE_A</code> a šipka doprava hodnotou
<code>SDL_SCANCODE_RIGHT</code>. Pokud je hodnota na daném indexu klávesy v poli nenulová, tak to znamená, že je tato klávesa
zrovna stisknutá:</p>
<pre><code class="language-c">const Uint8* key_state = SDL_GetKeyboardState(NULL);
if (key_state[SDL_SCANCODE_SPACE]) {
    printf(&quot;Prave ted je stisknut mezernik\n&quot;);
}
</code></pre>
<h1><a class="header" href="#chipmunk" id="chipmunk">Chipmunk</a></h1>
<p>Při tvorbě interaktivních grafických aplikací nebo her můžeme chtít simulovat pohyb objektů tak, aby
dodržoval fyzikální zákony (působení gravitace, tření a kolize objektů, pohyb lana atd.). K tomu
můžeme použít nějakou knihovnu na simulaci fyziky. <a href="https://chipmunk-physics.net"><code>Chipmunk</code></a> je
knihovna pro simulování jednoduchých fyzikálních procesů ve 2D prostoru.
<a href="https://www.youtube.com/watch?v=K84I4qqU8wg">Zde</a> se můžete podívat, co všechno se s takovou
knihovnou dá udělat.</p>
<p>Možná znáte hry jako <a href="https://youtu.be/aiiQ8btusrs?t=399">Angry Birds</a> nebo
<a href="https://youtu.be/3bdBToxbGqg?t=212">Fruit Ninja</a>. Podobné typy her by se bez nějaké knihovny pro
simulaci fyziky neobešly.</p>
<h2><a class="header" href="#instalace-1" id="instalace-1">Instalace</a></h2>
<p>Knihovna Chipmunk nenabízí distribuci již přeložených objektových souborů, musíme tedy její zdrojové
soubory přidat k našemu projektu a přeložit je ručně.</p>
<p>Stáhněte si poslední verzi <a href="https://chipmunk-physics.net/release/ChipmunkLatest.tgz">zdrojových kódů knihovny</a>
z webu <a href="https://chipmunk-physics.net/downloads.php">Chipmunku</a>, rozbalte je a výslednou složku
(např. <code>Chipmunk-X.Y.Z</code> nebo <code>ChipmunkLatest</code>) přejmenujte na <code>Chipmunk</code>.</p>
<p>Dále můžete knihovnu přidat ke svému <code>CMake</code> projektu pomocí následující <code>CMakeLists.txt</code> souboru:</p>
<details>
<summary>Ukázkový CMakeLists.txt soubor pro Chipmunk</summary>
<pre><code class="language-cmake">cmake_minimum_required(VERSION 3.4)

project(physics)

# Parametr -pthread je nutný při použití této knihovny
set(CMAKE_C_FLAGS &quot;${CMAKE_C_FLAGS} -pthread&quot;)

# Vložení adresáře Chipmunk
add_subdirectory(Chipmunk)

# Vytvoření programu
add_executable(physics main.c)

# Přidání knihovny k našemu programu
target_include_directories(physics PRIVATE Chipmunk/include/chipmunk)
target_link_libraries(physics chipmunk)
</code></pre>
</details>
<h2><a class="header" href="#chipmunk-hello-world" id="chipmunk-hello-world"><code>Chipmunk</code> hello world</a></h2>
<p>Stejně jako u <a href="c/aplikovane_ulohy/sdl.html"><code>SDL</code></a> není v silách tohoto textu poskytnout kompletního průvodce touto
knihovnou. Pro to můžete použít <a href="https://chipmunk-physics.net/release/ChipmunkLatest-Docs/">manuál</a>
nebo podrobnou <a href="https://chipmunk-physics.net/release/ChipmunkLatest-API-Reference/modules.html">dokumentaci funkcí</a>.</p>
<p>Zde je okomentovaná ukázka &quot;hello-world&quot; příkladu, který simuluje pád sady kostek a vykresluje je
pomocí SDL:</p>
<details>
<summary>Okomentovaný program využívající knihovny Chipmunk a SDL</summary>
<pre><code class="language-c">#include &lt;chipmunk.h&gt;
#include &lt;SDL2/SDL.h&gt;
#include &lt;SDL2/SDL_image.h&gt;
#include &lt;assert.h&gt;
#include &lt;stdbool.h&gt;

const int WIDTH = 800;
const int HEIGHT = 600;

int main() {
    // Vytvoření SDL okna a kreslítka
    assert(!SDL_Init(SDL_INIT_VIDEO));

    SDL_Window* window = SDL_CreateWindow(&quot;Physics&quot;, 100, 100, WIDTH, HEIGHT, SDL_WINDOW_SHOWN);
    SDL_Renderer* renderer = SDL_CreateRenderer(window, -1, SDL_RENDERER_ACCELERATED | SDL_RENDERER_PRESENTVSYNC);

    // Načtení obrázku z disku
    SDL_Texture* image = IMG_LoadTexture(renderer, &quot;wood.jpg&quot;);
    assert(image);

    SDL_SetRenderDrawColor(renderer, 0, 0, 0, 255);

    // Vytvoření prostoru, ve kterém bude probíhat fyzikální simulace
    cpSpace* space = cpSpaceNew();
    // Nastavení síly gravitace
    cpSpaceSetGravity(space, (cpVect) { .x = 0, .y = -100.0f });

    // Vytvoření země
    cpShape* ground = cpSegmentShapeNew(
        cpSpaceGetStaticBody(space),
        (cpVect) { .x = 0, .y = 10},
        (cpVect) { .x = WIDTH, .y = 10},
        0
    );
    cpShapeSetFriction(ground, 1.0f);    // Nastavení tření země
    cpSpaceAddShape(space, ground);      // Přidání země do světa

    const float mass = 10.0f;            // Váha kostky
    const int dimension = 30;            // Rozměr kostky

    cpShape* boxes[10];                  // Pole kostek
    for (int i = 0; i &lt; 10; i++) {
        // Vytvoření těla kostky, které se bude hýbat
        cpBody* body = cpBodyNew(mass, cpMomentForBox(mass, dimension, dimension));
        // Přidání těla do prostoru
        cpSpaceAddBody(space, body);
        // Nastavení pozice kostky
        cpBodySetPosition(body, (cpVect) {
            .x = 100 + 5 * i,
            .y = 40 + i * (dimension + 10)
        });

        // Vytvoření tvaru kostky, který bude použito pro detekci kolizí
        cpShape* shape = cpBoxShapeNew(body, dimension, dimension, 1);
        // Přidání tvaru do prostoru
        cpSpaceAddShape(space, shape);
        // Nastavení tření kostky
        cpShapeSetFriction(shape, 1.0f);

        boxes[i] = shape;
    }

    Uint64 last = SDL_GetPerformanceCounter();   // Počítání času vykreslování
    float physics_counter = 0.0f;                // Počítání času fyziky
    float timestep = 1.0f / 60.0f;               // Časový krok, o který se bude fyzika posouvat

    bool quit = false;
    while (!quit) {
        SDL_Event event;
        while (SDL_PollEvent(&amp;event)) {
            if (event.type == SDL_QUIT) {
                quit = true;
            }
        }

        Uint64 now = SDL_GetPerformanceCounter();

        // Počet vteřin od poslední iterace herní smyčky
        float delta_time_s = ((float)(now - last) / (float)SDL_GetPerformanceFrequency());
        last = now;

        // Odsimulování času fyziky
        physics_counter += delta_time_s;
        while (physics_counter &gt;= timestep) {
            cpSpaceStep(space, timestep);  // Provedení jednoho časového kroku
            physics_counter -= timestep;
        }

        SDL_RenderClear(renderer);

        for (int i = 0; i &lt; 10; i++) {
            cpShape* shape = boxes[i];
            cpBody* body = cpShapeGetBody(shape);

            cpVect position = cpBodyGetPosition(body);  // Získání pozice kostky
            float angle_radians = cpBodyGetAngle(body); // Získání úhlu kostky (v radiánech)
            float angle_deg = angle_radians * (180 / M_PI); // Převod na stupně

            SDL_Rect rect = {
                .x = position.x - dimension / 2,
                .y = HEIGHT - (position.y + dimension / 2),  // V Chipmunku jde Y nahoru, v SDL dolů, musíme jej vyměnit
                .w = dimension,
                .h = dimension
            };

            SDL_RenderCopyEx(renderer, image, NULL, &amp;rect, -angle_deg, NULL, SDL_FLIP_NONE);
        }

        SDL_RenderPresent(renderer);
    }

    // Uvolnění prostředků
    for (int i = 0; i &lt; 10; i++) {
        cpShape* shape = boxes[i];
        cpBody* body = cpShapeGetBody(shape);

        cpSpaceRemoveShape(space, shape);
        cpSpaceRemoveBody(space, body);
        cpShapeFree(shape);
        cpBodyFree(body);
    }
    cpSpaceRemoveShape(space, ground);
    cpShapeFree(ground);
    cpSpaceFree(space);
    SDL_DestroyTexture(image);
    SDL_DestroyRenderer(renderer);
    SDL_DestroyWindow(window);
    SDL_Quit();

    return 0;
}
</code></pre>
</details>
<p>Ukázka fungování programu:</p>
<p><video src="../../static/video/chipmunk-boxes.webm" controls></video></p>
<p>Tento program spolu s <code>CMakeLists.txt</code> souborem a knihovnou Chipmunk si můžete stáhnout
<a href="c/aplikovane_ulohy/../../static/snippets/physics.zip">zde</a>. Přeložit a spustit ho můžete pomocí následujících příkazů:</p>
<pre><code class="language-bash">$ mkdir build
$ cd build
$ cmake ..
$ make -j
$ cd ..
$ ./build/physics
</code></pre>
<h1><a class="header" href="#co-dál" id="co-dál">Co dál?</a></h1>
<p><em>C</em> je relativně malý jazyk, pokud jste si tedy přečetli předchozí část tohoto textu, tak znáte
většinu důležitých konstrukcí, která jsou v <em>C</em> dostupné. Nicméně neukázali jsme si úplně všechny –
zde je seznam několika vybraných věcí, které byly buď moc pokročilé pro UPR anebo jsme je jednoduše
nepotřebovali použít:</p>
<ul>
<li><a href="https://en.cppreference.com/w/c/variadic"><strong>Variadiacké funkce</strong></a> umožňují přijímat
libovolný počet parametrů (takto funguje například i nám známá funkce
<a href="https://devdocs.io/c/io/fprintf"><code>printf</code></a>).</li>
<li><a href="https://en.cppreference.com/w/c/language/enum"><strong>Enumerace</strong></a> (<em>enumerations</em>) umožňují
seskupit pojmenované konstanty.</li>
<li><a href="https://en.cppreference.com/w/c/language/union"><strong>Sjednocené struktury</strong></a> (<em>unions</em>)
umožňují interpretovat strukturu jako více různých datových typů.</li>
<li><a href="https://en.cppreference.com/w/c/language/bit_field"><strong>Bitová pole</strong></a> (<em>bit fields</em>)
umožňují rozdělit paměť struktury na úrovni jednotlivých bitů. </li>
<li><a href="http://www.cplusplus.com/reference/cwchar/"><strong>Široké znaky</strong></a> (<em>wide chars</em>) a s nimi související
funkce standardní knihovny umožňují používat složitější kódování než ASCII.</li>
<li><a href="https://en.cppreference.com/w/c/numeric/complex"><strong>Komplexní čísla</strong></a> (<em>complex numbers</em>) vám
umožní pracovat s datovými typy reprezentujícími komplexní čísla.</li>
</ul>
<blockquote>
<p>Pokud si chcete ověřit, jak jste na tom se znalostí jazyka <em>C</em>, projděte si tyto
<a href="c/../static/files/deepc.pdf">slidy</a>. Pokud budete umět odpovídat jako blonďatý
kluk, tak znáte základy jazyka <em>C</em>. Pokud budete umět odpovídat jako dívka s růžovými vlasy,
tak už vás v jazyce <em>C</em> téměř nic nepřekvapí.</p>
</blockquote>
<h2><a class="header" href="#co-se-dále-naučit" id="co-se-dále-naučit">Co se dále naučit</a></h2>
<p>Se znalostí samotného jazyka <em>C</em> souvisí i spousta dalších konceptů, se kterými se postupně musíte
seznámit, pokud chcete opravdu dopodrobna pochopit, co přesně se v počítači děje, když spustíte
vámi napsaný program. Poté můžete těchto znalostí využít k tvorbě robustnějších a rychlejších
programů. Na následujících odkazech se můžete dozvědět například:</p>
<ul>
<li>Jak fungují <a href="http://poli.cs.vsb.cz/edu/osy/osnova.html">operační systémy</a>.
<ul>
<li>Nebo dokonce jak si nějaký <a href="https://littleosbook.github.io/">napsat od nuly</a>.</li>
</ul>
</li>
<li>Jak komunikovat s jinými programy po <a href="http://www.beej.us/guide/bgnet/">síti</a>.</li>
<li>Jak psát programy přímo pomocí <a href="http://poli.cs.vsb.cz/edu/soj/down/soj-skripta.pdf">instrukcí procesoru</a></li>
<li>Jak urychlit provádění programů:
<ul>
<li>Pomocí <a href="https://computing.llnl.gov/tutorials/pthreads/">vláken</a>, které umí využít potenciál
vícejádrových procesorů.</li>
<li>Pomocí <a href="https://www.youtube.com/watch?v=qejTqnxQRcw">vektorových instrukcí</a>,
které umí pracovat s více než jednou hodnotou najednou.</li>
<li>Pomocí pochopení <a href="https://github.com/Kobzol/hardware-effects">architektury procesoru</a>, která
silně ovlivňuje výkon programů.</li>
</ul>
</li>
<li>Jak si napsat vlastní <a href="https://www3.nd.edu/%7Edthain/compilerbook/compilerbook.pdf">překladač</a> či
<a href="http://www.buildyourownlisp.com/chapter1_introduction">programovací jazyk</a>.</li>
<li>Jak si napsat vlastní <a href="https://cstack.github.io/db_tutorial/">databázi</a>.</li>
<li>Jak funguje <a href="http://mrl.cs.vsb.cz/people/fabian/pg1_course.html">počítačová grafika</a>.
<ul>
<li>Můžete si napsat vlastní <a href="https://learnopengl.com/">3D herní engine</a> pomocí OpenGL.</li>
</ul>
</li>
<li>Jak si napsat program pro nějaké vestavěné (<em>embedded</em>) zařízení, například <a href="https://www.arduino.cc/en/Tutorial/BuiltInExamples/Blink">Arduino</a>.</li>
</ul>
<h1><a class="header" href="#různé" id="různé">Různé</a></h1>
<p>Tato sekce obsahuje různá témata a návody, které nezapadají do zbytku textu, ale je dobré o nich
vědět.</p>
<h1><a class="header" href="#rozklad-problému" id="rozklad-problému">Rozklad problému</a></h1>
<p>Často se setkáte s tím, že dostanete k naprogramování úlohu, se kterou si nevíte rady a netušíte ani
jak začít. Například:</p>
<p><code>Načti obrázek z disku, změň jeho velikost, ulož ho do jiného souboru a vykresli jej na obrazovku.</code></p>
<p>Tato úloha vypadá velmi jednoduše, když je zadaná větou (v češtině), ale obzvláště pro začínající
programátory je obtížné převést takovouto úlohu do programovacího jazyka. Obecným pravidlem k usnadnění
řešení složitých úloh je rozdělovat je na menší a jednodušší podúlohy tak dlouho, dokud se nedostaneme
k podúloze, kterou již umíme vyřešit. Poté z těchto malých kousků, které máme vyřešené, zpětně poskládáme
celý program, který vyřeší původní úlohu.</p>
<p>Například zmíněnou úlohu můžeme rozdělit na následující podúlohy: </p>
<ul>
<li>Načti obrázek z disku
<ul>
<li>Otevři soubor se vstupním obrázkem</li>
<li>Načti hlavičku obrázku</li>
<li>Vytvoř paměť pro pixely obrázku
<ul>
<li>Naalokuj dostatek paměti dle hlavičky (šířka x výška)</li>
</ul>
</li>
</ul>
</li>
<li>Změň velikost obrázku
<ul>
<li>Vytvoř obrázek s novým rozměrem</li>
<li>Překopíruj původní obrázek do nového obrázku
<ul>
<li>Projdi všechny pixely nového obrázku
<ul>
<li>Projdi každý řádek</li>
<li>Pro každý řádek projdi každý sloupec</li>
</ul>
</li>
<li>Pro každý pixel spočítej původní pozici pixelu
<ul>
<li>Pro výpočet použij poměr šířky/výšky nového/starého obrázku</li>
</ul>
</li>
<li>Překopíruj pixel ze starého obrázku do nového</li>
</ul>
</li>
<li>Vrať nový obrázek</li>
</ul>
</li>
<li>Zapiš upravený obrázek
<ul>
<li>Otevři soubor k zápisu</li>
<li>Zapiš hlavičku obrázku do souboru</li>
<li>Zapiš pixely obrázku do souboru</li>
</ul>
</li>
<li>Vykresli upravený obrázek
<ul>
<li>Vytvoř okno pro vykreslení obrázku</li>
<li>Překopíruj pixely obrázku do otevřeného okna</li>
<li>Zobraz okno s obrázkem</li>
</ul>
</li>
</ul>
<p>Pomocí tohoto univerzálního postupu se dříve či později dostanete k (pod)úloze, kterou byste již měli umět
vyřešit (např. otevření souboru). Jakmile danou podúlohu vyřešíte, tak budete o krok blíže k řešení
původní složité úlohy.</p>
<p>Tímto způsobem můžeme programy rovnou od začátku začít psát. Například při řešení výše zmíněné úlohy
můžeme začít nadefinováním hlavní logiky programu pomocí volání funkcí, kde každá funkce bude reprezentovat
jednu podúlohu. I když funkce zatím nebudou naprogramované a později se třeba jejich název nebo rozhraní
trochu změní, tak nám toto rozdělení může pomoct přemýšlet nad problémem abstraktněji, zorientovat s
v něm a také získat naději, že se nám úlohu vůbec podaří vyřešit. Stejný princip opět můžeme použít
při implementaci jednotlivých funkcí. Program (či funkci) pak lze přečíst jako větu a je tak jednodušší
pochopit, co má vlastně dělat.</p>
<pre><code class="language-c">int main() {
    // Načti obrázek
    FILE* vstupni_soubor = otevri_soubor(...);
    Img obrazek = nacti_obrazek(vstupni_soubor);

    // Uprav jeho velikost
    Img upraveny_obrazek = uprav_velikost_obrazku(&amp;obrazek);

    // Zapiš obrázek
    FILE* vystupni_soubor = otevri_soubor(...);
    zapis_obrazek(vystupni_soubor, &amp;upraveny_obrazek);

    // Vykresli obrázek
    vykresli_obrazek(&amp;upraveny_obrazek);

    return 0;
}
</code></pre>
<h1><a class="header" href="#vyhodnocování-výrazů" id="vyhodnocování-výrazů">Vyhodnocování výrazů</a></h1>
<p>Abyste pochopili, co se děje, když váš program běží, a uměli ho odladit, tak je důležité, abyste si
uměli myšlenkově &quot;odsimulovat&quot;, co přesně procesor provádí, když vykonává příkazy vašeho programu.
Asi nejlepším nástrojem pro tento účel je použití <a href="ruzne/../prostredi/ladeni.html#krokov%C3%A1n%C3%AD">debuggeru</a>,
pomocí kterého můžete provádět váš program příkaz po příkazu a sledovat, jak se během toho měni
jeho výstup a hodnoty v paměti.</p>
<p>Důležité je zejména vědět, jak fungují příkazy <a href="ruzne/../c/rizeni_toku/rizeni_toku.html">řízení toku</a> a
jak funguje vyhodnocování <a href="ruzne/../c/prikazy_vyrazy.html">výrazů</a>. Níže naleznete několik příkladů, které
slouží k demonstraci toho, jak se postupně vyhodnocují výrazy v jazyce <em>C</em>.<sup class='margin-toggle sidenote-number'>1</sup></p>
<span class='sidenote'><p><sup class='number'>1</sup>Procesor ve skutečnosti s největší pravděpodobností nebude výrazy vyhodnocovat přesně tak,
jak je zde ukázáno, ale mnohem efektivněji. Výsledek by však měl být stejný, proto se vyplatí umět
vyhodnocovat výrazy &quot;v hlavě&quot;, abychom si ověřili, že program dělá to, co očekáváme.</p>
</span>
<ul>
<li>Aritmetické <a href="ruzne/../c/datove_typy/celociselne_typy.html">operace</a> a čtení <a href="ruzne/../c/promenne/promenne.html">proměnných</a>
<pre><code class="language-c">int a = 5;
int b = 8;
int c = 6;

// Níže je rozepsané vyhodnocení výrazu `c = (a + b) * c + 1 - b`
c = (a + b) * c + 1 - b;

// c = (a + b) * c + 1 - b
// c = (5 + b) * c + 1 - b
// c = (5 + 8) * c + 1 - b
// c = (13) * c + 1 - b
// c = 13 * c + 1 - b
// c = 13 * 6 + 1 - b
// c = 78 + 1 - b
// c = 79 - b
// c = 79 - 8
// c = 71

// Hodnota proměnné c je nyní 71
</code></pre>
</li>
<li>Volání <a href="ruzne/../c/funkce/funkce.html">funkcí</a>
<pre><code class="language-c">int foo(int a, int b) {
    int c = a + b;
    return c * 2 + b;
}
int main() {
    int x = 8;
    int y = foo(x, 5 + 2);
    // y = foo(x, 5 + 2)
    // y = foo(8, 5 + 2)
    // y = foo(8, 7)
    // y = 37

    int z = foo(foo(x, x), foo(y, 1) + 8);
    // z = foo(foo(x, x), foo(y, 1) + 8)
    // z = foo(foo(8, x), foo(y, 1) + 8)
    // z = foo(foo(8, 8), foo(y, 1) + 8)
    // z = foo(40, foo(y, 1) + 8)
    // z = foo(40, foo(37, 1) + 8)
    // z = foo(40, 77 + 8)
    // z = foo(40, 85)
    // z = foo(40, 85)
    // z = 335

    return 0;
}
</code></pre>
</li>
</ul>
<h1><a class="header" href="#generování-náhodných-čísel" id="generování-náhodných-čísel">Generování náhodných čísel</a></h1>
<p>Počítače jsou <strong>deterministické</strong> stroje, což znamená, že stejný program vždy na stejný vstup
vrátí stejný výstup. Často ovšem chceme, aby naše programy obsahovaly prvky &quot;náhody&quot;, když chceme
například:</p>
<ul>
<li>Hodit si kostkou v deskové hře</li>
<li>Udělit náhodný počet zranění v rozsahu zbraně</li>
<li>Oživit hráče na náhodné pozici na mapě</li>
</ul>
<p>Počítače samy o sobě opravdovou náhodu vytvořit nemohou, nicméně můžou ji simulovat pomocí tzv.
<strong>pseudo-náhodných generátorů čísel</strong> (<em>pseudo-random number generation</em>).</p>
<p>Vygenerovat (pseudo-)náhodnou sekvenci čísel pomocí deterministických operací můžeme například
následujícím algoritmem:</p>
<ol>
<li>Začneme s číslem <code>S</code>, které se nazývá <strong>počáteční náhodná hodnota</strong> (<em>random seed</em>).</li>
<li>Aplikujeme nějakou matematickou operaci na <code>S</code> a vyjde nám nové číslo <code>N</code>.</li>
<li><code>N</code> použijeme jako vygenerované &quot;náhodné číslo&quot;.</li>
<li>Nastavíme <code>S = N</code>.</li>
<li>Opakujeme postup od bodu 2).</li>
</ol>
<p>Ukázka kódu, který takovýto algoritmus implementuje:</p>
<pre><code class="language-c editable">int S = 5;
int vygeneruj_cislo() {
    int N = S;
    N = (5 * N + 3) % 6323;
    N = (4 * N + 2) % 8127;
    S = N;
    return N;
}
int main() {
    int r1 = vygeneruj_cislo(); // 114
    int r2 = vygeneruj_cislo(); // 2294
    int r3 = vygeneruj_cislo(); // 4348
    int r4 = vygeneruj_cislo(); // 2971
    int r5 = vygeneruj_cislo(); // 723
    return 0;
}
</code></pre>
<p>Takovýto algoritmus bude generovat (nekonečnou) sekvenci čísel, která bude lidem připadat &quot;náhodná&quot;
(bude těžké uhodnout, jaké číslo algoritmus vrátí příště).</p>
<h3><a class="header" href="#volba-počáteční-hodnoty-s" id="volba-počáteční-hodnoty-s">Volba počáteční hodnoty <code>S</code></a></h3>
<p>Určite jste si všimli, že výše zmíněný algoritmus bude pokaždé generovat stejnou sekvenci čísel pro
stejné počáteční <code>S</code>. To se může hodit, chceme-li například mít možnost zpětně přehrát sekvenci
pseudo-náhodných čísel, například pro odladění chyby v programu. Nicméně pokud by sekvence byla pokaždé
stejná, tak o (pseudo-)náhodě nemůže být řeč.</p>
<p>Proto se obvykle hodnota <em>seedu</em> volí tak, aby při každém spuštění programu byla jiná. Přirozenou
volbou pro počáteční hodnotu <code>S</code> je tak například čas<sup class='margin-toggle sidenote-number'>1</sup> při spuštění programu. Lze ale také použít
například pohyby myši nebo stisky kláves, které nedávno na počítači proběhly.</p>
<span class='sidenote'><p><sup class='number'>1</sup>Ve formě <a href="https://en.wikipedia.org/wiki/Unix_time">UNIX časového razítka</a>, tedy počtu vteřin
uběhlých od 1. 1. 1970.</p>
</span>
<h3><a class="header" href="#pseudo-náhodný-generátor-ve-standardní-knihovně-c" id="pseudo-náhodný-generátor-ve-standardní-knihovně-c">Pseudo-náhodný generátor ve standardní knihovně <em>C</em></a></h3>
<p>Při praktickém použití si obvykle nebudete psát generátor pseudo-náhodných sami, ale použijete již
hotové řešení. To nabízí například standardní knihovna <em>C</em> ve formě funkcí <code>srand</code> (nastav hodnotu
<em>seed</em>u) a <code>rand</code> (vygeneruj pseudo-náhodné číslo):</p>
<pre><code class="language-c editable">#include &lt;stdlib.h&gt;
#include &lt;time.h&gt;

int main() {
    int cas = (int) time(NULL); // získej současný čas
    srand(cas); // nastav S na současný čas

    int cislo1 = rand(); // pseudo-náhodné číslo z intervalu [0, RAND_MAX]
    int cislo2 = rand() % 100; // z intervalu [0, 99]
    int cislo3 = rand() % 100 + 5; // z intervalu [5, 104]
    float cislo4 = rand() / (float) RAND_MAX; // z intervalu [0.0, 1.0]

    return 0;
}
</code></pre>
<h1><a class="header" href="#dynamicky-rostoucí-pole" id="dynamicky-rostoucí-pole">Dynamicky rostoucí pole</a></h1>
<p>V kapitolách o <a href="ruzne/../c/pole/staticka_pole.html">statických</a> a <a href="ruzne/../c/pole/dynamicka_pole.html">dynamických</a>
polích jsme si ukázali, jak můžeme vytvořit paměť pro více proměnných uložených sekvenčně za sebou
v paměti. Tato pole však měla vždy jedno omezení, protože jejich velikost se po jejich vytvoření nedala
měnit. Jakmile však naše programy začnou být složitější, budeme si určitě chtít pamatovat více hodnot
bez toho, abychom museli nutně dopředu vědět, kolik těchto hodnot bude. Například:</p>
<ul>
<li>Čteme řádky z textového souboru, a nevíme dopředu, kolik těch řádků bude.</li>
<li>Chceme projít existující pole a vytáhnout z něj pouze ty prvky, které splňují nějakou vlastnost.</li>
<li>Uživatel v naší <a href="ruzne/../c/aplikovane_ulohy/sdl.html">SDL</a> aplikaci kliká na obrazovku a my chceme na každém
bodu kliknutí něco vykreslit.</li>
</ul>
<p>Proto je vhodné naučit se vytvořit pole, které můžeme postupně naplňovat, a jehož velikost se může
v čase zvětšovat. Takovému poli budeme říkat <strong>dynamicky rostoucí pole</strong> (dále pouze <em>rostoucí pole</em>).
Tato datová struktura je tak užitečná a často využívaná, že se ve spoustě programovacích jazycích
vyskytuje jako vestavěný stavební blok<sup class='margin-toggle sidenote-number'>1</sup>.</p>
<span class='sidenote'><p><sup class='number'>1</sup>C++: <a href="https://en.cppreference.com/w/cpp/container/vector">std::vector</a>, Java: <a href="https://docs.oracle.com/javase/8/docs/api/java/util/ArrayList.html">ArrayList</a>, C#: <a href="https://learn.microsoft.com/en-us/dotnet/api/system.collections.generic.list-1">List</a>, JavaScript: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array">Array</a></p>
</span>
<h2><a class="header" href="#implementace" id="implementace">Implementace</a></h2>
<p>Rostoucí pole bude muset být naalokované na haldě, protože na zásobníku bychom nebyli
schopni jeho velikost měnit, a museli bychom ji znát v době překladu, což by nám nepomohlo. Rostoucí
pole bude fungovat zhruba takto:</p>
<ol>
<li>Naalokujeme na haldě dynamické pole s nějakou počáteční velikostí.
<ul>
<li>Pole bude na začátku &quot;prázdné&quot;, tj. nebudou v něm uloženy žádné validní hodnoty, ale bude
obsahovat dostatečnou kapacitu na uložení nějakého počtu hodnot.</li>
</ul>
</li>
<li>Budeme do něj postupně přidávat prvky.</li>
<li>Jakmile bude pole zcela zaplněné, tak jej zvětšíme, abychom udělali místo pro další prvky.</li>
</ol>
<p>Zde je ukázka struktury, která bude implementovat rostoucí pole celých čísel (<code>int</code>ů):</p>
<pre><code class="language-c">typedef struct {
    int* data;
    int pocet;
    int kapacita;
} PoleIntu;
</code></pre>
<p>Pro implementaci budeme potřebovat minimálně tyto tři údaje:</p>
<ul>
<li><code>data</code> - ukazatel na data na haldě, která budou naalokovaná funkcí <a href="https://devdocs.io/c/memory/malloc"><code>malloc</code></a>.</li>
<li><code>pocet</code> - současný počet prvků v poli. Při práci s jakýmkoliv polem potřebujeme vždy vědět, kolik
prvků v něm je. Abychom si tuto informaci nemuseli pamatovat někde bokem, dáme ji přímo do struktury
rostoucího pole.</li>
<li><code>kapacita</code> - maximální počet prvků, které pole může obsahovat. Tato hodnota odpovídá tomu, pro kolik
prvků jsme vyalokovali paměť funkcí <code>malloc</code>.</li>
</ul>
<p>Nyní si ukážeme jak naimplementovat funkce, které budou s tímto polem pracovat.</p>
<h3><a class="header" href="#vytvoření-pole" id="vytvoření-pole">Vytvoření pole</a></h3>
<p>Pro vytvoření pole potřebujeme naalokovat paměť na haldě s nějakou úvodní <code>kapacitou</code>, kterou si můžeme
do funkce na vytvoření pole poslat jako argument:</p>
<pre><code class="language-c">void poleintu_vytvor(PoleIntu* pole, int kapacita) {
    // Naalokujeme pamet na halde
    pole-&gt;data = (int*) malloc(sizeof(int) * kapacita);
    // Na zacatku je pole prazdne, takze je pocet prvku 0
    pole-&gt;pocet = 0;
    // Kapacita odpovida tomu, kolik je pole schopne udrzet prvku, nez mu dojde misto
    pole-&gt;kapacita = kapacita;
}
</code></pre>
<h3><a class="header" href="#přidání-prvku-do-pole" id="přidání-prvku-do-pole">Přidání prvku do pole</a></h3>
<p>Při přidávání prvku do pole musíme daný prvek zapsat na první &quot;volné&quot; místo v poli. Na jaký index
musíme prvek zapsat?</p>
<ul>
<li>Když je pole prázdné (<code>pocet = 0</code>), tak zapíšeme nový prvek na index <code>0</code>:
<pre><code>[?, ?, ?, ?]
 ^
</code></pre>
</li>
<li>Když má pole jeden prvek (<code>pocet = 1</code>), tak zapíšeme nový prvek na index <code>1</code>:
<pre><code>[8, ?, ?, ?]
    ^
</code></pre>
</li>
<li>Když má pole dva prvky (<code>pocet = 2</code>), tak zapíšeme nový prvek na index <code>2</code>:
<pre><code>[8, 4, ?, ?]
       ^
</code></pre>
</li>
</ul>
<p>Počet prvků v poli tedy vždy přímo odpovídá indexu, na který bychom měli zapsat příští prvek.</p>
<p>Dejme tomu, že máme pole s kapacitou <code>4</code>, s dvěma prvky (<code>pocet</code> je <code>2</code>) a chceme do něj uložit
novou hodnotu <code>8</code>. Tuto hodnotu musíme zapsat na index <code>2</code>. A po zápisu prvku musíme také zvýšit
počet prvků v poli, protože jsme do pole vložili nový prvek!</p>
<pre><code>[5, 4, ?, ?]
       ^
       (pocet = 2)

[5, 4, 8, ?]
          ^
          (pocet = 3)
</code></pre>
<p>V kódu by to mohlo vypadat takto:</p>
<pre><code class="language-c">void poleintu_pridej(PoleIntu* pole, int hodnota) {
    // Zapiseme novy prvek na index dany soucasnemu poctu prvku
    pole-&gt;data[pole-&gt;pocet] = hodnota;
    // Zvysime pocet prvku o jednicku
    pole-&gt;pocet += 1;
}
</code></pre>
<h3><a class="header" href="#zvětšení-velikosti-pole" id="zvětšení-velikosti-pole">Zvětšení velikosti pole</a></h3>
<p>Nicméně to samo o sobě nestačí. Co když je totiž pole už plné? V tom případě nesmíme zapsat hodnotu
do paměti na indexu <code>pocet</code>, protože bychom zapsali data mimo validní paměť a došlo by tak k
<a href="ruzne/../caste_chyby/pametove_chyby.html#segmentation-fault">paměťové chybě</a> 💣!</p>
<p>Pokud tedy dojde k situaci, že už je naše pole plné, tak jej nejprve musíme zvětšit. To můžeme udělat
následujícím postupem:</p>
<ol>
<li>Naalokujeme nové, větší pole na haldě.
<ul>
<li>Jakou velikost (kapacitu) zvolit pro nové pole? Pokud bychom zvyšovali velikost o <code>1</code>, tak budeme
muset pole zvětšovat při přidání každého prvku, což by bylo velmi neefektivní. Obvykle se kapacita
rostoucích polí zdvojnásobí, díky čehož bude velikost růst exponenciálně a my tak nebudeme muset
často velikost zvětšovat.</li>
</ul>
</li>
<li>Překopírujeme původní data ze starého pole do nového pole.</li>
<li>Uvolníme paměť starého pole.</li>
<li>Nastavíme ukazatel (<code>data</code>) na nové pole na haldě.</li>
</ol>
<p>V kódu by to mohlo vypadat např. takto:</p>
<pre><code class="language-c">// Pokud je pole plne
if (pole-&gt;pocet == pole-&gt;kapacita) {
    // Zdvojnasobime kapacitu
    pole-&gt;kapacita = pole-&gt;kapacita * 2;
    // Naalokujeme nove pole s dvojnasobnou kapacitou
    int* nove_pole = (int*) malloc(sizeof(int) * pole-&gt;kapacita);
    // Prekopirujeme hodnoty ze stareho pole do noveho
    for (int i = 0; i &lt; pole-&gt;pocet; i++) {
        nove_pole[i] = pole-&gt;data[i];
    }
    // Uvolnime pamet stareho pole
    free(pole-&gt;data);
    // Nastavime ukazatel na nove pole
    pole-&gt;data = nove_pole;
}
</code></pre>
<p>Jelikož je tato funkcionalita v jazyce <em>C</em> relativně často používaná, standardní knihovna <em>C</em> obsahuje
funkci <a href="https://devdocs.io/c/memory/realloc"><code>realloc</code></a>, která toto zvětšení pole umí udělat za nás.
Kód výše tak lze zjednodušit:</p>
<pre><code class="language-c">if (pole-&gt;pocet == pole-&gt;kapacita) {
    pole-&gt;kapacita = pole-&gt;kapacita * 2;
    pole-&gt;data = (int*) realloc(pole-&gt;data, sizeof(int) * pole-&gt;kapacita);
}
</code></pre>
<p>Kompletní kód funkce na přidání prvku do rostoucího pole naleznete níže. </p>
<h3><a class="header" href="#smazání-pole" id="smazání-pole">Smazání pole</a></h3>
<p>Nesmíme samozřejmě zapomenout ani na to po sobě uklidit. Po skončení práce s polem bychom tedy měli
jeho paměť smazat:</p>
<pre><code class="language-c">void poleintu_smaz(PoleIntu* pole) {
    free(pole-&gt;data);
}
</code></pre>
<p>Celý kód dynamicky rostoucího pole <code>int</code>ů můžete naleznout zde:</p>
<details>
<summary>Dynamicky rostoucí pole intů</summary>
<pre><code class="language-c">typedef struct {
    // Ukazatel na data na haldě
    int* data;
    // Soucasny pocet prvku v poli
    int pocet;
    // Pocet prvku, ktery lze v poli maximalne mit.
    // Maximalni hodnota, ktere muze nabyvat `pocet`.
    int kapacita;
} PoleIntu;

void poleintu_vytvor(PoleIntu* pole, int kapacita) {
    // Naalokujeme pamet na halde
    pole-&gt;data = (int*) malloc(sizeof(int) * kapacita);
    // Na zacatku je pole prazdne, takze je pocet prvku 0
    pole-&gt;pocet = 0;
    // Kapacita odpovida tomu, kolik je pole schopne udrzet prvku, nez mu dojde misto
    pole-&gt;kapacita = kapacita;
}

void poleintu_pridej(PoleIntu* pole, int hodnota) {
    // Pokud je pole plne
    if (pole-&gt;pocet == pole-&gt;kapacita) {
        // Zdvojnasobime kapacitu
        pole-&gt;kapacita = pole-&gt;kapacita * 2;
        // Naalokujeme nove pole s dvojnasobnou kapacitou a nastavime ukazatel na nove pole
        pole-&gt;data = (int*) realloc(pole-&gt;data, sizeof(int) * pole-&gt;kapacita);
    }

    // Zapiseme novy prvek na index dany soucasnemu poctu prvku
    pole-&gt;data[pole-&gt;pocet] = hodnota;
    // Zvysime pocet prvku o jednicku
    pole-&gt;pocet += 1;
}

void poleintu_smaz(PoleIntu* pole) {
    // Smazeme dynamicke pole
    free(pole-&gt;data);
}
</code></pre>
</details>
<h2><a class="header" href="#zobecnění-pro-více-datových-typů" id="zobecnění-pro-více-datových-typů">Zobecnění pro více datových typů</a></h2>
<p>Výše popsané pole je velmi užitečné, nicméně můžeme jej použít pouze s jedním datovým typem (<code>int</code>).
V našich programech si určitě budeme chtít ukládat do rostoucího pole více datových typů. Jak toho
můžeme dosáhnout?</p>
<h3><a class="header" href="#separátní-kód-pro-každý-datový-typ" id="separátní-kód-pro-každý-datový-typ">Separátní kód pro každý datový typ</a></h3>
<p>Asi nejjednodušší způsob je prostě vzít kód tohoto pole a zkopírovat jej pro každý datový typ, který
budeme chtít do pole ukládat. Takže nám vzniknou struktury <code>PoleIntu</code>, <code>PoleCharu</code>, <code>PoleBoolu</code> atd.</p>
<p>I když je tento způsob relativně jednoduchý na provedení (<code>Ctrl + C</code>, <code>Ctrl + V</code> a přejmenování názvů),
tak asi tušíte, že má řadu nevýhod. V našem programu by vznikla spousta kódu, který by byl silně
zduplikovaný a pokud bychom narazili na nějakou chybu, tak bychom ji museli opravit na více místech.
Tento opakující se kód by také pravděpodobně byl dost nepřehledný.</p>
<p>Můžeme si trochu pomoct využitím <a href="ruzne/../c/preprocesor/makra.html">maker</a>:</p>
<pre><code class="language-c">#define VYTVOR_LIST(nazev, typ)\
typedef struct {\
   typ* data;\
   int pocet;\
   int kapacita;\
} nazev;

VYTVOR_LIST(PoleIntu, int)
VYTVOR_LIST(PoleFloatu, float)
</code></pre>
<p>Nicméně to má také své nevýhody (upravovat kód makra je relativně namáhavé) a pořád budeme mít separátní
datovou strukturu pro každý datový typ.</p>
<h3><a class="header" href="#pole-ukazatelů" id="pole-ukazatelů">Pole ukazatelů</a></h3>
<p>Pokud se zamyslíme nad tím, proč nemůžeme použít <code>PoleIntu</code> pro libovolný datový typ, je to způsobeno
tím, že každý prvek v tomto poli má fixní velikost (<code>sizeof(int)</code>, tedy pravděpodobně <code>4</code> byty). Do
tohoto pole tedy nemůžeme jednoduše ukládat prvky, které mají jinou velikost, což je problém.</p>
<p>Abychom tento problém obešli, můžeme vytvořit pole, jehož prvky budou mít také fixní velikost, ale
zároveň budou schopny poskytovat přístup k libovolné hodnotě libovolného datového typu. Toho můžeme
dosáhnout tak, že do pole nebudeme ukládat přímo hodnoty, které si chceme zapamatovat, ale pouze jejich
adresy. Vytvoříme tedy pole ukazatelů! Jelikož nevíme, s jakým datovým typem bude chtít uživatel toto
pole použít, tak nezvolíme pro typ ukazatele <code>int*</code> nebo např. <code>float*</code>, ale použijeme datový typ
&quot;obecného&quot; ukazatele, který prostě obsahuje adresu, ale neříká, co na dané adrese leží. Tím je typ
<code>void*</code>.</p>
<p>Strukturu pole bychom tedy mohli upravit takto:</p>
<pre><code class="language-c">typedef struct {
    void** data;
    int pocet;
    int kapacita;
} RostouciPole;
</code></pre>
<p>Předtím jsme uchovávali ukazatel, v němž byla adresa, na které ležel datový typ <code>int</code>, proto byl typ
atributu <code>data</code> <code>int*</code>. Nyní uchováváme ukazatel, v němž bude adrese, na které bude ležet datový typ
<code>void*</code>, proto bude typ atributu <code>data</code> <code>void**</code>.</p>
<p>V paměti bude tedy pole vypadat cca takto:</p>
<pre><code>// Predtim
[5, 8, 6, 4]

// Ted
 5
 ^   6
 |   ^
[|,|,|,|]
   |   |
   |   v
   |   4
   |
   ╰-&gt; 8
</code></pre>
<p>Každý prvek pole bude mít fixní velikost (<code>sizeof(void*)</code>, tedy pravděpodobně <code>8</code> bytů), a bude obsahovat
pouze adresu nějakého prvku (libovolného datového typu).</p>
<p>Když si tedy pole pamatuje adresy, odkud je vzít? Pokud bychom do pole dávali adresy např. lokálních
proměnných, tak pravděpodobně brzy narazíme na problémy:</p>
<pre><code class="language-c">RostouciPole pole;
pole_vytvor(&amp;pole, 10);
for (int i = 0; i &lt; 10; i++) {
    // Vloz do pole adresu promenne i
    pole_pridej(&amp;pole, &amp;i);
}
</code></pre>
<ol>
<li>Lokální proměnná může zaniknout dříve, než pole. V ten moment bude adresa v poli neplatná a dojde
k <a href="ruzne/nedefinovane_chovani.html">nedefinovanému chování</a> 💣.</li>
<li>V případě výše si ukládáme do pole adresu té stejné proměnné, takže všechny prvky v poli budou mít
stejnou hodnotu.</li>
<li>I pokud lokální proměnná bude existovat dostatečně dlouho, a budeme do pole ukládat adresy různých
proměnných, tak pořád budeme mít problém v tom, že si budeme muset tuto proměnnou ukládat &quot;někde bokem&quot;,
protože v poli bude pouze její adresa. Tím nevyřešíme náš původní problém s pole rostoucí velikosti,
pouze jej přesuneme jinam.</li>
</ol>
<p>Z toho důvodu se nám vyplatí ukládat do pole takové adresy, jejichž životnost bude neomezená, a nebudeme
se tak muset starat o to, jestli náhodou nejsou dealokovány moc brzy. Jinak řečeno, můžeme do pole
ukládat paměť alokovanou na <a href="ruzne/../c/prace_s_pameti/dynamicka_pamet.html">haldě</a>.</p>
<p>Takovéto pole by pak šlo používat např. takto:</p>
<pre><code class="language-c">RostouciPole pole;
pole_vytvor(&amp;pole, 10);

for (int i = 0; i &lt; 10; i++) {
    int* pamet = malloc(sizeof(int));
    *pamet = i + 1;
    pole_pridej(&amp;pole, pamet);
}

for (int i = 0; i &lt; 10; i++) {
    int* pamet = (int*) pole-&gt;data[i];
    printf(&quot;Prvek cislo %d: %d\n&quot;, i, *pamet);
}

pole_smaz(pole);
</code></pre>
<p>Při mazání pole bychom neměli zapomenout na uvolnění všech adres, které jsou v něm uloženy:</p>
<pre><code class="language-c">void pole_smaz(RostouciPole* pole) {
    for (int i = 0; i &lt; pole-&gt;pocet; i++) {
        free(pole-&gt;data[i]);
    }
    free(pole-&gt;data);
}
</code></pre>
<blockquote>
<p>V současné podobě lze funkci <code>pole_vloz</code> špatně použít. Pokud do ní dáme adresu, která nepochází
z funkce <code>malloc</code>, tak dojde k nedefinovanému chování při mazání pole. Zkuste navrhnout jinou verzi
funkce <code>pole_vloz</code>, která nepůjde použít špatně, a která zajistí, že paměť bude vždy vytvořena na
haldě. Můžete (musíte!) pro to změnit signaturu funkce.</p>
</blockquote>
<h4><a class="header" href="#typová-kontrola" id="typová-kontrola">Typová kontrola</a></h4>
<p>U obecného rostoucího pole je třeba dávat si velký pozor na to, že do něj budeme vkládat a poté z něj
vybírat stejné datové typy! Tím, že používáme typ <code>void*</code>, tak nás překladač nebude upozorňovat na
práci s nekompatibilními datovými typy. Pokud do pole nejprve vložíte adresu <code>int</code>u, a poté se k této
adrese budete chovat, jako by to byla adresa např. <code>float</code>u (<code>float*</code>), tak se váš program nebude
chovat správně!</p>
<p>Celý kód dynamicky rostoucího pole <code>int</code>ů můžete naleznout zde:</p>
<details>
<summary>Dynamicky rostoucí pole adres</summary>
<pre><code class="language-c">typedef struct {
    // Ukazatel na data na haldě
    void** data;
    // Soucasny pocet prvku v poli
    int pocet;
    // Pocet prvku, ktery lze v poli maximalne mit.
    // Maximalni hodnota, ktere muze nabyvat `pocet`.
    int kapacita;
} RostouciPole;

void pole_vytvor(RostouciPole* pole, int kapacita) {
    // Naalokujeme pamet na halde
    pole-&gt;data = (void**) malloc(sizeof(void*) * kapacita);
    // Na zacatku je pole prazdne, takze je pocet prvku 0
    pole-&gt;pocet = 0;
    // Kapacita odpovida tomu, kolik je pole schopne udrzet prvku, nez mu dojde misto
    pole-&gt;kapacita = kapacita;
}

void pole_pridej(RostouciPole* pole, void* adresa) {
    // Pokud je pole plne
    if (pole-&gt;pocet == pole-&gt;kapacita) {
        // Zdvojnasobime kapacitu
        pole-&gt;kapacita = pole-&gt;kapacita * 2;
        // Naalokujeme nove pole s dvojnasobnou kapacitou a nastavime ukazatel na nove pole
        pole-&gt;data = (void**) realloc(pole-&gt;data, sizeof(void*) * pole-&gt;kapacita);
    }

    // Zapiseme novy prvek na index dany soucasnemu poctu prvku
    pole-&gt;data[pole-&gt;pocet] = adresa;
    // Zvysime pocet prvku o jednicku
    pole-&gt;pocet += 1;
}

void pole_smaz(RostouciPole* pole) {
    for (int i = 0; i &lt; pole-&gt;pocet; i++) {
        free(pole-&gt;data[i]);
    }
    free(pole-&gt;data);
}
</code></pre>
</details>
<h3><a class="header" href="#pole-bytů" id="pole-bytů">Pole bytů</a></h3>
<p>Pole ukazatelů je relativně jednoduché na použití, ale má také nevýhody, hlavně co se týče plýtvání
pamětí, protože musíme všechny hodnoty alokovat na haldě, a také s tím související neefektivitou.</p>
<p>Rostoucí pole můžeme navrhnout ještě jinak, pokud se k němu budeme chovat v podstatě jako k poli bytů,
do kterých budeme byte po bytu kopírovat hodnoty, které v něm chceme ukládat. V této variantě bychom
si ve struktuře ukládali pole bytů (znaků), a také velikost datového typu, který chceme do pole ukládat.</p>
<pre><code class="language-c">typedef struct {
    // Pole bytů/znaků
    char* data;
    // Velikost datového typu
    int velikost_prvku;
    int pocet;
    int kapacita;
} RostouciPole;
</code></pre>
<p>Při vkládání nového prvku pak stačí jeho byty nakopírovat do našeho pole, a při získávání prvku zase
byty zpět vykopírovat na adresu, kterou poskytne uživatel:</p>
<pre><code class="language-c">void pole_pridej(RostouciPole* pole, void* adresa) {
    if (pole-&gt;pocet == pole-&gt;kapacita) { /* zvetseni pole */ }

    // Vypocteme cilovou adresu, která bude na &quot;indexu&quot; `pocet` * `velikost_prvku`
    void* cil = pole-&gt;data + (pole-&gt;pocet * pole-&gt;velikost_prvku);
    // Zapiseme na danou adresu vsechny byty nasi vkladane hodnoty
    memcpy(cil, adresa, pole-&gt;velikost_prvku);
}

void pole_vrat(RostouciPole* pole, int index, void* adresa) {
    // Vypocteme cilovou adresu, která bude na &quot;indexu&quot; `index` * `velikost_prvku`
    void* zdroj = pole-&gt;data + (indexu * pole-&gt;velikost_prvku);
    // Zapiseme na predanou adresu vsechny byty nasi ziskavane hodnoty
    memcpy(adresa, zdroj, pole-&gt;velikost_prvku);
}
</code></pre>
<p>Aby toto řešení bylo plně korektní, museli bychom implementaci ještě rozšířit tak, aby brala v potaz
<a href="ruzne/../c/struktury/pametova_reprezentace.html#zarovn%C3%A1n%C3%AD">zarovnání</a> daného datového typu, jinak by se mohlo
stát, že bude vložená hodnota v poli ležet na nezarovnané adrese.</p>
<h1><a class="header" href="#funkce-main" id="funkce-main">Funkce <code>main</code></a></h1>
<p>Funkce <code>main</code> je speciální funkce, která se začne vykonávat při spuštění programu. Může vypadat
například takto:</p>
<pre><code class="language-c">int main() {
    return 0;
}
</code></pre>
<p>Proč tato funkce vrací číslo (<code>int</code>) a proč se obvykle z této funkce vrací hodnota <code>0</code>? Operační
systémy mají zavedenou konvenci, že každý spuštěný program by měl po svém vykonání vrátit číselnou
hodnotu, která systému napoví, jestli program proběhl úspěšně, nebo ne. Díky tomu pak lze relativně
jednoduše detekovat, jestli v programu nastala chyba, a případně na ni nějak zareagovat (z Windows
možná znáte dialog &quot;Program neproběhl správně…&quot;).</p>
<p>Číslo, které vrátíte z funkce <code>main</code>, se použije právě jako návratová hodnota programu pro operační
systém. Význam navrácených čísel není nijak standardizován, jediné, co platí obecně, je, že hodnota
<code>0</code> značí úspěch a jakákoliv jiná hodnota značí neúspěch. Proto tedy za normálních okolností z
<code>main</code>u vracíme <code>0</code>, abychom dali systému najevo, že program proběhl úspěšně.</p>
<h3><a class="header" href="#vstupní-parametry-funkce-main" id="vstupní-parametry-funkce-main">Vstupní parametry funkce <code>main</code></a></h3>
<p>Funkce <code>main</code> je speciální ve více ohledech. Kromě formy bez parametrů, kterou jste viděli výše,
můžete <code>main</code> použít také takto, s dvěma parametry:</p>
<pre><code class="language-c">int main(int argc, char** argv) {
    return 0;
}
</code></pre>
<p>První parametr je typu <code>int</code> a druhý parametr typu <a href="ruzne/../c/prace_s_pameti/ukazatele.html">ukazatel</a> na
<a href="ruzne/../c/text/retezce.html">řetězec</a>. Do těchto parametrů se uloží hodnoty zadané při spuštění programu v
terminálu, tzv. <strong>argumenty příkazového řádku</strong> (<em>command line arguments</em>). Parametr <code>argc</code>
(<em>argument count</em>) bude obsahovat počet předaných argumentů a parametr <code>argv</code> obsahuje ukazatel na
první prvek <a href="ruzne/../c/pole/pole.html">pole</a> <em>C</em> <a href="ruzne/../c/text/retezce.html">řetězců</a>, kde každý řetězec bude obsahovat
jeden argument. Prvním argumentem je dle konvence vždy cesta k spustitelnému souboru programu,
který je právě spouštěn, další argumenty se nastaví podle zadaného textu v terminálu (argumenty
jsou oddělené mezerou).</p>
<p>Například, pokud program spustíte takto: <code>./program hello world</code>, tak parametry funkce <code>main</code> budou
mít následující hodnoty:</p>
<ul>
<li><code>argc</code> bude obsahovat celé číslo <code>3</code> </li>
<li><code>argv[0]</code> bude obsahovat řetězec <code>&quot;./program&quot;</code></li>
<li><code>argv[1]</code> bude obsahovat řetězec <code>&quot;hello&quot;</code></li>
<li><code>argv[2]</code> bude obsahovat řetězec <code>&quot;world&quot;</code></li>
</ul>
<h1><a class="header" href="#parametry-překladače" id="parametry-překladače">Parametry překladače</a></h1>
<p>Překladač GCC obsahuje sadu několika stovek parametrů, pomocí kterých můžeme ovlivnit, jak překlad
programu proběhne. Můžeme například určit, pro jaký procesor se mají vygenerovat instrukce, jakou
variantu jazyka <em>C</em> má překladač očekávat nebo jestli má náš program zoptimalizovat, aby běžel
rychleji.</p>
<blockquote>
<p>Kromě GCC existuje řada dalších překladačů <em>C</em>, například <a href="https://clang.llvm.org/">Clang</a>.
Nejčastější parametry (jako je např. <code>-o</code>) obvykle fungují ve všech překladačích obdobně, každý
překladač ale obsahuje sadu specifických parametrů, které můžete naleznout v jeho
<a href="https://clang.llvm.org/docs/ClangCommandLineReference.html">dokumentaci</a>.</p>
</blockquote>
<p>Seznam všech parametrů můžete naleznout v
<a href="https://gcc.gnu.org/onlinedocs/gcc/Invoking-GCC.html">dokumentaci <code>gcc</code></a>, zde je uveden seznam
nejužitečnějších parametrů:</p>
<ul>
<li>
<p><strong>Optimalizace</strong>: Existuje spousta parametrů, pomocí kterých můžete ovlivnit, jak překladač převede
váš zdrojový kód na strojové instrukce a jak je zoptimalizuje. Nejzákladnějším parametrem je <code>-O</code>:</p>
<ul>
<li><code>-O0</code> Nebudou použity téměř žádné optimalizace. Toto je implicitní nastavení,
pokud ho nezměníte. Program v tomto stavu lze dobře <a href="ruzne/../prostredi/ladeni.html#krokov%C3%A1n%C3%AD">krokovat</a>,
ale může být dost pomalý.</li>
<li><code>-O1</code> Aplikuje základní optimalizace.</li>
<li><code>-O2</code> Aplikuje nejužitečnější optimalizace. Pokud chcete získat rozumně rychlý program,
doporučujeme použít tento mód. Díky němu může být program třeba až 1000x rychlejší než s <code>-O0</code>.<sup class='margin-toggle sidenote-number'>1</sup><span class='sidenote'><p><sup class='number'>1</sup>Anebo nemusí být rychlejší vůbec, záleží na programu.</p>
</span></li>
<li><code>-O3</code> Aplikuje ještě více optimalizací. Program tak může být ještě rychlejší než s <code>-O2</code>.
Obecně při použití optimalizací však platí, že čím vyšší optimalizační stupeň, tím více hrozí,
že se váš program přestane chovat správně, pokud program obsahuje jakékoliv
<a href="ruzne/../c/promenne/promenne.html#v%C5%BEdy-inicializujte-prom%C4%9Bnn%C3%A9">nedefinované chování</a>. Je tak třeba dávat
pozor na to, aby k tomu nedošlo.</li>
</ul>
<p>Kromě parametru <code>-O</code> lze použít spousty dalších parametrů, které ovlivňují například použití
<a href="ruzne/../c/co_dal.html">vektorových instrukcí</a>.</p>
</li>
<li>
<p><strong>Ladění programu</strong>:
Jak už jste jistě poznali, při použití jazyka <em>C</em> je velmi jednoduché způsobit nějaké nedefinované
chování, například nějakou <a href="ruzne/../caste_chyby/pametove_chyby.html">paměťovou chybou</a>. Aby šlo tyto
chyby detekovat, obsahují překladače tzv. <em>sanitizery</em>. Při použití sanitizeru se do vašeho
programu přidají dodatečné instrukce, které poté při běhu programu kontrolují, jestli nedochází
k nějakému problému. Cenou za tuto kontrolu je pomalejší běh programu (cca 2-5x). Sanitizery tak
raději používejte pouze při vývoji programu.</p>
<p>Existuje více <a href="https://gcc.gnu.org/onlinedocs/gcc/Instrumentation-Options.html">typů sanitizerů</a>,
my si ukážeme dva:</p>
<ul>
<li><code>-fsanitize=address</code> Použije tzv. <em>Address Sanitizer</em>, který hlídá paměťové chyby, například
přístup k nevalidní paměti nebo neuvolnění <a href="ruzne/../c/prace_s_pameti/dynamicka_pamet.html">dynamické paměti</a>.
Tento sanitizer je nesmírně užitečný a doporučujeme ho vždy používat při vývoji programů v <em>C</em>.</li>
<li><code>-fsanitize=undefined</code> Použije tzv. <em>Undefined behaviour sanitizer</em>, který hlídá dodatečné
situace, při kterých může dojít k nedefinovanému chování (kromě paměťových chyb).</li>
</ul>
<p>Obecně při ladění programu je taky vhodné vždy použít přepínač <code>-g</code>. Ten způsobí, že překladač
přidá do výsledného spustitelného souboru informace o zdrojovém kódu (ty jinak ve spustitelném
souboru chybí). Díky tomu budou sanitizery schopny zobrazit konkrétní řádek, na kterém vznikl
nějaký problém a také půjde program ladit a krokovat. </p>
</li>
<li>
<p><strong>Analýza kódu</strong>: Kromě sanitizerů, které kontrolují váš program za běhu, lze také spoustu chyb
odhalit již při překladu programu. Bohužel překladač <code>gcc</code> v implicitním módu není moc striktní a
některé vyloženě chybné situace vám promine a program přeloží, i když je již dopředu jasné, že při
běhu pak dojde např. k pádu programu. Abychom tomu předešli, můžeme zapnout při překladu dodatečná
<strong>varování</strong> (<em>warnings</em>), která nás mohou na potenciálně problematické situace upozornit:</p>
<ul>
<li><code>-Wall</code> Zapne sadu několika desítek základních varování.</li>
<li><code>-Wextra</code> Zapne dodatečnou sadu varování.</li>
<li><code>-Wconversion</code> Zapne detekci situací, kdy implicitní konverze mezi různými datovými typy
může způsobit nežádoucí nebo neočekávané chování. Pokud je chování detekované touto analýzou
žádoucí, je třeba provést explicitní přetypování.</li>
<li><code>-pedantic</code> Zapne striktní kontrolu toho, že dodržujete předepsaný standard <em>C</em>. V kombinaci
s tímto přepínačem byste také měli explicitně říct, který standard chcete použít. V UPR používáme
standard <em>C99</em>, který lze zadat pomocí <code>-std=c99</code>.</li>
<li><code>-Werror</code> Způsobí, že libovolné varování bude vnímáno jako chyba. Pokud tak
v programu <code>gcc</code> nalezne jakoukoliv situaci, která vytvoří varování, program se nepřeloží.</li>
</ul>
<p>Pokud chcete mít při překladu co největší zpětnou vazbu od překladače a zajistit co největší
&quot;bezpečnost&quot; vašeho programu, doporučujeme používat tuto kombinaci přepínačů:</p>
<pre><code class="language-bash">$ gcc -g -fsanitize=address -Wall -Wextra -Wconversion -pedantic -std=c99
</code></pre>
</li>
</ul>
<h1><a class="header" href="#nedefinované-chování" id="nedefinované-chování">Nedefinované chování</a></h1>
<p>V těchto skriptech často zmiňujeme pojem <strong>nedefinované chování</strong> 💣 (<em>undefined behaviour</em> neboli <em>UB</em>).
Tento mechanismus jazyka <em>C</em> je často těžko uchopitelný, a nemusí být jasné, proč jej vlastně tento jazyk obsahuje,
a jak velké nebezpečí pro korektnost programů představuje. Tato kapitola se pokusí situaci trochu více osvětlit.</p>
<blockquote>
<p>Příklady v této kapitole předpokládají znalost některých konstrukcí <em>C</em>, které jsou postupně vysvětlovány ve skriptech.
Pokud jste se k těmto konstrukcím ještě nedostali a příkladům nerozumíte, tak se k nim vraťte později, až toho budete
znát z <em>C</em> více.</p>
</blockquote>
<p>Jazy <em>C</em> má svůj <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n1256.pdf">standard</a>, což je dokument, který definuje,
jaká jsou pravidla programů napsaných v <em>C</em>, a jakým způsobem se musí chovat překladače, aby <em>C</em> programy korektně přeložily.
Tento dokument popisuje například jaké velikosti můžou mít datové typy, jak má fungovat volání funkcí atd. Zároveň ale
také popisuje řadu situací, které jsou označeny jako <strong>nedefinované chování</strong>, odkud pochází název UB (undefined behaviour).
Tím, že jsou tyto situace označeny jako nedefinované, tak překladače při překladu programu mohou <strong>předpokládat, že k nim
nikdy nedojde</strong>.</p>
<p>Díky tomuto předpokladu jsou překladače schopny lépe optimalizovat <em>C</em> programy, a generovat tak efektivnější
strojový kód<sup class='margin-toggle sidenote-number'>1</sup>. Zároveň to ale znamená, že pokud programátor ve svém <em>C</em> programu takovouto nedefinovanou situaci vytvoří,
tak budou porušeny předpoklady překladače, což znamená, že může dojít k tomu, že překladač náš <strong>program přeloží špatně</strong>.
Pokud tedy ve vašem programu je situace způsobující UB, nemá žádný smysl bavit se o tom, co program dělá nebo co by mohl dělat.
Program je prostě špatně z pohledu pravidel jazyka <em>C</em>, a překladač z něj může vygenerovat program, který provádí něco
naprosto nesmyslného (nebo neprovádí vůbec nic). Problematické chování programů způsobené UB se projeví zejména, pokud
překládáte program s <a href="ruzne/parametry_prekladace.html">optimalizacemi</a>, nicméně to neznamená, že bez optimalizací je UB neškodné!</p>
<span class='sidenote'><p><sup class='number'>1</sup>Toto je také původní motivací, proč vůbec něco jako UB bylo vytvořeno - aby překladače mohly generovat efektivnější
kód, díky tomu, že můžou spoléhat na více předpokladů o našich programech.</p>
</span>
<p>Někdy lze nedefinované chování detekovat již pomocí statické analýzy, kterou provádí kompilátor.
Velké množství statické analýzy, kterou kompilátor dokáže provést, ovšem není implicitně zapnuto,
a musíme je vynutit při překladu pomocí <a href="ruzne/parametry_prekladace.html">parametrů kompilátoru</a>.
Při kompilaci je vhodné využívat alespoň parametry <code>-Wall -Wextra -Wconversion -Wuninitialized</code>.</p>
<p>Ne všechny situace způsobující nedefinované chování je ovšem možné zachytit statickou analýzou.
Musíte se tak spolehnout na to, že budete pozorně zkoumat svůj kód, a případně využívat nástrojů,
jako je <a href="ruzne/../prostredi/ladeni.html#address-sanitizer">Address sanitizer</a>, Undefined behaviour
sanitizer nebo <a href="ruzne/../prostredi/ladeni.html#valgrind">Valgrind</a>, které vám mohou pomoci detekovat
následky přítomnosti UB ve vašich programech za běhu programu.</p>
<h1><a class="header" href="#příklad" id="příklad">Příklad</a></h1>
<p>Zde si ukážeme příklad UB způsobeného přístupem mimo validní paměť pole. Na tomto příkladu si můžeme ukázat, že přítomnost
UB v našem zdrojovém kódu může způsobit kompletní rozklad programu, a že nemá smysl spekulovat nad tím, jak se program
obsahující UB bude nebo nebude chovat.</p>
<p>V této funkci dochází k zjišťování, jestli se předaný argument nachází v poli čtyř čísel. V cyklu dochází k UB - naleznete
jej?</p>
<pre><code class="language-c">int je_cislo_v_poli(int v) {
    int table[4] = { 5, 13, 8, 12 };

    for (int i = 0; i &lt;= 4; i++) {
        if (table[i] == v) return 1;
    }
    return 0;
}
</code></pre>
<p>Jedná se o přístup mimo pole, protože podmínka for cyklu je <code>i &lt;= 4</code>, místo <code>i &lt; 4</code>. Pokud uvidíte takovýto kód, může
vás napadnout, že při páté iteraci cyklu dojde k přístupu mimo paměť, možná se vyvolá
<a href="ruzne/../caste_chyby/pametove_chyby.html#segmentation-fault">segmentation fault</a>, ale pokud je funkce zavolána např. s argumentem
<code>5</code>, tak vlastně funkce proběhne &quot;normálně&quot;. Není tomu tak! Tento program obsahuje UB, takže jej překladač může přeložit,
jak se mu zachce.</p>
<p>Například může dojít k tomuto:</p>
<ol>
<li>Překladač vidí, že <code>table[4]</code> je UB, tj. k této situaci nikdy nemůže dojít.</li>
<li>Tím pádem <code>i</code> nikdy nemůže být <code>4</code>.</li>
<li>Pokud <code>i</code> nikdy nemůže být <code>4</code>, tak logicky nikdy nemůže být ani <code>5</code> (protože jinak by předtím muselo být <code>i=4</code>).</li>
<li>Jelikož <code>i</code> nemůže být <code>5</code>, tak smyčka je nekonečná, a jediný způsob, jak se může uvnitř smyčky funkce ukončit, je
provedením <code>return 1;</code>.</li>
<li>Tím pádem překladač funkci přeloží takto:
<pre><code class="language-c">int je_cislo_v_poli(int v) {
    return 1;
}
</code></pre>
</li>
</ol>
<p>Zdá se vám to moc divoké? Přesně toto <a href="https://godbolt.org/z/e8da3qYnx">udělá</a> překladač GCC, pokud takovouto funkci
přeložíte s optimalizacemi.</p>
<p>Nicméně, neznamená to, že se takto program musí zachovat vždy. Kdybyste použili jiný překladač, jinou verzi stejného
překladače, jiné <a href="ruzne/parametry_prekladace.html">parametry překladu</a> nebo dokonce program prostě spustili vícekrát, pokaždé
by se mohlo stát něco jiného. <strong>Nemá cenu řešit, jak se zachová program obsahující UB</strong>. Místo toho je nutné UB najít a
z kódu odstranit :)</p>
<h1><a class="header" href="#které-situace-vedou-k-ub" id="které-situace-vedou-k-ub">Které situace vedou k UB?</a></h1>
<p>Neexistuje jednotný seznam, který by vyjmenovával všechny možné situace vedoucí k UB, nicméně zde je alespoň seznam běžně
se vyskytujících problémových situací:</p>
<ul>
<li><strong>Dělení nulou</strong></li>
<li><strong>Čtení neinicializované paměti</strong>
U této situace si občas programátoři myslí, že když budou např. číst z neinicializované proměnné, tak program prostě
přečte nějaká &quot;náhodná&quot; data, která se zrovna vyskytují v paměti. To není pravda! Čtení neinicializované paměti je UB,
a tím pádem program může udělat cokoliv. Například:
<pre><code class="language-c">int foo(int a) {
    int b;
    if (a == 5 || b == 6) {
        return 1;
    }
    return 2;
}
</code></pre>
Pokud tento program <a href="https://godbolt.org/z/G5E5Y16cb">přeložíte</a> s optimalizacemi, tak se celá funkce může zredukovat
pouze na:
<pre><code class="language-c">int foo(int a) {
    return 1;
}
</code></pre>
Jak je to možné? Čtení neinicializované proměnné je UB, takže překladač klidně může předpokládat, že <code>b</code> bude vždy <code>6</code>,
a tím pádem bude z funkce vždy vrácena jednička.</li>
<li><strong>Chybějící <code>return</code> ve funkci, která nevrací <code>void</code></strong>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int foo() {}
int bar() {
  printf(&quot;bar\n&quot;);
}
</code></pre>
Zde je UB, protože <code>foo</code> nevrací hodnotu typu <code>int</code>. Když se podíváme, jak překladač může tuto funkci
<a href="https://godbolt.org/z/aacGjqhzE">přeložit</a>, tak se např. může stát to, že <code>foo</code> bude na stejné adrese jako <code>bar</code>,
takže kdyby někdo zavolal funkci <code>foo</code>, ve skutečnosti se začne provádět funkce <code>bar</code>!</li>
<li><strong>Přetečení celého čísla se znaménkem</strong>
Čísla se znaménkem (např. <code>int</code>) nesmí &quot;přetéct&quot;, tj. dostat se přes svou nejvyšší hodnotu. Tato situace je v jazyce <em>C</em>
UB.</li>
<li><strong>Přístup mimo validní paměť</strong> Přístup mimo validní paměť (např. mimo rozsah pole) je klasický příklad UB.</li>
<li><strong>Dereference NULL ukazatele</strong> Toto je opět klasický příklad UB.</li>
<li><strong>Vícenásobné uvolnění dynamické paměti</strong> Viz <a href="ruzne/../caste_chyby/pametove_chyby.html#segmentation-fault">Segmentation fault</a>.</li>
<li><strong>Přístup k uvolněné dynamické paměti</strong> Viz <a href="ruzne/../caste_chyby/pametove_chyby.html#segmentation-fault">Segmentation fault</a>.</li>
</ul>
<h1><a class="header" href="#provedení-ub" id="provedení-ub">Provedení UB</a></h1>
<p>UB způsobuje problémy &quot;pouze&quot; pokud je kód obsahující UB opravdu proveden za běhu programu. Přesněji řečeno, pokud se
program kdykoliv dostane do stavu, že někdy v budoucnu nutně musí dojít k provedení UB (tj. například program je na řádku
5, UB je na řádku 8, ale mezi těmito řádky není žádný skok/podmínka/cyklus/něco, co by mohlo přerušit chod programu), tak
v tento moment může UB způsobit problémy.</p>
<p>Například, v tomto konkrétním programu není chyba, protože UB (dělení nulou) na řádku 4 se nikdy neprovede.</p>
<pre><code class="language-c mainbody">int main() {
    int a = 5;
    if (a &gt; 6) {
        a / 0;
    }

    return 0;
}
</code></pre>
<p>Naproti tomu, v následujícím programu může dojít k nesmyslnému chování (nevypíše se nic na výstup, i když funkce dostane
nulu jako argument), i když samotné UB v ten moment vzniká až na řádku <code>5 / a</code>:</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int foo(int a) {
  if (a == 0) {
    printf(&quot;spatny vstup\n&quot;);
  }
  return 5 / a;
}
</code></pre>
<p>Proč? Protože překladač může předpokládat, že k dělení nulou nemůže nikdy dojít (protože dělení nulou je UB). Jelikož
nemůžeme dělit nulou, a ve funkci dochází k dělení <code>a</code>, tak <code>a == 0</code> musí být nutně <code>false</code>! Tím pádem k výpisu nikdy
nemusí dojít, ani kdyby do funkce byl zaslán argument <code>0</code>.</p>
<p>Více informací o UB se můžete dozvědět např. <a href="https://blog.llvm.org/2011/05/what-every-c-programmer-should-know.html">zde</a>.</p>
<h1><a class="header" href="#tahák" id="tahák">Tahák</a></h1>
<p>Tato stránka obsahuje zkomprimované informace o všech důležitých syntaktických konstrukcích jazyka <em>C</em>, které budeme
v UPR používat. Zejména ze začátku může být užitečná pro to, abyste si mohli rychle připomenout, jak v <em>C</em> zapsat nějaký
konkrétní příkaz. Podobné taháky můžete naleznout také třeba <a href="https://quickref.me/c.html">zde</a> nebo
<a href="https://cheatography.com/ashlyn-black/cheat-sheets/c-reference/">zde</a>.</p>
<h3><a class="header" href="#základní-program-a-hrefruznecprikazy_vyrazyhtmlvc3bdpis-vc3bdrazc5afučivoa" id="základní-program-a-hrefruznecprikazy_vyrazyhtmlvc3bdpis-vc3bdrazc5afučivoa">Základní program (<a href="ruzne/../c/prikazy_vyrazy.html#v%C3%BDpis-v%C3%BDraz%C5%AF">učivo</a>)</a></h3>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int main() {
  // Radkovy komentar
  /*
   * Blokovy komentar
   */
  printf(&quot;Hello world\n&quot;);
  return 0;
}
</code></pre>
<h3><a class="header" href="#překlad-a-spuštění-programu-a-hrefruzneprostredipreklad_programuhtmlpc599eklad-prvnc3adho-programuučivoa" id="překlad-a-spuštění-programu-a-hrefruzneprostredipreklad_programuhtmlpc599eklad-prvnc3adho-programuučivoa">Překlad a spuštění programu (<a href="ruzne/../prostredi/preklad_programu.html#p%C5%99eklad-prvn%C3%ADho-programu">učivo</a>)</a></h3>
<pre><code class="language-bash">$ gcc main.c -g -fsanitize=address -o main
$ ./main
</code></pre>
<h3><a class="header" href="#základní-výpis-a-hrefruznecprikazy_vyrazyhtmlvc3bdpis-vc3bdrazc5afučivoa" id="základní-výpis-a-hrefruznecprikazy_vyrazyhtmlvc3bdpis-vc3bdrazc5afučivoa">Základní výpis (<a href="ruzne/../c/prikazy_vyrazy.html#v%C3%BDpis-v%C3%BDraz%C5%AF">učivo</a>)</a></h3>
<ul>
<li>Textu
<pre><code class="language-c">printf(&quot;Ahoj UPR\n&quot;);
</code></pre>
</li>
<li>Číselného výrazu
<pre><code class="language-c">printf(&quot;Cislo: %d\n&quot;, &lt;výraz&gt;);
printf(&quot;Cislo: %d\n&quot;, 1 + 2);
</code></pre>
</li>
</ul>
<h3><a class="header" href="#proměnné-a-hrefruznecpromennepromennehtmlučivoa" id="proměnné-a-hrefruznecpromennepromennehtmlučivoa">Proměnné (<a href="ruzne/../c/promenne/promenne.html">učivo</a>)</a></h3>
<ul>
<li>Vytvoření: <code>&lt;datový typ&gt; &lt;název&gt; = &lt;výraz&gt;;</code>
<pre><code class="language-c">int vek = 18;
</code></pre>
</li>
<li>Užitečné datové typy:
<ul>
<li><code>int</code>: celé číslo se znaménkem</li>
<li><code>float</code>: desetinné číslo</li>
<li><code>char</code>: znak</li>
</ul>
</li>
<li>Čtení (získání hodnoty proměnné): <code>&lt;název proměnné&gt;</code>
<pre><code class="language-c">printf(&quot;%d\n&quot;, vek);
int x = vek + 1;
</code></pre>
</li>
<li>Zápis (změna hodnoty proměnné): <code>&lt;název proměnné&gt; = &lt;výraz&gt;;</code>
<pre><code class="language-c">vek = 42;
</code></pre>
</li>
</ul>
<h3><a class="header" href="#výrazy-a-hrefruznecdatove_typycelociselne_typyhtmltabulka-aritmetickc3bdch-operc3a1torc5afučivoa" id="výrazy-a-hrefruznecdatove_typycelociselne_typyhtmltabulka-aritmetickc3bdch-operc3a1torc5afučivoa">Výrazy (<a href="ruzne/../c/datove_typy/celociselne_typy.html#tabulka-aritmetick%C3%BDch-oper%C3%A1tor%C5%AF">učivo</a>)</a></h3>
<ul>
<li>Sčítání: <code>a + b</code></li>
<li>Odčítání: <code>a - b</code></li>
<li>Násobení: <code>a * b</code></li>
<li>Dělení: <code>a / b</code></li>
<li>Zbytek po dělení: <code>a % b</code></li>
<li>Rovná se: <code>a == b</code></li>
<li>Menší než: <code>a &lt; b</code></li>
<li>Menší nebo rovno než: <code>a &lt;= b</code></li>
<li>Větší než: <code>a &gt; b</code></li>
<li>Větší  nebo rovno než: <code>a &gt;= b</code></li>
<li>A zároveň: <code>a &amp;&amp; b</code></li>
<li>Nebo: <code>a || b</code></li>
</ul>
<h3><a class="header" href="#podmínky-a-hrefruznecrizeni_tokupodminkyhtmlučivoa" id="podmínky-a-hrefruznecrizeni_tokupodminkyhtmlučivoa">Podmínky (<a href="ruzne/../c/rizeni_toku/podminky.html">učivo</a>)</a></h3>
<p>Podmínka (příkaz) <a href="ruzne/../c/rizeni_toku/if.html">if</a>:</p>
<pre><code class="language-c">if (&lt;výraz 1&gt;) {
  // Provede se, pokud je &lt;výraz 1&gt; pravdivý
} else if (&lt;výraz 2&gt;) {
  // Provede se, pokud &lt;výraz 1&gt; není pravdivý, a &lt;výraz 2&gt; je pravdivý
} else {
  // Provede se, pokud &lt;výraz 1&gt; není pravdivý, a &lt;výraz 2&gt; také není pravdivé
}
</code></pre>
<pre><code class="language-c editable mainbody">#include &lt;stdio.h&gt;

int main() {
  int a = 10;
  if (a &gt; 5) {
    printf(&quot;a je vetsi nez 5\n&quot;);
  } else {
    printf(&quot;a je mensi nebo rovno 5\n&quot;);
  }
  return 0;
}
</code></pre>
<h3><a class="header" href="#cykly-a-hrefruznecrizeni_tokucyklyhtmlučivoa" id="cykly-a-hrefruznecrizeni_tokucyklyhtmlučivoa">Cykly (<a href="ruzne/../c/rizeni_toku/cykly.html">učivo</a>)</a></h3>
<ul>
<li>
<p>Cyklus <a href="ruzne/../c/rizeni_toku/while.html">while</a></p>
<pre><code class="language-c">// &lt;výraz&gt; -&gt; &lt;tělo&gt; -v
//    ^               |
//    -----------------
// Dokud je &lt;výraz&gt; pravdivý
while (&lt;vyraz&gt;) {
  &lt;telo&gt;
}
</code></pre>
<pre><code class="language-c editable mainbody">#include &lt;stdio.h&gt;

int main() {
  int a = 10;
  while (a &gt; 0) {
    printf(&quot;a=%d\n&quot;, a);
    a = a - 1;
  }
  return 0;
}
</code></pre>
</li>
<li>
<p>Cyklus <a href="ruzne/../c/rizeni_toku/for.html">for</a></p>
<pre><code class="language-c">// &lt;příkaz&gt; -&gt; &lt;výraz 1&gt; -&gt; &lt;tělo&gt; -&gt; &lt;výraz 2&gt; -v
//                ^                              |
//                -------------------------------&lt;
// Dokud je &lt;výraz 1&gt; pravdivý
for (&lt;prikaz&gt;; &lt;vyraz 1&gt;; &lt;vyraz 2&gt;) {
  &lt;telo&gt;
}
</code></pre>
<pre><code class="language-c editable mainbody">#include &lt;stdio.h&gt;

int main() {
  for (int i = 0; i &lt; 10; i++) {
    printf(&quot;i = %d, i * 2 = %d\n&quot;, i, i * 2);
  }
  return 0;
}
</code></pre>
</li>
</ul>
<h3><a class="header" href="#funkce-a-hrefruznecfunkcefunkcehtmlučivoa" id="funkce-a-hrefruznecfunkcefunkcehtmlučivoa">Funkce (<a href="ruzne/../c/funkce/funkce.html">učivo</a>)</a></h3>
<ul>
<li>Deklarace
<pre><code class="language-c">&lt;datový typ&gt; &lt;název funkce&gt;(
  &lt;datový typ parametru 1&gt; &lt;název parametru 1&gt;,
  &lt;datový typ parametru 2&gt; &lt;název parametru 2&gt;, …
) {
  // tělo
}
</code></pre>
</li>
<li>Funkce, která nic nevrací
<pre><code class="language-c">void vypis_text() {
  printf(&quot;Ahoj\n&quot;);
}
</code></pre>
</li>
<li>Funkce, která vrací hodnotu
<pre><code class="language-c">int secti(int a, int b) {
  return a + b;
}
</code></pre>
</li>
<li>Volání funkce
<pre><code class="language-c">int main() {
  int c = secti(1, 2);
  return 0;
}
</code></pre>
</li>
</ul>
<h3><a class="header" href="#ukazatele-a-hrefruznecprace_s_pametiukazatelehtmlučivoa" id="ukazatele-a-hrefruznecprace_s_pametiukazatelehtmlučivoa">Ukazatele (<a href="ruzne/../c/prace_s_pameti/ukazatele.html">učivo</a>)</a></h3>
<ul>
<li>Vytvoření ukazatele
<pre><code class="language-c">int* p = NULL;
</code></pre>
</li>
<li>Získání adresy proměnné
<pre><code class="language-c">int a = 5;
int* p = &amp;a;
</code></pre>
</li>
<li>Dereference ukazatele
<pre><code class="language-c">int a = 5;
int* p = &amp;a;
printf(&quot;%d\n&quot;, *p);
</code></pre>
</li>
</ul>
<h3><a class="header" href="#pole-a-hrefruznecpolestaticka_polehtmlučivoa" id="pole-a-hrefruznecpolestaticka_polehtmlučivoa">Pole (<a href="ruzne/../c/pole/staticka_pole.html">učivo</a>)</a></h3>
<ul>
<li>Vytvoření pole na zásobníku
<pre><code class="language-c">int arr[10] = {};
</code></pre>
</li>
<li>Inicializace prvků pole
<pre><code class="language-c">int arr[5] = {1, 2, 3, 4, 5};
</code></pre>
</li>
<li>Čtení z pole
<pre><code class="language-c">int druhy_prvek = arr[1];
</code></pre>
</li>
<li>Zápis do pole
<pre><code class="language-c">arr[1] = 1;
</code></pre>
</li>
</ul>
<h3><a class="header" href="#dynamická-paměť-a-hrefruznecprace_s_pametidynamicka_pamethtmlučivoa" id="dynamická-paměť-a-hrefruznecprace_s_pametidynamicka_pamethtmlučivoa">Dynamická paměť (<a href="ruzne/../c/prace_s_pameti/dynamicka_pamet.html">učivo</a>)</a></h3>
<ul>
<li>Alokace proměnné na haldě
<pre><code class="language-c">int* mem = (int*) malloc(sizeof(int));
</code></pre>
</li>
<li>Alokace pole na haldě
<pre><code class="language-c">int* mem = (int*) malloc(sizeof(int) * 10);
</code></pre>
</li>
<li>Uvolnění dynamické paměti
<pre><code class="language-c">free(mem);  
</code></pre>
</li>
</ul>
<h3><a class="header" href="#Řetězce-a-hrefruznectextretezcehtmlučivoa" id="Řetězce-a-hrefruznectextretezcehtmlučivoa">Řetězce (<a href="ruzne/../c/text/retezce.html">učivo</a>)</a></h3>
<ul>
<li>Vytvoření řetězce pro čtení (nelze modifikovat)
<pre><code class="language-c">const char* text = &quot;Hello UPR&quot;;
</code></pre>
</li>
<li>Vytvoření řetězce na zásobníku (lze modifikovat)
<pre><code class="language-c">char text[] = &quot;Hello UPR&quot;;
</code></pre>
</li>
<li>Vypsání řetězce
<pre><code class="language-c">printf(&quot;%s\n&quot;, text);
</code></pre>
</li>
<li>Přístup k znaku řetězce
<pre><code class="language-c">char c = text[1];
</code></pre>
</li>
<li>Zjištění délky řetězce
<pre><code class="language-c">#include &lt;string.h&gt;
…
const char* text = &quot;Hello UPR&quot;;
int delka = strlen(text);
</code></pre>
</li>
<li>Porovnání dvou řetězců
<pre><code class="language-c">#include &lt;string.h&gt;
…
const char* text1 = &quot;Hello UPR&quot;;
const char* text2 = &quot;Hello&quot;;
if (strcmp(text1, text2) == 0) {
  // Řetězce jsou stejné
}
</code></pre>
</li>
<li>Převod textu na číslo
<pre><code class="language-c">#include &lt;stdlib.h&gt;
…
const char* text = &quot;123&quot;;
int cislo = strtol(text, NULL, 10);
</code></pre>
</li>
</ul>
<h3><a class="header" href="#vstup-a-hrefruznectextvstuphtmlučivoa" id="vstup-a-hrefruznectextvstuphtmlučivoa">Vstup (<a href="ruzne/../c/text/vstup.html">učivo</a>)</a></h3>
<ul>
<li>Načtení řádku
<pre><code class="language-c">char buf[80];
fgets(buf, sizeof(buf), stdin);
</code></pre>
</li>
<li>Načtení formátovaného vstupu
<pre><code class="language-c">int a;
scanf(&quot;%d&quot;, &amp;a);
</code></pre>
</li>
</ul>
<h3><a class="header" href="#struktury-a-hrefruznecstrukturystrukturyhtmlučivoa" id="struktury-a-hrefruznecstrukturystrukturyhtmlučivoa">Struktury (<a href="ruzne/../c/struktury/struktury.html">učivo</a>)</a></h3>
<ul>
<li>
<p>Deklarace struktury</p>
<pre><code class="language-c">struct &lt;název struktury&gt; {
  &lt;datový typ prvního členu&gt; &lt;název prvního členu&gt;;
  &lt;datový typ druhého členu&gt; &lt;název druhého členu&gt;;
  &lt;datový typ třetího členu&gt; &lt;název třetího členu&gt;;
  …
};
</code></pre>
<pre><code class="language-c">typedef struct {
  const char* login;
  int age;
} Student;
</code></pre>
</li>
<li>
<p>Inicializace proměnné typu struktury</p>
<pre><code class="language-c">Student s = { .login = &quot;BER0134&quot;, age = 29 };
</code></pre>
</li>
<li>
<p>Čtení členu</p>
<pre><code class="language-c">int age = s.age;
</code></pre>
</li>
<li>
<p>Zápis členu</p>
<pre><code class="language-c">s.age = s.age + 1;
</code></pre>
</li>
<li>
<p>Přístup k členu přes ukazatel</p>
<pre><code class="language-c">Student* p = &amp;s;
p-&gt;age = p-&gt;age + 1;
</code></pre>
</li>
</ul>
<h3><a class="header" href="#soubory-a-hrefruznecsouborysouboryhtmlučivoa" id="soubory-a-hrefruznecsouborysouboryhtmlučivoa">Soubory (<a href="ruzne/../c/soubory/soubory.html">učivo</a>)</a></h3>
<ul>
<li>Otevření souboru pro čtení
<pre><code class="language-c">FILE* file = fopen(&quot;file.txt&quot;, &quot;r&quot;); // Textový mód
FILE* file2 = fopen(&quot;file.txt&quot;, &quot;rb&quot;); // Binární mód
</code></pre>
</li>
<li>Otevření souboru pro zápis
<pre><code class="language-c">FILE* file = fopen(&quot;file.txt&quot;, &quot;w&quot;); // Textový mód
FILE* file2 = fopen(&quot;file.txt&quot;, &quot;wb&quot;); // Binární mód
</code></pre>
</li>
<li>Zavření souboru
<pre><code class="language-c">fclose(file);
</code></pre>
</li>
<li>Textový zápis do souboru (vyžaduje textový mód)
<pre><code class="language-c">fprintf(file, &quot;%d&quot;, 1);
</code></pre>
</li>
<li>Textové čtení ze souboru (vyžaduje textový mód)
<pre><code class="language-c">char row[80];
fgets(row, sizeof(radek), file);
</code></pre>
</li>
<li>Zjištění, jestli předchozí pokus o čtení vyústil v konec souboru
<pre><code class="language-c">if (feof(file)) { … }
</code></pre>
</li>
<li>Binární zápis do souboru (vyžaduje binární mód)
<pre><code class="language-c">int arr[5] = { 1, 2, 3, 4, 5 };
fwrite(arr, sizeof(int), 5, file);
</code></pre>
</li>
<li>Binární čtení ze souboru (vyžaduje binární mód)
<pre><code class="language-c">int arr[5] = { 1, 2, 3, 4, 5 };
fread(arr, sizeof(int), 5, file);
</code></pre>
</li>
</ul>
<h3><a class="header" href="#modularizace-a-hrefruznecmodularizacemodularizacehtmlučivoa" id="modularizace-a-hrefruznecmodularizacemodularizacehtmlučivoa">Modularizace (<a href="ruzne/../c/modularizace/modularizace.html">učivo</a>)</a></h3>
<ul>
<li>Hlavičkový soubor <code>functions.h</code>
<pre><code class="language-c">#pragma once

int secti(int a, int b);
</code></pre>
</li>
<li>Zdrojový soubor <code>functions.c</code>
<pre><code class="language-c">#include &quot;functions.h&quot;

int secti(int a, int b) {
  return a + b;
}
</code></pre>
</li>
<li>Zdrojový soubor <code>main.c</code>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &quot;functions.h&quot;

int main() {
  printf(&quot;%d\n&quot;, secti(1, 2));
  return 0;
}
</code></pre>
</li>
<li>Překlad
<pre><code class="language-bash">$ gcc -c functions.c
$ gcc -c main.c
$ gcc functions.o main.o -o main
</code></pre>
</li>
</ul>
<h1><a class="header" href="#Úlohy-1" id="Úlohy-1">Úlohy</a></h1>
<p>V této sekci naleznete různé úlohy, které si můžete zkusit naimplementovat, abyste se zlepšili
v programování.</p>
<h2><a class="header" href="#Řešené-úlohy" id="Řešené-úlohy">Řešené úlohy</a></h2>
<p>📹 K následujícím úlohám je k dispozici video, ve kterém je ukázané, jak dojít k řešení dané úlohy.</p>
<ul>
<li><a href="ulohy/promenne.html#prohozen%C3%AD-dvou-%C4%8D%C3%ADsel">Prohození dvou čísel</a> [5:45]</li>
<li><a href="ulohy/podminky_a_cykly.html#fizzbuzz">FizzBuzz</a> [14:40]</li>
<li><a href="ulohy/pole.html#po%C4%8D%C3%ADt%C3%A1n%C3%AD-v%C3%BDskyt%C5%AF-%C4%8D%C3%ADsla">Počítání výskytů čísla</a> [13:31]</li>
</ul>
<h2><a class="header" href="#další-úlohy" id="další-úlohy">Další úlohy</a></h2>
<p>Další úlohy můžete najít také například na těchto odkazech:</p>
<ul>
<li><a href="https://adventofcode.com/2018/events">Advent of Code</a></li>
<li><a href="https://projecteuler.net/archives">Project Euler</a></li>
<li><a href="https://onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;category=3">Online Judge</a></li>
<li><a href="https://w3resource.com/c-programming-exercises/">W3 C programming exercises</a></li>
</ul>
<h1><a class="header" href="#proměnné-1" id="proměnné-1">Proměnné</a></h1>
<p>K vyřešení těchto úloh by vám mělo stačit znát <a href="ulohy/../c/promenne/promenne.html">proměnné</a>, <a href="ulohy/../c/datove_typy/datove_typy.html">datové typy</a>
a základní <a href="ulohy/../c/prikazy_vyrazy.html#v%C3%BDpis-v%C3%BDraz%C5%AF">výpis výrazů</a>.</p>
<h2><a class="header" href="#obvod-a-obsah-obdélníku" id="obvod-a-obsah-obdélníku">Obvod a obsah obdélníku</a></h2>
<p>Program bude mít jako vstup dvě proměnné (\( a \), \( b \)), které budou udávat velikosti stran
obdélníku (hodnoty proměnných si nastavte na začátku programu). Podle známého vzorce (viz níže) poté program vypočítá a
vypíše hodnoty obou stran, spolu s obvodem a obsahem obdélníku s danými délkami stran.</p>
<div style="display: flex; justify-content: center">
  <svg>
    <rect width=200 height=100 fill=#eee stroke=black />
    <text x=100 y=115 fill=black text-anchor=middle font-style=italic>a</text>
    <text x=210 y=50 fill=black text-anchor=middle font-style=italic>b</text>
  </svg>
  <div>
    $$\begin{aligned}
    o &= 2 \cdot (a + b) \\
    S &= a \cdot b
    \end{aligned}$$
  </div>
</div>
<details>
<summary>Ukázkový výstup</summary>
<pre><code>a = 200
b = 100
o = 600
S = 20000
</code></pre>
</details>
<h2><a class="header" href="#prohození-dvou-čísel" id="prohození-dvou-čísel">Prohození dvou čísel</a></h2>
<blockquote>
<p>📹 K této úloze je k dispozici <a href="https://www.youtube.com/watch?v=arzJllZi_oY">video</a> [5:45] s popisem řešení.</p>
</blockquote>
<p>Program prohodí hodnotu dvou proměnných. Na začátku programu budou dvě celočíselné proměnné (<code>a</code> a <code>b</code>) s libovolně
zvolenými hodnotami. Tyto proměnné budou na začátku programu vypsány na výstup.</p>
<p>Dále program prohodí hodnoty těchto dvou proměnných, tj. např. pokud proměnná <code>a</code> měla hodnotu
<code>5</code> a proměnná <code>b</code> měla hodnotu <code>10</code>, tak po prohození by měla proměnná <code>a</code> mít hodnotu <code>10</code> a proměnná <code>b</code> hodnotu <code>5</code>.
Pro prohození použijte třetí proměnnou. Kód pro prohození dvou proměnných napište obecně - měl by fungovat pro libovolné
hodnoty proměnných <code>a</code> a <code>b</code>. Po prohození program opět obě proměnné vypíše.</p>
<details>
<summary>Ukázkový výstup</summary>
<pre><code>a = 10
b = 50

a = 50
b = 10
</code></pre>
</details>
<h1><a class="header" href="#podmínky-a-cykly" id="podmínky-a-cykly">Podmínky a cykly</a></h1>
<p>K vyřešení těchto úloh by vám mělo stačit znát <a href="ulohy/../c/rizeni_toku/podminky.html">podmínky</a> a <a href="ulohy/../c/rizeni_toku/cykly.html">cykly</a>
(a samozřejmě veškeré předchozí učivo).</p>
<h2><a class="header" href="#výpočet-daně" id="výpočet-daně">Výpočet daně</a></h2>
<p>Na začátku programu si vytvořte dvě celočíselné proměnné. První proměnná bude částku utracenou za nákup akcií v loňském
roce. Druhá proměnná bude obsahovat současnou hodnotu průměrné mzdy v ČR. Poté vypočtěte daň, kterou je potřeba zaplatit
za nákup akcií. Daň se vypočítává následovně:</p>
<ol>
<li>Pokud byly nakoupeny akcie za méně, než 100 000 Kč, tak se neplatí žádná daň.</li>
<li>Pokud byly nakoupeny akcie za více, než 48násobek průměrné mzdy, tak se platí daň 23 %.</li>
<li>Ve zbylých případech se platí daň 15 %.</li>
</ol>
<p>Daň zaokrouhlete směrem k nule na celé číslo pomocí <a href="ulohy/../c/datove_typy/konverze.html">převodu</a> z desetinné na celočíselnou
hodnotu.</p>
<p>Po výpočtu daně vypište utracenou částku, průměrnou mzdu a výslednou hodnotu daně.</p>
<details>
<summary>Ukázkové výstupy</summary>
<pre><code>utraceno = 10021
mzda = 41265
dan = 0
</code></pre>
<pre><code>utraceno = 10412
mzda = 41265
dan = 1561
</code></pre>
<pre><code>utraceno = 2000000
mzda = 41265
dan = 460000
</code></pre>
</details>
<h2><a class="header" href="#maximum-ze-tří-čísel" id="maximum-ze-tří-čísel">Maximum ze tří čísel</a></h2>
<p>Na začátku programu vytvořte tři celočíselné proměnné a nastavte do nich nějaké hodnoty. Poté napište kód, který nalezne
maximum z těchto tří čísel, a vypíše jej na výstup.</p>
<p><img src="ulohy/../mdbook-plantuml-img/75ac180089a811ef0b0f84fad12f3b915d26d791.svg" alt="" /></p>
<details>
<summary>Ukázkový výstup</summary>
<pre><code>a = 10
b = 40
c = 20

maximum je 40
</code></pre>
</details>
<h2><a class="header" href="#výpis-druhých-mocnin-čísel" id="výpis-druhých-mocnin-čísel">Výpis druhých mocnin čísel</a></h2>
<p>Vypište všechna čísla od 0 do 20 (včetně), spolu s jejich druhou mocninou.</p>
<details>
<summary>Ukázkový výstup</summary>
<pre><code>0 na druhou je 0
1 na druhou je 1
2 na druhou je 4
3 na druhou je 9
...
19 na druhou je 361
20 na druohu je 400
</code></pre>
</details>
<h2><a class="header" href="#výpis-sudých-čísel" id="výpis-sudých-čísel">Výpis sudých čísel</a></h2>
<p>Vypište všechna sudá čísla od 0 do 100 (včetně). Výsledný program by neměl mít více než ~15 řádků kódu.</p>
<details>
<summary>Ukázkový výstup</summary>
<pre><code>0
2
4
...
98
100
</code></pre>
</details>
<h2><a class="header" href="#fizzbuzz" id="fizzbuzz">FizzBuzz</a></h2>
<blockquote>
<p>📹 K této úloze je k dispozici <a href="https://www.youtube.com/watch?v=VNYnSFGhdWo">video</a> [14:40] s popisem řešení.</p>
</blockquote>
<p>Naimplementujte program zvaný <a href="https://en.wikipedia.org/wiki/Fizz_buzz">FizzBuzz</a><sup class='margin-toggle sidenote-number'>1</sup>. Vypište čísla 1 až 100 tak, že:</p>
<span class='sidenote'><p><sup class='number'>1</sup>Tento program často bývá obsahem interview programátorů ve firmách.</p>
</span>
<ul>
<li>pokud je číslo násobkem 3, tak vypište místo čísla text <code>Fizz</code></li>
<li>pokud je číslo násobkem 5, tak vypište místo čísla text <code>Buzz</code></li>
<li>pokud je číslo násobkem 3 i násobkem 5, tak vypíše místo čísla text <code>FizzBuzz</code></li>
</ul>
<details>
<summary>Výstup programu</summary>
<pre><code>1
2
Fizz
4
Buzz
Fizz
7
8
Fizz
Buzz
11
Fizz
13
14
Fizz Buzz
16
...
</code></pre>
</details>
<p><strong>Složitá varianta</strong>: Naimplementujte tento program bez použití podmínek. Nesimulujte ani podmínku
žádným cyklem. Použijte jediný cyklus <code>for</code> pro průchod čísly 1 až 100 a uvnitř tohoto cyklu nepoužijte
žádnou podmínku. K vyřešení této varianty budete potřebovat znát koncepty z pozdějších lekcí.</p>
<h2><a class="header" href="#textové-kreslení-obrazců" id="textové-kreslení-obrazců">Textové kreslení obrazců</a></h2>
<p>Napište program, který bude umět vykreslovat následující obrazce. Napište kód pro jejich vykreslování tak, aby počet
řádků, na který se obrazec vykreslí (případně rozměry obrazce), byl jednoduše konfigurovatelný pomocí změny hodnoty jedné
proměnné. Jinak řečeno, například pro změnu počtu řádků/sloupců vykresleného čtverce by mělo stačit změnit hodnotu jedné
proměnné, zbytek kódu by měl zůstat stejný.</p>
<details>
<summary>Vyplněný čtverec</summary>
<pre><code>xxxx
xxxx
xxxx
xxxx
</code></pre>
</details>
<details>
<summary>Nevyplněný čtverec</summary>
<pre><code>xxxx
x  x
x  x
xxxx
</code></pre>
</details>
<details>
<summary>Čtverec vyplněný rostoucími čísly</summary>
<pre><code>xxxxx
x012x
x345x
x678x
xxxxx
</code></pre>
</details>
<details>
<summary>Diagonála</summary>
<pre><code>x
 x
  x
   x
    x
</code></pre>
</details>
<details>
<summary>Trojúhelník</summary>
<pre><code>  x  
 x x 
xxxxx
</code></pre>
</details>
<details>
<summary>Písmeno T</summary>
<pre><code>xxxxxxx
   x 
   x
   x
   x
   x
</code></pre>
</details>
<details>
<summary>Písmeno H</summary>
<pre><code>x     x
x     x 
x     x
xxxxxxx
x     x
x     x
x     x
</code></pre>
</details>
<details>
<summary>Písmeno Z</summary>
<pre><code>xxxxxx
    x 
   x  
  x 
 x
xxxxxx
</code></pre>
</details>
<h1><a class="header" href="#odrážející-se-kulička-v-terminálu" id="odrážející-se-kulička-v-terminálu">Odrážející se kulička v terminálu</a></h1>
<p>Vykreslujte do terminálu obdélník spolu s pohybující se kuličkou. Jakmile kulička narazí do stěny
čtverce, zvyšte počítadlo nárazů pro danou zeď. Dodržujte princip
<a href="https://cs.wikipedia.org/wiki/Odraz_vln%C4%9Bn%C3%AD">zákonu odrazu</a>.</p>
<details>
<summary>Přibližný postup řešení</summary>
Kuličku reprezentujte dvěmi proměnými (pozice X a Y). Opakovaně provádějte následující akce:
<ul>
<li>Posuňte kuličku ve směru jejího pohybu.</li>
<li>Pokud kulička narazí do stěny, změňte směr jejího pohybu.</li>
<li>Vyčistěte terminál, aby zmizelo herní pole z minulé iterace. Lze to provést více způsoby:
<ul>
<li>Vytiskněte velké množství prázdných řádků.</li>
<li>Vytiskněte text <code>&quot;\e[1;1H\e[2J&quot;</code>, který terminál bude interpretovat jako vyčistění obrazovky.</li>
</ul>
</li>
<li>Vykreslete kuličku a obdélník.</li>
<li>Uspěte na chvíli program, abyste mohli pozorovat změněný stav hry. Můžete použít například funkci
<a href="https://man7.org/linux/man-pages/man3/usleep.3.html"><code>usleep</code></a>: <code>usleep(100 * 1000)</code>.</li>
</ul>
</details>
<p>Výsledek by měl vypadat zhruba takto:</p>
<p><img src="ulohy/../static/video/ball_terminal.gif" alt="Odrážející se kulička v terminálu" /></p>
<h1><a class="header" href="#vykreslování-grafu-funkce" id="vykreslování-grafu-funkce">Vykreslování grafu funkce</a></h1>
<p>Napište program, který dokáže vykreslit graf funkce. Graf vykreslujte do terminálu, není třeba
implementovat grafickou aplikaci. Využijte například znak <code>|</code> pro znázornění osy y, znak <code>-</code>
pro znázornění osy x, a <code>+</code> pro znázornění počátku. Pomocí znaku <code>*</code> můžete znázornit funkci
vlastního výběru.</p>
<h2><a class="header" href="#ukázka" id="ukázka">Ukázka</a></h2>
<details>
<summary>Graf lineární funkce</summary>
<pre><code>                              |
                              |     *
                              |
                              |    *
                              |
                              |   *
                              |
                              |  *
                              |
                              | *
                              |
                              |*
                              |
                              *
                              |
                             *|
------------------------------+------------------------------
                            * |
                              |
                           *  |
                              |
                          *   |
                              |
                         *    |
                              |
                        *     |
                              |
                       *      |
                              |
                      *       |
                              |
</code></pre>
</details>
<details>
<summary>Graf exponenciální funkce</summary>
<pre><code>                              |   *
                              |
                              |
                              |
                              |
                              |
                              |
                              |
                              |  *
                              |
                              |
                              |
                              | *
                              |
                              |*
                              *
******************************+------------------------------
                              |
                              |
                              |
                              |
                              |
                              |
                              |
                              |
                              |
                              |
                              |
                              |
                              |
                              |
</code></pre>
</details>
<h2><a class="header" href="#tipy" id="tipy">Tipy</a></h2>
<ul>
<li>Zvolte si fixní šířku a výšku grafu, aby se graf vešel do rozumně velkého okna terminálu
(v ukázkách je využita velikost 61x31).</li>
<li>Funkci vykreslujte jen pro celé hodnoty <code>x</code> (graf tedy bude nespojitý).</li>
<li>Experimentujte s funkcemi a zkuste vykreslit grafy různých funkcí (např. logaritmus,
exponenciální funkce, kvadratická a kubická funkce, ...).</li>
<li>Pro výpočet funkcí lze využít matematickou knihovnu <code>math.h</code>, která je součástí standardní
knihovny jazyka C. Knihovnu je ovšem potřeba při kompilaci explicitně slinkovat přepínačem <code>-lm</code>,
který pouze předáte kompilátoru (<code>gcc main.c -o main -lm</code>).</li>
<li>Nehledejte v úloze zbytečnou komplexitu. Nejjednodušší variantu úlohy (viz ukázka) lze
naprogramovat na 30 řádků za využití dvou cyklů, podmínek a parametrické rovnice přímky
(<code>y = ax + b</code>).</li>
</ul>
<h2><a class="header" href="#složitější-varianta" id="složitější-varianta">Složitější varianta</a></h2>
<p>Zkuste graf vykreslovat spojitě. Využít můžete například
<a href="https://en.wikipedia.org/wiki/Bresenham%27s_line_algorithm">Bresenhamům algoritmus pro vykreslení přímky</a>.</p>
<p>Nebo zkuste vykreslování grafů implementovat jako interaktivní terminálovou aplikaci. Využít lze
například knihovnu <a href="https://man.archlinux.org/man/ncurses.3x.en">ncurses</a>, nebo přímo ANSI
escape sekvence. Aplikace může umožnit panning (posouvání doleva, doprava, nahoru a dolů)
a zooming (změná škály souřadnicových os).</p>
<p>Interaktivní aplikace by také mohla na okrajích okna znázorňovat, na jaké souřadnice se uživatel
dívá (ať se při procházení grafu neztratí) a aktuální úroveň přiblížení, a implementovat klávesovou
zkratku pro reset náhledu na graf (vycentrování počátku a nastavení zoomu na <code>1.0</code>).</p>
<p>Pokud si chcete s úlohou opravdu vyhrát, můžete také naprogramovat možnost zadat vlastní funkci
za běhu programu. Toho lze dosáhnout jak manuálním parsováním uživatelského vstupu, tak
embeddováním nějakého skriptovacího jazyka (např. <a href="https://www.lua.org/pil/24.html">Lua</a>) do svého
programu, a umožněním uživateli naprogramovat si vlastní, libovolně složitou funkci (využívající
například podmínky, atp.). Fantazii se meze nekladou.</p>
<p>Složitější varianta <strong>není vhodná</strong> pro úplné začátečníky.</p>
<h1><a class="header" href="#funkce-1" id="funkce-1">Funkce</a></h1>
<p>K vyřešení těchto úloh by vám mělo stačit znát <a href="ulohy/../c/funkce/funkce.html">funkce</a> (a samozřejmě veškeré předchozí učivo).</p>
<h2><a class="header" href="#maximum" id="maximum">Maximum</a></h2>
<p>Napište funkci <code>max</code>, která přijme dva celočíselné argumenty a vrátí větší z nich.</p>
<details>
<summary>Ukázka použití funkce</summary>
<pre><code class="language-c">printf(&quot;%d&quot;, max(0, 0));    // Vypíše 0
printf(&quot;%d&quot;, max(1, 5));    // Vypíše 5
printf(&quot;%d&quot;, max(2, -3));   // Vypíše 2
</code></pre>
</details>
<h2><a class="header" href="#výpočet-daně-funkce" id="výpočet-daně-funkce">Výpočet daně (funkce)</a></h2>
<p>Naimplementujte úlohu <a href="ulohy/./podminky_a_cykly.html#v%C3%BDpo%C4%8Det-dan%C4%9B">Výpočet daně</a> pomocí funkce <code>vypocti_dan</code>. Funkce dostane
částku utracenou za nákupy akcií a průměrnou mzdu, a vrátí vypočtenou daň ve formě celého čísla.</p>
<details>
<summary>Ukázka použití funkce</summary>
<pre><code class="language-c">printf(&quot;Dan=%d&quot;, vypocti_dan(10021, 41265));    // Vypíše Dan=0
printf(&quot;%d&quot;, vypocti_dan(10412, 41265));        // Vypíše 1561
printf(&quot;%d&quot;, vypocti_dan(2000000, 41265));      // Vypíše 460000

int dan = vypocti_dan(100000, 40000) + vypocti_dan(200000, 38000);
// dan bude 45000
</code></pre>
</details>
<h2><a class="header" href="#textové-kreslení-obrazců-funkce" id="textové-kreslení-obrazců-funkce">Textové kreslení obrazců (funkce)</a></h2>
<p>Naimplementujte úlohu <a href="ulohy/./podminky_a_cykly.html#textov%C3%A9-kreslen%C3%AD-obrazc%C5%AF">Textové kreslení obrazců</a> pomocí funkcí. Pro
každý typ obrazce udělejte separátní funkci, která obdrží parametry nutné pro vykreslení daného obrazce, a vykreslí jej
na výstup pomocí znaku <code>x</code>.
Parametry můžou být např:</p>
<ul>
<li>délka strany pro funkci <code>ctverec</code></li>
<li>délka dvou stran (šířka × výška) pro funkci <code>obdelnik</code></li>
<li>délka a směr diagonály pro funkci <code>diagonala</code></li>
</ul>
<details>
<summary>Ukázka použití funkce</summary>
<pre><code class="language-c">ctverec(4); // Vykreslí:
// xxxx
// xxxx
// xxxx
// xxxx

obdelnik(2, 3); // Vykreslí:
// xx
// xx
// xx

obdelnik(3, 1); // Vykreslí:
// xxx
</code></pre>
</details>
<h2><a class="header" href="#fibonacciho-číslo" id="fibonacciho-číslo">Fibonacciho číslo</a></h2>
<p>Napište funkci <code>fibonacci</code>, která vypočte <code>n</code>-té <a href="https://cs.wikipedia.org/wiki/Fibonacciho_posloupnost">Fibonacciho číslo</a>
(<code>n</code> bude parametrem funkce).</p>
<details>
<summary>Ukázka použití funkce</summary>
<pre><code class="language-c">printf(&quot;%d&quot;, fibonacci(0));   // Vypíše 0
printf(&quot;%d&quot;, fibonacci(1));   // Vypíše 1
printf(&quot;%d&quot;, fibonacci(2));   // Vypíše 1
printf(&quot;%d&quot;, fibonacci(3));   // Vypíše 2
printf(&quot;%d&quot;, fibonacci(4));   // Vypíše 3
printf(&quot;%d&quot;, fibonacci(5));   // Vypíše 5
printf(&quot;%d&quot;, fibonacci(6));   // Vypíše 8
</code></pre>
</details>
<h2><a class="header" href="#faktoriál" id="faktoriál">Faktoriál</a></h2>
<p>Napište funkci <code>factorial</code>, která vypočte <a href="https://cs.wikipedia.org/wiki/Faktori%C3%A1l">faktoriál</a> předaného
parametru.</p>
<details>
<summary>Ukázka použití funkce</summary>
<pre><code class="language-c">printf(&quot;%d&quot;, factorial(0));   // Vypíše 1
printf(&quot;%d&quot;, factorial(1));   // Vypíše 1
printf(&quot;%d&quot;, factorial(4));   // Vypíše 24
printf(&quot;%d&quot;, factorial(5));   // Vypíše 120
</code></pre>
</details>
<h1><a class="header" href="#ukazatele-1" id="ukazatele-1">Ukazatele</a></h1>
<p>K vyřešení těchto úloh by vám mělo stačit znát <a href="ulohy/../c/prace_s_pameti/ukazatele.html">ukazatele</a> (a samozřejmě veškeré
předchozí učivo).</p>
<h2><a class="header" href="#nastavení-maxima" id="nastavení-maxima">Nastavení maxima</a></h2>
<p>Vytvořte funkci <code>set_max</code>, která přijme adresu celého čísla (<code>int</code>) pomocí ukazatele a dvě další
čísla a nastaví paměť na dané adrese na větší ze dvou zadaných čísel.</p>
<pre><code class="language-c">int res;
set_max(&amp;res, 5, 6);
// res == 6
</code></pre>
<h2><a class="header" href="#prohození-hodnoty" id="prohození-hodnoty">Prohození hodnoty</a></h2>
<p>Vytvořte funkci <code>swap</code>, která přijme dva ukazatele a prohodí hodnoty proměnných, na které ukazují.</p>
<pre><code class="language-c">int a = 5, b = 6;
swap(&amp;a, &amp;b);
// a == 6, b == 5
</code></pre>
<h2><a class="header" href="#výpočet-kořenů-kvadratické-rovnice" id="výpočet-kořenů-kvadratické-rovnice">Výpočet kořenů kvadratické rovnice</a></h2>
<p>Vytvořte funkci <code>quadratic_roots</code>, která vrátí počet kořenů kvadratické rovnice \( ax^2 + bx + c = 0 \) pomocí <code>return</code> a vypočítané kořeny vrátí pomocí předaných ukazatelů v argumentech funkce.</p>
<pre><code class="language-c">int quadratic_roots(float a, float b, float c, float *x1, float *x2);
</code></pre>
<p>Počet kořenů lze zjistit vypočítáním diskriminantu \( D = b^2 - 4ac \).
Pokud vyjde diskriminant záporný, tak funkce vrátí nulu, protože žádné řešení v \( \mathbb{R} \) neexistuje.
Pro nulový diskriminant funkce vrátí <code>1</code> a uloží dvojnásobný kořen na adresu ukazatelů <code>x1</code>, <code>x2</code>.
Pro kladný diskriminant funkce vrátí <code>2</code> a vypočítá kořeny pomocí:
$$ x_{1, 2} = \frac{-b \pm \sqrt{D}}{2a} $$</p>
<p><upr-parabola></upr-parabola></p>
<h1><a class="header" href="#pole-1" id="pole-1">Pole</a></h1>
<p>K vyřešení těchto úloh by vám mělo stačit znát <a href="ulohy/../c/pole/pole.html">pole</a> (a samozřejmě veškeré
předchozí učivo).</p>
<h2><a class="header" href="#naplnění-pole" id="naplnění-pole">Naplnění pole</a></h2>
<p>Vytvořte funkci <code>fill_array</code>, která naplní pole <code>array</code> čísly zvětšujícími se po přírůstku <code>increment</code> a
začínajícími od hodnoty <code>start</code>. </p>
<pre><code class="language-c">void fill_array(int* array, int len, int start, int increment);
</code></pre>
<p>Níže je interaktivní diagram znázorňující, jak má vypadat pole po provedení funkce. Jednotlivé argumenty
volané funkce můžete v diagramu měnit.</p>
<p><upr-array-fill></upr-array-fill></p>
<h2><a class="header" href="#počítání-výskytů-čísla" id="počítání-výskytů-čísla">Počítání výskytů čísla</a></h2>
<blockquote>
<p>📹 K této úloze je k dispozici <a href="https://www.youtube.com/watch?v=QCmH3uN9Au8">video</a> [13:31] s popisem řešení.</p>
</blockquote>
<p>Vytvořte funkci <code>num_count</code>, která spočítá a vrátí počet výskytů čísla <code>num</code> v poli <code>array</code>.</p>
<pre><code class="language-c">int num_count(int* array, int len, int num);
</code></pre>
<p>Níže je interaktivní animace, která zobrazuje průběh programu.</p>
<p><upr-array-interval array="[10, 2, 4, 3, 4, 8, 9, 4]" from="4" to="4"></upr-array-interval></p>
<h2><a class="header" href="#počítání-čísel-v-intervalu" id="počítání-čísel-v-intervalu">Počítání čísel v intervalu</a></h2>
<p>Vytvořte funkci <code>in_interval</code>, která spočítá počet čísel z uzavřeného intervalu <code>[from, to]</code> v poli
<code>array</code>.</p>
<pre><code class="language-c">int in_interval(int* array, int len, int from, int to);
</code></pre>
<p>Níže je interaktivní animace, která zobrazuje průběh programu.</p>
<p><upr-array-interval array="[10, 2, 4, 3, 4, 8, 9, 4]" from="2" to="5"></upr-array-interval></p>
<h2><a class="header" href="#průměrná-hodnota" id="průměrná-hodnota">Průměrná hodnota</a></h2>
<p>Vytvořte funkci <code>average</code>, která spočítá průměr čísel v poli <code>array</code>.</p>
<pre><code class="language-c">double average(int* array, int len);
</code></pre>
<p>Při dělení nezapomeňte přetypovat alespoň jeden operand na typ <code>double</code>, aby nedošlo k
celočíselnému dělení. Pokud bude pole prázdné, vraťte hodnotu <code>0.0</code>.</p>
<h2><a class="header" href="#minimální-hodnota-v-poli" id="minimální-hodnota-v-poli">Minimální hodnota v poli</a></h2>
<p>Vytvořte funkci, která v poli <code>array</code> nalezne minimální hodnotu.</p>
<pre><code class="language-c">int array_min(int *array, int len);
</code></pre>
<p>Níže je interaktivní animace, která zobrazuje průběh programu.</p>
<p><upr-array-min array="[3, 5, 2, 8, 7, 1, 3]"></upr-array-min></p>
<p>Následně funkci upravte, aby funkce vrátila pomocí ukazatele poslední index v poli, na kterém je minimální hodnota
daného pole.</p>
<pre><code class="language-c">int array_min(int *array, int len, int *min_index);
</code></pre>
<h2><a class="header" href="#minimální-a-maximální-hodnota" id="minimální-a-maximální-hodnota">Minimální a maximální hodnota</a></h2>
<p>Předchozí funkci upravte, aby hledala minimum a maximum zároveň.
Nalezené extrémy vraťte pomocí ukazatelů <code>min</code> a <code>max</code>.</p>
<pre><code class="language-c">void min_max(int* array, int len, int *min, int *max);
</code></pre>
<p>Ve funkci si nejprve nastavte index minimální a maximální hodnoty na nultý prvek.
Parametr <code>min</code> je ukazatel, a je tedy nutné přistupovat k jeho hodnotě pomoci dereference - <code>*min</code>,
protože výraz <code>min</code> obsahuje pouze adresu, kde je minimální index uložen. Následně projděte
pole a pokud bude hodnota aktuálního prvku menší než hodnota prvku na dosud nalezeném indexu,
nastavte hodnotu minimálního indexu na aktuální index. Stejný postup aplikujte i pro nalezení
maximálního prvku (stačí udělat jeden průchod polem).</p>
<h2><a class="header" href="#obrácení-pole" id="obrácení-pole">Obrácení pole</a></h2>
<p>Vytvořte funkci <code>array_reverse</code>, která obrátí prvky v poli.</p>
<pre><code class="language-c">void array_reverse(int* array, int len);
</code></pre>
<p>Pole projděte pomoci cyklu do jeho půlky a vždy prohazujte prvky z obou konců.</p>
<p>Níže je interaktivní animace, která zobrazuje průběh programu.</p>
<p><upr-array-reverse array="[10, 20, 30, 40, 50, 60]"></upr-array-reverse></p>
<p>Přehození dvou prvků nemůžete udělat najednou. Uložte si například prvek z levého konce do proměnné
a následně do tohoto prvku zapište hodnotu z pravého konce. Poté hodnotu z proměnné uložte do pravého
konce. Alternativně také můžete využít <a href="ulohy/ukazatele.html#prohozen%C3%AD-hodnoty">dříve</a> naimplementovanou funkci
<code>void swap(int* a, int* b)</code>.</p>
<h2><a class="header" href="#skalární-součin" id="skalární-součin">Skalární součin</a></h2>
<p>Vytvořte funkci <code>dot</code>, která spočítá
<a href="https://cs.wikipedia.org/wiki/Skal%C3%A1rn%C3%AD_sou%C4%8Din">skalární součin</a> dvou vektorů.</p>
<pre><code class="language-c">int dot(int* a, int* b, int len);
</code></pre>
<h2><a class="header" href="#načtení-dynamického-počtu-hodnot" id="načtení-dynamického-počtu-hodnot">Načtení dynamického počtu hodnot</a></h2>
<p>Načtěte od uživatele číslo <code>n</code>. Poté naalokujte paměť o velikosti <code>n</code> <code>int</code>ů a 
načtěte ze vstupu <code>n</code> čísel, které postupně uložte do vytvořeného pole. Vypište součet načteného
pole.</p>
<h2><a class="header" href="#třízení" id="třízení">Třízení</a></h2>
<p>Naimplementujte funkci, která setřídí pole. Můžete použít například algoritmus
<a href="https://en.wikipedia.org/wiki/Bubble_sort">bubble sort</a>.</p>
<h2><a class="header" href="#counting-sort" id="counting-sort">Counting sort</a></h2>
<p>Vygenerujte pole 10 000 000 <a href="ulohy/../ruzne/nahodna_cisla.html">náhodných čísel</a> z intervalu \( \langle 1000, 2000 \rangle \).
Pomocí algoritmu counting sort seřaďte čísla v poli od nejmenšího po největší.</p>
<ol>
<li>vytvořte pole počítadel pro všechny možné hodnoty v poli</li>
<li>vynulujte počitadla na 0</li>
<li>sekvenčně projděte pole čísel a inkrementujte odpovídající počítadlo</li>
<li>projděte pole počítadel a tiskněte hodnotu tolikrát, kolik je hodnota počítadla</li>
</ol>
<p><upr-counting-sort></upr-counting-sort></p>
<h1><a class="header" href="#pvp-bitevní-hra" id="pvp-bitevní-hra">PvP bitevní hra</a></h1>
<p><asciinema-player src="pvp.cast"></asciinema-player></p>
<p>Vytvořte simulaci PvP bitevní hry dle vašich představ.
Hra bude simulována dle náhody v herních kolech dle následující kostry programu:</p>
<pre><code class="language-c">while(nepratele_nebo_hrac_nazivu()) {
  // zvolim si nepritele
  // zautocim na nej a sebere mu zivoty
  // nepritel zautoci na me a sebere mi zivoty
  
  // smazani terminalu
  printf(&quot;\e[1;1H\e[2J&quot;);

  // nove vykresleni

  // uspani na 500 ms
  usleep(500 * 1000);
}
</code></pre>
<p>Životy nepřátel reprezentujme pomocí pole čísel a na začátku hry jim náhodně přiřaďme čísla z intervalu např. 150 - 400.
Hrdinovi životy vygenerujme obdobně - využijte tedy <strong>funkci</strong> pro vygenerovaní životů, ať zbytečně nekopírujeme kód.
Obdobně můžeme také vytvořit pole štítů a zbraní.
Konkrétního nepřítele můžeme vybrat pomocí několika strategií - každá může být naimplementovaná ve funkci přijímající pole životů/štítů/zbraní a počet nepřátel.
Funkce pak může vracet index vybraného hrdiny na kterého zaútočíme.</p>
<ol>
<li>vybrat nepřítele náhodně</li>
<li>vybrat nepřítele s nejmenším počtem životů</li>
<li>vybrat nepřítele s nejmenším počtem životů a štítu</li>
<li>vybrat nepřítele s nejslabší zbraní</li>
</ol>
<p>Po zaútočení ubereme nepříteli životy a zajistíme, aby nemohly být záporné - například pomocí ternárního výrazu.
Pokud má však štít, tak musíme mu nejprve ubrat životy ze štítu a poté z životů.</p>
<p>Zraněný nepřítel poté zaútočí na nás a odebere nám štít či životy - použijme funkci ať nekopírujeme kód.</p>
<p>Poté naimplementujeme funkci v podmínce cyklu - funkce bude vracet <code>TRUE</code>, pokud je hrdina naživu a zároveň je naživu alespoň jeden nepřítel.</p>
<p>Hru můžeme dále vylepšit o:</p>
<ul>
<li>critical damage 4%
<ul>
<li>pokud vygenerujeme číslo z rozsahu 0-99 a hodnota bude menší než např. 4, tak zaútočíme s dvojnásobným poškozením</li>
</ul>
</li>
<li>degradace zbraní
<ul>
<li>po každém útoku se poškozeni zbraně zmenší o 5%</li>
</ul>
</li>
<li>inventář zbraně hrdiny
<ul>
<li>hrdina bude mít několik zbraní</li>
<li>po každém útoku si hrdina vymění zbraň za následující v inventáři
<ul>
<li>realizujte to posunováním zbraní v inventáři
<ul>
<li>zazálohujeme si nultý prvek v poli do proměnné</li>
<li>první prvek nakopírujeme do nultého prvku</li>
<li>druhý prvek nakopírujeme do prvního prvku atd</li>
<li>následně na poslední index uložíme hodnotu zazálohovanou v proměnné</li>
</ul>
</li>
<li>alternativně si pamatujte index aktuální zbraně a ten inkrementujeme
<ul>
<li>pokud bude index vetší nebo roven počtu prvků, tak jej vrátíme opět na začátek</li>
<li>můžeme elegantně také využít operátor zbytku po dělení - tím nám odpadne podmínka či ternární výraz</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>prohazování zbraní dvou nepřátel po každém útoku</li>
<li>náhodné uzdravování a postupná regenerace štítu</li>
</ul>
<p><a href="https://en.wikipedia.org/wiki/Box-drawing_character">Rámečky</a> můžeme kreslit pomocí Unicode znaků - stačí je jenom zkopírovat a vložit do <code>printf</code>.</p>
<p>Barvy v terminálu můžeme měnit pomocí escape sekvencí:</p>
<pre><code class="language-c">#define RESET &quot;\x1B[0m&quot;
#define RED &quot;\x1B[31m&quot;
#define GREEN &quot;\x1B[32m&quot;
#define YELLOW &quot;\x1B[33m&quot;
#define BLUE &quot;\x1B[34m&quot;
#define MAGENTA &quot;\x1B[35m&quot;
#define CYAN &quot;\x1B[36m&quot;
#define WHITE &quot;\x1B[37m&quot;
...
printf(RED &quot;%d&quot; RESET, hp_left); 
</code></pre>
<p>Návrh hry také můžete později vylepšit pomocí <a href="ulohy/../c/struktury/vlastni_datove_typy.html">struktury</a> <code>Player</code>, která by obsahovala životy, štít a zbraně jednoho hráče po kupě.</p>
<h1><a class="header" href="#dvourozměrné-pole" id="dvourozměrné-pole">Dvourozměrné pole</a></h1>
<h2><a class="header" href="#vytisknutí-matice" id="vytisknutí-matice">Vytisknutí matice</a></h2>
<p>Vytvořte funkci <code>print_matrix</code>, která vypíše obrázek reprezentovaný
<a href="ulohy/../c/pole/vicerozmerna_pole.html">dvourozměrným</a> (2D) polem.</p>
<pre><code class="language-c">void print_matrix(int* matrix, int rows, int cols);
</code></pre>
<p>Projděte matici po řádcích a sloupcích a vypište jednotlivé prvky.</p>
<h2><a class="header" href="#vykreslení-hvězdice" id="vykreslení-hvězdice">Vykreslení hvězdice</a></h2>
<p>Vytvořte funkci <code>draw_star</code>, která do 2D matice vykreslí hvězdici.</p>
<pre><code class="language-c">void draw_star(int* matrix, int rows, int cols);
</code></pre>
<pre><code>X    X    X
 X   X   X 
  X  X  X  
   X X X   
    XXX    
XXXXXXXXXXX
    XXX    
   X X X   
  X  X  X  
 X   X   X 
X    X    X
</code></pre>
<p>Hvězdici můžete vykreslit do pole pomocí jediného cyklu.
Zkuste vytvořit funkce na vykreslení dalších tvarů (čára, čtverec, kružnice, trojúhelník, …).</p>
<h2><a class="header" href="#násobení-matice-skalárem" id="násobení-matice-skalárem">Násobení matice skalárem</a></h2>
<p>Vytvořte funkci <code>matrix_mul_scalar</code>, která vynásobí každý prvek matice číslem <code>k</code>. </p>
<pre><code class="language-c">void matrix_mul_scalar(int* matrix, int rows, int cols, int k);
</code></pre>
<p><img src="ulohy/../static/img/matrix_scalar.svg" alt="Násobení matice skalárem" /></p>
<h2><a class="header" href="#násobení-matice-vektorem" id="násobení-matice-vektorem">Násobení matice vektorem</a></h2>
<p>Vytvořte funkci <code>matrix_mul_vector</code>, která vynásobí matici vektorem.</p>
<pre><code class="language-c">int* matrix_mul_vec(int* matrix, int rows, int cols, int *vec, int len);
</code></pre>
<!--
![Násobení matice vektorem](../static/img/matrix_vector.svg)
-->
<p><upr-matrix-mul a="[[1, 2, 3], [4, 5, 6], [7, 8, 9]]" b="[[10], [20], [30]]"></upr-matrix-mul></p>
<h2><a class="header" href="#násobení-matice-maticí" id="násobení-matice-maticí">Násobení matice maticí</a></h2>
<p>Vytvořte funkci pro násobení matice \( A \) o rozměrech \( rows_1 \times cols_1 \) s druhou matici \( B \) o rozměrech \( rows_2 \times cols_2 \).
Funkce vrátí <code>NULL</code> v případě, že matice nepůjdou vynásobit např. v případě, že počet řádků první matice není shodný s počtem sloupců druhé matice.
Výslednou matici o rozměrech \( rows_1 \times cols_1 \) alokujte dynamicky.</p>
<upr-container>
  <upr-matrix-mul a="[[1, 2, 3], [4, 5, 6]]" b="[[10, 20], [30, 40], [50, 60]]"></upr-matrix-mul>
  <!--
  <upr-arrow dst="table" dst-anchor="south" src-anchor="north">a</upr-arrow>
  <upr-arrow dst="table:nth-of-type(2)" dst-anchor="south" src-anchor="north">b</upr-arrow>
  <upr-arrow dst="table:nth-of-type(3)" dst-anchor="south" src-anchor="north">result</upr-arrow>
  -->
</upr-container>
<h1><a class="header" href="#digitální-hodiny" id="digitální-hodiny">Digitální hodiny</a></h1>
<upr-segment />
<p>Vytvořme real-time digitální hodiny ukazující aktuální čas ve stylu <a href="https://en.wikipedia.org/wiki/Seven-segment_display">7-segmentových</a> displejů.</p>
<p>Cifry hodin budeme vykreslovat do 2D matice realizované pomocí jednodimenzionálního pole.
Jeden segmentový displej bude mít délku či výšku například 3 znaky.
Mezi každou cifrou bude jeden znak volný.
Na základě těchto parametrů vypočítáme potřebnou velikost 2D matice a následně alokujeme potřebnou paměť.</p>
<p>Pro čitelnější kód bude vhodné vytvořit následující funkci:</p>
<pre><code class="language-c">void screen_draw_pixel(char* screen, int width, int height, int x, int y, char c)
</code></pre>
<p>Tato funkce vykreslí znak <code>c</code> (mřížku nebo mezeru) na souřadnici <code>[x, y]</code>.
Uvnitř funkce by také měla byt kontrola, zda se souřadnice nevyskytuje mimo vykreslovanou plochu pro rychlejší detekci případných chyb.</p>
<p>Segmenty jsou reprezentované vodorovnou či svislou čarou.
Vytvoříme si funkci pro kreslení vodorovné čáry:</p>
<pre><code class="language-c">void screen_draw_hline(char* screen, int width, int height, int x, int y, int len)
</code></pre>
<p>V cyklu délky <code>len</code> budeme následně vykreslovat pixely pomocí dříve vytvořené funkce <code>screen_draw_pixel</code>.
Obdobně vytvoříme i funkci <code>screen_draw_vline</code> pro vykreslení vertikální čáry.</p>
<p>Následně si vytvoříme funkci, která nám vykreslí pro <code>n</code>-tou cifru segment <code>s</code> pomocí dříve vytvořených funkcí kreslení čár:</p>
<pre><code class="language-c">void screen_draw_segment(char* screen, int width, int height, int n, int s);
</code></pre>
<p>A poté si uděláme funkci pro vykreslení číslice <code>num</code>:</p>
<pre><code class="language-c">void screen_draw_num(char* screen, int width, int height, int n, int num);
</code></pre>
<p>Alternativně také můžeme obě funkce spojit do jedné a informaci o zobrazovaných segmentech zakódovat do bitů, kde na nejnižším bitu je jednička, pokud má svítit segment G.
Díky této úpravě se nám kod zjednoduší.</p>
<pre><code>//     ABCDEFG
// 0 - 1111110
// 1 - 0110000
</code></pre>
<p>Po úspěšném otestování všech cifer si můžeme vytvořit nekonečnou smyčku a zobrazovat aktuální čas:</p>
<pre><code class="language-c">#include &lt;time.h&gt;

int main() {
  char *display = ...;

  for(;;) {
    // vymazani terminalu
    printf(&quot;\e[1;1H\e[2J&quot;);

    // TODO: vykresleni aktualniho casu
    time_t t = time(NULL);
    struct tm *tm = localtime(&amp;t);
    printf(&quot;%d:%d:%d\n&quot;, tm-&gt;tm_hour, tm-&gt;tm_min, tm-&gt;tm_sec);

    usleep(1000 * 1000);
  }
}
</code></pre>
<h1><a class="header" href="#text-2" id="text-2">Text</a></h1>
<p>K vyřešení těchto úloh by vám mělo stačit znát <a href="ulohy/../c/text/retezce.html">řetězce</a> a <a href="ulohy/../c/text/vstupavystup.html">vstupně/výstupní operace</a>
(a samozřejmě veškeré předchozí učivo).</p>
<h2><a class="header" href="#převod-na-velké-znaky" id="převod-na-velké-znaky">Převod na velké znaky</a></h2>
<p>Vytvořte funkci, která převede textový řetězec na velké znaky.</p>
<pre><code class="language-c">char str[] = { &quot;hello&quot; };
uppercase(str);
// str by se zde měl rovnat &quot;HELLO&quot;
</code></pre>
<h2><a class="header" href="#nahrazení-znaku" id="nahrazení-znaku">Nahrazení znaku</a></h2>
<p>Vytvořte funkci, která v řetězci nahradí všechny výskyty daného znaku za znak <code>'X'</code>.</p>
<pre><code class="language-c">char str[] = { &quot;hello&quot; };
replace(str, 'l');
// str by se zde měl rovnat &quot;heXXo&quot;
</code></pre>
<h2><a class="header" href="#Šifrování-řetězce" id="Šifrování-řetězce">Šifrování řetězce</a></h2>
<p>Vytvořte funkci, která &quot;zašifruje&quot; řetězec tím, že ke každému znaku přičte číslo (klíč).
K ní vytvořte funkci, která řetězec opět odšifruje (odečtením klíče).</p>
<pre><code class="language-c">char str[] = { &quot;abc&quot; };
encrypt(str, 1);
// str by se zde měl rovnat &quot;bcd&quot;
decrypt(str, 1);
// str by se zde měl opět rovnat &quot;abc&quot;
</code></pre>
<h2><a class="header" href="#délka-řetězce" id="délka-řetězce">Délka řetězce</a></h2>
<p>Vytvořte funkci <code>my_strlen</code>, která vypočte délku řetězce (obdoba funkce
<a href="https://devdocs.io/c/string/byte/strlen"><code>strlen</code></a> ze standardní knihovny <em>C</em>).</p>
<pre><code class="language-c">my_strlen(&quot;&quot;);          // 0
my_strlen(&quot;abc&quot;);       // 3
my_strlen(&quot;abc 0 asd&quot;); // 9
</code></pre>
<h2><a class="header" href="#porovnávání-řetězců" id="porovnávání-řetězců">Porovnávání řetězců</a></h2>
<p>Vytvořte funkci, která vrátí <code>true</code>, pokud jsou dva předané řetězce stejné.
Vytvořte i variantu funkce, která porovnává řetězce bez ohledu na velikosti znaků.</p>
<pre><code class="language-c">strequal(&quot;ahoj&quot;, &quot;ahoj&quot;);               // 1
strequal(&quot;ahoj&quot;, &quot;aho&quot;);                // 0
strequal_ignorecase(&quot;ahoj&quot;, &quot;AhOj&quot;);    // 1
</code></pre>
<h2><a class="header" href="#palindrom" id="palindrom">Palindrom</a></h2>
<p>Vytvořte funkci, která vrátí <code>true</code>, pokud je předaný řetězec
<a href="https://cs.wikipedia.org/wiki/Palindrom">palindrom</a> (slovo, které se čte stejně zepředu i pozpátku).</p>
<p><img src="ulohy/../static/img/palindrom.svg" alt="palindrom" /></p>
<h2><a class="header" href="#histogram" id="histogram">Histogram</a></h2>
<p>Vytvořte funkci, která vypočte <a href="https://cs.wikipedia.org/wiki/Histogram">histogram</a> znaků v řetězci.
Histogram je pole, ve kterém prvek na pozici <code>x</code> udává, kolikrát se znak <code>x</code> vyskytoval v daném řetězci.</p>
<pre><code class="language-c">int histogram[255] = {};
calc_histogram(&quot;aabacc&quot;, histogram);
// histogram['a'] == 3
// histogram['b'] == 1
// histogram['c'] == 2
// histogram['d'] == 0
</code></pre>
<h2><a class="header" href="#převod-textu-na-číslo" id="převod-textu-na-číslo">Převod textu na číslo</a></h2>
<p>Vytvořte funkci, která převede řetězec na číslo v desítkové soustavě. Pokud číslo nelze převést,
vraťte hodnotu <code>0</code>.</p>
<pre><code class="language-c">convert(&quot;5&quot;);   // vrátí int s hodnotou 5
convert(&quot;123&quot;); // vrátí int s hodnotou 123
</code></pre>
<p>Zkuste přidat i podporu pro záporná čísla.</p>
<h2><a class="header" href="#načítání-pinu" id="načítání-pinu">Načítání PINu</a></h2>
<p>Načtěte od uživatele PIN (4 číslice). Poté opakovaně vyzývejte uživatele k zadání PINu. Pokud
uživatel zadá 3x nesprávný PIN, vypište chybovou hlášku a ukončete program. Pokud uživatel zadá PIN správně,
tak vypište <code>&quot;Uspesne zadani PINu&quot;</code> a ukončete program.</p>
<h2><a class="header" href="#hádací-hra-guessing-game" id="hádací-hra-guessing-game">Hádací hra (<em>guessing game</em>)</a></h2>
<p>Vygenerujte <a href="ulohy/../ruzne/nahodna_cisla.html">náhodné číslo</a>. Poté nechte uživatele hádat, jaké číslo
program vygeneroval. Po každém tipu uživateli dejte vědět, jestli uhádl správně nebo jestli jeho
tip byl vyšší či nižší než číslo, které hádá.</p>
<h1><a class="header" href="#kalkulačka" id="kalkulačka">Kalkulačka</a></h1>
<p>Načtěte ze vstupu programu nebo z <a href="ulohy/../ruzne/funkce_main.html">parametrů příkazového řádku</a> matematický
výraz, který bude obsahovat celá čísla a operátory <code>+</code>, <code>-</code>, <code>/</code>, <code>*</code> a vypište výsledek tohoto
výrazu.</p>
<ul>
<li><em>Varianta 1</em>: Použijte klasický zápis v <a href="https://cs.wikipedia.org/wiki/Infixov%C3%A1_notace">infixové notaci</a>.
Nemusíte řešit prioritu operátorů.</li>
<li><em>Varianta 2</em>: Přidejte podporu pro prioritu operátorů a závorky <code>(</code>, <code>)</code>. Použijte algoritmus
<a href="https://cs.wikipedia.org/wiki/Algoritmus_shunting-yard">Shunting yard</a>.</li>
<li><em>Varianta 3</em>: Použijte <a href="https://cs.wikipedia.org/wiki/Postfixov%C3%A1_notace">postfixovou notaci</a>.
Zde bude fungovat priorita operátorů a &quot;závorkování&quot; bez nutnosti složitého načítání vstupu z
varianty 2.</li>
</ul>
<h1><a class="header" href="#střelba-na-terč" id="střelba-na-terč">Střelba na terč</a></h1>
<p>Vytvořte program, který načte souřadnice terčů a střel, a vykreslí je do obrázku ve formátu
vektorové grafiky <a href="https://en.wikipedia.org/wiki/Scalable_Vector_Graphics">SVG</a>. Pokud si vygenerovaný SVG obrázek otevřete v internetovém prohlížeči, tak by se po najetí
myši na terč mělo ukázat skóre vybraného terče.</p>
<p><object data="terc/01_basic.svg"></object></p>
<p>Ze vstupu přečtěte počet terčů a následně si dynamicky alokujte 3 pole typu <code>float</code> pro <code>x</code> souřadnice terčů, <code>y</code> souřadnice terčů a poloměry terčů.</p>
<p>Poté pro každý terč přečtěte jeho <code>x</code> souřadnici, <code>y</code> souřadnici, poloměr a uložte je do
odpovídajících polí.
Například následující vstup nám popisuje 2 terče.
První terč má střed na souřadnici \( [50, 70 ] \) a poloměr \( 40 \) a druhý terč leží na středu \( [160, 90 ] \) s poloměrem \( 60 \).</p>
<pre><code>2
50 70 40
160 90 60
</code></pre>
<p>Tento vstup nezadávejte pořad dokola z klávesnice, ale <a href="ulohy/../c/text/vstupavystup.html#standardn%C3%AD-souborov%C3%A9-deskriptory">přesměrujte</a>
si jej do programu ze souboru:</p>
<pre><code>$ ./main &lt; terce.txt
</code></pre>
<p>Terče si pomocí <code>printf</code> vykreslete do vektorového obrázku ve formátu svg, ve kterém lze pomocí tagů definovat útvary.
Útvary v obrázku obalte tagem <code>svg</code>:</p>
<pre><code class="language-xml">&lt;svg xmlns='http://www.w3.org/2000/svg'&gt;
  &lt;!-- kresleni kruhu --&gt;
&lt;/svg&gt;
</code></pre>
<p>Terč se středem \( [50, 70] \) a poloměrem \( 40 \) lze vykreslit pomocí:</p>
<pre><code class="language-svg">&lt;circle cx='50' cy='70' r='40' stroke='black' fill='red' /&gt;
</code></pre>
<p>Vytvořený SVG obrázek si ze standardního výstupu <a href="ulohy/../c/text/vstupavystup.html#standardn%C3%AD-souborov%C3%A9-deskriptory">přesměrujte</a>
do souboru a otevřete si jej například v prohlížeči firefox.</p>
<pre><code class="language-shell">$ ./main &lt; terce.txt &gt; obrazek.svg
$ firefox obrazek.svg
</code></pre>
<p>Následně si ze vstupu přečtěte počet střel a alokujte pro ně dvě pole - jedno bude reprezentovat <code>x</code> souřadnice a druhé <code>y</code> souřadnice jednotlivých střel.
Souřadnice si následně přečtěte do těchto polí.
Pole si projděte a vykreslete do obrázku jako kruhy např. s poloměrem \( 4 \).</p>
<p>Střela zasáhla terč, pokud leží na kruhu.
Jinými slovy - střela zasáhla terč, pokud je vzdálenost od středu terče menší než poloměr terče.
Vzdálenost vypočítáme jednoduše pomocí Pythagorovy věty, kde <code>x</code> odvěsna je rozdíl mezi <code>x</code> souřadnici středu terče a <code>x</code> souřadnici střely. Odvěsna <code>y</code> lze vypočítat obdobně a poté můžeme vypočítat přeponu, která reprezentuje vzdálenost střely od středu terče.</p>
<svg>
   <circle cx="50" cy="50" r="50" fill="rgb(190, 83, 85)" />
   <circle cx="75" cy="20" r="5" fill="black" />
   <line x1=50 y1=50 x2=75 y2=20 stroke='black'/>
   <line x1=50 y1=50 x2=75 y2=50 stroke='black'/>
   <line x1=75 y1=20 x2=75 y2=50 stroke='black'/>
   <text x=60 y=35 text-anchor="end">dist</text>
</svg>
<p>Protože máme více terčů a více střel, tak musíme aplikovat výpočet vzdálenosti mezi každou střelou
a každým terčem pomocí dvou vnořených <code>for</code> cyklů.
Vnější cyklus bude procházet střely a vnitřní cyklus bude procházet terče.
Ve vnitřním cyklu vypočítáme vzdálenost mezi střelou a terčem a pokud je menší než poloměr,
tak tento konkrétní terč byl zasažen střelou z vnějšího cyklu.
V případě, že se více kruhů překrývá, tak střela zasáhla terč s menším poloměrem.
Budeme tedy hledat zasáhnutý terč s nejmenším poloměrem.</p>
<p>Skóre při zasažení středu s poloměrem 20 je 10 bodů a body postupně klesají.
Zdrojový kód SVG ukázek si můžete zobrazit.</p>
<details>
<summary>Dva terče</summary>
<p><object data="terc/01_basic.svg"></object></p>
<pre><code>2
50 70 40
160 90 60

4
25 70
80 90
150 100
55 140
</code></pre>
</details>
<details>
<summary>Překrývající se terče</summary>
<p><object data="terc/02_overlayed.svg"></object></p>
<pre><code>2
160 90 60
90 70 40

4
125 70 
80 90
150 100
55 140
</code></pre>
</details>
<details>
<summary>Překrývající se terče se stejným středem</summary>
<p><object data="terc/03_same_c.svg"></object></p>
<pre><code>3
50 70 40
160 90 60
160 90 40
7
25 70
80 90
55 140
125 60
140 130
150 100
215 100
</code></pre>
</details>
<h1><a class="header" href="#Čištění-chatu" id="Čištění-chatu">Čištění chatu</a></h1>
<p>Napište program, který transformuje cO0l zPráVy<img height="20" src="https://emoji.gg/assets/emoji/GWjiangoOmegaLUL.png"><img height="20" src="https://emoji.gg/assets/emoji/1219_KEKW.png"> z chatu do čitelné podoby.
Zprávy jsou do našeho programu přesměrovány na standardní vstup - úkolem bude číst zprávy nebo části zprav po řádcích a provádět následující úpravy:</p>
<ol>
<li>
<p>Odstranit bílé znaky (whitespace - mezera, tabulátor, ...) ze začátku a konce každého řádku</p>
<p>možné řešení:</p>
<ol>
<li>najít pozici prvního non-whitespace znaku</li>
<li>překopírovat všechny znaky od této pozice na začátek pomocí vlastního cyklu nebo <code>strcpy</code>, <code>memcpy</code> či <code>memmove</code></li>
<li>cyklem jít od konce řetězce a najít první non-whitespace znak</li>
<li>uložit za něj nový konec <code>\0</code></li>
</ol>
</li>
<li>
<p>Transformovat cO0L tExT do čitelné podoby</p>
<p>Každá věta začne velkým písmem a všechna ostatní písmena ve větě budou převedena na malá písmena.
Věta je ukončena znakem <code>.</code>, <code>!</code> nebo <code>?</code>.</p>
<p>Např. si před cyklem vytvořit proměnnou indikující start nové věty.
Cyklem projít všechny znaky a první písmeno věty zvětšit a zbytek zmenšovat.
Tečka, otazník či vykřičník poté nastaví nastaví proměnnou indikující novou větu.</p>
</li>
<li>
<p>Nahradit opakující se znaků jedním výskytem</p>
<p>Např. si pamatovat proměnnou s předchozím znakem nebo porovnávat přímo předchozí znak - pozor abychom nepřistoupili před/za pole.
Na velikosti písmen nebude záležet - <code>xXxxXx</code> se také nahradí jedním <code>x</code>.
Můžeme si udržovat dva indexy - jeden ve vstupním stringu a druhý ve výstupním stringu.
Pokud se znak opakuje, tak jej nepřidáváme do výstupního stringu.</p>
</li>
<li>
<p>Smazat smajlíky zapsané pomocí <code>:nazev:</code></p>
<p>Procházíme znak po znaku a pamatujeme si, jestli jsme narazili na <code>:</code>.
Pokud ano, tak nepřidáváme znaky do výstupního stringu.
Pokud nenarazíme na ukončovací <code>:</code>, tak text musíme do stringu přidat - viz ukázka v testu.</p>
</li>
<li>
<p>Cenzurovat zakázaná slova pomocí hvězdiček</p>
<p>Každé slovo z pole blocklistu o velikosti <code>sizeof(blocklist) / sizeof(blocklist[0])</code> zkusíme najít v řetězci.
Pokud najdeme, tak celé slovo vyhvězdičkujeme a zkusíme hledat další výskyt od konce tohoto výskytu.
Při hledání nebude záležet na velikosti písmen.</p>
<pre><code class="language-c">const char *blocklist[] = {
   &quot;windows&quot;,
   &quot;mac&quot;,
   &quot;c#&quot;,
   &quot;fortnite&quot;,
   &quot;php&quot;,
   &quot;javascript&quot;,
   &quot;.net&quot;,
};
// blocklist[0] je &quot;windows&quot;
</code></pre>
</li>
</ol>
<h1><a class="header" href="#překladač-jazyka-brainfuck" id="překladač-jazyka-brainfuck">Překladač jazyka Brainfuck</a></h1>
<p>Jazyk <a href="https://esolangs.org/wiki/Brainfuck">Brainfuck</a> je velmi jednoduchý esoterický programovací
jazyk obsahující pouze osm instrukcí, lineární paměť a adresu aktuální paměťové buňky. Jedna buňka
odpovídá jednomu bytu.</p>
<ul>
<li>Instrukce <code>+</code> inkrementuje hodnotu aktuální buňky.</li>
<li>Instrukce <code>-</code> dekrementuje hodnotu aktuální buňky.</li>
<li>Instrukce <code>&gt;</code> inkrementuje adresu buňky (po inkrementaci ukazujeme na následující buňku).</li>
<li>Instrukce <code>&lt;</code> dekrementuje adresu buňky (po dekrementaci ukazujeme na předcházející buňku).</li>
<li>Instrukce <code>[</code> uvozuje začátek cyklu. Cyklus probíhá, dokud hodnota buňky adresované v době
vyhodnocování podmínky není nulová (adresovanou buňku můžeme měnit uvnitř cyklu).</li>
<li>Instrukce <code>]</code> představuje konec těla cyklu. Jakmile program narazí na instrukce <code>]</code>, zkontroluje
hodnotu v aktuálně adresované paměťové buňce, a buď se vrátí zpět na odpovídající <code>[</code>, nebo je
cyklus ukončen a vykonávání programu pokračuje prováděním instrukcí bezprostředně za cyklem.</li>
<li>Instrukce <code>,</code> přečte jeden byte ze vstupu a uloží hodnotu do aktuálně adresované buňky.</li>
<li>Instrukce <code>.</code> vypíše hodnotu aktuálně adresované buňky jako ASCII znak na standardní výstup.</li>
</ul>
<p>Všechny ostatní znaky jsou ignorovány.</p>
<p>Program <code>Hello, World!</code> v jazyce Brainfuck může vypadat například následovně:</p>
<pre><code>++++++++
[
    &gt;++++++++&lt;-
]
&gt;++++++++.&gt;++++++++
[
    &gt;++++++++++++&lt;-
]
&gt;+++++.+++++++..+++.&gt;++++++++
[
    &gt;+++++&lt;-
]
&gt;++++.------------.&lt;&lt;&lt;&lt;+++++++++++++++.&gt;&gt;.+++.------.--------.&gt;&gt;+.
</code></pre>
<p>Naprogramujte interpret jazyka Brainfuck. Interpret (angl. <em>interpreter</em>), je překladač, který
zdrojový kód vykonává při každém spuštění cílového programu. Program se tedy nikdy nekompiluje
do spustitelného binárního souboru.</p>
<h2><a class="header" href="#implementace-1" id="implementace-1">Implementace</a></h2>
<ul>
<li>Program procházejte znak po znaku a jednotlivé instrukce interpretujte.</li>
<li>Pokud narazíte na konec cyklu (<code>]</code>), stačí se vrátit v textu zpět na odpovídající <code>[</code>.</li>
<li>Nezapomeňte, že cykly můžou být i vnořené.</li>
<li>Paměť lze reprezentovat polem bytů fixní velikosti.</li>
<li>Adresu lze reprezentovat indexem nebo ukazatelem.</li>
<li>Vstup můžeme číst například pomocí <code>getc(stdout)</code>.</li>
<li>Výstup můžeme realizovat pomocí funkce <code>putchar</code>.</li>
<li>Při vstupu a výstupu paměť interpretujte jako ASCII znaky. V opačných případech ji lze
interpretovat jako obyčejné číslo.</li>
<li>Při přístupu mimo alokovanou paměť interpret vypíše chybu a překlad programu skončí.</li>
</ul>
<h2><a class="header" href="#ukázkové-programy" id="ukázkové-programy">Ukázkové programy</a></h2>
<p>Pro otestování svého překladače můžete využít například následující programy. Další programy
napsané v jazyce Brainfuck naleznete na internetu, případně si můžete zkusit napsat program
vlastní.</p>
<p>Hello, World:</p>
<pre><code>++++++++[&gt;++++++++&lt;-]&gt;++++++++.&gt;++++++++[&gt;++++++++++++&lt;-]&gt;+++++.+++++++..+++.&gt;++++++++[&gt;+++++&lt;-]&gt;++++.------------.&lt;&lt;&lt;&lt;+++++++++++++++.&gt;&gt;.+++.------.--------.&gt;&gt;+.
</code></pre>
<p>Echo (program opakující svůj vstup):</p>
<pre><code>+[&gt;,.&lt;]
</code></pre>
<h2><a class="header" href="#složitější-varianta-1" id="složitější-varianta-1">Složitější varianta</a></h2>
<p>Namísto pásky pevně dané velikosti naprogramujte paměť, která se bude zleva i zprava zvětšovat,
pokud se program pokusí přistoupit za hranice pásky.</p>
<p>Zkuste místo přímé interpretace vstupního řetězce nejprve sestavit
<a href="https://en.wikipedia.org/wiki/Abstract_syntax_tree">abstraktní syntaktický strom (AST)</a>
reprezentující daný program. Tvorba AST bude vyžadovat znalosti z pozdějších lekcí. Interpretujte
poté AST, ne přímo vstupní řetězec.</p>
<p>Při tvorbě AST proveďte základní optimalizace - například sérii inkrementací převeďte na jedno
přičtení většího čísla (tedy např. sérii osmi inkrementací převedeme na přičtení čísla osm).</p>
<p>Nakonec můžete zkusit namísto interpretace program zkompilovat. Kompilovat můžete například
do Assembly, nebo do <a href="https://llvm.org/docs/LangRef.html">LLVM IR kódu</a>. Výstup vašeho překladače
nakonec necháte přeložit assemblerem nebo LLVM.</p>
<h1><a class="header" href="#struktury-1" id="struktury-1">Struktury</a></h1>
<p>Vytvořte strukturu <code>Student</code>, která bude obsahovat atributy pro jeho věk, jméno, počet bodů a
nejlepšího přítele (to bude také student). Dále naimplementujte tyto funkce:</p>
<pre><code class="language-c">/**
 * Nainicializujte studenta se zadaným věkem a jménem.
 * Počet bodů i nejlepší přítel by měli být nastaveni na nulu.
 */
void student_init(Student* student, int age, const char* name) {}

/**
 * Spočítejte, kolik studentů v předaném poli má maximálně zadaný věk.
 * Příklad:
 *   Student students[3];
 *   students[0].age = 18;
 *   students[1].age = 19;
 *   students[2].age = 16;
 *
 *   count_young_students(students, 3, 18); // 2
 */
int count_young_students(Student* students, int count, int maximum_age) {}

/**
 * Přiřaďte studentům body na základě výsledků testů.
 * V poli `points` jsou body pro jednotlivé studenty v poli `students`.
 * Parameter `count` obsahuje počet studentů a testů.
 */
void assign_points(Student* students, const int* points, int count) {}

/**
 * Vraťe v parametru `good_students` pole studentů, kteří mají alespoň 51 bodů a v
 * parametru `good_student_count` jejich počet.
 * Budete muset dynamicky naalokovat nové pole s odpovídající velikostí.
 */
void filter_good_students(
    const Student* students,
    int count,
    Student** good_students,
    int* good_student_count
);

/**
 * Otestujte, jestli je student šťastný.
 * Student je šťastný, pokud:
 * 1) Má alespoň 51 bodů, a zároveň
 * 2) Jeho nejlepší přítel je šťastný
 *
 * Pokud student nemá nejlepšího přítele, pokládejte podmínku 2) za splněnou.
 */
int student_is_happy(Student* student) {}
</code></pre>
<p>K otestování vaší implementace můžete použít následující testovací program<sup class='margin-toggle sidenote-number'>1</sup>:</p>
<span class='sidenote'><p><sup class='number'>1</sup>Implementace svých funkcí v tomto programu umístěte nad <code>main</code> a program spusťte s
<a href="ulohy/../prostredi/ladeni.html#address-sanitizer"><code>Address sanitizerem</code></a>. Pokud program nic nevypíše, máte
implementaci pravděpodobně správně.</p>
</span><details>
<summary>Testovací program</summary>
<pre><code class="language-c">#include &lt;assert.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;

// Zde vložte implementace funkcí

int main()
{
    Student jirka;
    student_init(&amp;jirka, 18, &quot;Jiri Novak&quot;);
    assert(jirka.age == 18);
    assert(!strcmp(jirka.name, &quot;Jiri Novak&quot;));
    assert(jirka.points == 0);
    assert(jirka.best_friend == NULL);

    Student students[3];
    for (int i = 0; i &lt; 3; i++)
    {
        student_init(students + i, 17 + i, &quot;&quot;);
    }
    assert(count_young_students(students, 3, 18) == 2);

    int points[] = { 10, 15, 3 };
    assign_points(students, points, 3);
    assign_points(students, points, 1);
    assert(students[0].points == 20);
    assert(students[1].points == 15);
    assert(students[2].points == 3);

    Student a = {}, b = {}, c = {};
    a.points = 51;
    b.points = 50;
    c.points = 50;
    assert(student_is_happy(&amp;a));
    a.best_friend = &amp;b;
    assert(!student_is_happy(&amp;a));
    b.points = 51;
    assert(student_is_happy(&amp;a));
    b.best_friend = &amp;c;
    assert(!student_is_happy(&amp;a));
    c.points = 100;
    assert(student_is_happy(&amp;a));

    Student students2[3] = {};
    students2[0].age = 15;
    students2[2].age = 18;
    int points2[] = { 51, 20, 60 };
    assign_points(students2, points2, 3);

    Student* good_students;
    int good_students_count;
    filter_good_students(students2, 3, &amp;good_students, &amp;good_students_count);
    assert(good_students_count == 2);
    assert(good_students[0].age == 15);
    assert(good_students[1].age == 18);

    free(good_students);

    return 0;
}
</code></pre>
</details>
<h1><a class="header" href="#kreslení-obrazovky-apple-watch" id="kreslení-obrazovky-apple-watch">Kreslení obrazovky Apple Watch</a></h1>
<p>Pro tuto úlohu využijte stuktury a funkce pro zápis obrázku formátu <a href="ulohy/../c/aplikovane_ulohy/tga.html">TGA</a> do souboru.</p>
<p>Vše má svůj příběh a tak tedy započněme naši cestu např. ve firmě <a href="https://www.apple.com">Apple</a>…</p>
<p>Představte si, že jste vývojářem/kou ve firmě Apple a <a href="https://en.wikipedia.org/wiki/Steve_Jobs">Steve Jobs</a> Vás pověří programátorským úkolem.</p>
<p>Firma aktuálně pracuje na super tajném projektu <a href="https://en.wikipedia.org/wiki/Apple_Watch">nových smart hodinek</a>, které chce uvést na trh.
Vašim úkolem je pod přímým vedením Steva Jobse (původního zakladatele firmy) naprogramovat digitální ciferník nových hodinek.</p>
<h3><a class="header" href="#technické-specifikace-displeje" id="technické-specifikace-displeje">Technické specifikace displeje</a></h3>
<p>Displej hodinek má rozlišení <code>368x448</code> px (<a href="https://en.wikipedia.org/wiki/Pixel">pixelů</a>).</p>
<h3><a class="header" href="#schéma-pro-zobrazení-znaků" id="schéma-pro-zobrazení-znaků">Schéma pro zobrazení znaků</a></h3>
<p>Na obrázku níže je rozklesleno, jak by se měl zobrazovat čas na hodinkách.</p>
<p><img src="ulohy/../static/img/watches_clock.svg" alt="" /></p>
<p>První řádek slouží pro zobrazeni hodin, druhý řádek pro zobrazení minut.
Tloušťky jednotlivých segmentů a rozestupy jsou také zakresleny.
Modře je znázorněna oblast, kde se nevykreslují číslice, ale je možno kreslit pozadí ciferníku.
Jsou znázorněna jen čtyři čísla, zbytek si již odvodíte sami.</p>
<h3><a class="header" href="#funkce-a-struktury-na-implementaci" id="funkce-a-struktury-na-implementaci">Funkce a struktury na implementaci</a></h3>
<p>Postupně naimplementujte následující funkce a struktury.</p>
<h4><a class="header" href="#funkce-pro-vykreslení-času" id="funkce-pro-vykreslení-času">Funkce pro vykreslení času</a></h4>
<pre><code class="language-c">void watch_draw_time(TGAImage* self, const int hours, const int minutes);
</code></pre>
<p>Funkce nakreslí do obrázku <code>self</code> čas zadaný pomocí času v hodinách (<code>hours</code>) a minutách (<code>minutes</code>).
Barvu čísel si zvolte libovolně, stejně jako barvu pozadí.</p>
<h4><a class="header" href="#struktura-pro-reprezentaci-barvy-pixelu-rgba" id="struktura-pro-reprezentaci-barvy-pixelu-rgba">Struktura pro reprezentaci barvy pixelu (<code>RGBA</code>)</a></h4>
<p>Barva se do každého pixelu zapisuje jako čtveřice bajtů <code>BGRA</code> (<code>B</code> - Blue, <code>G</code> - Green, <code>R</code> - Red,
<code>A</code> - Alpha). Nadefinujte si strukturu <code>RGBA</code>, která bude tyto bajty reprezentovat pomocí čtyř
proměnných: <code>r</code>, <code>g</code>, <code>b</code>, <code>a</code> patřičného datového typu.</p>
<h4><a class="header" href="#funkce-pro-vykreslení-času-s-určením-barev" id="funkce-pro-vykreslení-času-s-určením-barev">Funkce pro vykreslení času s určením barev</a></h4>
<pre><code class="language-c">void watch_draw_time_color(
    TGAImage* self,
    const int hours,
    const int minutes,
    const RGBA* fg_color,
    const RGBA* bg_color
);
</code></pre>
<p>Funkce nakreslí do obrázku <code>self</code> čas zadaný pomocí času v hodinách (<code>hours</code>) a minutách (<code>minutes</code>).
Barva čísel je předána parametrem <code>fg_color</code>, barva pozadí pak parametrem <code>bg_color</code>.</p>
<h1><a class="header" href="#létající-písmenka" id="létající-písmenka">Létající písmenka</a></h1>
<p>Využijte znalosti <a href="ulohy/../c/pole/vicerozmerna_pole.html">dvourozměrných polí</a>, <a href="ulohy/../c/text/retezce.html">řetězců</a>
a <a href="ulohy/../ruzne/funkce_main.html#vstupn%C3%AD-parametry-funkce-main">argumentů programu</a> pro vytvoření následující
animace:</p>
<p><asciinema-player src="letters.cast"></asciinema-player></p>
<ol>
<li>
<p>Vytvoříme si strukturu reprezentující vykreslovací plochu</p>
<pre><code class="language-c">typedef struct {
 char *content; // rows x cols &quot;pixelu&quot;
 int rows;
 int cols;
} Board;
</code></pre>
</li>
<li>
<p>Naimplementujeme si funkci pro vytvoření nové vykreslovací plochy o předaných rozměrech</p>
<pre><code class="language-c">Board* board_new(int rows, int cols) {
 // dynamická alokace paměti pro strukturu složenou z pointeru na obsah a dvou proměnných udávající rozměry
 // dynamická alokace paměti pro rows*cols pixelů typu char a uložení do pointeru content
 // uložení rows a cols do struktury a vrácení
}
</code></pre>
<p>Nesmíme také zapomenout ošetřovat různé chybové stavy - alokace paměti nemusí být vždy úspěšná a musíme provést kontrolu, zda navrácená paměť není <code>NULL</code>.
K této funkci je také vhodné doimplementovat funkci pro uvolnění pixelů a poté samostatné struktury:</p>
<pre><code class="language-c">void board_delete(Board* b);
</code></pre>
</li>
<li>
<p>Funkce pro vykreslení pixelu / znaku</p>
<p>Pro jednoduší a čitelnější kód si naimplementujeme funkci, která nám vykreslí znak <code>c</code> na řádek <code>row</code> a sloupec <code>col</code>.
Funkce by také měla zkontrolovat, zda souřadnice není před nultým či posledním řádkem a sloupcem, aby nedocházelo k pádu programu nebo k vykreslování jinam.</p>
<pre><code class="language-c">void board_draw_pixel(Board *b, int row, int col, char c);
</code></pre>
<p>Přepočet 2D souřadnice <code>[row, col]</code> na 1D index můžeme podle následujícího obrázku:
<img src="ulohy//static/img/2d_array.svg"></p>
</li>
<li>
<p>Vykreslení rámečku</p>
<p>Kolem okrajů vykreslíme rámeček pomocí funkce <code>board_draw_pixel</code>.
Pro vykreslování rámečku <strong>NENÍ</strong> potřeba procházet vnitřek - stačí dvě smyčky za sebou.
První smyčka bude procházet všechny řádky a kreslit na nultý a poslední sloupec.
Obdobně druhá smyčka bude procházet sloupce a kreslit na nultý a poslední řádek.
Procházením vnitřku plochy se může znatelně zpomalit např. při rozlišení 8k.</p>
<pre><code>#################
#               #
#               #
#               #
#               #
#               #
#               #
#################
</code></pre>
</li>
<li>
<p>Reprezentace písmenka a jeho vykreslování</p>
<p>Písmenko budeme reprezentovat pomocí struktury složené ze znaku, pozice a rychlost pohybu:</p>
<pre><code class="language-c">typedef struct {
 int row;
 int col;
} Coord;

typedef struct {
  char c;
  Coord position;
  Coord speed;
} Letter;
</code></pre>
<p>Rychlost pohybu <code>speed</code> bude nabývat hodnot <code>-1</code> pro směr vlevo v případě sloupcové souřadnice nebo směr nahoru v případě řádkové souřadnice.
Hodnota <code>1</code> pak bude znamenat směr doprava respektive dolů.</p>
<p>Následně si vytvoříme funkci pro jeho vykreslení do plochy:</p>
<pre><code>void letter_render(Letter *letter, Board *board);
</code></pre>
</li>
<li>
<p>Pohyb písmenka s odrážením od stěn</p>
<p>Vytvoříme si funkci simulující jeden pohyb písmenka:</p>
<pre><code>void letter_step(Letter *letter, Board *board);
</code></pre>
<p>K aktuální pozici písmenka v řádku a sloupci přičteme rychlost <code>speed</code> z odpovídající souřadnice.
Poté zkontrolujeme, zda je nová pozice na prvním řádku/sloupci či předposledním řádku/sloupci.
Pokud ano, tak změníme směr písmenka a tím dojde v příštím kroku k odrazu.</p>
</li>
<li>
<p>Hlavní smyčka</p>
<p>Pro otestování odrazu je opět vhodné si udělat hlavní vykreslovací smyčku:</p>
<pre><code class="language-c">Board *b = board_new(20, 50);
Letter l;
l.c = 'O';
l.position.row = b-&gt;rows / 2;
l.position.col = b-&gt;cols / 2;
l.speed.row = 1;
l.speed.col = -1;

for(;;) {
 // smazani terminalu
 printf(&quot;\e[1;1H\e[2J&quot;);

 // vykresleni ramecku
 board_draw_border(b);

 // jeden krok pismenka
 letter_step(&amp;l, b);

 // vykresleni pismenka
 letter_render(&amp;l, b);

 // uspani na 500 ms
 usleep(500 * 1000);
}
</code></pre>
</li>
<li>
<p>Více písmenek</p>
<p>Textový řetězec si převedeme na pole létajících písmenek pomocí funkce:</p>
<pre><code class="language-c">typedef struct {
 Letter *letters;
 int count;
} Sentence;

Sentence* sentence_new(const char* sentence) {
 // dynamická alokace struktury sentence
 // dynamická alokace pole pro písmenka letters
 // v cyklu projdeme řetězec sentence a nastavíme písmenka v letters, tak aby následovala za sebou a měla náhodnou rychlost
 // vrátíme ukazatel na strukturu
}
</code></pre>
<p>Vykreslovací smyčku poté upravíme, aby uměla pracovat s celou větou a ne jenom s jediným písmenkem - prakticky půjde pouze o doplnění cyklu přes všechna písmenka.</p>
</li>
</ol>
<h1><a class="header" href="#soubory-1" id="soubory-1">Soubory</a></h1>
<p>K vyřešení těchto úloh by vám mělo stačit znát <a href="ulohy/../c/soubory/soubory.html">soubory</a> a <a href="ulohy/../c/aplikovane_ulohy/tga.html">TGA</a>
(a samozřejmě veškeré předchozí učivo).</p>
<h2><a class="header" href="#spočítání-řádků" id="spočítání-řádků">Spočítání řádků</a></h2>
<p>Naimplementujte funkci, která načte soubor na zadané cestě a vrátí počet řádků, které se v něm
vyskytují.</p>
<pre><code class="language-c">int count_lines(const char* path);
</code></pre>
<h2><a class="header" href="#kopírování-souboru" id="kopírování-souboru">Kopírování souboru</a></h2>
<p>Naimplementujte funkci, která přijme cestu ke vstupnímu a výstupnímu souboru a zkopíruje obsah
vstupního souboru do výstupního souboru.</p>
<pre><code class="language-c">void copy_file(const char* src, const char* destination);
</code></pre>
<h2><a class="header" href="#Šifrování-souboru" id="Šifrování-souboru">Šifrování souboru</a></h2>
<p>Naimplementujte funkci, která přičte číslo <code>key</code> ke všem znakům v souboru na zadané cestě.</p>
<pre><code class="language-c">void encrypt_file(const char* path, int key);
</code></pre>
<p>Dále udělejte druhou funkci, která od znaků v souboru na zadané cestě naopak číslo <code>key</code> odečte.
Otestujte, že soubor po zašifrování a odšifrování obsahuje stejný obsah. Pro testování používejte
soubory s ASCII textem.</p>
<pre><code class="language-c">void decrypt_file(const char* path, int key);
</code></pre>
<h1><a class="header" href="#meme-generátor" id="meme-generátor">Meme generátor</a></h1>
<p>Vytvořte generátor meme obrázků dle instrukcí na standardním vstupu:</p>
<pre><code>blank.tga
meme.tga
2 2
I dont always do
memes
but when i do
i do them in C
</code></pre>
<p><img src="ulohy/meme/meme.png" alt="Image of a meme" /></p>
<p>Možné kroky pro vytvoření generátoru:</p>
<ol>
<li>Načtěte <a href="ulohy/../c/aplikovane_ulohy/tga.html">TGA obrázek</a> pozadí (např. <a href="ulohy/meme/meme_bg.tga">tento</a>), jehož cesta bude zadána na prvním řádku na vstupu
programu. Dále načtěte ze vstupu cestu k výstupnímu TGA obrázku, a počet řádků v horní a spodní části obrázku, do kterých
budete vypisovat text.</li>
<li>Načtěte obrázek pro každé písmeno anglické abecedy (obrázky jsou k dispozici <a href="ulohy/font.zip">zde</a>), a uložte si tato písmena
do pole. </li>
<li>Načtěte ze vstupu daný počet řádků textu a každý řádek vykrselete do načteného obrázku s pozadím. Pro vykreslení řádku
v cyklu projděte všechny znaky řádku, pro každý znak nalezněte TGA obrázek odpovídající danému znaku, a překopírujte jej
na odpovídající místo v obrázku s pozadím. Po vykreslení každého znaku se posuňte na vykreslované pozici doprava o šířku
vykresleného písmene, po vykreslení řádku se posuňte o výšku řádku níže.</li>
<li>Zapište výsledný meme obrázek na cestu zadanou na druhém řádku vstupu programu.</li>
</ol>
<p>Pokud chcete přidat do výsledku průhlednost, můžete pro vykreslování můžete využít tzv.
<a href="https://en.wikipedia.org/wiki/Alpha_compositing">alfa blending</a>. Při zápisu písmenka do pozadí můžete výslednou barvu
pixelu pro každou barevnou složku vypočítat následovně: 
$$ \text{RES} = \frac{\text{LETTER} \cdot \text{LETTER.ALFA} + \text{BG} \cdot (255 - \text{LETTER.ALFA})}{255} $$</p>
<h1><a class="header" href="#sdl-1" id="sdl-1">SDL</a></h1>
<p>Zkuste vytvořit nějakou animaci nebo jednoduchou hru pomocí knihovny <a href="ulohy/../c/aplikovane_ulohy/sdl.html">SDL</a>.</p>
<h2><a class="header" href="#tvorba-animace" id="tvorba-animace">Tvorba animace</a></h2>
<p>Pomocí knihovny pro práci s <a href="ulohy/../c/aplikovane_ulohy/gif.html">GIF animacemi</a> nebo pomocí <a href="ulohy/../c/aplikovane_ulohy/sdl.html">SDL</a> vytvořte nějakou
zajímavou animaci. Například se zkuste přiblížit této animaci z Matrixu:</p>
<p><img src="ulohy/../static/img/matrix-rain.gif" alt="" /></p>
<p>nebo můžete zkusit vytvořit animaci ohně z počítačové hry <a href="https://fabiensanglard.net/doom_fire_psx/">Doom</a>:</p>
<p><img src="ulohy/doom-fire.gif" alt="" /></p>
<h1><a class="header" href="#had" id="had">Had</a></h1>
<p>Zkuste vytvořit jednoduchý klon hry <a href="https://en.wikipedia.org/wiki/Snake_(video_game_genre)">Snake</a> pomocí
<a href="ulohy/snake/../../c/aplikovane_ulohy/sdl.html">SDL</a>.</p>
<p><a href="ulohy/snake/demo/a.html">Demo</a></p>
<ol>
<li>
<p>Vykreslete mřížku s políčky o rozměrech 32x32</p>
<ul>
<li>Nekreslete první dvě a poslední dvě políčka</li>
<li>Do struktury <code>Game</code> přidejte rozměry vnitřní mřížky</li>
<li>Presuňte vykreslování do vlastní funkce</li>
</ul>
<img src="ulohy/snake/grid.png" width="400px">
</li>
<li>
<p>Reprezentace a inicializace hada pomocí struktury <code>Snake</code></p>
<pre><code class="language-c">typedef struct {
   SDL_Point *parts; // pole souradnic clanku hada
   int tail; // index souradnice ocasu v poli parts
   int head; // index souradnice hlavy v poli parts
} Snake;
</code></pre>
<ul>
<li>
<p>pamatujeme si souřadnice (<code>SDL_Point</code>) všech aktivních článků hada v mřížce</p>
<ul>
<li>had může maximálně zabírat celou mřížku - alokace pole o velikosti ROWS x COLS</li>
<li>pamatujeme si index ocasu a index hlavy, které pak budeme posunovat pro pohyb</li>
</ul>
</li>
<li>
<p>vytvoříme hada o dvou článcích uprostřed mřížky</p>
<ul>
<li>uložíme souřadnici článku a inkrementujeme indexy hlavy</li>
<li>a ještě jednou pro ten druhý článek</li>
</ul>
<p><upr-snake></upr-snake></p>
</li>
</ul>
</li>
<li>
<p>Vykreslení hada</p>
<ul>
<li>projdeme všechny články od ocasu k hlavě a vykreslíme jako čtverce v mřížce</li>
<li>nastavíme si <code>i = tail</code></li>
<li>cyklus dokud <code>i</code> není index hlavy
<ul>
<li>vykreslíme čtverec se souřadnici <code>i</code> v mřížce</li>
<li>posuneme se na další článek
<ul>
<li>pokud jsme na konci pole, tak pokračujeme od začátku pole <code>parts</code> (modulo...)</li>
</ul>
</li>
</ul>
</li>
</ul>
<img src="ulohy/snake/init.png" width="300px">
</li>
<li>
<p>Pohyb hada</p>
<ul>
<li>pokud uběhlo 200 ms, tak pohnout hada o políčko</li>
<li>inkrementace indexu ocasu (opět s modulem)</li>
<li>výpočet nové hlavy jako <code>old_head + direction</code></li>
<li>uložení nové hlavy do pole parts na index hlavy</li>
<li>inkrementace indexu hlavy (opět s modulem)</li>
</ul>
</li>
<li>
<p>Pohyb pomocí šípek</p>
</li>
<li>
<p>Generování jablek</p>
<ul>
<li>vygenerovat náhodnou souřadnici jablka a vykreslovat jako čtverec</li>
<li>pokud se hlava dostane na pozici jablka, tak neposunovat index ocasu (dojde k zvětšeni hada)</li>
</ul>
</li>
<li>
<p>Při nárazu do stěny či do sebe vypsat konec hry se skórem</p>
</li>
<li>
<p>Vykreslení hada pomoci textur včetně záhybů</p>
<p>Textura obsahuje v mřížce políčka o velikosti 64x64. 
Jednotlivá políčka lze vybrat pomocí třetího parametru <code>srcrect</code> v <code>SDL_RenderCopy</code>.
Záhyb lze vybrat podle pozice předchozího a následujícího článku.</p>
<img src="https://rembound.com/files/creating-a-snake-game-tutorial-with-html5/snake-graphics.png" width="300px" />
</li>
</ol>
<h1><a class="header" href="#Časté-chyby" id="Časté-chyby">Časté chyby</a></h1>
<p>V této sekci naleznete často se vyskytující chyby, na které můžete narazit, spolu s návodem, jak je
vyřešit.</p>
<h3><a class="header" href="#záměna--a-" id="záměna--a-">Záměna <code>=</code> a <code>==</code></a></h3>
<ul>
<li>Operátor <code>=</code> <a href="caste_chyby/../c/promenne/promenne.html#z%C3%A1pis">přiřazuje</a> hodnotu do svého levého operandu a vyhodnotí se s
hodnotou pravého operandu.</li>
<li>Operátor <code>==</code> <a href="caste_chyby/../c/datove_typy/pravdivostni_typy.html#porovn%C3%A1v%C3%A1n%C3%AD-hodnot">porovnává</a> dvě hodnoty a vyhodnotí
se jako pravdivostní hodnota <code>bool</code>.</li>
</ul>
<p>Je důležité tyto operátory nezaměňovat! Oba dva operátory jsou výrazy, takže se v něco vyhodnotí a
i když je použijete špatně, tak často nedostanete chybovou hlášku, což jejich záměnu dělá ještě
nebezpečnější.</p>
<pre><code class="language-c">int a = 0;
a = 5; // nastaví hodnotu `5` do proměnné `a`
a == 5; // porovná `a` s hodnotou `5`, vrátí hodnotu `true`, ale nic se neprovede

// podmínka se provede, pokud se `a` rovná `5`
if (a == 5) {}

// podmínka se provede vždy, výraz `a = 5` se vyhodnotí na `5` (`true`)
// zároveň při provedení podmínky se přepíše hodnota proměnné `a` na `5`
if (a = 5) {}
</code></pre>
<h3><a class="header" href="#záměna--s--nebo--s-" id="záměna--s--nebo--s-">Záměna <code>&amp;</code> s <code>&amp;&amp;</code> nebo <code>|</code> s <code>||</code></a></h3>
<ul>
<li>Operátor <code>&amp;</code> provádí <a href="caste_chyby/../c/datove_typy/celociselne_typy.html#tabulka-aritmetick%C3%BDch-oper%C3%A1tor%C5%AF">bitový součin</a>,
očekává jako operandy celá čísla (např. <code>int</code>) a vrací celé číslo.</li>
<li>Operátor <code>&amp;&amp;</code> provádí <a href="caste_chyby/../c/datove_typy/pravdivostni_typy.html#tabulka-logick%C3%BDch-oper%C3%A1tor%C5%AF">logický součin</a>,
očekává jako operandy pravdivostní hodnoty (<code>bool</code>) a vrací pravdivostní hodnotu.</li>
</ul>
<p>Je důležité tyto operátory nezaměňovat. Jelikož <code>bool</code> lze implicitně převést na celé číslo a naopak,
záměna těchto operátorů opět typicky nepovede k chybě při překladu, nicméně program nejspíše při
jejich záměně nebude fungovat tak, jak má. Operátor <code>&amp;</code> má zároveň větší
<a href="https://en.cppreference.com/w/c/language/operator_precedence">přednost</a> než <code>&amp;&amp;</code>, takže se výraz
s tímto operátorem může vyhodnotit jinak, než očekáváte. Obdobná situace platí i u dvojice
operátorů <code>|</code> (bitový součet) a <code>||</code> (logický součet).</p>
<pre><code class="language-c">int a = 3;
a &amp; 4; // `0` 
a &amp;&amp; 4; // `true`

// stejné jako a &gt; (5 &amp; a) &lt; 6
if (a &gt; 5 &amp; a &lt; 6) {}
</code></pre>
<h3><a class="header" href="#použití-operátoru--pro-umocnění" id="použití-operátoru--pro-umocnění">Použití operátoru <code>^</code> pro umocnění</a></h3>
<p>Operátor <code>^</code> provádí v <em>C</em> bitovou operaci <a href="caste_chyby/../c/datove_typy/celociselne_typy.html#operace-s-%C4%8D%C3%ADseln%C3%BDmi-typy">XOR</a>,
nesnažte se jej tedy použít k výpočtu mocnin! Pro výpočet mocniny použijte funkci <a href="https://devdocs.io/c/numeric/math/pow"><code>pow</code></a>
(<em>power</em> je anglické označení pro mocninu).</p>
<pre><code class="language-c editable mainbody">#include &lt;stdio.h&gt;
#include &lt;math.h&gt;

int main() {
    int a = 5 ^ 2;
    printf(&quot;%d\n&quot;, a);

    int b = pow(5, 2);
    printf(&quot;%d\n&quot;, b);

    return 0;
}
</code></pre>
<h3><a class="header" href="#použití-neexistujících-negací-operátorů-porovnávání" id="použití-neexistujících-negací-operátorů-porovnávání">Použití neexistujících negací operátorů porovnávání</a></h3>
<p>Jediné existující operátory porovnávání v <em>C</em> jsou <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, <code>&gt;=</code>, <code>==</code> a <code>!=</code>.
Operátory jako <code>!&lt;</code>, <code>!&gt;</code>, <code>=&lt;</code> ani <code>=&gt;</code> v <em>C</em> neexistují! Negací operátoru <code>&lt;</code> je operátor <code>&gt;=</code> a negací operátoru
<code>&gt;</code> je operátor <code>&lt;=</code>.</p>
<h3><a class="header" href="#porovnávání-výrazu-s-více-hodnotami-najednou" id="porovnávání-výrazu-s-více-hodnotami-najednou">Porovnávání výrazu s více hodnotami najednou</a></h3>
<p>Pokud budete chtít zjistit, jestli např. nějaká proměnná je menší než jedna hodnota a zároveň větší
než jiná hodnota, musíte tyto dvě kontroly provést separátně a poté jejich výsledek spojit logickým
operátorem <code>&amp;&amp;</code>. Pokud použijete výraz jako např. <code>2 &lt; a &lt; 8</code>, tak se <code>2 &lt; a</code> vyhodnotí jako hodnota
typu <code>bool</code>, a poté se provede porovnání <code>true &lt; 8</code>, popřípadě <code>false &lt; 8</code>, což nejspíše není to, co
zamýšlíte.</p>
<pre><code class="language-c editable mainbody">#include &lt;stdio.h&gt;

int main() {
    int a = 100;

    // špatně
    if (2 &lt; a &lt; 8) {
        printf(&quot;A: a patri do intervalu (2, 8)\n&quot;);
    }

    // správně
    if (2 &lt; a &amp;&amp; a &lt; 8) {
        printf(&quot;B: a patri do intervalu (2, 8)\n&quot;);
    }

    return 0;
}
</code></pre>
<h3><a class="header" href="#středník-za-for-while-nebo-if" id="středník-za-for-while-nebo-if">Středník za <code>for</code>, <code>while</code> nebo <code>if</code></a></h3>
<p>Příkazy <code>for</code>, <code>while</code> nebo <code>if</code> za svou uzavírací závorkou <code>)</code> očekávají jeden příkaz:</p>
<pre><code class="language-c">if (a &gt; b) printf(&quot;%d&quot;, a);
</code></pre>
<p>nebo blok s příkazy:</p>
<pre><code class="language-c">if (a &gt; b) {
    printf(&quot;%d&quot;, a);
    ...
}
</code></pre>
<p>Pokud však za závorku dáte rovnou středník (<code>;</code>), tak to překladač pochopí jako prázdný příkaz, který
nic nedělá.</p>
<p>V následující ukázce se provede 10× prázdné tělo cyklu <code>for</code> a následně se jednou vypíše řetězec <code>&quot;Hello\n&quot;</code>.</p>
<pre><code class="language-c editable mainbody">#include &lt;stdio.h&gt;

int main() {
    for(int i = 0; i &lt; 10; i++); {
        printf(&quot;Hello\n&quot;);
    }
    return 0;
}
</code></pre>
<p>Zde opět středník za <code>if</code> reprezentuje prázdný příkaz, takže blok kódu s příkazem <code>printf</code> se provede
vždy, i když je tato podmínka nesplnitelná.</p>
<pre><code class="language-c editable mainbody">#include &lt;stdio.h&gt;

int main() {
    if(0); {
        printf(&quot;Hello\n&quot;);
    }

    return 0;
}
</code></pre>
<p>Je to ekvivalentní, jako byste napsali</p>
<pre><code class="language-c editable mainbody">#include &lt;stdio.h&gt;

int main() {
    if (0) { /* zde není co provést */ }

    // tento blok se provede vždy
    {
      printf(&quot;Hello\n&quot;);
    }

    return 0;
}
</code></pre>
<h3><a class="header" href="#Špatné-volání-funkce" id="Špatné-volání-funkce">Špatné volání funkce</a></h3>
<p>Abychom zavolali funkci (tj. řekli počítači, aby začal vykonávat kód, který v ní je), napíšeme
název funkce, závorky a do nich případně seznam argumentů. Při volání funkce už nezadáváme její
návratový typ, ten se udává pouze u definice funkce.</p>
<pre><code class="language-c">int secti(int a, int b) {
    return a + b;
}
int main() {
    secti(1, 2);        // správně
    int secti(1, 2);    // špatně

    return 0;
}
</code></pre>
<h3><a class="header" href="#záměna--s" id="záměna--s">Záměna <code>'</code> s <code>&quot;</code></a></h3>
<ul>
<li>Apostrof (<code>'</code>) slouží k zapsání (jednoho) <a href="caste_chyby/../c/text/znaky.html">znaku</a>. Neukládejte do něj více znaků či celý text.</li>
<li>Uvozovky (<code>&quot;</code>) slouží k zapsání <a href="caste_chyby/../c/text/text.html">řetězce</a>, tj. pole znaků ukončeného hodnotou <code>0</code>.</li>
</ul>
<pre><code class="language-c">char a = 'asd'; // špatně, více znaků v ''
char a = &quot;asd&quot;; // špatně, ukládáme řetězec do typu `char` (mělo by být `const char*`)

char a = 'x';               // správně
const char* str = &quot;hello&quot;;  // správně
</code></pre>
<h3><a class="header" href="#porovnávání-řetězců-pomocí-" id="porovnávání-řetězců-pomocí-">Porovnávání řetězců pomocí <code>==</code></a></h3>
<p>Řetězce jsou v jazyce <em>C</em> reprezentovány jako <a href="caste_chyby/../c/text/retezce.html">pole znaků</a>. Když pracujete
s řetězcem, tak máte obvykle k dispozici <a href="caste_chyby/../c/prace_s_pameti/ukazatele.html">ukazatel</a> na jeho první
<a href="caste_chyby/../c/text/znaky.html">znak</a>.</p>
<p>Pokud k porovnání dvou řetězců použijete operátor <code>==</code>, tak vlastně porovnáte akorát hodnotu dvou
ukazatelů. Pokud budou tyto ukazatele obsahovat stejnou adresu v paměti, tak bude výsledek pravdivý.
Ale dva řetězce se můžou rovnat i v případě, že leží na různých místech v paměti! Pro porovnání
dvou řetězců tak použijte funkci <a href="https://devdocs.io/c/string/byte/strcmp"><code>strcmp</code></a>.</p>
<pre><code class="language-c">#include &lt;string.h&gt;

void funkce(const char* a, const char* b) {
    if (a == b) { ... }             // špatně
    if (strcmp(a, b) == 0) { ... }  // správně
}
</code></pre>
<blockquote>
<p>Může vám přijít zvláštní, že pokud porovnáváte dva <a href="caste_chyby/../c/text/retezce.html#%C5%98et%C4%9Bzcov%C3%BD-liter%C3%A1l">řetězcové literály</a>,
tak porovnání dvou stejných řetězců pomocí <code>==</code> bude fungovat (vrátí pravdivou hodnotu). To je ale
dáno pouze tím, že překladač stejné řetězcové literály ukládá na stejné místo v paměti, takže mají
stejnou adresu a <code>==</code> zde bude fungovat. Pro porovnávání řetězců, které ale načtete např. z
terminálu nebo ze souboru, to však fungovat nebude, proto <code>==</code> nikdy pro porovnávání řetězců
nepoužívejte.</p>
</blockquote>
<h3><a class="header" href="#porovnávání-řetězce-načteného-funkcí-fgets" id="porovnávání-řetězce-načteného-funkcí-fgets">Porovnávání řetězce načteného funkcí <code>fgets</code></a></h3>
<p>Funkce <code>fgets</code> umí načíst <a href="caste_chyby/../c/text/vstup.html#na%C4%8Dten%C3%AD-%C5%99%C3%A1dku">řádek</a> ze vstupního souboru či ze
standardního vstupu. Pokud s takto načteným řádkem chcete dále pracovat, dejte si pozor na to, že
na konci tohoto řetězce může být znak odřádkování (<code>'\n'</code>)! Pokud tomu tak bude, tak nebude např.
fungovat přímé porovnání řádku s nějakým řetězcovým literálem:</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

int main() {
    char buffer[80];
    fgets(buffer, sizeof(buffer), stdin);

    // Pokud uživatel zadá v terminálu ahoj, tak v proměnné `buffer` bude
    // řetězec &quot;ahoj\n&quot;, takže toto porovnání nebude fungovat.
    if (strcmp(buffer, &quot;ahoj&quot;) == 0) {
        printf(&quot;Ahoj!\n&quot;);
    }

    return 0;
}
</code></pre>
<p>Pokud tedy chcete takto pracovat s načteným řádkem, nejprve byste se měli podívat, jestli nekončí
znakem odřádkování, a pokud ano, tak tento znak
<a href="caste_chyby/../c/text/retezce.html#k-%C4%8Demu-slou%C5%BE%C3%AD-nulov%C3%BD-znak-na-konci">odstranit</a>.</p>
<p>Znak odřádkování na konci řetězce být nemusí například pokud načtete poslední řádek ze souboru,
který není ukončen znakem odřádkování. Před změnou řetězce s načteným řádkem byste tak vždy měli
nejprve zkontrolovat, že se na jeho konci znak odřádkování opravdu nachází.</p>
<h3><a class="header" href="#Špatná-práce-s-ukazatelem" id="Špatná-práce-s-ukazatelem">Špatná práce s ukazatelem</a></h3>
<p><a href="caste_chyby/../c/prace_s_pameti/ukazatele.html">Ukazatele</a> jsou čísla, která interpretujeme jako
<a href="caste_chyby/../uvod/pamet.html">adresy v paměti</a>. Můžete s nimi sice provádět některé aritmetické operace
(například sčítání či odčítání), nicméně v takovém případě provádíte výpočet s adresou, ne s
hodnotou, která je na dané adrese uložena.</p>
<p>Například v této funkci, která by měla přičíst hodnotu <code>x</code> k paměti na adrese <code>ptr</code>, musíte
nejprve přistoupit k hodnotě na dané adrese (<code>*ptr</code>), a až k této hodnotě pak přičíst <code>x</code>:</p>
<pre><code class="language-c">void pricti_hodnotu(int* ptr, int x) {
    ptr += x;   // špatně, přičteme `x` k adrese `ptr`
    *ptr += x;  // správně, přičteme `x` k hodnotě na adrese `ptr` 
}
</code></pre>
<h3><a class="header" href="#vytváření-spousty-proměnných-místo-použití-pole" id="vytváření-spousty-proměnných-místo-použití-pole">Vytváření spousty proměnných místo použití pole</a></h3>
<p>Pokud potřebujete jednotně pracovat s větším počtem hodnot v paměti, použijte <a href="caste_chyby/../c/pole/pole.html">pole</a>.
Signálem, že jste měli použít pole, může být to, že máte ve funkci spoustu proměnných a pro rozlišení
každé proměnné musíte přidat nový řádek kódu:</p>
<pre><code class="language-c">for (a0 = 0, a1 = 0, a2 = 0, a3 = 0, a4 = 0, a5 = 0; i &lt; pocet; i++)
{
    if (hodnota == 1)
    {
        a0++;
    }
    else if (hodnota == 2)
    {
        a1++;
    }
    else if (hodnota == 3)
    {
        a2++;
    }
    ...
}
</code></pre>
<h3><a class="header" href="#použití-operátoru-sizeof-na-ukazatel" id="použití-operátoru-sizeof-na-ukazatel">Použití operátoru <code>sizeof</code> na ukazatel</a></h3>
<p>Operátor <code>sizeof</code> se často hodí ke zjištění velikosti pole. Pokud jej ovšem použijete na ukazatel
(i kdyby v daném ukazateli byla adresa pole!), tak vám vrátí pouze velikost ukazatele, tedy
pravděpodobně hodnotu <code>8</code> na 64-bitovém systému.</p>
<pre><code class="language-c">char pole[3];
char* ptr = pole;

sizeof(pole); // 3
sizeof(ptr);  // 8
</code></pre>
<p>Pozor na to, že pokud použijete datový typ pole pro parametr funkce, tak pro překladač se takový
parametr chová jako ukazatel! Pole se do funkcí vždy předávají jako adresa prvního prvku pole.</p>
<pre><code class="language-c">void print_size(char pole[3]) {
    sizeof(pole); // 8
}
</code></pre>
<p>Podobný problém může vzniknout i třeba při alokaci paměti. Například zde:</p>
<pre><code class="language-c">typedef struct {
    int vek;
    const char* jmeno;
} Osoba;

int main() {
    Osoba* osoby = (Osoba*) malloc(sizeof(Osoba*) * 5);

    return 0;
}
</code></pre>
<p>Dochází k alokaci paměti pro 5 ukazatelů na datový typ <code>Osoba</code>, místo alokace paměti pro pět hodnot typu <code>Osoba</code>!
Správné použití by bylo <code>malloc(sizeof(Osoba) * 5)</code>;</p>
<h3><a class="header" href="#undefined-reference-to-nazev" id="undefined-reference-to-nazev"><code>undefined reference to 'NAZEV'</code></a></h3>
<p>Snažíte se zavolat funkci <code>NAZEV</code>, která nebyla nalezena v žádném
<a href="caste_chyby/../c/modularizace/linker.html">objektovém souboru</a>, který jste předali pro překlad. Ověřte si, že
máte název volané funkce správně.</p>
<h1><a class="header" href="#paměťové-chyby" id="paměťové-chyby">Paměťové chyby</a></h1>
<p>V <em>C</em> lze s pamětí programu pracovat <a href="caste_chyby/../c/prace_s_pameti/dynamicka_pamet.html">manuálně</a>, což velmi často vede
k různým paměťovým chybám, které můžou způsobit špatné chování či pád programu. Jsou také
nejčastějším zdrojem různých
<a href="https://owasp.org/www-community/attacks/Buffer_overflow_attack">zranitelností</a>, které umožňují
útočníkům převzít kontrolu nad programem nebo celým počítačem.</p>
<p>Pro částečnou prevenci paměťových chyb silně doporučujeme při vývoji <em>C</em> programů používat
nástroj <a href="caste_chyby/../prostredi/ladeni.html#address-sanitizer">Address sanitizer</a>.</p>
<h2><a class="header" href="#stack-overflow" id="stack-overflow">Stack overflow</a></h2>
<p>Pokud bychom vytvořili v zásobníkovém rámci moc proměnných, proměnné, které jsou
<a href="caste_chyby/../c/pole/pole.html">moc velké</a>, anebo bychom měli v jednu chvíli aktivních moc zásobníkových rámců
(například při moc hluboké <a href="caste_chyby/../c/funkce/rekurze.html">rekurzi</a>), tak může dojít paměť určená pro zásobník.
Tato situce se nazývá <strong>přetečení zásobníku</strong> (<em>stack overflow</em>):</p>
<pre><code class="language-c">int funkce(int x) {
    return funkce(x + 1);
}
int main() {
    funkce(0);
    return 0;
}
</code></pre>
<h2><a class="header" href="#segmentation-fault" id="segmentation-fault">Segmentation fault</a></h2>
<p>Tato chyba je způsobena pokusem o zapsání nebo čtení neplatné adresy v paměti. K této chybě často
dochází zejména při těchto situacích:</p>
<ul>
<li>
<p>Zapísujeme nebo čteme z paměti pole mimo jeho rozsah (tj. &quot;před&quot; nebo &quot;za&quot; pamětí pole).
Tato situace se nazývá <a href="https://owasp.org/www-community/vulnerabilities/Buffer_Overflow"><em>buffer overflow</em></a>.
Tato chyba už způsobila nespočet bezpečnostních chyb v různých softwarech.</p>
<pre><code class="language-c">#include &lt;stdlib.h&gt;

int main() {
    int* p = (int*) malloc(sizeof(int));
    p[1] = 5;
    return 0;
}
</code></pre>
</li>
<li>
<p>Pokoušíme se přečíst hodnotu na adrese 0 (<code>NULL</code>), která je používána pro inicializaci
ukazatelů. Tato situace se nazývá
<a href="https://owasp.org/www-community/vulnerabilities/Null_Dereference"><em>null pointer dereference</em></a>.</p>
<pre><code class="language-c">int main() {
    int* p = (void*) 0;
    int a = *p;

    return 0;
}
</code></pre>
</li>
<li>
<p>Snažíme se přistoupit k paměti, která již byla <a href="caste_chyby/../c/prace_s_pameti/dynamicka_pamet.html#uvoln%C4%9Bn%C3%AD-pam%C4%9Bti">uvolněna</a>.
Tato situace se nazývá
<a href="https://owasp.org/www-community/vulnerabilities/Using_freed_memory"><em>use-after-free</em></a>.</p>
<pre><code class="language-c">#include &lt;stdlib.h&gt;

int main() {
    int* p = (int*) malloc(sizeof(int));
    free(p);

    *p = 1;
    return 0;
}
</code></pre>
<p>Přístup k již uvolněné paměti může nastat i bez použití
<a href="caste_chyby/../c/prace_s_pameti/dynamicka_pamet.html">dynamické paměti</a>. Například tento kód není správně:</p>
<pre><code class="language-c">#include &lt;stdlib.h&gt;

int* vrat_ukazatel(int x) {
    int y = x + 1;
    return &amp;y;
}

int main() {
    int* p = vrat_ukazatel(1);
    *p = 1;
    return 0;
}
</code></pre>
<p>Jakmile totiž vykonávání funkce <code>vrat_ukazatel</code> skončí, tak se
<a href="caste_chyby/../c/prace_s_pameti/automaticka_pamet.html">uvolní</a> paměť jejich lokálních proměnných. Adresa
uložená v <code>p</code> tak obsahuje nevalidní paměť a je chybou k ní přistupovat (ať už číst, tak
zapisovat).</p>
</li>
<li>
<p>Snažíme se uvolnit pamět, která již byla uvolněna. Tato situace se nazývá
<a href="https://owasp.org/www-community/vulnerabilities/Doubly_freeing_memory"><em>double free</em></a>.</p>
<pre><code class="language-c">#include &lt;stdlib.h&gt;

int main() {
    int* p = (int*) malloc(sizeof(int));
    free(p);
    free(p);
    return 0;
}
</code></pre>
</li>
</ul>
<blockquote>
<p>Zkuste si programy výše spustit nejprve bez Address sanitizeru a poté s ním. Dokázal sanitizer
detekovat některé z popsaných paměťových chyb?</p>
</blockquote>
<h2><a class="header" href="#memory-leak" id="memory-leak">Memory leak</a></h2>
<p>Pokud (opakovaně) alokujeme <a href="caste_chyby/../c/prace_s_pameti/dynamicka_pamet.html">dynamickou paměť</a> a neuvolňujeme ji, tak
dochází k tzv. <a href="https://owasp.org/www-community/vulnerabilities/Memory_leak"><em>memory leaku</em></a>
(úniku paměti). Pokud paměť programu stále roste a není nijak uvolňována, tak postupem času počítači
nutně dojde paměť a program tak bude násilně ukončen.</p>
<pre><code class="language-c">void leak() {
    // adresa alokované paměti je zahozena, nelze ji tedy uvolnit
    malloc(sizeof(int));
}
</code></pre>
<p>Tato chyba je celkem zákeřná, protože pokud paměť roste pomalu, tak může trvat dost dlouho, než
paměť programu dojde a vy se tak dozvíte o problému. K nalezení chyby doporučujeme opět použít Address
sanitizer, který na konci programu zkontroluje, jestli všechny dynamicky naalokované bloky byly
korektně uvolněny.</p>
<blockquote>
<p>Nemusíte se však bát, že by neuvolněná paměť ve vašem programu nějak narušovala chod operačního
systému. I když paměť manuálně neuvolníte, tak moderní operační systémy veškerou paměť vašeho
spuštěného programu uvolní, jakmile program skončí. Dokud však program běží, tak bude neuvolněná
paměť zabírat místo, což může způsobovat problémy.</p>
</blockquote>
<h1><a class="header" href="#galerie-projektů" id="galerie-projektů">Galerie projektů</a></h1>
<p>Zde naleznete vybrané projekty od studentů minulých ročníků <code>UPR</code>:</p>
<ul>
<li><a href="galerie_projektu/2020.html">Ročník 2020/2021</a></li>
<li><a href="galerie_projektu/2023.html">Ročník 2023/2024</a></li>
</ul>
<h1><a class="header" href="#galerie-projektů-20202021" id="galerie-projektů-20202021">Galerie projektů 2020/2021</a></h1>
<p>Galerie vybraných projektů od studentů z ročníku <code>2020/2021</code>.</p>
<h2><a class="header" href="#fruit-ninja" id="fruit-ninja">Fruit Ninja</a></h2>
<p><a href="galerie_projektu/../c/aplikovane_ulohy/sdl.html">SDL</a> + <a href="galerie_projektu/../c/aplikovane_ulohy/chipmunk.html">Chipmunk</a></p>
<p><video width="500" src="../static/projekty_2020/projekt1.webm" controls></video></p>
<h2><a class="header" href="#angry-birds" id="angry-birds">Angry Birds</a></h2>
<p><a href="galerie_projektu/../c/aplikovane_ulohy/sdl.html">SDL</a> + <a href="galerie_projektu/../c/aplikovane_ulohy/chipmunk.html">Chipmunk</a></p>
<p><video width="500" src="../static/projekty_2020/projekt2.webm" controls></video></p>
<h2><a class="header" href="#pacman" id="pacman">PacMan</a></h2>
<p><a href="galerie_projektu/../c/aplikovane_ulohy/sdl.html">SDL</a></p>
<p><video width="500" src="../static/projekty_2020/projekt3.webm" controls></video></p>
<h2><a class="header" href="#space-invaders" id="space-invaders">Space Invaders</a></h2>
<p><a href="galerie_projektu/../c/aplikovane_ulohy/sdl.html">SDL</a></p>
<p><video width="500" src="../static/projekty_2020/projekt4.webm" controls></video></p>
<h2><a class="header" href="#tetris" id="tetris">Tetris</a></h2>
<p><a href="galerie_projektu/../c/aplikovane_ulohy/sdl.html">SDL</a></p>
<p><video width="500" src="../static/projekty_2020/projekt5.webm" controls></video></p>
<p><video width="500" src="../static/projekty_2020/projekt6.webm" controls></video></p>
<h1><a class="header" href="#galerie-projektů-20232024" id="galerie-projektů-20232024">Galerie projektů 2023/2024</a></h1>
<p>Galerie vybraných projektů od studentů z ročníku <code>2023/2024</code>.</p>
<h2><a class="header" href="#breakout" id="breakout">Breakout</a></h2>
<p><a href="galerie_projektu/../c/aplikovane_ulohy/sdl.html">SDL</a></p>
<p><video width="500" src="../static/projekty_2023/projekt1.webm" controls></video></p>
<h2><a class="header" href="#bulánci" id="bulánci">Bulánci</a></h2>
<p><a href="galerie_projektu/../c/aplikovane_ulohy/sdl.html">SDL</a></p>
<p><video width="500" src="../static/projekty_2023/projekt2.webm" controls></video></p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        
        <!-- Google Analytics Tag -->
        <script type="text/javascript">
            var localAddrs = ["localhost", "127.0.0.1", ""];

            // make sure we don't activate google analytics if the developer is
            // inspecting the book locally...
            if (localAddrs.indexOf(document.location.hostname) === -1) {
                (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
                (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
                m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
                })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

                ga('create', 'UA-177556287-1', 'auto');
                ga('send', 'pageview');
            }
        </script>
        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        
        <script src="ace.js" type="text/javascript" charset="utf-8"></script>
        <script src="editor.js" type="text/javascript" charset="utf-8"></script>
        <script src="mode-rust.js" type="text/javascript" charset="utf-8"></script>
        <script src="theme-dawn.js" type="text/javascript" charset="utf-8"></script>
        <script src="theme-tomorrow_night.js" type="text/javascript" charset="utf-8"></script>
        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        
        <script type="text/javascript" src="theme/mode-c_cpp.min.js"></script>
        
        <script type="text/javascript" src="theme/asciinema-player.js"></script>
        
        <script type="text/javascript" src="src/wasm/xterm.min.js"></script>
        
        <script type="text/javascript" src="src/wasm/fit.min.js"></script>
        
        <script type="text/javascript" src="src/wasm/shared.js"></script>
        
        <script type="text/javascript" src="src/wasm/web.js"></script>
        
        <script type="text/javascript" src="src/static/animations/animations.js"></script>
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>
        
        

    </body>
</html>
