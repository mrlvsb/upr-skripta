<!DOCTYPE HTML>
<html lang="cs" class="sidebar-visible no-js rust">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Ãšvod do programovÃ¡nÃ­</title>
        
        <meta name="robots" content="noindex" />
        
        


        <!-- Custom HTML head -->
        <style>
.xterm {
  margin-top: 10px;
}
.content {
  overflow-y: visible !important;
}
video {
    max-width: 100%;
}
</style>
<script src="https://kelvin.cs.vsb.cz/upr/animations.js"></script>


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="favicon.svg">
        
        
        <link rel="shortcut icon" href="favicon.png">
        
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        
        <link rel="stylesheet" href="theme/css/tufte.css">
        
        <link rel="stylesheet" href="theme/asciinema-player.css">
        
        <link rel="stylesheet" href="src/wasm/xterm.min.css">
        

        
        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "rust" : "rust";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('rust')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item "><a href="uvod/uvod.html"><strong aria-hidden="true">1.</strong> Ãšvod</a><a class="toggle"><div>â±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="uvod/programovani.html"><strong aria-hidden="true">1.1.</strong> ProgramovÃ¡nÃ­</a></li><li class="chapter-item "><a href="uvod/programovaci_jazyky.html"><strong aria-hidden="true">1.2.</strong> ProgramovacÃ­ jazyky</a></li><li class="chapter-item "><a href="uvod/jazyk_c.html"><strong aria-hidden="true">1.3.</strong> Jazyk C</a></li><li class="chapter-item "><a href="uvod/pamet.html"><strong aria-hidden="true">1.4.</strong> PamÄ›Å¥</a></li></ol></li><li class="chapter-item "><a href="prostredi/nastaveni_prostredi.html"><strong aria-hidden="true">2.</strong> NastavenÃ­ prostÅ™edÃ­</a><a class="toggle"><div>â±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="prostredi/linux/linux.html"><strong aria-hidden="true">2.1.</strong> Linux</a><a class="toggle"><div>â±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="prostredi/linux/instalace.html"><strong aria-hidden="true">2.1.1.</strong> Instalace</a></li></ol></li><li class="chapter-item "><a href="prostredi/editor.html"><strong aria-hidden="true">2.2.</strong> Editor</a></li><li class="chapter-item "><a href="prostredi/preklad_programu.html"><strong aria-hidden="true">2.3.</strong> PÅ™eklad</a></li><li class="chapter-item "><a href="prostredi/ladeni.html"><strong aria-hidden="true">2.4.</strong> LadÄ›nÃ­</a></li></ol></li><li class="chapter-item "><a href="c/programovani.html"><strong aria-hidden="true">3.</strong> ProgramovÃ¡nÃ­ v C</a><a class="toggle"><div>â±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="c/syntaxe.html"><strong aria-hidden="true">3.1.</strong> Syntaxe</a></li><li class="chapter-item "><a href="c/prikazy_vyrazy.html"><strong aria-hidden="true">3.2.</strong> PÅ™Ã­kazy a vÃ½razy</a></li><li class="chapter-item "><a href="c/promenne/promenne.html"><strong aria-hidden="true">3.3.</strong> PromÄ›nnÃ©</a><a class="toggle"><div>â±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="c/promenne/globalni_promenne.html"><strong aria-hidden="true">3.3.1.</strong> GlobÃ¡lnÃ­ promÄ›nnÃ©</a></li><li class="chapter-item "><a href="c/promenne/konstanty.html"><strong aria-hidden="true">3.3.2.</strong> Konstanty</a></li><li class="chapter-item "><a href="c/promenne/slozeny_zapis.html"><strong aria-hidden="true">3.3.3.</strong> SloÅ¾enÃ½ zÃ¡pis</a></li><li class="chapter-item "><a href="c/promenne/pojmenovavani.html"><strong aria-hidden="true">3.3.4.</strong> PojmenovÃ¡vÃ¡nÃ­ promÄ›nnÃ½ch</a></li></ol></li><li class="chapter-item "><a href="c/datove_typy/datove_typy.html"><strong aria-hidden="true">3.4.</strong> DatovÃ© typy</a><a class="toggle"><div>â±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="c/datove_typy/celociselne_typy.html"><strong aria-hidden="true">3.4.1.</strong> CeloÄÃ­selnÃ© typy</a></li><li class="chapter-item "><a href="c/datove_typy/desetinne_typy.html"><strong aria-hidden="true">3.4.2.</strong> DesetinnÃ© ÄÃ­selnÃ© typy</a></li><li class="chapter-item "><a href="c/datove_typy/pravdivostni_typy.html"><strong aria-hidden="true">3.4.3.</strong> PravdivostnÃ­ typy</a></li><li class="chapter-item "><a href="c/datove_typy/konverze.html"><strong aria-hidden="true">3.4.4.</strong> Konverze</a></li></ol></li><li class="chapter-item "><a href="c/rizeni_toku/rizeni_toku.html"><strong aria-hidden="true">3.5.</strong> Å˜Ã­zenÃ­ toku</a><a class="toggle"><div>â±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="c/rizeni_toku/podminky.html"><strong aria-hidden="true">3.5.1.</strong> PodmÃ­nky</a><a class="toggle"><div>â±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="c/rizeni_toku/if.html"><strong aria-hidden="true">3.5.1.1.</strong> PÅ™Ã­kaz if</a></li><li class="chapter-item "><a href="c/rizeni_toku/switch.html"><strong aria-hidden="true">3.5.1.2.</strong> PÅ™Ã­kaz switch</a></li><li class="chapter-item "><a href="c/rizeni_toku/ternarni_operator.html"><strong aria-hidden="true">3.5.1.3.</strong> TernÃ¡rnÃ­ operÃ¡tor</a></li></ol></li><li class="chapter-item "><a href="c/rizeni_toku/cykly.html"><strong aria-hidden="true">3.5.2.</strong> Cykly</a><a class="toggle"><div>â±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="c/rizeni_toku/while.html"><strong aria-hidden="true">3.5.2.1.</strong> Cyklus while</a></li><li class="chapter-item "><a href="c/rizeni_toku/for.html"><strong aria-hidden="true">3.5.2.2.</strong> Cyklus for</a></li></ol></li></ol></li><li class="chapter-item "><a href="c/funkce/funkce.html"><strong aria-hidden="true">3.6.</strong> Funkce</a><a class="toggle"><div>â±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="c/funkce/rekurze.html"><strong aria-hidden="true">3.6.1.</strong> Rekurze</a></li><li class="chapter-item "><a href="c/funkce/stdlib.html"><strong aria-hidden="true">3.6.2.</strong> Funkce standardnÃ­ knihovny</a></li></ol></li><li class="chapter-item "><a href="c/preprocesor/preprocesor.html"><strong aria-hidden="true">3.7.</strong> Preprocesor</a><a class="toggle"><div>â±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="c/preprocesor/vkladani_souboru.html"><strong aria-hidden="true">3.7.1.</strong> VklÃ¡dÃ¡nÃ­ souborÅ¯</a></li><li class="chapter-item "><a href="c/preprocesor/makra.html"><strong aria-hidden="true">3.7.2.</strong> Makra</a></li></ol></li><li class="chapter-item "><a href="c/prace_s_pameti/prace_s_pameti.html"><strong aria-hidden="true">3.8.</strong> PrÃ¡ce s pamÄ›tÃ­</a><a class="toggle"><div>â±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="c/prace_s_pameti/automaticka_pamet.html"><strong aria-hidden="true">3.8.1.</strong> AutomatickÃ¡ pamÄ›Å¥</a></li><li class="chapter-item "><a href="c/prace_s_pameti/ukazatele.html"><strong aria-hidden="true">3.8.2.</strong> Ukazatele</a><a class="toggle"><div>â±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="c/prace_s_pameti/ukazatele_na_funkce.html"><strong aria-hidden="true">3.8.2.1.</strong> Ukazatele na funkce</a></li></ol></li><li class="chapter-item "><a href="c/prace_s_pameti/dynamicka_pamet.html"><strong aria-hidden="true">3.8.3.</strong> DynamickÃ¡ pamÄ›Å¥</a></li><li class="chapter-item "><a href="c/prace_s_pameti/globalni_pamet.html"><strong aria-hidden="true">3.8.4.</strong> GlobÃ¡lnÃ­ pamÄ›Å¥</a></li></ol></li><li class="chapter-item "><a href="c/pole/pole.html"><strong aria-hidden="true">3.9.</strong> Pole</a><a class="toggle"><div>â±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="c/pole/staticka_pole.html"><strong aria-hidden="true">3.9.1.</strong> StatickÃ© pole</a></li><li class="chapter-item "><a href="c/pole/dynamicka_pole.html"><strong aria-hidden="true">3.9.2.</strong> DynamickÃ© pole</a></li><li class="chapter-item "><a href="c/pole/vicerozmerna_pole.html"><strong aria-hidden="true">3.9.3.</strong> VÃ­cerozmÄ›rnÃ© pole</a><a class="toggle"><div>â±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="c/pole/zubata_pole.html"><strong aria-hidden="true">3.9.3.1.</strong> ZubatÃ¡ pole</a></li></ol></li></ol></li><li class="chapter-item "><a href="c/text/text.html"><strong aria-hidden="true">3.10.</strong> Text</a><a class="toggle"><div>â±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="c/text/znaky.html"><strong aria-hidden="true">3.10.1.</strong> Znaky</a></li><li class="chapter-item "><a href="c/text/retezce.html"><strong aria-hidden="true">3.10.2.</strong> Å˜etÄ›zce</a></li><li class="chapter-item "><a href="c/text/vstupavystup.html"><strong aria-hidden="true">3.10.3.</strong> Vstup a vÃ½stup</a><a class="toggle"><div>â±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="c/text/vstup.html"><strong aria-hidden="true">3.10.3.1.</strong> Vstup</a></li><li class="chapter-item "><a href="c/text/vystup.html"><strong aria-hidden="true">3.10.3.2.</strong> VÃ½stup</a></li></ol></li></ol></li><li class="chapter-item "><a href="c/struktury/vlastni_datove_typy.html"><strong aria-hidden="true">3.11.</strong> VlastnÃ­ datovÃ© typy</a><a class="toggle"><div>â±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="c/struktury/struktury.html"><strong aria-hidden="true">3.11.1.</strong> Struktury</a><a class="toggle"><div>â±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="c/struktury/pametova_reprezentace.html"><strong aria-hidden="true">3.11.1.1.</strong> Reprezentace v pamÄ›ti</a></li></ol></li><li class="chapter-item "><a href="c/struktury/struktury_funkce.html"><strong aria-hidden="true">3.11.2.</strong> Struktury a funkce</a></li></ol></li><li class="chapter-item "><a href="c/soubory/soubory.html"><strong aria-hidden="true">3.12.</strong> Soubory</a><a class="toggle"><div>â±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="c/soubory/otevirani_souboru.html"><strong aria-hidden="true">3.12.1.</strong> OtevÅ™enÃ­ souborÅ¯</a></li><li class="chapter-item "><a href="c/soubory/prace_se_soubory.html"><strong aria-hidden="true">3.12.2.</strong> PrÃ¡ce se soubory</a><a class="toggle"><div>â±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="c/soubory/zapis_do_souboru.html"><strong aria-hidden="true">3.12.2.1.</strong> ZÃ¡pis do souboru</a></li><li class="chapter-item "><a href="c/soubory/cteni_ze_souboru.html"><strong aria-hidden="true">3.12.2.2.</strong> ÄŒtenÃ­ ze souboru</a></li></ol></li></ol></li><li class="chapter-item "><a href="c/modularizace/modularizace.html"><strong aria-hidden="true">3.13.</strong> Modularizace</a><a class="toggle"><div>â±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="c/modularizace/linker.html"><strong aria-hidden="true">3.13.1.</strong> Linker</a></li><li class="chapter-item "><a href="c/modularizace/pouzivani_kodu_z_jinych_souboru.html"><strong aria-hidden="true">3.13.2.</strong> PouÅ¾Ã­vÃ¡nÃ­ kÃ³du z jinÃ½ch souborÅ¯</a></li><li class="chapter-item "><a href="c/modularizace/hlavickove_soubory.html"><strong aria-hidden="true">3.13.3.</strong> HlaviÄkovÃ© soubory</a></li><li class="chapter-item "><a href="c/modularizace/knihovny.html"><strong aria-hidden="true">3.13.4.</strong> Knihovny</a></li></ol></li><li class="chapter-item "><a href="c/automatizace_prekladu.html"><strong aria-hidden="true">3.14.</strong> Automatizace pÅ™ekladu</a></li><li class="chapter-item "><a href="c/aplikovane_ulohy/ulohy.html"><strong aria-hidden="true">3.15.</strong> AplikovanÃ© Ãºlohy</a><a class="toggle"><div>â±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="c/aplikovane_ulohy/tga.html"><strong aria-hidden="true">3.15.1.</strong> TGA</a></li><li class="chapter-item "><a href="c/aplikovane_ulohy/gif.html"><strong aria-hidden="true">3.15.2.</strong> GIF</a></li><li class="chapter-item "><a href="c/aplikovane_ulohy/sdl.html"><strong aria-hidden="true">3.15.3.</strong> SDL</a><a class="toggle"><div>â±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="c/aplikovane_ulohy/sdl/herni_smycka.html"><strong aria-hidden="true">3.15.3.1.</strong> HernÃ­ smyÄka</a></li><li class="chapter-item "><a href="c/aplikovane_ulohy/sdl/kresleni.html"><strong aria-hidden="true">3.15.3.2.</strong> KreslenÃ­</a></li><li class="chapter-item "><a href="c/aplikovane_ulohy/sdl/vstup.html"><strong aria-hidden="true">3.15.3.3.</strong> Vstup</a></li></ol></li><li class="chapter-item "><a href="c/aplikovane_ulohy/chipmunk.html"><strong aria-hidden="true">3.15.4.</strong> Chipmunk</a></li></ol></li><li class="chapter-item "><a href="c/co_dal.html"><strong aria-hidden="true">3.16.</strong> Co dÃ¡l?</a></li></ol></li><li class="chapter-item "><a href="ruzne/ruzne.html"><strong aria-hidden="true">4.</strong> RÅ¯znÃ©</a><a class="toggle"><div>â±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="ruzne/rozklad_problemu.html"><strong aria-hidden="true">4.1.</strong> Rozklad problÃ©mu</a></li><li class="chapter-item "><a href="ruzne/vyhodnocovani_vyrazu.html"><strong aria-hidden="true">4.2.</strong> VyhodnocovÃ¡nÃ­ vÃ½razÅ¯</a></li><li class="chapter-item "><a href="ruzne/nahodna_cisla.html"><strong aria-hidden="true">4.3.</strong> GenerovÃ¡nÃ­ nÃ¡hodnÃ½ch ÄÃ­sel</a></li><li class="chapter-item "><a href="ruzne/dynamicky_rostouci_pole.html"><strong aria-hidden="true">4.4.</strong> Dynamicky rostoucÃ­ pole</a></li><li class="chapter-item "><a href="ruzne/funkce_main.html"><strong aria-hidden="true">4.5.</strong> Funkce main</a></li><li class="chapter-item "><a href="ruzne/parametry_prekladace.html"><strong aria-hidden="true">4.6.</strong> Parametry pÅ™ekladaÄe</a></li><li class="chapter-item "><a href="ruzne/nedefinovane_chovani.html"><strong aria-hidden="true">4.7.</strong> NedefinovanÃ© chovÃ¡nÃ­</a></li><li class="chapter-item "><a href="ruzne/tahak.html"><strong aria-hidden="true">4.8.</strong> TahÃ¡k</a></li></ol></li><li class="chapter-item "><a href="ulohy/ulohy.html"><strong aria-hidden="true">5.</strong> Ãšlohy</a><a class="toggle"><div>â±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="ulohy/promenne.html"><strong aria-hidden="true">5.1.</strong> PromÄ›nnÃ©</a></li><li class="chapter-item "><a href="ulohy/podminky_a_cykly.html"><strong aria-hidden="true">5.2.</strong> PodmÃ­nky a cykly</a><a class="toggle"><div>â±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="ulohy/kulicka.html"><strong aria-hidden="true">5.2.1.</strong> OdrÃ¡Å¾ejÃ­cÃ­ se kuliÄka</a></li><li class="chapter-item "><a href="ulohy/grafy.html"><strong aria-hidden="true">5.2.2.</strong> VykreslovÃ¡nÃ­ grafÅ¯ funkcÃ­</a></li></ol></li><li class="chapter-item "><a href="ulohy/funkce.html"><strong aria-hidden="true">5.3.</strong> Funkce</a></li><li class="chapter-item "><a href="ulohy/ukazatele.html"><strong aria-hidden="true">5.4.</strong> Ukazatele</a></li><li class="chapter-item "><a href="ulohy/pole.html"><strong aria-hidden="true">5.5.</strong> Pole</a><a class="toggle"><div>â±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="ulohy/pvp.html"><strong aria-hidden="true">5.5.1.</strong> PvP bitevnÃ­ hra</a></li><li class="chapter-item "><a href="ulohy/dvourozmerne_pole.html"><strong aria-hidden="true">5.5.2.</strong> DvourozmÄ›rnÃ© pole</a><a class="toggle"><div>â±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="ulohy/digitalni_hodiny.html"><strong aria-hidden="true">5.5.2.1.</strong> DigitÃ¡lnÃ­ hodiny</a></li></ol></li></ol></li><li class="chapter-item "><a href="ulohy/text.html"><strong aria-hidden="true">5.6.</strong> Text</a><a class="toggle"><div>â±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="ulohy/kalkulacka.html"><strong aria-hidden="true">5.6.1.</strong> KalkulaÄka</a></li><li class="chapter-item "><a href="ulohy/strelba_na_terc.html"><strong aria-hidden="true">5.6.2.</strong> StÅ™elba na terÄ</a></li><li class="chapter-item "><a href="ulohy/cisteni_chatu.html"><strong aria-hidden="true">5.6.3.</strong> ÄŒiÅ¡tÄ›nÃ­ chatu</a></li><li class="chapter-item "><a href="ulohy/brainfuck.html"><strong aria-hidden="true">5.6.4.</strong> PÅ™ekladaÄ jazyka Brainfuck</a></li></ol></li><li class="chapter-item "><a href="ulohy/struktury.html"><strong aria-hidden="true">5.7.</strong> Struktury</a><a class="toggle"><div>â±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="ulohy/tga_watch.html"><strong aria-hidden="true">5.7.1.</strong> TGA hodiny</a></li><li class="chapter-item "><a href="ulohy/letters.html"><strong aria-hidden="true">5.7.2.</strong> LÃ©tajÃ­cÃ­ pÃ­smenka</a></li></ol></li><li class="chapter-item "><a href="ulohy/soubory.html"><strong aria-hidden="true">5.8.</strong> Soubory</a><a class="toggle"><div>â±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="ulohy/meme.html"><strong aria-hidden="true">5.8.1.</strong> Meme generÃ¡tor</a></li></ol></li><li class="chapter-item "><a href="ulohy/sdl.html"><strong aria-hidden="true">5.9.</strong> SDL</a><a class="toggle"><div>â±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="ulohy/snake/snake.html"><strong aria-hidden="true">5.9.1.</strong> Had</a></li></ol></li></ol></li><li class="chapter-item "><a href="caste_chyby/caste_chyby.html"><strong aria-hidden="true">6.</strong> ÄŒastÃ© chyby</a><a class="toggle"><div>â±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="caste_chyby/pametove_chyby.html"><strong aria-hidden="true">6.1.</strong> PamÄ›Å¥ovÃ© chyby</a></li></ol></li><li class="chapter-item "><a href="galerie_projektu/galerie_projektu.html"><strong aria-hidden="true">7.</strong> Galerie projektÅ¯</a><a class="toggle"><div>â±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="galerie_projektu/2020.html"><strong aria-hidden="true">7.1.</strong> 2020/2021</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">Ãšvod do programovÃ¡nÃ­</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        <a href="https://github.com/mrlvsb/upr-skripta" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#Ãšvod" id="Ãšvod">Ãšvod</a></h1>
<p>Tento text vznikl pro potÅ™eby vÃ½uky pÅ™edmÄ›tu <a href="https://github.com/geordi/upr-course">Ãšvod do programovÃ¡nÃ­</a> na FEI VÅ B-TUO.
SlouÅ¾Ã­ k zÃ­skÃ¡nÃ­ pÅ™ehledu o zÃ¡kladnÃ­ch konceptech programovacÃ­ho jazyka C.
NenÃ­ vÅ¡ak plnohodnotnou nÃ¡hradou za poslechy pÅ™ednÃ¡Å¡ek a nÃ¡vÅ¡tÄ›vy cviÄenÃ­ a programovat vÃ¡s (stejnÄ›
jako Å¾Ã¡dnÃ½ jinÃ½ text) nenauÄÃ­, toho lze dosÃ¡hnout pouze opakovanÃ½m zkouÅ¡enÃ­m a Å™eÅ¡enÃ­m rÅ¯znÃ½ch Ãºloh.
StudentÅ¯m tedy silnÄ› doporuÄujeme, aby pÅ™ednÃ¡Å¡ky a cviÄenÃ­ navÅ¡tÄ›vovali a hlavnÄ› aby se vÄ›novali programovÃ¡nÃ­
doma, alespoÅˆ hodinu dennÄ›.</p>
<p>V tomto textu naleznete struÄnÃ½ Ãºvod o programovÃ¡nÃ­, pÅ™ekladu a ladÄ›nÃ­ programÅ¯, nastavenÃ­ prostÅ™edÃ­
k editaci zdrojovÃ©ho kÃ³du, a zejmÃ©na popis zÃ¡kladnÃ­ch konstrukcÃ­ jazyka <em>C</em> (promÄ›nnÃ©, podmÃ­nky,
cykly, funkce, ukazatele, pole, Å™etÄ›zce, struktury atd.) spolu se sadou Ãºloh k procviÄenÃ­ jednotlivÃ½ch
tÃ©mat. PomocÃ­ ikony <i class="fa fa-search"></i> vlevo nahoÅ™e mÅ¯Å¾ete v textu rychle vyhledÃ¡vat, pokud
potÅ™ebujete najÃ­t informace o konkrÃ©tnÃ­m tÃ©matu.</p>
<p>NÄ›kolik poznÃ¡mek k textu:</p>
<ul>
<li>Tento text neslouÅ¾Ã­ jako kompletnÃ­ prÅ¯vodce jazyka C. Pro takovÃ½to ÃºÄel lze doporuÄit nÄ›kterÃ½
kniÅ¾nÃ­ titul, napÅ™. UÄebnice jazyka <em>C</em> od Pavla Herouta nebo pÅ™Ã­mo standard jazyka <a href="http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1256.pdf">C99</a>.</li>
<li>JelikoÅ¾ je pÅ™edmÄ›t UPR zamÄ›Å™en na vÃ½voj v operaÄnÃ­m systÃ©mu Linux, tak ukÃ¡zky kÃ³du a pÅ™Ã­kazÅ¯ v terminÃ¡lu
pÅ™edpoklÃ¡dajÃ­ pouÅ¾itÃ­ tohoto operaÄnÃ­ho systÃ©mu (konkrÃ©tnÄ› distribuce <code>Ubuntu</code>).</li>
<li>Tento text je psÃ¡n Äesky, nicmÃ©nÄ› primÃ¡rnÃ­m jazykem programovÃ¡nÃ­ (celosvÄ›tovÄ›) je angliÄtina. PÅ™eloÅ¾enÃ© pojmy,
kterÃ© majÃ­ zavedenÃ© anglickÃ© nÃ¡zvy, budou v tomto textu uvedeny v zÃ¡vorce <em>kurzÃ­vou</em>.</li>
<li>V tomto textu naleznete rÅ¯znÃ© ukÃ¡zky <em>C</em> kÃ³du. NÄ›kterÃ© z nich mÅ¯Å¾ete sami upravovat a dokonce
i spustit rovnou v prohlÃ­Å¾eÄi pomocÃ­ ikony <i class="fa fa-play"></i> v pravÃ©m hornÃ­m rohu kÃ³du.
UkÃ¡zky budou pro zjednoduÅ¡enÃ­ pouÅ¾Ã­vat nÃ¡zvy v ÄeÅ¡tinÄ›, nicmÃ©nÄ› jakmile uÅ¾ nebudete v
programovÃ¡nÃ­ ÃºplnÃ­ novÃ¡Äci, silnÄ› vÃ¡m doporuÄujeme psÃ¡t zdrojovÃ© kÃ³dy v angliÄtinÄ›.</li>
<li>Pokud v textu naleznete gramatickou Äi faktickou chybu nebo budete mÃ­t jakoukoliv zpÄ›tnou vazbu
k obsahu Äi formÄ› textu, dejte nÃ¡m prosÃ­m vÄ›dÄ›t na <a href="mailto:jakub.beranek@vsb.cz?subject=UPR%20skripta%20-%20chyba">tento e-mail</a>
nebo vytvoÅ™te issue na <a href="https://github.com/mrlvsb/upr-skripta/issues/new">GitHubu</a>.</li>
</ul>
<p>Autory textu jsou <a href="https://github.com/geordi">Jan Gaura</a>, <a href="https://github.com/trnila">Dan Trnka</a> a
<a href="https://github.com/kobzol">Kuba BerÃ¡nek</a>.</p>
<p><em>Historii zmÄ›n</em> tohoto studijnÃ­ho textu mÅ¯Å¾ete naleznout v jeho
<a href="https://github.com/mrlvsb/upr-skripta/commits/master">GitHub repozitÃ¡Å™i</a>.</p>
<h1><a class="header" href="#programovÃ¡nÃ­" id="programovÃ¡nÃ­">ProgramovÃ¡nÃ­</a></h1>
<p>ProgramovÃ¡nÃ­ je proces tvorby programu, tj. sady pÅ™Ã­kazÅ¯ pro poÄÃ­taÄ, kterÃ½ slouÅ¾Ã­ k vyÅ™eÅ¡enÃ­
nÄ›jakÃ©ho konkrÃ©tnÃ­ho <strong>problÃ©mu</strong>. ProblÃ©mem se zde myslÃ­ nÄ›jakÃ¡ Ãºloha, kterou chceme vyÅ™eÅ¡it.
TakovÃ©to Ãºlohy obsahujÃ­ nÄ›jakÃ½ (poÄÃ­taÄem zpracovatelnÃ½) vstup, napÅ™Ã­klad:</p>
<ul>
<li>pohyb myÅ¡i</li>
<li>stisk klÃ¡vesy</li>
<li>zvuk z mikrofonu</li>
<li>textovÃ½ soubor na disku</li>
</ul>
<p>a k nim urÄenÃ½ vÃ½stup, napÅ™Ã­klad:</p>
<ul>
<li>vykreslenÃ­ obrazce Äi textu na monitoru</li>
<li>zapsÃ¡nÃ­ dat do souboru na disku</li>
<li>odeslÃ¡nÃ­ informacÃ­ pÅ™es sÃ­Å¥</li>
</ul>
<p>Aby poÄÃ­taÄovÃ½ program korektnÄ› Å™eÅ¡il nÄ›jakou Ãºlohu, tak musÃ­ na vÅ¡echny validnÃ­ vstupy vrÃ¡tit
sprÃ¡vnÃ½ vÃ½stup. Pokud vstup neodpovÃ­dÃ¡ zadÃ¡nÃ­, tak by mÄ›l program vrÃ¡tit rozumnou chybovou hlÃ¡Å¡ku.
Postup pro Å™eÅ¡enÃ­ nÄ›jakÃ© Ãºlohy danÃ½ jasnÄ› definovanÃ½mi kroky se nazÃ½vÃ¡ <strong>algoritmus</strong>. ZÃ¡pisu
(algoritmu) v nÄ›jakÃ©m konkrÃ©tnÃ­m programovacÃ­m jazyce se pak Å™Ã­kÃ¡ <strong>implementace</strong> (algoritmu).</p>
<p>Zde je pÅ™Ã­klad Ãºloh, kterÃ© se bÄ›hem semestru nauÄÃ­te Å™eÅ¡it pomocÃ­ jazyka <em>C</em>:</p>
<ul>
<li>SpoÄÃ­tej prÅ¯mÄ›r seznamu ÄÃ­sel</li>
<li>NaÄti Ãºdaje o uÅ¾ivateli ze souboru a vypiÅ¡ je v podobÄ› tabulky</li>
<li>NaÄti obrÃ¡zek z disku, zmÄ›Åˆ jeho velikost a uloÅ¾ ho do jinÃ©ho souboru</li>
<li>VytvoÅ™ animaci ze sady obrÃ¡zkÅ¯ na disku</li>
</ul>
<p>Å˜eÅ¡enÃ­m podobnÃ½ch Ãºloh si osvojÃ­te zÃ¡klady programovÃ¡nÃ­ a budete potÃ© moct Å™eÅ¡it zajÃ­mavÄ›jÅ¡Ã­ Ãºlohy,
jako je napÅ™Ã­klad tvorba poÄÃ­taÄovÃ© hry nebo aplikace komunikujÃ­cÃ­ pÅ™es internet.</p>
<h1><a class="header" href="#programovacÃ­-jazyky" id="programovacÃ­-jazyky">ProgramovacÃ­ jazyky</a></h1>
<p>Z pohledu poÄÃ­taÄe je program sekvence pÅ™Ã­kazÅ¯ (nazÃ½vanÃ½ch <strong>instrukce</strong>), kterÃ© mÅ¯Å¾e poÄÃ­taÄ
vykonat k vyÅ™eÅ¡enÃ­ nÄ›jakÃ©ho problÃ©mu. Abychom mohli poÄÃ­taÄi Å™Ã­ct, co mÃ¡ vykonÃ¡vat, potÅ™ebujeme mu
pÅ™Ã­kazy zadat ve formÄ›, kterÃ© bude rozumÄ›t. AÄ se to moÅ¾nÃ¡ nezdÃ¡, tak poÄÃ­taÄe umÃ­ vykonÃ¡vat pouze
velmi jednoduchÃ© pÅ™Ã­kazy. V podstatÄ› umÃ­ pouze provÃ¡dÄ›t aritmetickÃ© a logickÃ© operace (sÄÃ­tÃ¡nÃ­,
odÄÃ­tÃ¡nÃ­, nÃ¡sobenÃ­) s ÄÃ­sly a manipulovat (ÄÃ­st, zapisovat, pÅ™esouvat) s tÄ›mito ÄÃ­sly v pamÄ›ti.</p>
<p>VeÅ¡kerÃ© sloÅ¾itÄ›jÅ¡Ã­ Ãºkoly, jako tÅ™eba vykreslenÃ­ obrÃ¡zku na obrazovku, zapsÃ¡nÃ­ textu do dokumentu
nebo simulace svÄ›ta v poÄÃ­taÄovÃ© hÅ™e je vÃ½sledkem kombinacÃ­ tisÃ­cÅ¯ Äi milionÅ¯ takovÃ½chto
jednoduchÃ½ch instrukcÃ­.</p>
<p>Zde je ukÃ¡zka jednoduchÃ©ho programu, kterÃ½ zdvojnÃ¡sobÃ­ ÄÃ­slo <code>8</code> pomocÃ­ pÅ™Ã­kazÅ¯ <code>MOV</code> a <code>ADD</code>:</p>
<pre><code class="language-x86asm">MOV EAX, 8
ADD EAX, EAX
</code></pre>
<p>Pokud bychom programy psali pouze pomocÃ­ tÄ›chto jednoduchÃ½ch pÅ™Ã­kazÅ¯<sup class='margin-toggle sidenote-number'>1</sup>, tak by bylo sloÅ¾itÃ© se v
nich vyznat, obzvlÃ¡Å¡tÄ›, pokud by obsahovaly stovky, tisÃ­ce nebo dokonce miliony takovÃ½chto pÅ™Ã­kazÅ¯.
IdeÃ¡lnÄ› bychom chtÄ›li programy zapisovat v pÅ™irozenÃ©m jazyce (<code>Vykresli Ätverec na obrazovku</code>,
<code>ZapiÅ¡ text do dokumentu</code>), nicmÃ©nÄ› tomu poÄÃ­taÄe nerozumÃ­ a je velmi nÃ¡roÄnÃ© jej pÅ™evÃ©st na
sprÃ¡vnou sekvenci pÅ™Ã­kazÅ¯ pro poÄÃ­taÄ, protoÅ¾e jazyky, kterÃ© pouÅ¾Ã­vÃ¡me, jsou Äasto nejednoznaÄnÃ© a
nemajÃ­ jednotnou strukturu.</p>
<span class='sidenote'><p><sup class='number'>1</sup>VyzkouÅ¡Ã­te si to v navazujÃ­cÃ­m pÅ™edmÄ›tu <a href="https://poli.cs.vsb.cz/edu/apps/">Architektury poÄÃ­taÄÅ¯ a paralelnÃ­ch systÃ©mÅ¯</a>.</p>
</span>
<p>Jako kompromis tak vznikly <strong>programovacÃ­ jazyky</strong>, kterÃ© umoÅ¾ÅˆujÃ­ zÃ¡pis programÅ¯ ve formÄ›, kterÃ¡
je lidem srozumitelnÃ¡, ale zÃ¡roveÅˆ ji lze relativnÄ› jednoduÅ¡e pÅ™evÃ©st na pÅ™Ã­kazy, kterÃ© je schopen
poÄÃ­taÄ provÃ©st. PÅ™evodu programu zapsanÃ©ho v programovacÃ­m jazyce na poÄÃ­taÄovÃ© instrukce se
Å™Ã­kÃ¡ <strong>pÅ™eklad</strong>
(<em>compilation</em>) a programy, kterÃ© tento pÅ™eklad provÃ¡dÄ›jÃ­, se nazÃ½vajÃ­ <strong>pÅ™ekladaÄe</strong> (<em>compilers</em>)
. PozdÄ›ji si ukÃ¡Å¾eme, jak takovÃ½to pÅ™ekladaÄ pouÅ¾Ã­t k pÅ™ekladu kÃ³du.</p>
<p>Zde je ukÃ¡zka ÄÃ¡sti programu v jazyce <em>C</em>:</p>
<pre><code class="language-c">while (je_tlacitko_zmacknuto(MEZERNIK)) {
    posun_nahoru(postava);
}
</code></pre>
<p>I nÄ›kdo, kdo se s jazykem <em>C</em> nikdy nesetkal, mÅ¯Å¾e z tohoto kusu kÃ³du zhruba odvodit, co asi dÄ›lÃ¡,
pokud ho pÅ™eÄte jako vÄ›tu. Tento program vÅ¡ak mÅ¯Å¾e bÃ½t pÅ™eveden na stovky aÅ¾ tisÃ­ce poÄÃ­taÄovÃ½ch
instrukcÃ­ a z takovÃ©ho mnoÅ¾stvÃ­ pÅ™Ã­kazÅ¯ uÅ¾ by bylo sloÅ¾itÃ© odvodit, k Äemu je program urÄen.</p>
<h1><a class="header" href="#jazyk-c" id="jazyk-c">Jazyk <em>C</em></a></h1>
<p>Existuje nespoÄet programovacÃ­ch jazykÅ¯, napÅ™Ã­klad Python, Java, C#, PHP, Rust Äi Javascript. KaÅ¾dÃ½
z nich mÃ¡ svÃ© vÃ½hody a nevÃ½hody a zÃ¡leÅ¾Ã­ na konkrÃ©tnÃ­m problÃ©mu, kterÃ½ je tÅ™eba vyÅ™eÅ¡it, pro
zvolenÃ­ vhodnÃ©ho programovacÃ­ho jazyka.</p>
<p>V tomto kurzu se budeme zabÃ½vat pouze programovacÃ­m jazykem <strong>C</strong>. Tento jazyk vytvoÅ™ili Dennis
Ritchie a Ken Thompson v laboratoÅ™Ã­ch firmy Bell v roce 1972, tedy pÅ™ed vÃ­ce neÅ¾ 50 lety, a za tu
dobu se nedoÄkal mnoha vÃ½raznÃ½ch zmÄ›n.</p>
<p>I kdyÅ¾ pro nÄ›j v dneÅ¡nÃ­ dobÄ› asi nenaleznete tolik pracovnÃ­ch nabÃ­dek (jako tÅ™eba pro JavaScript),
a nenÃ­ primÃ¡rnÃ­ volbou pro tvorbu webovÃ½ch Äi mobilnÃ­ch aplikacÃ­, vyplatÃ­ se mu rozumÄ›t a umÄ›t ho
pouÅ¾Ã­vat, a to hned z nÄ›kolika dÅ¯vodÅ¯:</p>
<ul>
<li>Jazyk <em>C</em> lze pouÅ¾Ã­t na tÃ©mÄ›Å™ vÅ¡ech existujÃ­cÃ­ch platformÃ¡ch a je tak velmi univerzÃ¡lnÃ­m jazykem.
TÃ©mÄ›Å™ veÅ¡kerÃ½ existujÃ­cÃ­ software obsahuje kusy kÃ³du v jazyce <em>C</em>. OperaÄnÃ­ systÃ©my (Linux,
OSÂ X, Windows, Android, iOS), prohlÃ­Å¾eÄe (Chrome, Firefox, Edge), multimediÃ¡lnÃ­ programy
(Photoshop, Powerpoint, Word, BitTorrent), hry (World of Warcraft, Quake, Doom, Call of Duty,
League of Legends, DOTA 2, Fortnite), vestavÄ›nÃ¡ zaÅ™Ã­zenÃ­ (mikroÄipy, praÄky, Å™Ã­dÃ­cÃ­ jednotky
vesmÃ­rnÃ½ch letadel nebo aut). VÅ¡echny tyto vÄ›ci jsou buÄ ÄÃ¡steÄnÄ› anebo zcela pohÃ¡nÄ›ny jazykem
<em>C</em>.</li>
<li>Je to relativnÄ› jednoduchÃ½ jazyk, kterÃ½ neobsahuje velkÃ© mnoÅ¾stvÃ­ funkcÃ­, kterÃ© lze naleznout
ve vÄ›tÅ¡inÄ› modernÄ›jÅ¡Ã­ch jazykÅ¯. DÃ­ky tomu se dajÃ­ jeho zÃ¡klady nauÄit za jeden semestr.</li>
<li>Jeho ÃºroveÅˆ abstrakce nenÃ­ o mnoho vÃ½Å¡e neÅ¾ zÃ¡kladnÃ­ poÄÃ­taÄovÃ© instrukce. PÅ™i vÃ½uce <em>C</em> tak lze
zÃ¡roveÅˆ pochopit, jak funguje poÄÃ­taÄ a operaÄnÃ­ systÃ©m. DÃ­ky tomu lze takÃ© pÅ™i sprÃ¡vnÃ©m
zachÃ¡zenÃ­ psÃ¡t velmi efektivnÃ­ programy (to ale nicmÃ©nÄ› nenÃ­ obsahem tohoto kurzu). PochopenÃ­ toho,
jak vÄ›ci &quot;na pozadÃ­ poÄÃ­taÄe&quot; fungujÃ­, je jednou z pÅ™idanou hodnot studia jazyka C.</li>
<li><strong>Syntaxe</strong> (zpÅ¯sob zÃ¡pisu) jazyka <em>C</em> ovlivnila velkÃ© mnoÅ¾stvÃ­ jazykÅ¯, kterÃ© vznikly po nÄ›m.
Jakmile se ji nauÄÃ­te, tak budete schopni rozumÄ›t syntaxi vÄ›tÅ¡iny souÄasnÃ½ch nejpouÅ¾Ã­vanÄ›jÅ¡Ã­ch
jazykÅ¯ (C++, C#, Java, Kotlin, Javascript, PHP, Rust, â€¦).</li>
</ul>
<p>Jazyk <em>C</em> mÃ¡ samozÅ™ejmÄ› takÃ© Å™adu nevÃ½hod. Vzhledem k jeho stÃ¡Å™Ã­ a omezenÃ© sadÄ› funkcionalit je
Äasto znaÄnÄ› pracnÄ›jÅ¡Ã­ a zdlouhavÄ›jÅ¡Ã­ pomocÃ­ nÄ›j dosÃ¡hnout stejnÃ©ho vÃ½sledku neÅ¾ u modernÄ›jÅ¡Ã­ch
programovacÃ­ch jazykÅ¯. Nevede takÃ© programÃ¡tory za ruÄiÄku â€“ pÅ™i psanÃ­ programu v jazyce <em>C</em> je
velmi jednoduchÃ© udÄ›lat chybu, kterÃ¡ mÅ¯Å¾e zpÅ¯sobit (v lepÅ¡Ã­m pÅ™Ã­padÄ›) pÃ¡d programu nebo
(v horÅ¡Ã­m pÅ™Ã­padÄ›) mÅ¯Å¾e bÄ›Å¾Ã­cÃ­ program poÅ¡kodit tak, Å¾e zaÄne vydÃ¡vat chybnÃ½ vÃ½stup nebo se zaÄne
chovat zcela nepÅ™edvÃ­datelnÄ›.  Tyto chyby se mÅ¯Å¾ou projevit jen nÄ›kdy, nebo jenom na urÄitÃ© kombinaci
hardwaru Äi operaÄnÃ­ho systÃ©mu, a programÃ¡tor na nÄ› nenÃ­ Äasto nijak upozornÄ›n a musÃ­ je najÃ­t ruÄnÄ›
zkoumÃ¡nÃ­m zdrojovÃ©ho kÃ³du. PodobnÃ½ typ chyb je takÃ© nejÄastÄ›jÅ¡Ã­m zdrojem bezpeÄnostnÃ­ch dÄ›r ve vÅ¡ech
moÅ¾nÃ½ch softwarech, kterÃ© (jak uÅ¾ vÃ­me) tÃ©mÄ›Å™ vÅ¾dy obsahujÃ­ alespoÅˆ ÄÃ¡st kÃ³du napsanÃ©ho v &quot;CÃ©Äku&quot;.</p>
<blockquote>
<p>TÃ­m, Å¾e jazyk <em>C</em> existuje pÅ™es 50 let, je v nÄ›m spousta pravidel, kterÃ© nemusÃ­ dÃ¡vat smysl nebo
nejdou odvodit a pokud je neznÃ¡te, vÃ¡Å¡ program nemusÃ­ sprÃ¡vnÄ› fungovat. PÅ™i prÃ¡ci s tÃ­mto jazykem
se tak zkuste obrnit trpÄ›livostÃ­. Budete ji potÅ™ebovat ğŸ™‚.</p>
</blockquote>
<p>Pokud byste se chtÄ›li podÃ­vat, jak mÅ¯Å¾ou vypadat velkÃ© programy napsanÃ© v jazyce <em>C</em>, zde je
seznam nÄ›kolika vybranÃ½ch populÃ¡rnÃ­ch programÅ¯, kterÃ© jsou v nÄ›m napsanÃ©. Tyto programy jsou tzv. <strong>open-source</strong><sup class='margin-toggle sidenote-number'>2</sup>,
takÅ¾e si jejich zdrojovÃ½ kÃ³d mÅ¯Å¾ete prohlÃ©dnout a v pÅ™Ã­padÄ› potÅ™eby i modifikovat:</p>
<span class='sidenote'><p><sup class='number'>2</sup>Jejich zdrojovÃ½ kÃ³d je volnÄ› k dispozici a je sdÃ­lenÃ½ na internetu.</p>
</span>
<ul>
<li><a href="https://github.com/torvalds/linux">Linux</a> (operaÄnÃ­ systÃ©m)</li>
<li><a href="https://github.com/id-Software/Quake-III-Arena">Quake III</a> (poÄÃ­taÄovÃ¡ hra)</li>
<li><a href="https://github.com/git/git">git</a> (verzovacÃ­ systÃ©m)</li>
<li><a href="https://github.com/php/php-src">PHP</a> (pÅ™ekladaÄ/interpret jazyka PHP)</li>
<li><a href="https://github.com/obsproject/obs-studio">OBS Studio</a> (streamovacÃ­ software)</li>
</ul>
<h1><a class="header" href="#pamÄ›Å¥" id="pamÄ›Å¥">PamÄ›Å¥</a></h1>
<p>PoÄÃ­taÄe si potÅ™ebujÃ­ uklÃ¡dat vÃ½sledky vÃ½poÄtÅ¯ do pamÄ›ti, aby je pozdÄ›ji mohly opÄ›t naÄÃ­st a
pracovat s nimi. Je mnoho typÅ¯ pamÄ›ti, s kterÃ½mi lze pracovat, nejbÄ›Å¾nÄ›ji se setkÃ¡me s tzv.
operaÄnÃ­ pamÄ›tÃ­ (<strong>RAM</strong>). RAM znamenÃ¡ Random-Access Memory, tedy pamÄ›Å¥ s nÃ¡hodnÃ½m pÅ™Ã­stupem. To
znamenÃ¡, Å¾e poÄÃ­taÄ mÅ¯Å¾e do pamÄ›ti Å¡ahat v libovolnÃ©m poÅ™adÃ­ a na libovolnÃ©m mÃ­stÄ›, kde je to
potÅ™eba.</p>
<h3><a class="header" href="#reprezentace-hodnot-v-pamÄ›ti" id="reprezentace-hodnot-v-pamÄ›ti">Reprezentace hodnot v pamÄ›ti</a></h3>
<p>PoÄÃ­taÄovÃ¡ pamÄ›Å¥ uchovÃ¡vÃ¡ informace v buÅˆkÃ¡ch, kterÃ© obsahujÃ­ jedno ÄÃ­slo, kterÃ© mÅ¯Å¾e obsahovat 256
rÅ¯znÃ½ch hodnot. To vychÃ¡zÃ­ z toho, Å¾e informace je reprezentovÃ¡na <strong>bity</strong>, jednotkou informacÃ­,
kterÃ¡ mÅ¯Å¾e nabÃ½vat pouze dvÄ› hodnoty - pravda (<em>true</em>) nebo nepravda (<em>false</em>). KaÅ¾dÃ¡ buÅˆka pamÄ›ti
obsahuje jeden <strong>byte</strong>, neboli 8 bitÅ¯.</p>
<p>Pracuje se zde s dvojkovou (binÃ¡rnÃ­) soustavou, pokud tedy mÃ¡me k dispozici <em>n</em> bitÅ¯, tak pomocÃ­
nich mÅ¯Å¾eme reprezentovat \( 2^n \) hodnot. NapÅ™. s dvÄ›ma bity mÅ¯Å¾eme reprezentovat 4 rÅ¯znÃ©
hodnoty (00, 01, 10, 11), a s 8 bity (jednÃ­m bytem) mÅ¯Å¾eme reprezentovat prÃ¡vÄ› 256 hodnot. VÃ­ce o binÃ¡rnÃ­
soustavÄ› a bytech se dozvÃ­te v pÅ™edmÄ›tu
<a href="https://edison.sso.vsb.cz/cz.vsb.edison.edu.study.prepare.web/SubjectVersion.faces?version=440-2104/01&amp;subjectBlockAssignmentId=375761&amp;studyFormId=2&amp;studyPlanId=22001&amp;locale=cs&amp;back=true">ZÃ¡klady digitÃ¡lnÃ­ch systÃ©mÅ¯ (ZDS)</a>.</p>
<p>I kdyÅ¾ pamÄ›Å¥ vÅ¾dy obsahuje hodnoty (ÄÃ­sla) v dvojkovÃ© soustavÄ›, je dÅ¯leÅ¾itÃ© si uvÄ›domit, Å¾e vÃ½znam
tÄ›mto hodnotÃ¡m pÅ™iÅ™azujeme my, tedy programÃ¡toÅ™i a uÅ¾ivatelÃ© poÄÃ­taÄe. Pokud je v pamÄ›ti hodnota <strong>65</strong>,
tak mÅ¯Å¾e reprezentovat napÅ™Ã­klad:</p>
<ul>
<li>poÄet zÃ­skanÃ½ch bodÅ¯ studenta (interpretujeme ji jako ÄÃ­slo)</li>
<li>pÃ­smeno <code>A</code> v nÄ›jakÃ©m dokumentu (interpretujeme ji jako znak v
kÃ³dovÃ¡nÃ­ <a href="https://www.asciitable.com/">ASCII</a>)</li>
<li>tmavÄ› Å¡edÃ½ pixel (interpretujeme ji jako barvu)</li>
</ul>
<p>I v pÅ™Ã­padÄ›, Å¾e hodnoty v pamÄ›ti interpretujeme pÅ™Ã­mo jako ÄÃ­sla, tak reprezentovanÃ© ÄÃ­slo nemusÃ­
pÅ™Ã­mo odpovÃ­dat ÄÃ­selnÃ© hodnotÄ› v pamÄ›ti. NapÅ™Ã­klad hodnotu <strong>255</strong> uloÅ¾enou v <em>bytu</em> pamÄ›ti mÅ¯Å¾eme
vnÃ­mat jako celÃ© nezÃ¡pornÃ© ÄÃ­slo (<em>unsigned integer</em>) <strong>255</strong>, anebo takÃ© jako celÃ© ÄÃ­slo se
znamÃ©nkem (<em>signed integer</em>) <strong>-1</strong>
v <a href="https://cs.wikipedia.org/wiki/Dvojkov%C3%BD_dopln%C4%9Bk">dvojkovÃ©m doplÅˆku</a>.<sup class='margin-toggle sidenote-number'>1</sup></p>
<span class='sidenote'><p><sup class='number'>1</sup>MÅ¯Å¾eme si ale klidnÄ› vymyslet i reprezentaci, kde hodnota <code>255</code> v pamÄ›ti bude reprezentovat
ÄÃ­slo <code>42</code>. Nebo tÅ™eba emoji ğŸ˜ˆ. ZÃ¡leÅ¾Ã­ jen na nÃ¡s.</p>
</span>
<p><strong>ÄŒÃ­sla v pamÄ›ti tak sama o sobÄ› nemajÃ­ Å¾Ã¡dnÃ½ vÃ½znam, zÃ¡leÅ¾Ã­ pouze na tom, jak je my, a obzvlÃ¡Å¡tÄ› naÅ¡e
programy, interpretujÃ­ a jakÃ© operace nad nimi provÃ¡dÄ›jÃ­.</strong></p>
<h3><a class="header" href="#adresovÃ¡nÃ­-pamÄ›ti" id="adresovÃ¡nÃ­-pamÄ›ti">AdresovÃ¡nÃ­ pamÄ›ti</a></h3>
<p>Abychom se mohli odkazovat na hodnoty v pamÄ›ti, tak musÃ­me mÃ­t moÅ¾nost rozliÅ¡it jednotlivÃ© buÅˆky od
sebe. Toho dosÃ¡hneme pomocÃ­ <strong>adresy</strong>. PamÄ›Å¥ je adresovÃ¡na tak, Å¾e kaÅ¾dÃ¡ pamÄ›Å¥ovÃ¡ buÅˆka (kaÅ¾dÃ½ <em>byte</em>)
mÃ¡ ÄÃ­selnou adresu od 0 do velikosti pamÄ›ti (nevÄetnÄ›). Velmi zjednoduÅ¡enÄ› Å™eÄeno, pokud mÃ¡te RAM
pamÄ›Å¥ o velikosti 8 GiB (8 589 934 592 &quot;bajtÅ¯&quot;), tak mÅ¯Å¾ete adresovat buÅˆky od 0 do 8589934591<sup class='margin-toggle sidenote-number'>2</sup>.</p>
<span class='sidenote'><p><sup class='number'>2</sup>Programy bÄ›Å¾nÄ› nemajÃ­ pÅ™Ã­stup k celÃ© pamÄ›ti poÄÃ­taÄe (mimo jinÃ© z bezpeÄnostnÃ­ch dÅ¯vodÅ¯). VÃ¡Å¡
operaÄnÃ­ systÃ©m pouÅ¾Ã­vÃ¡ tzv. <strong>virtuÃ¡lnÃ­ pamÄ›Å¥</strong>, kterÃ¡ kaÅ¾dÃ©mu bÄ›Å¾Ã­cÃ­mu programu pÅ™idÄ›luje urÄitÃ©
rozsahy pamÄ›ti, s kterÃ½mi mÅ¯Å¾e pracovat. VÃ­ce se dozvÃ­te v pÅ™edmÄ›tu
<a href="http://poli.cs.vsb.cz/edu/osy/">OperaÄnÃ­ systÃ©my</a>.</p>
</span>
<p>Pokud byste programovali poÄÃ­taÄ pÅ™Ã­mo pomocÃ­ instrukcÃ­, tak mu mÅ¯Å¾ete dÃ¡t napÅ™Ã­klad instrukci
<code>Nastav byte na adrese 58 na hodnotu 5</code> nebo <code>PÅ™eÄti 4 byty zaÄÃ­najÃ­cÃ­ na adrese 1028</code>. PÅ™i
programovÃ¡nÃ­ v <em>C</em> ovÅ¡em Äasto budou adresy skrytÃ© na pozadÃ­ a bude se o nÄ› starat pÅ™ekladaÄ, my se
budeme na konkrÃ©tnÃ­ Ãºsek pamÄ›ti obvykle odkazovat jmÃ©nem, kterÃ© mu pÅ™iÅ™adÃ­me.</p>
<h1><a class="header" href="#nastavenÃ­-prostÅ™edÃ­" id="nastavenÃ­-prostÅ™edÃ­">NastavenÃ­ prostÅ™edÃ­</a></h1>
<p>Abyste mohli efektivnÄ› programovat v <em>C</em>, musÃ­te si nainstalovat, nakonfigurovat a nauÄit se pouÅ¾Ã­vat
sadu programÅ¯. V tÃ©to kapitole naleznete struÄnÃ½ popis toho, jak si nastavit
<a href="prostredi/linux/linux.html">operaÄnÃ­ systÃ©m Linux</a>, <a href="prostredi/editor.html">textovÃ½ editor</a>
k psanÃ­ programÅ¯, <a href="prostredi/preklad_programu.html">pÅ™ekladaÄ</a> pro pÅ™eklad z jazyka <em>C</em> do spustitelnÃ©ho souboru
a takÃ© jak <a href="prostredi/ladeni.html">Å™eÅ¡it chyby</a> pÅ™i psanÃ­ programÅ¯.</p>
<h1><a class="header" href="#linux" id="linux">Linux</a></h1>
<p>Jak uÅ¾ bylo zmÃ­nÄ›no v <a href="prostredi/linux/../../uvod/uvod.html">Ãºvodu</a>, v UPR budeme psÃ¡t a spouÅ¡tÄ›t programy v operaÄnÃ­m
systÃ©m <a href="https://en.wikipedia.org/wiki/Linux">Linux</a>. Je tak nutnÃ©, abyste si na svÃ©m poÄÃ­taÄi
tento operaÄnÃ­ systÃ©m zprovoznili.</p>
<h2><a class="header" href="#proÄ-linux" id="proÄ-linux">ProÄ Linux?</a></h2>
<p>Linux je v souÄasnÃ© dobÄ› v oblasti IT tÃ©mÄ›Å™ vÅ¡ude - pouÅ¾Ã­vÃ¡ ho vÄ›tÅ¡ina webovÃ½ch serverÅ¯, cloudovÃ½ch
sluÅ¾eb, mobilnÃ­ch zaÅ™Ã­zenÃ­ nebo tÅ™eba i superpoÄÃ­taÄÅ¯. UmoÅ¾Åˆuje nÃ¡m ovlÃ¡dat poÄÃ­taÄ jednoduÅ¡e pomocÃ­
textovÃ½ch pÅ™Ã­kazÅ¯ v terminÃ¡lu, dÃ­ky ÄehoÅ¾ si mÅ¯Å¾eme zautomatizovat a ulehÄit prÃ¡ci s poÄÃ­taÄem, a
zÃ¡roveÅˆ mÅ¯Å¾eme trochu nahlÃ©dnout pod pokliÄku toho, jak poÄÃ­taÄ funguje.</p>
<p>Pro pouÅ¾Ã­vÃ¡nÃ­ jazyka <em>C</em> nÃ¡m Linux umoÅ¾Åˆuje velmi jednoduÅ¡e pÅ™eklÃ¡dat programy prÃ¡vÄ› z terminÃ¡lu,
a dÃ­ky tomu, Å¾e je <em>C</em> na Linuxu &quot;jako doma&quot;, tak nÃ¡m to usnadnÃ­ i dalÅ¡Ã­ vÄ›ci, napÅ™. pouÅ¾Ã­vÃ¡nÃ­ knihoven
(kÃ³du, kterÃ½ jiÅ¾ pro nÃ¡s naprogramoval nÄ›kdo jinÃ½). OstatnÄ› i samotnÃ½ Linux je napsÃ¡n tÃ©mÄ›Å™ vÃ½luÄnÄ›
v jazyce <em>C</em> a samotnÃ½ jazyk <em>C</em> vznikl pÅ™ed 50 lety pro tvorbu operaÄnÃ­ch systÃ©mÅ¯ <code>Unix</code>, kterÃ©
byly inspiracÃ­ pro vznik Linuxu.</p>
<h2><a class="header" href="#co-si-mÃ¡m-nainstalovat" id="co-si-mÃ¡m-nainstalovat">Co si mÃ¡m nainstalovat?</a></h2>
<ul>
<li>Pokud pouÅ¾Ã­vÃ¡te operaÄnÃ­ systÃ©m Windows, tak si musÃ­te Linux nainstalovat. Jako nÃ¡vod k tomu
slouÅ¾Ã­ <a href="prostredi/linux/instalace.html">samostatnÃ¡ strÃ¡nka</a>.</li>
<li>Pokud pouÅ¾Ã­vÃ¡te operaÄnÃ­ systÃ©m OS X, tak teoreticky Linux instalovat nemusÃ­te, staÄÃ­ si nastavit
pÅ™ekladaÄ <a href="https://www.cyberciti.biz/faq/howto-apple-mac-os-x-install-gcc-compiler/"><code>gcc</code></a>.</li>
<li>Pokud jiÅ¾ pouÅ¾Ã­vÃ¡te operaÄnÃ­ systÃ©m Linux, nemusÃ­te nic dalÅ¡Ã­ho Å™eÅ¡it a mÅ¯Å¾ete pÅ™ejÃ­t k
nastavenÃ­ <a href="prostredi/linux/../editor.html">editoru</a>.</li>
</ul>
<blockquote>
<p><strong>Pokud pÅ™i instalaci Linuxu narazÃ­te na problÃ©my, kterÃ© se vÃ¡m nepodaÅ™Ã­ vyÅ™eÅ¡it, konzultujte je
ihned s vaÅ¡Ã­m cviÄÃ­cÃ­m, kterÃ½ vÃ¡m s instalacÃ­ pomÅ¯Å¾e. Je nezbytnÃ© mÃ­t zprovoznÄ›nÃ½ pÅ™ekladaÄ <code>gcc</code>
a Linux (nebo OS X), abyste mohli Å™eÅ¡it Ãºlohy do UPR.</strong></p>
</blockquote>
<h2><a class="header" href="#zÃ¡klady-pouÅ¾Ã­vÃ¡nÃ­-linuxu" id="zÃ¡klady-pouÅ¾Ã­vÃ¡nÃ­-linuxu">ZÃ¡klady pouÅ¾Ã­vÃ¡nÃ­ Linuxu</a></h2>
<p>Linux se v zÃ¡sadÄ› pouÅ¾Ã­vÃ¡ velmi podobnÄ› jako operaÄnÃ­ systÃ©m Windows, nicmÃ©nÄ› narozdÃ­l od Windows,
kde jste asi zvyklÃ­ ovlÃ¡dat poÄÃ­taÄ zejmÃ©na myÅ¡Ã­, se v Linuxu bÄ›Å¾nÄ› spousta ÃºkonÅ¯ provÃ¡dÃ­ v tzv.
<strong>terminÃ¡lu</strong>, neboli pÅ™Ã­kazovÃ© Å™Ã¡dce (<em>command line</em>), kde ovlÃ¡dÃ¡te poÄÃ­taÄ pomocÃ­ textovÃ½ch pÅ™Ã­kazÅ¯.</p>
<p>Pro otevÅ™enÃ­ terminÃ¡lu na Linuxu zmÃ¡ÄknÄ›te <code>Ctrl + Alt + T</code> nebo zmÃ¡ÄknÄ›te klÃ¡vesu <code>Start</code>
a vyhledejte program <code>Terminal</code>. Pokud pouÅ¾Ã­vÃ¡te WSL, tak spusÅ¥te z nabÃ­dky Start program <code>Ubuntu</code>.</p>
<p>Po otevÅ™enÃ­ terminÃ¡lu byste mÄ›li vidÄ›t nÄ›co podobnÃ©ho:
<img src="prostredi/linux/../../static/img/terminal1.png" alt="" /></p>
<p>PÅ™ed znakem dolaru (<code>$</code>) vÅ¾dy uvidÃ­te adresÃ¡Å™<sup class='margin-toggle sidenote-number'>1</sup>, ve kterÃ©m se zrovna v terminÃ¡lu nachÃ¡zÃ­te. OdpovÃ­dÃ¡
to zhruba tomu, jako kdyÅ¾ na Windows v prohlÃ­Å¾eÄi souborÅ¯ rozkliknete nÄ›jakÃ½ adresÃ¡Å™ a vidÃ­te soubory,
kterÃ© se v nÄ›m nachÃ¡zÃ­. PomocÃ­ pÅ™Ã­kazu <code>cd</code> (viz nÃ­Å¾e) se mÅ¯Å¾ete mezi adresÃ¡Å™i pÅ™epÃ­pnat.</p>
<span class='sidenote'><p><sup class='number'>1</sup>AdresÃ¡Å™ (nebo taky sloÅ¾ka) oznaÄuje pojmenovanou sadu souborÅ¯ umÃ­stÄ›nou na nÄ›jakÃ© <strong>cestÄ›</strong> na
disku. AdresÃ¡Å™e mohou obsahovat jak soubory, tak dalÅ¡Ã­ adresÃ¡Å™e.</p>
</span>
<p>NynÃ­ mÅ¯Å¾ete do terminÃ¡lu psÃ¡t pÅ™Ã­kazy, pomocÃ­ kterÃ½ch si mÅ¯Å¾ete napÅ™. vypsat soubory v souÄasnÃ©m
adresÃ¡Å™i, vytvoÅ™it novÃ½ adresÃ¡Å™, spustit nÄ›jakÃ½ program nebo se pÅ™esunout do jinÃ©ho adresÃ¡Å™e:</p>
<ul>
<li>VypsÃ¡nÃ­ souborÅ¯ v souÄasnÃ©m adresÃ¡Å™i (<code>ls = list files</code>)
<pre><code class="language-bash">~$ ls
soubor1
soubor2
slozka1
</code></pre>
</li>
<li>PÅ™esunutÃ­ do jinÃ©ho adresÃ¡Å™e (<code>cd = change directory</code>)
<pre><code class="language-bash">~$ cd slozka1
~/slozka1$
</code></pre>
</li>
<li>VytvoÅ™enÃ­ adresÃ¡Å™e (<code>mkdir = make directory</code>)
<pre><code class="language-bash">~$ mkdir moje-slozka
~$ ls
moje-slozka
</code></pre>
</li>
<li>SpuÅ¡tÄ›nÃ­ programu
<pre><code class="language-bash">~$ ./program
</code></pre>
</li>
</ul>
<p>VÃ­ce informacÃ­ o prÃ¡ci s terminÃ¡lem a Linuxem se dozvÃ­te na internetu. Zkuste se podÃ­vat napÅ™.
na <a href="https://naucse.python.cz/2021/linuxadmin-podzim/sessions/shell-1/">tento kurz</a>.
<a href="https://github.com/geordi/upr-course/blob/master/assets/cheatsheets/linux.pdf">Zde</a> potÃ© naleznete
tahÃ¡k rÅ¯znÃ½ch uÅ¾iteÄnÃ½ch pÅ™Ã­kazÅ¯, kterÃ© mÅ¯Å¾ete v terminÃ¡lu pouÅ¾Ã­t.</p>
<h1><a class="header" href="#instalace-linuxu" id="instalace-linuxu">Instalace Linuxu</a></h1>
<p>Pokud pouÅ¾Ã­vÃ¡te operaÄnÃ­ systÃ©m Windows, tak pro pouÅ¾itÃ­ Linuxu mÅ¯Å¾ete vyuÅ¾Ã­t jednu z nÃ¡sledujÃ­cÃ­ch
tÅ™Ã­ moÅ¾nostÃ­.</p>
<blockquote>
<p>Linux nenÃ­ pouze jeden operaÄnÃ­ systÃ©m, ale pouze tzv. <strong>jÃ¡dro</strong> (<em>kernel</em>) operaÄnÃ­ho systÃ©mu,
nad kterÃ½m vznikajÃ­ tzv. <em>distribuce</em>, kterÃ© se liÅ¡Ã­ ve vizuÃ¡lnÃ­ strÃ¡nce, zpÅ¯sobu ovlÃ¡dÃ¡nÃ­, sprÃ¡vÄ›
softwarovÃ½ch balÃ­ÄkÅ¯ atd. Jednou z nejpouÅ¾Ã­vanÄ›jÅ¡Ã­ch a takÃ© nejjednoduÅ¡Å¡Ã­ distribucÃ­ Linuxu
je <strong>Ubuntu</strong>. PÅ™i instalaci Linuxu vÃ¡m tak doporuÄujeme pouÅ¾Ã­t prÃ¡vÄ› tuto distribuci.</p>
</blockquote>
<h2><a class="header" href="#windows-subsystem-for-linux-doporuÄeno" id="windows-subsystem-for-linux-doporuÄeno">Windows Subsystem for Linux (doporuÄeno)</a></h2>
<p><code>WSL</code> je systÃ©m, kterÃ½ umoÅ¾Åˆuje nainstalovat Linux pod operaÄnÃ­m systÃ©mem Windows tak, Å¾e se Linux
bude chovat jako program spouÅ¡tÄ›nÃ½ pod Windows. Tato varianta vÃ¡m umoÅ¾nÃ­ jednoduÅ¡e sdÃ­let data
mezi Windows a Linuxem, a takÃ© vÃ¡m umoÅ¾nÃ­ si jednoduÅ¡e pod Windows spustit LinuxovÃ½ terminÃ¡l, ze
kterÃ©ho budete moct napÅ™. pÅ™eklÃ¡dat svÃ© <em>C</em> programy.</p>
<p>Nejprve si musÃ­te na Windows <code>WSL</code> nainstalovat. NÃ¡vod pro instalaci naleznete <a href="https://docs.microsoft.com/cs-cz/windows/wsl/install">zde</a>.
Pokud mÃ¡te aktualizovanÃ½ Windows 10/11, tak by mÄ›lo staÄit spustit pÅ™Ã­kazovou Å™Ã¡dku Windows jako administrÃ¡tor<sup class='margin-toggle sidenote-number'>1</sup>,
potÃ© napsat <code>wsl.exe --install</code> a zmÃ¡Äknout klÃ¡vesu Enter. Jakmile se WSL nainstaluje, tak restartujte poÄÃ­taÄ.
Tento pÅ™Ã­kaz by vÃ¡m mÄ›l nainstalovat distribuci <em>Ubuntu</em> do vaÅ¡eho Windows poÄÃ­taÄe.</p>
<span class='sidenote'><p><sup class='number'>1</sup>NabÃ­dka start -&gt; NapiÅ¡te <code>cmd</code> -&gt; KliknÄ›te pravÃ½m tlaÄÃ­tkem na nalezenÃ½ pÅ™Ã­kazovÃ½ Å™Ã¡dek -&gt; Spustit jako administrÃ¡tor</p>
</span>
<p>PotÃ© mÅ¯Å¾ete spustit terminÃ¡l (<code>bash</code>) bÄ›Å¾Ã­cÃ­ pod Ubuntu spuÅ¡tÄ›nÃ­m programu <code>Ubuntu</code> (napÅ™. z nabÃ­dky
Start). Tento <a href="prostredi/linux/linux.html#z%C3%A1klady-pou%C5%BE%C3%ADv%C3%A1n%C3%AD-linuxu">terminÃ¡l</a> mÅ¯Å¾ete pouÅ¾Ã­vat pro prÃ¡ci se soubory nebo
pÅ™eklad <em>C</em> programÅ¯.</p>
<blockquote>
<p>Soubory z Windows jsou v pÅ™Ã­kazovÃ© Å™Ã¡dce Ubuntu pod WSL dostupnÃ© na cestÄ› <code>/mnt/c</code>. Pokud byste
se tak napÅ™Ã­klad chtÄ›li v terminÃ¡lu pÅ™esunout do sloÅ¾ky <code>C:/Users/Katka/Desktop</code>, tak v terminÃ¡lu
spusÅ¥te pÅ™Ã­kaz <code>cd /mnt/c/Users/Katka/Desktop</code>.</p>
<p>Naopak soubory z WSL jsou pod Windows dostupnÃ© na cestÄ› <code>\\wsl$\Ubuntu\&lt;cesta&gt;</code>. KdyÅ¾ do adresnÃ­ho
Å™Ã¡dku prohlÃ­Å¾eÄe souborÅ¯ ve Windows napÃ­Å¡ete <code>\\wsl$</code>, tak se mÅ¯Å¾ete k souborÅ¯m proklikat.</p>
</blockquote>
<p>Jakmile budete ve WSL <code>bash</code> terminÃ¡lu, tak si nejprve nainstalujte programy nutnÃ© pro prÃ¡ci s <code>C</code>
(zejmÃ©na pÅ™ekladaÄ) pomocÃ­ nÃ¡sledujÃ­ch dvou pÅ™Ã­kazÅ¯:</p>
<pre><code class="language-bash">$ sudo apt update
$ sudo apt install build-essential gdb
</code></pre>
<blockquote>
<p>PÅ™i pokusu o instalaci vÃ¡s program vyzve, abyste instalaci potvrdili. UdÄ›lejte to zmÃ¡ÄknutÃ­m klÃ¡vesy <code>y</code>
a potvrÄte klÃ¡vesou Enter.</p>
</blockquote>
<h2><a class="header" href="#visual-studio-code" id="visual-studio-code">Visual Studio Code</a></h2>
<p>Pokud chcete pod WSL pouÅ¾Ã­vat editor Visual Studio Code, tak ho <strong>nespouÅ¡tÄ›jte z Windows</strong>,
ale nejprve si otevÅ™ete WSL <code>bash</code> terminÃ¡l, a potÃ© spusÅ¥e VSCode pomocÃ­ tohoto pÅ™Ã­kazu:</p>
<pre><code class="language-bash">$ code .
</code></pre>
<p>Pokud takto VSCode spustÃ­te, tak si nainstaluje sÃ¡m rozÅ¡Ã­Å™enÃ­ pro WSL a bude potÃ© vyuÅ¾Ã­vat WSL bash
a pÅ™ekladaÄ pro spouÅ¡tÄ›nÃ­ a pÅ™eklad vaÅ¡ich <code>C</code> programÅ¯. Do VSCode si potÃ© nainstalujte jeÅ¡tÄ›
rozÅ¡Ã­Å™enÃ­ (extension) <code>C/C++</code> a takÃ© rozÅ¡Ã­Å™enÃ­ <code>Remote development</code>, kterÃ© vÃ¡m umoÅ¾nÃ­ pracovat s WSL
soubory z VSCode.</p>
<p>PodrobnÄ›jÅ¡Ã­ nÃ¡vod pro zprovoznÄ›nÃ­ WSL spolu s prostÅ™edÃ­m pro vÃ½voj v jazyce <em>C</em> naleznete
<a href="https://code.visualstudio.com/docs/cpp/config-wsl">zde</a>.</p>
<h2><a class="header" href="#virtualizovanÃ½-linux" id="virtualizovanÃ½-linux">VirtualizovanÃ½ Linux</a></h2>
<p>Linux mÅ¯Å¾ete takÃ© pouÅ¾Ã­vat ve virtualizovanÃ© podobÄ› pomocÃ­
<a href="https://cs.wikipedia.org/wiki/Virtu%C3%A1ln%C3%AD_stroj">virtuÃ¡lnÃ­ho stroje</a>. V tÃ©to variantÄ› se
pod Windows spustÃ­ celÃ½ virtuÃ¡lnÃ­ poÄÃ­taÄ, na kterÃ©m pobÄ›Å¾Ã­ Linux, kterÃ½ nebude mÃ­t vÅ¯bec tuÅ¡enÃ­ o
tom, Å¾e je spuÅ¡tÄ›n pod Windows. VÃ½hodou tohoto Å™eÅ¡enÃ­ je, Å¾e se virtuÃ¡lnÃ­ poÄÃ­taÄ bude chovat jako
plnohodnotnÃ¡ instalace Linuxu, a tÃ©mÄ›Å™ vÅ¡e by tedy na nÄ›m mÄ›lo fungovat (i vÄetnÄ› napÅ™. grafickÃ½ch
aplikacÃ­, kterÃ© pod WSL nemusÃ­ fungovat). NevÃ½hodou je, Å¾e virtuÃ¡lnÃ­ poÄÃ­taÄ je znaÄnÄ› nÃ¡roÄnÃ½ na procesor
i pamÄ›Å¥ poÄÃ­taÄe, a mÅ¯Å¾e bÃ½t obtÃ­Å¾nÄ›jÅ¡Ã­ s virtuÃ¡lnÃ­m poÄÃ­taÄem sdÃ­let data z Windows (ve srovnÃ¡nÃ­ s WSL).</p>
<p>PÅ™ipravili jsme pro vÃ¡s tzv. obraz virtuÃ¡lnÃ­ho stroje, kterÃ½ obsahuje jiÅ¾ nastavenÃ½ Linux, konkrÃ©tnÄ›
<code>Ubuntu 20.04</code>, se vÅ¡Ã­m potÅ™ebnÃ½m pro pÅ™edmÄ›t UPR. Abyste jej mohli pouÅ¾Ã­t, tak si nejprve musÃ­te
nainstalovat virtualizaÄnÃ­ program <a href="https://www.virtualbox.org/wiki/Downloads">VirtualBox</a>. PotÃ© si
<a href="https://drive.google.com/file/d/1RsFoternYw1vNYlHefa5wr1ZwLv81wBi/view?usp=sharing">pÅ™edpÅ™ipravenÃ½ obraz</a> stÃ¡hnÄ›te, otevÅ™ete ho ve VirtualBoxu
a potvrÄte import s vÃ½chozÃ­m nastavenÃ­m.</p>
<p>VirtuÃ¡lnÃ­ poÄÃ­taÄ potÃ© bude moÅ¾nÃ© spustit z programu VirtualBox. UÅ¾ivatelskÃ© jmÃ©no i heslo je
<code>student</code>.</p>
<h2><a class="header" href="#nativnÃ­-instalace-linuxu" id="nativnÃ­-instalace-linuxu">NativnÃ­ instalace Linuxu</a></h2>
<p>NejspolehlivÄ›jÅ¡Ã­ variantou pouÅ¾itÃ­ Linuxu je nainstalovat si ho pÅ™Ã­mo &quot;na Å¾elezo&quot;, tj. bez
virtualizace. MÅ¯Å¾ete jej napÅ™Ã­klad nastavit v reÅ¾imu
<a href="https://www.tecmint.com/install-ubuntu-alongside-with-windows-dual-boot/">dual boot</a>, kdy se pÅ™i
startu poÄÃ­taÄe mÅ¯Å¾ete rozhodnout, zdali se nabootuje do Windows (Äi jinÃ©ho operaÄnÃ­ho systÃ©mu)
nebo do Linuxu. Pokud jste s Linuxem nikdy nepracovali, tak doporuÄujeme pouÅ¾Ã­t Linuxovou
<a href="https://itsfoss.com/install-ubuntu/">distribuci Ubuntu</a> ve verzi <code>22.04</code>.</p>
<h1><a class="header" href="#vÃ½vojovÃ©-prostÅ™edÃ­" id="vÃ½vojovÃ©-prostÅ™edÃ­">VÃ½vojovÃ© prostÅ™edÃ­</a></h1>
<p>Abychom mohli pÅ™eloÅ¾it a spustit nÄ›jakÃ½ program, musÃ­me ho obvykle nejprve zapsat do
jednoho nebo vÃ­ce souborÅ¯ ve formÄ› tzv. <strong>zdrojovÃ©ho kÃ³du</strong> (<em>source code</em>). K usnadnÄ›nÃ­ tohoto procesu
existujÃ­ <strong>textovÃ© editory</strong> a <strong>vÃ½vojovÃ¡ prostÅ™edÃ­</strong> jako napÅ™Ã­klad <code>MS Visual Studio</code>, <code>QtCreator</code>, <code>JetBrains CLion</code>,
<code>CodeBlocks</code>, <code>Visual Studio Code</code>, <code>vim</code>, <code>emacs</code> apod. Tyto programy usnadÅˆujÃ­ psanÃ­ kÃ³du pomocÃ­ zvÃ½razÅˆovÃ¡nÃ­
syntaxe, automatizace pÅ™ekladu, spouÅ¡tÄ›nÃ­ a testovÃ¡nÃ­ programÅ¯ a takÃ© sprÃ¡vy projektÅ¯.</p>
<p>Na cviÄenÃ­ch UPR budeme pouÅ¾Ã­vat editor <code>Visual Studio Code</code>, kterÃ½ je
<a href="https://code.visualstudio.com/">dostupnÃ½ zdarma</a>. NÃ­Å¾e je struÄnÃ½ nÃ¡vod k jeho pouÅ¾itÃ­. PÅ™i
programovÃ¡nÃ­ se hodÃ­ detailnÄ› znÃ¡t a efektivnÄ› vyuÅ¾Ã­vat editor, kterÃ½ pouÅ¾Ã­vÃ¡te, ale pro zaÄÃ¡tek
nÃ¡m budou staÄit naprostÃ© zÃ¡klady.</p>
<h2><a class="header" href="#instalace-vscode" id="instalace-vscode">Instalace VSCode</a></h2>
<ul>
<li>
<p>Pokud pouÅ¾Ã­vÃ¡te virtualizovanÃ½ nebo nativnÃ­ Linux (Ubuntu), stÃ¡hnÄ›te si <a href="https://code.visualstudio.com/">odsud</a>
<code>.deb</code> soubor s balÃ­Äkem VSCode a nainstalujte jej (poklikÃ¡nÃ­m myÅ¡i na soubor nebo spuÅ¡tÄ›nÃ­m pÅ™Ã­kazu</p>
<pre><code class="language-bash">$ sudo apt install ./&lt;nazev-souboru&gt;.deb
</code></pre>
</li>
<li>
<p>Pokud pouÅ¾Ã­vÃ¡te <code>WSL</code>, tak by uÅ¾ mÄ›l bÃ½t VSCode pÅ™edinstalovanÃ½<sup class='margin-toggle sidenote-number'>1</sup>. SpustÃ­te ho tak, Å¾e v <code>bash</code>
terminÃ¡lu spustÃ­te tento pÅ™Ã­kaz:</p>
<span class='sidenote'><p><sup class='number'>1</sup>Pokud by tomu tak nebylo, nÃ¡vod na instalaci VSCode na Linuxu naleznete
<a href="https://code.visualstudio.com/docs/setup/linux">zde</a>.</p>
</span>
<pre><code class="language-bash">$ code .
</code></pre>
<p>Ten otevÅ™e VSCode v adresÃ¡Å™i, ve kterÃ©m se zrovna v terminÃ¡lu budete nachÃ¡zet. Ve VSCode
si potÃ© takÃ© nainstalujte dodateÄnÃ© rozÅ¡Ã­Å™enÃ­
<a href="https://marketplace.visualstudio.com/items?itemName=ms-vscode-remote.vscode-remote-extensionpack"><code>Remote Development</code></a>
(viz nÃ¡vod, jak instalovat rozÅ¡Ã­Å™enÃ­ <a href="prostredi/editor.html#instalace-pot%C5%99ebn%C3%BDch-roz%C5%A1%C3%AD%C5%99en%C3%AD-pomoc%C3%AD-u%C5%BEivatelsk%C3%A9ho-rozhran%C3%AD">nÃ­Å¾e</a>).</p>
<p>PodrobnÃ½ nÃ¡vod, jak zprovoznit VSCode v kombinaci s WSL, naleznete
<a href="https://code.visualstudio.com/docs/remote/wsl">zde</a> nebo <a href="https://code.visualstudio.com/docs/cpp/config-wsl">zde</a>.</p>
</li>
</ul>
<h3><a class="header" href="#chybÄ›jÃ­cÃ­-hlaviÄkovÃ©-soubory" id="chybÄ›jÃ­cÃ­-hlaviÄkovÃ©-soubory">ChybÄ›jÃ­cÃ­ hlaviÄkovÃ© soubory</a></h3>
<p>Pokud spustÃ­te VSCode, otevÅ™ete v nÄ›m nÄ›jakÃ½ program s <em>C</em> kÃ³dem a budete mÃ­t ÄervenÄ› podtrÅ¾enÃ½ napÅ™.
takovÃ½to Å™Ã¡dek:</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
</code></pre>
<p>tak je to pravdÄ›podobnÄ› zpÅ¯sobeno jednou z dvou nÃ¡sledujÃ­cÃ­ch vÄ›cÃ­:</p>
<ol>
<li>SpouÅ¡tÃ­te VSCode z Windows a ne z Ubuntu WSL terminÃ¡lu. SpouÅ¡tÄ›jte VSCode vÅ¾dy pÅ™Ã­mo z Ubuntu
terminÃ¡lu, aby mÄ›lo sprÃ¡vnÃ½ pÅ™Ã­stup k systÃ©movÃ½m souborÅ¯m jazyka <em>C</em>. Viz
<a href="prostredi/linux/instalace.html#visual-studio-code">VSCode na WSL</a>.</li>
<li>NemÃ¡te nainstalovanÃ½ pÅ™ekladaÄ (<code>gcc</code>). SpusÅ¥te Ubuntu terminÃ¡l a nainstalujte jej, viz
<a href="prostredi/preklad_programu.html">pÅ™eklad programu</a>.</li>
</ol>
<blockquote>
<p>ObecnÄ› Å™eÄeno, to, Å¾e se vÃ¡m ve VSCode ukazuje nÄ›jakÃ½ problÃ©m s kÃ³dem, jeÅ¡tÄ› neznamenÃ¡, Å¾e tento
problÃ©m v kÃ³du opravdu je. DÅ¯leÅ¾itÃ© je, co Å™ekne <a href="prostredi/preklad_programu.html">pÅ™ekladaÄ</a> pÅ™i pÅ™ekladu
programu, VSCode je obÄas zmatenÃ© anebo nenÃ­ sprÃ¡vnÄ› nastavenÃ©. SamozÅ™ejmÄ› je ale ideÃ¡lnÃ­ si ho sprÃ¡vnÄ›
nastavit, aÅ¥ vÃ¡s to neplete.</p>
</blockquote>
<h2><a class="header" href="#instalace-potÅ™ebnÃ½ch-rozÅ¡Ã­Å™enÃ­-pomocÃ­-terminÃ¡lu" id="instalace-potÅ™ebnÃ½ch-rozÅ¡Ã­Å™enÃ­-pomocÃ­-terminÃ¡lu">Instalace potÅ™ebnÃ½ch rozÅ¡Ã­Å™enÃ­ (pomocÃ­ terminÃ¡lu)</a></h2>
<p>VSCode podporuje programovacÃ­ jazyky pomocÃ­ rozÅ¡Ã­Å™enÃ­, po prvnÃ­ instalaci VSCode
tak nejprve musÃ­me nainstalovat potÅ™ebnÃ¡ rozÅ¡Ã­Å™enÃ­ pro jazyk <em>C</em>. V terminÃ¡lu spusÅ¥te tyto pÅ™Ã­kazy:</p>
<pre><code class="language-bash">$ code --install-extension ms-vscode.cpptools
</code></pre>
<h2><a class="header" href="#instalace-potÅ™ebnÃ½ch-rozÅ¡Ã­Å™enÃ­-pomocÃ­-uÅ¾ivatelskÃ©ho-rozhranÃ­" id="instalace-potÅ™ebnÃ½ch-rozÅ¡Ã­Å™enÃ­-pomocÃ­-uÅ¾ivatelskÃ©ho-rozhranÃ­">Instalace potÅ™ebnÃ½ch rozÅ¡Ã­Å™enÃ­ (pomocÃ­ uÅ¾ivatelskÃ©ho rozhranÃ­)</a></h2>
<ol>
<li>SpusÅ¥te Visual Studio Code</li>
<li>OtevÅ™ete obrazovku rozÅ¡Ã­Å™enÃ­ (<code>Ctrl+Shift+X</code> nebo spusÅ¥te akci <code>Install Extensions</code>)</li>
<li>Vyhledejte rozÅ¡Ã­Å™enÃ­ (<code>C/C++</code>) a nainstalujte jej</li>
</ol>
<h2><a class="header" href="#ukÃ¡zka-nastavenÃ­-projektu" id="ukÃ¡zka-nastavenÃ­-projektu">UkÃ¡zka nastavenÃ­ projektu</a></h2>
<p>Jako vzorovÃ½ projekt mÅ¯Å¾ete pouÅ¾Ã­t <a href="https://github.com/geordi/upr-course/tree/master/faq/vscode-template-project">tuto</a>
Å¡ablonu. Pro otevÅ™enÃ­ adresÃ¡Å™e ve VSCode kliknÄ›te na <code>Soubor (File) -&gt; OtevÅ™Ã­t adresÃ¡Å™ (Open Folder)</code>
a vyberte nÄ›jakÃ½ adresÃ¡Å™, ve kterÃ©m chcete programovat.</p>
<p><img src="prostredi/../static/video/vsc_first_run.gif" alt="NastavenÃ­ VSCode" /></p>
<h2><a class="header" href="#uklÃ¡dÃ¡nÃ­-souborÅ¯" id="uklÃ¡dÃ¡nÃ­-souborÅ¯">UklÃ¡dÃ¡nÃ­ souborÅ¯</a></h2>
<p>Pokud v otevÅ™enÃ©m zdrojovÃ©m souboru provedete nÄ›jakÃ© zmÄ›ny, tak se neuloÅ¾Ã­ na disk, dokud soubor neuloÅ¾Ã­te (pomocÃ­
klÃ¡vesovÃ© zkratky <code>Ctrl + S</code>). ObÄas se studentÅ¯m stÃ¡vÃ¡, Å¾e provedou zmÄ›nu, potÃ© se snaÅ¾Ã­ pÅ™eloÅ¾it program, ale jejich
zmÄ›ny se neprojevÃ­ a studenti nerozumÃ­, proÄ tomu tak je. ÄŒasto je to prÃ¡vÄ› proto, Å¾e soubor nenÃ­ uloÅ¾en!
<strong>NeuloÅ¾enÃ½ soubor</strong> poznÃ¡te tak, Å¾e v zÃ¡loÅ¾ce s nÃ¡zvem souboru je bÃ­lÃ© koleÄko:
<img src="prostredi/../static/img/vsc-unsaved-file.png" alt="" /></p>
<p>VÅ¾dy tak po provedenÃ­ zmÄ›n uklÃ¡dejte soubor pomocÃ­ <code>Ctrl + S</code>, pÅ™Ã­padnÄ› si mÅ¯Å¾ete v nastavenÃ­ (<code>Settings</code>) zapnout volbu
<code>Auto Save</code>.</p>
<h2><a class="header" href="#automatickÃ©-formÃ¡tovÃ¡nÃ­-kÃ³du" id="automatickÃ©-formÃ¡tovÃ¡nÃ­-kÃ³du">AutomatickÃ© formÃ¡tovÃ¡nÃ­ kÃ³du</a></h2>
<p>Pokud s programovÃ¡nÃ­m zaÄÃ­nÃ¡te, tak budete ze zaÄÃ¡tku nejspÃ­Å¡e trochu bojovat s tÃ­m, jak zformÃ¡tovat zdrojovÃ½ kÃ³d,
aby byl pÅ™ehlednÃ½ a dalo se v nÄ›m vyznat. Tuto Äinnost vÅ¡ak mÅ¯Å¾ete nechat plnÄ› na editoru Äi vÃ½vojovÃ©m prostÅ™edÃ­.
Ve Visual Studio Code mÅ¯Å¾ete pouÅ¾Ã­t klÃ¡vesovou zkratku <code>Ctrl + Shift + I</code>, kterÃ¡ vÃ¡m prÃ¡vÄ› otevÅ™enÃ½ soubor s kÃ³dem
automaticky zformÃ¡tuje.</p>
<p>MÅ¯Å¾ete si dokonce editor nastavit tak, aby po kaÅ¾dÃ©m uloÅ¾enÃ­ souboru kÃ³d automaticky zformÃ¡toval. KliknÄ›te na
<code>File -&gt; Preferences -&gt; Settings</code>, potÃ© do vyhledÃ¡vacÃ­ho okÃ©nka napiÅ¡te <code>Format On Save</code> a zaÅ¡krtnÄ›te tuto moÅ¾nost:
<img src="prostredi/../static/img/vsc-format-on-save.png" alt="" /></p>
<h2><a class="header" href="#pokroÄilÃ©-moÅ¾nosti-nastavenÃ­-projektu" id="pokroÄilÃ©-moÅ¾nosti-nastavenÃ­-projektu">PokroÄilÃ© moÅ¾nosti nastavenÃ­ projektu</a></h2>
<p>Pokud byste si chtÄ›li nastavit VSCode tak, aby pÅ™eklÃ¡dal nebo spouÅ¡tÄ›l vÃ¡Å¡ program s jinÃ½m, neÅ¾ zÃ¡kladnÃ­m
nastavenÃ­m, mÅ¯Å¾ete k tomu vyuÅ¾Ã­t konfiguraci pomocÃ­ souborÅ¯ <code>launch.json</code>, kterÃ½ definuje, jak bude VSCode
vÃ¡Å¡ program spouÅ¡tÄ›t, pÅ™Ã­padnÄ› <code>tasks.json</code>, pomocÃ­ kterÃ©ho mÅ¯Å¾eme nastavit, jak se bude program pÅ™eklÃ¡dat.</p>
<p><code>launch.json</code> je moÅ¾no vytvoÅ™it po kliknutÃ­ na zÃ¡loÅ¾ku <code>Run and Debug</code> (Ctrl+Shift+D) a potÃ© na tlaÄÃ­tko <code>create a launch.json file</code> (tlaÄÃ­tko se zobrazÃ­, pokud mÃ¡te otevÅ™enÃ½ C soubor ve VSCode). Soubor se vytvoÅ™Ã­ v souÄasnÄ› otevÅ™enÃ©m
adresÃ¡Å™i, ve sloÅ¾ce <code>.vscode</code> (mÅ¯Å¾ete ho pÅ™Ã­padnÄ› i vytvoÅ™it manuÃ¡lnÄ›).</p>
<p>Do vygenerovanÃ©ho souboru mÅ¯Å¾ete zkopÃ­rovat tento obsah:</p>
<pre><code class="language-json">{
    &quot;version&quot;: &quot;0.2.0&quot;,
    &quot;configurations&quot;: [
        {
            &quot;name&quot;: &quot;C program (gdb) Launch&quot;,
            &quot;type&quot;: &quot;cppdbg&quot;,
            &quot;request&quot;: &quot;launch&quot;,
            &quot;program&quot;: &quot;${workspaceFolder}/main&quot;,
            &quot;args&quot;: [],
            &quot;cwd&quot;: &quot;${workspaceFolder}&quot;,
            &quot;MIMode&quot;: &quot;gdb&quot;,
            &quot;miDebuggerPath&quot;: &quot;/usr/bin/gdb&quot;,
            &quot;preLaunchTask&quot;: &quot;C compile&quot;,
        }
    ]
}
</code></pre>
<p>Atributy tÃ©to konfigurace potÃ© mÅ¯Å¾ete upravovat. UÅ¾iteÄnÃ© pro vÃ¡s budou zejmÃ©na tyto atributy:</p>
<ul>
<li><strong>program</strong> - cesta ke <strong>spustitelnÃ©mu</strong> (pÅ™eloÅ¾enÃ©mu) souboru, kterÃ½ bude konfigurace spouÅ¡tÄ›t</li>
<li><strong>cwd</strong> - pracovnÃ­ adresÃ¡Å™, ve kterÃ©m se program spustÃ­</li>
<li><strong>args</strong> - <a href="prostredi/../ruzne/funkce_main.html#vstupn%C3%AD-parametry-funkce-main">argumenty pÅ™Ã­kazovÃ©ho Å™Ã¡dku</a> pÅ™edanÃ©
spouÅ¡tÄ›nÃ©mu programu</li>
</ul>
<p>Pokud byste si chtÄ›li pÅ™i ladÄ›nÃ­ pÅ™esmÄ›rovat obsah souboru na <a href="prostredi/../c/text/vstup.html">standardnÃ­ vstup</a> programu,
tak pÅ™idejte na konec <code>args</code> Å¡ipku doleva a cestu k souboru, kterÃ½ chcete pÅ™esmÄ›rovat na vstup:</p>
<pre><code class="language-json">&quot;args&quot;: [
    &quot;&lt;&quot;,
    &quot;${workspaceFolder}/stdin_file.stdin&quot;
]
</code></pre>
<p>DÃ¡le budete muset nastavit soubor <strong>tasks.json</strong>, pro automatickÃ½ pÅ™eklad programu
(vytvoÅ™te jej opÄ›t ve <code>.vscode</code> sloÅ¾ce projektu). Pokud tento soubor bude chybÄ›t, pÅ™i pokusu o ladÄ›nÃ­ programu
dostanete chybovou hlÃ¡Å¡ku podobnou tÃ©to:</p>
<blockquote>
<p>launch: program <code>&lt;cesta&gt;/main</code> does not exists</p>
</blockquote>
<p>Do <code>tasks.json</code> si mÅ¯Å¾ete zkopÃ­rovat tento obsah:</p>
<pre><code class="language-json">{
    &quot;version&quot;: &quot;2.0.0&quot;,
    &quot;tasks&quot;: [
        {
            &quot;type&quot;: &quot;cppbuild&quot;,
            &quot;label&quot;: &quot;C compile&quot;,
            &quot;command&quot;: &quot;gcc&quot;,
            &quot;args&quot;: [
                &quot;${workspaceFolder}/main.c&quot;,
                &quot;-o&quot;,
                &quot;${workspaceFolder}/main&quot;
            ]
        }
    ]
}
</code></pre>
<p>Zde jsou dÅ¯leÅ¾itÃ© hlavnÄ› dva atributy:</p>
<ul>
<li><strong>label</strong> - nÃ¡zev tasku pro spuÅ¡tÄ›nÃ­. <strong>Tento nÃ¡zev musÃ­ odpovÃ­dat atributu <code>preLaunchTask</code> v souboru <code>launch.json</code></strong>.</li>
<li><strong>args</strong> - <a href="prostredi/../ruzne/parametry_prekladace.html">parametry pÅ™ekladaÄe</a> pouÅ¾itÃ© pÅ™i pÅ™ekladu.
<ul>
<li>PrvnÃ­m argumentem by mÄ›la bÃ½t cesta k pÅ™eklÃ¡danÃ©mu C zdrojovÃ©mu souboru.</li>
<li>DÃ¡le by v <code>args</code> mÄ›la bÃ½t cesta k vÃ½slednÃ©mu pÅ™eloÅ¾enÃ©ho souboru, pÅ™edanÃ¡ za parametrem <code>-o</code>.
<strong>Tato cesta musÃ­ odpovÃ­dat atributu <code>program</code> v souboru <code>launch.json</code></strong>.</li>
<li>DÃ¡le zde mÅ¯Å¾ete pÅ™edÃ¡vat dalÅ¡Ã­ parametry pÅ™ekladaÄe, napÅ™. zapnout <a href="prostredi/ladeni.html#address-sanitizer">Address sanitizer</a>
(<code>-fsanitize=address</code>) nebo pÅ™ilinkovat nÄ›jakÃ© <a href="prostredi/../c/modularizace/knihovny.html">knihovny</a> (napÅ™. <code>-lm</code>).</li>
</ul>
</li>
</ul>
<p>VÃ­ce informacÃ­ o moÅ¾nostech nastavenÃ­ tÄ›chto dvou souborÅ¯ mÅ¯Å¾ete naleznout na tÄ›chto odkazech:</p>
<ul>
<li><a href="https://code.visualstudio.com/docs/cpp/launch-json-reference">Microsoft Configure C/C++ debugging</a></li>
<li><a href="https://code.visualstudio.com/docs/editor/variables-reference">Microsoft Variables Reference</a></li>
</ul>
<h2><a class="header" href="#uÅ¾iteÄnÃ©-zkratky" id="uÅ¾iteÄnÃ©-zkratky">UÅ¾iteÄnÃ© zkratky</a></h2>
<ul>
<li>Spustit program - <code>F5</code></li>
<li>NaformÃ¡tovat kÃ³d - <code>Ctrl + Shift + I</code></li>
<li>UloÅ¾it provedenÃ© zmÄ›ny v souboru - <code>Ctrl + S</code></li>
<li>Zobrazit vyhledÃ¡vaÄ akcÃ­ - <code>Ctrl + Shift + P</code></li>
</ul>
<h1><a class="header" href="#pÅ™eklad-programu" id="pÅ™eklad-programu">PÅ™eklad programu</a></h1>
<p>Pro pÅ™eklad programÅ¯, kterÃ© budeme psÃ¡t v jazyce <em>C</em>, do <strong>spustitelnÃ©ho</strong> (<em>executable</em>) souboru
budeme pouÅ¾Ã­vat program, kterÃ©mu se Å™Ã­kÃ¡ pÅ™ekladaÄ.
PÅ™ekladaÄÅ¯ jazyka <em>C</em> existuje celÃ¡ Å™ada, my budeme vyuÅ¾Ã­vat asi nejpouÅ¾Ã­vanÄ›jÅ¡Ã­ pÅ™ekladaÄ pro
LinuxovÃ© systÃ©my s nÃ¡zvem <a href="https://gcc.gnu.org/"><strong>GCC</strong></a> (GNU Compiler Collection). </p>
<p>PÅ™ekladaÄ <code>gcc</code>, spolu s dalÅ¡Ã­mi potÅ™ebnÃ½mi nÃ¡stroji, mÅ¯Å¾ete na Ubuntu v terminÃ¡lu nainstalovat
pomocÃ­ nÃ¡sledujÃ­cÃ­ch dvou pÅ™Ã­kazÅ¯:</p>
<pre><code class="language-bash">$ sudo apt update
$ sudo apt install build-essential gdb
</code></pre>
<blockquote>
<p>PÅ™i pokusu o instalaci vÃ¡s program vyzve, abyste instalaci potvrdili. UdÄ›lejte to zmÃ¡ÄknutÃ­m klÃ¡vesy <code>y</code>
a potvrÄte klÃ¡vesou Enter.</p>
</blockquote>
<h2><a class="header" href="#pÅ™eklad-prvnÃ­ho-programu" id="pÅ™eklad-prvnÃ­ho-programu">PÅ™eklad prvnÃ­ho programu</a></h2>
<p>JeÅ¡tÄ› neÅ¾ si ukÃ¡Å¾eme, jak vlastnÄ› programovacÃ­ jazyk <em>C</em> funguje, tak zkusÃ­me pÅ™eloÅ¾it velmi jednoduchÃ½
<em>C</em> program do spustitelnÃ©ho souboru a spustit jej.
VytvoÅ™te soubor s nÃ¡zvem <code>main.c</code> a nakopÃ­rujte<sup class='margin-toggle sidenote-number'>1</sup> do nÄ›j nÃ¡sledujÃ­cÃ­ <em>C</em> kÃ³d (pozdÄ›ji si vysvÄ›tlÃ­me,
jak tento kÃ³d funguje):</p>
<span class='sidenote'><p><sup class='number'>1</sup>KÃ³d z bunÄ›k mÅ¯Å¾ete kopÃ­rovat pomocÃ­ tlaÄÃ­tka <i class="fa fa-copy"></i> v pravÃ©m hornÃ­m rohu
buÅˆky s kÃ³dem.</p>
</span>
<pre><code class="language-c editable">#include &lt;stdio.h&gt;

int main() {
    printf(&quot;Hello world!\n&quot;);
    return 0;
}
</code></pre>
<blockquote>
<p>Tento program se nazÃ½vÃ¡ <code>Hello world</code>, jelikoÅ¾ tento text vypÃ­Å¡e na obrazovku.
PodobnÃ½ jednoduchÃ½ program je zpravidla tÃ­m prvnÃ­m, co programÃ¡tor vytvoÅ™Ã­, kdyÅ¾ se uÄÃ­ nÄ›jakÃ½
programovacÃ­ jazyk.</p>
</blockquote>
<p>NynÃ­ otevÅ™ete terminÃ¡l (<code>Ctrl + Alt + T</code> v Ubuntu), pÅ™esuÅˆte se do sloÅ¾ky s tÃ­mto souborem pomocÃ­
pÅ™Ã­kazu <code>cd</code>, spusÅ¥te program <code>gcc</code> a pÅ™edejte mu cestu k tomuto souboru:</p>
<pre><code class="language-bash">$ gcc main.c -o program
</code></pre>
<p>TÃ­mto pÅ™Ã­kazem Å™eknete &quot;GÃ©cÃ©cÃ©Äku&quot;, aby pÅ™eloÅ¾il zdrojovÃ½ soubor <code>main.c</code> a uloÅ¾il vÃ½slednÃ½ spustitelnÃ½
soubor do souboru <code>program</code><sup class='margin-toggle sidenote-number'>2</sup>. Pokud byste pÅ™epÃ­naÄ <code>-o &lt;nazev souboru&gt;</code> nepouÅ¾ili, tak se vytvoÅ™Ã­ spustitelnÃ½
soubor s nÃ¡zvem <code>a.out</code>.</p>
<span class='sidenote'><p><sup class='number'>2</sup>Na Windowsu spustitelnÃ© soubory majÃ­ obvykle pÅ™Ã­ponu <code>.exe</code>, na Linuxu to vÅ¡ak nenÃ­ bÄ›Å¾nou praxÃ­ a spustitelnÃ© soubory typicky Å¾Ã¡dnou pÅ™Ã­ponu nemajÃ­.</p>
</span>
<p>Pokud chcete nynÃ­ program spustit, staÄÃ­ v terminÃ¡lu zadat cestu k danÃ©mu spustitelnÃ©mu souboru.</p>
<pre><code class="language-bash">$ ./program
Hello world!
</code></pre>
<p>Program by mÄ›l na vÃ½stup vytisknout text <code>Hello world!</code>.</p>
<details>
<summary>Tipy pro prÃ¡ci s pÅ™Ã­kazovou Å™Ã¡dkou</summary>
<ul>
<li>PÅ™i psanÃ­ programu budete chtÃ­t Äasto po ÃºpravÄ› zdrojovÃ©ho kÃ³du opÄ›tovnÄ› provÃ©st pÅ™eklad a potÃ©
program spustit. Abyste to provedli v jednom terminÃ¡lovÃ©m pÅ™Ã­kazu, mÅ¯Å¾ete tyto dva pÅ™Ã­kazy spojit pomocÃ­ <code>&amp;&amp;</code>:
<pre><code class="language-bash">$ gcc main.c -o main &amp;&amp; ./main
</code></pre>
Pokud pÅ™eklad probÄ›hne ÃºspÄ›Å¡nÄ›, tak operÃ¡tor <code>&amp;&amp;</code> zajistÃ­ spuÅ¡tÄ›nÃ­ nÃ¡sledujÃ­cÃ­ho pÅ™Ã­kazu.</li>
<li>Pokud nechcete pÅ™Ã­kazy v terminÃ¡lu psÃ¡t neustÃ¡le dokola, Å¡ipkou nahoru (â†‘) mÅ¯Å¾ete vyvolat nedÃ¡vno
spuÅ¡tÄ›nÃ© pÅ™Ã­kazy v terminÃ¡lu.</li>
<li>MÅ¯Å¾ete pouÅ¾Ã­vat i terminÃ¡l vestavenÃ½ pÅ™Ã­mo ve <code>Visual Studio Code</code> (<code>View -&gt; Terminal</code>).</li>
</ul>
</details>
<p>ğŸ“¹ Pro lepÅ¡Ã­ pÅ™edstavu o pÅ™ekladu programÅ¯ zde mÃ¡te k dispozici jeÅ¡tÄ› krÃ¡tkÃ© shrnujÃ­cÃ­ video:</p>
<iframe width="560" height="315" src="https://www.youtube.com/embed/Hu7l9NpQ3g8" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
<h3><a class="header" href="#jak-pÅ™eklad-probÃ­hÃ¡" id="jak-pÅ™eklad-probÃ­hÃ¡">Jak pÅ™eklad probÃ­hÃ¡?</a></h3>
<p>PÅ™eklad programu bude detailnÄ› vysvÄ›tlen pozdÄ›ji v sekci o <a href="prostredi/../c/modularizace/linker.html">linkeru</a>.
ProzatÃ­m nÃ¡m bude staÄit tato zkrÃ¡cenÃ¡ verze:</p>
<p>PÅ™eklad programÅ¯ probÃ­hÃ¡ ve dvou hlavnÃ­ch fÃ¡zÃ­ch: <strong>pÅ™eklad</strong> (<em>translation</em>) a <strong>linkovÃ¡nÃ­</strong> (<em>linking</em>).
Dohromady se oboum tÄ›mto krokÅ¯m takÃ© Å™Ã­kÃ¡ <strong>kompilace</strong> (<em>compilation</em>).</p>
<p>PÅ™i pÅ™ekladu pÅ™ekladaÄ vezme kaÅ¾dÃ½ <em>C</em> zdrojovÃ½ soubor, kterÃ½ mu pÅ™edloÅ¾Ã­me, a samostatnÄ› jej pÅ™eloÅ¾Ã­
do tzv. <strong>objektovÃ©ho souboru</strong> (<em>object file</em>). TakovÃ½to soubor obsahuje jiÅ¾ pÅ™eloÅ¾enÃ© instrukce pro
procesor, ale nenÃ­ sÃ¡m o sobÄ› spustitelnÃ½, tj. nejednÃ¡ se o program, ale pouze o pÅ™eloÅ¾enÃ½ binÃ¡rnÃ­ kÃ³d.</p>
<p>Jakmile jsou vÅ¡echny zdrojovÃ© soubory pÅ™eloÅ¾eny do objektovÃ½ch souborÅ¯, tak pÅ™ichÃ¡zÃ­ na Å™adu dalÅ¡Ã­
program, tzv. <strong>linker</strong>, kterÃ½ tyto objektovÃ© soubory spojÃ­ dohromady,
<a href="https://cs.wikipedia.org/wiki/Linker#Funkce_linkeru">propojÃ­</a> je dle potÅ™eby, pÅ™Ã­padnÄ› k nim pÅ™ipojÃ­
externÃ­ <a href="prostredi/../c/modularizace/knihovny.html">knihovny</a> a na konci vytvoÅ™Ã­ finÃ¡lnÃ­ spustitelnÃ½ soubor, kterÃ½ lze potÃ©
spustit.</p>
<p>KdyÅ¾ pouÅ¾ijete program <code>gcc</code> zpÅ¯sobem, jakÃ½ jsme si ukÃ¡zali vÃ½Å¡e, tak se na pozadÃ­ spustÃ­ pÅ™ekladaÄ
a potÃ© i linker a oba dva tyto kroky se tak provedou automaticky. Je ale moÅ¾nÃ© provÃ©st je i separÃ¡tnÄ›:</p>
<pre><code class="language-bash">$ gcc -c main.c      # vytvoÅ™Ã­ objektovÃ½ soubor main.o
$ gcc main.o -o main # slinkovÃ¡nÃ­ souboru main.o 
</code></pre>
<h1><a class="header" href="#ladÄ›nÃ­-programÅ¯" id="ladÄ›nÃ­-programÅ¯">LadÄ›nÃ­ programÅ¯</a></h1>
<p>Tato sekce slouÅ¾Ã­ k Å™eÅ¡enÃ­ Äasto se vyskytujÃ­cÃ­ch problÃ©mÅ¯ pÅ™i programovÃ¡nÃ­ v C. Pokud vÃ¡Å¡ program
padÃ¡ pÅ™i bÄ›hu nebo se nechovÃ¡ tak, jak mÃ¡, tak v nÄ›m nejspÃ­Å¡e mÃ¡te nÄ›jakou chybu (tzv. <strong>bug</strong>).
Proces hledÃ¡nÃ­ chyby, kterÃ¡ zpÅ¯sobuje pÃ¡d nebo Å¡patnÃ© chovÃ¡nÃ­ programu se pak nazÃ½vÃ¡ <strong>ladÄ›nÃ­</strong> (<em>debugging</em>).</p>
<h3><a class="header" href="#chyby-pÅ™i-pÅ™ekladu-programu" id="chyby-pÅ™i-pÅ™ekladu-programu">Chyby pÅ™i pÅ™ekladu programu</a></h3>
<p>Pokud vÃ¡Å¡ program nelze pÅ™eloÅ¾it a pÅ™ekladaÄ vypisuje nÄ›jakou chybovou hlÃ¡Å¡ku, tak mÃ¡te v zÃ¡pisu programu
nÄ›jakou chybu, obvykle v syntaxi, tedy zÃ¡pisu kÃ³du. Je dobrÃ© si danou chybovou hlÃ¡Å¡ku poÅ™Ã¡dnÄ› pÅ™eÄÃ­st,
obvykle se odkazuje na relativnÄ› pÅ™esnÃ© mÃ­sto, kde mÃ¡te kÃ³d Å¡patnÄ›, a nÄ›kdy dokonce i nabÃ­zÃ­ Å™eÅ¡enÃ­,
jak problÃ©m vyÅ™eÅ¡it.</p>
<p>PÅ™i pÅ™ekladu mÅ¯Å¾ete dostat napÅ™Ã­klad nÃ¡sledujÃ­cÃ­ chybovou hlÃ¡Å¡ku:</p>
<pre><code class="language-bash">main.c: In function â€˜mainâ€™:
main.c:2:2: error: â€˜aâ€™ undeclared (first use in this function)
    2 |  a = 0;
</code></pre>
<p>Tato konkrÃ©tnÃ­ chyba byla zpÅ¯sobena tÃ­m, Å¾e byla pouÅ¾itÃ¡ promÄ›nnÃ¡ bez jejÃ­ pÅ™edchozÃ­ deklarace. Pokud
chybÄ› nerozumÃ­te, zkuste ji nejprve vygooglit, ideÃ¡lnÄ› pouze ÄÃ¡st, kterÃ¡ nenÃ­ konkrÃ©tnÄ› zÃ¡vislÃ¡ na
podobÄ› vaÅ¡eho projektu. NemÃ¡ cenu googlit <code>main.c:2:2</code>, protoÅ¾e tento text je zÃ¡vislÃ½ na tom, jak jste
si pojmenovali svÃ© soubory, ostatnÃ­ programÃ¡toÅ™i nejspÃ­Å¡e majÃ­ jinÃ© nÃ¡zvy souborÅ¯. V pÅ™Ã­padÄ› tÃ©to chyby
by tedy bylo lepÅ¡Ã­ googlit text <code>error: undeclared (first use in this function)</code>.</p>
<p>MÅ¯Å¾e se stÃ¡t, Å¾e pÅ™ekladaÄ vypÃ­Å¡e vÃ­ce chybovÃ½ch hlÃ¡Å¡ek zÃ¡roveÅˆ, i kdyÅ¾ chyba
v programu je pouze jedna. Zkuste scrollovat vÃ½stupem hlÃ¡Å¡ek nahoru, abyste zjistili, kterÃ¡ chyba
byla vypsÃ¡na jako prvnÃ­, zbytek vÃ½pisu mÅ¯Å¾e bÃ½t &quot;planÃ½ poplach&quot;.</p>
<p>Pokud se vÃ¡m nedaÅ™Ã­ chybu vygooglit, tak kontaktujte svÃ©ho cviÄÃ­cÃ­ho.</p>
<p>PÅ™i pÅ™ekladu mÅ¯Å¾ete pouÅ¾Ã­t dodateÄnÃ© pÅ™epÃ­naÄe, pÅ™i jejichÅ¾ pouÅ¾itÃ­ vydÃ¡ pÅ™ekladaÄ vÃ­ce varovÃ¡nÃ­ o
moÅ¾nÃ½ch problÃ©movÃ½ch mÃ­stech ve vaÅ¡em kÃ³du:</p>
<pre><code class="language-bash">$ gcc -Wall -Wextra -pedantic main.c -o program
</code></pre>
<p>PodÃ­vejte se takÃ© do sekce <a href="prostredi/../caste_chyby/caste_chyby.html">ÄŒastÃ© chyby</a>, kde je seznam Äasto se
vyskytujÃ­cÃ­ch chyb.</p>
<h3><a class="header" href="#chyby-pÅ™i-bÄ›hu-programu" id="chyby-pÅ™i-bÄ›hu-programu">Chyby pÅ™i bÄ›hu programu</a></h3>
<p>Pokud vÃ¡Å¡ program tzv. &quot;padÃ¡&quot; pÅ™i bÄ›hu, mÅ¯Å¾ete zkusit nÃ¡sledujÃ­cÃ­ zpÅ¯soby ladÄ›nÃ­:</p>
<h4><a class="header" href="#address-sanitizer" id="address-sanitizer">Address sanitizer</a></h4>
<p>Tento nÃ¡stroj modifikuje vÃ¡Å¡ program tak, aby dokÃ¡zal detekovat znaÄnÃ© mnoÅ¾stvÃ­ chyb pÅ™i jeho bÄ›hu,
a pokud nÄ›jakou chybu najde, tak vÃ¡Å¡ program okamÅ¾itÄ› ukonÄÃ­ a popÃ­Å¡e, k jakÃ©mu problÃ©mu doÅ¡lo. </p>
<pre><code class="language-bash">$ gcc -g -fsanitize=address main.c -o program
</code></pre>
<p>Jakmile takto pÅ™eloÅ¾enÃ½ program spustÃ­te a dojde k nÄ›jakÃ© chybÄ›, tak bude jejÃ­ popis vypsÃ¡n na vÃ½stup.</p>
<p>Pokud se chyba opravÃ­ tÄ›snÄ› po svÃ©m vzniku, je to mnohem jednoduÅ¡Å¡Ã­, neÅ¾ kdyÅ¾ se chyba projevÃ­ aÅ¾
pozdÄ›ji v ÃºplnÄ› jinÃ© ÄÃ¡sti kÃ³du. <strong>DoporuÄujeme tak vÅ¾dy pouÅ¾Ã­vat Address Sanitizer pÅ™i vÃ½voji programÅ¯ v C</strong>.
UÅ¡etÅ™Ã­te si tak spoustu Äasu a nÃ¡mahy pÅ™i ladÄ›nÃ­ chyb.</p>
<h4><a class="header" href="#valgrind" id="valgrind">Valgrind</a></h4>
<p>Address sanitizer je velmi uÅ¾iteÄnÃ½ nÃ¡stroj, ale nedokÃ¡Å¾e odhalit vÅ¡echny problÃ©movÃ© situace v programech napsanÃ½ch v
jazyce <em>C</em>. DÃ¡le existuje takÃ© nÃ¡stroj <a href="https://valgrind.org/">Valgrind</a>, kterÃ½ dokÃ¡Å¾e odhalit moÅ¾nÃ½ch chyb vÃ­ce
(napÅ™. ÄtenÃ­ z <a href="prostredi/../c/promenne/promenne.html#v%C5%BEdy-inicializujte-prom%C4%9Bnn%C3%A9">nedefinovanÃ© promÄ›nnÃ©</a>). Pokud
se vÃ¡s program chovÃ¡ &quot;divnÄ›&quot;, a Address sanitizer v nÄ›m nenachÃ¡zÃ­ Å¾Ã¡dnÃ© chyby, mÅ¯Å¾ete mÃ­sto nÄ›j zkusit Valgrind s
nÃ¡strojem Memcheck:</p>
<ol>
<li>Nejprve si nainstalujte Valgrind:
<pre><code class="language-bash">$ sudo apt-get install valgrind
</code></pre>
</li>
<li>A potÃ© spusÅ¥te svÅ¯j pÅ™eloÅ¾enÃ½ program pod Valgrindem/Memcheckem:
<pre><code class="language-bash">$ valgrind --tool=memcheck --track-origins=yes --leak-check=full -s ./program
</code></pre>
</li>
</ol>
<p>Valgrind a Address sanitizer nelze kombinovat, proto pÅ™i pouÅ¾itÃ­ Valgrindu <strong>nepouÅ¾Ã­vejte</strong> parametr pÅ™ekladaÄe
<code>-fsanitize=address</code>. StaÄÃ­ program pÅ™eloÅ¾it pomocÃ­ <code>gcc -g main.c -o program</code>.</p>
<h4><a class="header" href="#logovÃ¡nÃ­" id="logovÃ¡nÃ­">LogovÃ¡nÃ­</a></h4>
<p>JednÃ­m z nejjednoduÅ¡Å¡Ã­ch zpÅ¯sobÅ¯, jak se dozvÄ›dÄ›t, co se v programu dÄ›je, je jednoduÅ¡e tisknout
hodnoty zajÃ­mavÃ½ch promÄ›nnÃ½ch na vÃ½stup programu. Pokud pÅ™idÃ¡te takovÃ½to vÃ½stup na rÅ¯znÃ¡ mÃ­sta v kÃ³du,
mÅ¯Å¾ete pak podle vÃ½stupu zpÄ›tnÄ› rekonstruovat, co se pÅ™i bÄ›hu programu dÄ›lo.</p>
<h4><a class="header" href="#krokovÃ¡nÃ­" id="krokovÃ¡nÃ­">KrokovÃ¡nÃ­</a></h4>
<p>Pro interaktivnÄ›jÅ¡Ã­ zkoumÃ¡nÃ­ chovÃ¡nÃ­ programÅ¯ je moÅ¾nÃ© je tzv. <strong>krokovat</strong>. K tomu je potÅ™eba nÃ¡stroj,
kterÃ½ umÃ­ program pozastavit pÅ™i jeho bÄ›hu a zobrazit uÅ¾ivateli, co se v nÄ›m dÄ›je. TakovÃ©to nÃ¡stroje se nazÃ½vajÃ­
<strong>debuggery</strong>. PÅ™i krokovÃ¡nÃ­ se program zastavÃ­ na urÄitÃ©m mÃ­stÄ› (Å™Ã¡dku) v kÃ³du, a programÃ¡tor pak mÅ¯Å¾e
zkoumat hodnoty promÄ›nnÃ½ch a spouÅ¡tÄ›t program Å™Ã¡dek po Å™Ã¡dku.</p>
<blockquote>
<p>DoporuÄujeme za zaÄÃ¡tku pouÅ¾Ã­vat <strong>krokovÃ¡nÃ­</strong> neustÃ¡le, abyste se nauÄili, jak se vlastnÄ› program
provÃ¡dÃ­ a lÃ©pe tak pochopili, co vykonÃ¡vajÃ­ jednotlivÃ© pÅ™Ã­kazy, kterÃ© v kÃ³du pÃ­Å¡ete. Je to takÃ© mocnÃ½
nÃ¡stroj na hledÃ¡nÃ­ chyb v programech.</p>
</blockquote>
<p>Pro vÃ¡s je nejjednoduÅ¡Å¡Ã­ pouÅ¾Ã­t krokovÃ¡nÃ­ integrovanÃ© ve VSCode:</p>
<ul>
<li>KliknÄ›te na sloupeÄek vlevo od ÄÃ­sla Å™Ã¡dku, na kterÃ©m chcete, aby se program zastavil.
ObjevÃ­ se tam ÄervenÃ© koleÄko (tzv. <strong>breakpoint</strong>).</li>
<li>SpusÅ¥te program s ladÄ›nÃ­m (<code>F5</code>). Program by se na Å™Ã¡dku s breakpointem mÄ›l zastavit.</li>
<li>Ve sloupci <code>Variables</code> v levÃ© ÄÃ¡sti VSCode mÅ¯Å¾ete prozkoumat hodnoty promÄ›nnÃ½ch.</li>
<li>PomocÃ­ pÅ™Ã­kazu <code>Step Over</code> (<code>F10</code>) program vykonÃ¡ nÃ¡sledujÃ­cÃ­ Å™Ã¡dek a potÃ© se opÄ›t zastavÃ­. Pokud
nechcete pÅ™eskakovat volÃ¡nÃ­ funkcÃ­, pouÅ¾ijte <code>Step Into</code> (<code>F11</code>).</li>
</ul>
<p><video src="../static/video/debugging.webm" controls></video></p>
<blockquote>
<p>VSCode pouÅ¾Ã­vÃ¡ pro ladÄ›nÃ­ vaÅ¡eho programu debugger <code>gdb</code>. Pokud ho chcete pouÅ¾Ã­t manuÃ¡lnÄ›, nÃ¡vod
mÅ¯Å¾ete najÃ­t napÅ™Ã­klad <a href="https://www.root.cz/clanky/trasovani-a-ladeni-nativnich-aplikaci-v-linuxu-pouziti-gdb-a-jeho-nadstaveb/">zde</a>.</p>
</blockquote>
<h1><a class="header" href="#programovÃ¡nÃ­-v-c" id="programovÃ¡nÃ­-v-c">ProgramovÃ¡nÃ­ v <em>C</em></a></h1>
<p>V tÃ©to kapitole naleznete popis zÃ¡kladnÃ­ch konstrukcÃ­ jazyka <em>C</em>, kterÃ© jsou zÃ¡kladnÃ­mi
stavebnÃ­mi kameny pro tvorbu programÅ¯. Ke kaÅ¾dÃ©mu tÃ©matu je k dispozici takÃ© sada Ãºloh. Pokud Ãºlohy
zvlÃ¡dnete vypracovat, tak budete mÃ­t jistotu, Å¾e jste danÃ© tÃ©ma pochopili a mÅ¯Å¾ete se posunout dÃ¡le.
Pokud nezvlÃ¡dnete Ãºlohy splnit, tak mÅ¯Å¾ete mÃ­t s navazujÃ­cÃ­mi koncepty problÃ©m. Pokud nebudete
stÃ­hat, tak kontaktujte svÃ©ho cviÄÃ­cÃ­ho.</p>
<p>PÅ™ed pÅ™eÄtenÃ­m tÃ©to kapitoly si nejprve pÅ™eÄtÄ›te pÅ™edchozÃ­ kapitoly, zejmÃ©na sekci o
<a href="c/../uvod/pamet.html">pamÄ›ti</a>.</p>
<p>NÃ­Å¾e je pÅ™ibliÅ¾nÃ½ seznam tÃ©mat, kterÃ© si bÄ›hem semestru ukÃ¡Å¾eme. PoÅ™adÃ­ tÃ©mat probÃ­ranÃ½ch na cviÄenÃ­
a pÅ™ednÃ¡Å¡kÃ¡ch se mÅ¯Å¾e od tohoto seznamu liÅ¡it, tento text je urÄen spÃ­Å¡e jako &quot;kuchaÅ™ka&quot;, ve kterÃ©
se mÅ¯Å¾ete k jednotlivÃ½m tÃ©matÅ¯m vracet, abyste si je pÅ™ipomnÄ›li. Text je nicmÃ©nÄ› psanÃ½ tak, aby se
dal zhruba ÄÃ­st v uvedenÃ©m poÅ™adÃ­ bez toho, aby pouÅ¾Ã­val pojmy, kterÃ© zatÃ­m nebyly vysvÄ›tleny.</p>
<h2><a class="header" href="#zÃ¡kladnÃ­-tÃ©mata" id="zÃ¡kladnÃ­-tÃ©mata">ZÃ¡kladnÃ­ tÃ©mata</a></h2>
<ul>
<li><a href="c/syntaxe.html">Syntaxe</a> - jak vypadÃ¡ syntaxe (zpÅ¯sob zÃ¡pisu) jazyka <em>C</em></li>
<li><a href="c/prikazy_vyrazy.html">PÅ™Ã­kazy a vÃ½razy</a> - jak provÃ¡dÄ›t vÃ½poÄty</li>
<li><a href="c/promenne/promenne.html">PromÄ›nnÃ©</a> - jak nÄ›co uloÅ¾it a naÄÃ­st z pamÄ›ti</li>
<li><a href="c/datove_typy/datove_typy.html">DatovÃ© typy</a> - jak interpretovat hodnoty v pamÄ›ti</li>
<li><a href="c/rizeni_toku/rizeni_toku.html">Å˜Ã­zenÃ­ toku</a> - jak se rozhodovat a provÃ¡dÄ›t akce opakovanÄ›</li>
<li><a href="c/funkce/funkce.html">Funkce</a> - jak opakovanÄ› vyuÅ¾Ã­t a parametrizovat opakujÃ­cÃ­ se kÃ³d</li>
<li><a href="c/prace_s_pameti/ukazatele.html">Ukazatele</a> - jak sdÃ­let data v pamÄ›ti a pracovat s adresami</li>
<li><a href="c/pole/pole.html">Pole</a> - jak jednotnÄ› pracovat s velkÃ½m mnoÅ¾stvÃ­m dat</li>
<li><a href="c/text/text.html">Text</a> - jak v programech pracovat s textem</li>
<li><a href="c/struktury/vlastni_datove_typy.html">Struktury</a> - jak vytvoÅ™it vlastnÃ­ datovÃ© typy</li>
<li><a href="c/soubory/soubory.html">Soubory</a> - jak ÄÃ­st a zapisovat soubory</li>
<li><a href="c/modularizace/modularizace.html">Modularizace</a> - jak rozdÄ›lit program do vÃ­ce zdrojovÃ½ch souborÅ¯</li>
<li><a href="c/modularizace/knihovny.html">Knihovny</a> - jak vyuÅ¾Ã­t existujÃ­cÃ­ kÃ³d od jinÃ½ch programÃ¡torÅ¯</li>
</ul>
<p>VÅ¡echny tyto koncepty jsou velmi univerzÃ¡lnÃ­ a v
tzv. <a href="https://cs.wikipedia.org/wiki/Imperativn%C3%AD_programov%C3%A1n%C3%AD">imperativnÃ­ch</a>
programovacÃ­ch jazycÃ­ch jsou v podstatÄ› vÅ¡udypÅ™Ã­tomnÃ©. Jakmile se je jednou nauÄÃ­te, tak je budete
moct vyuÅ¾Ã­vat tÃ©mÄ›Å™ v libovolnÃ©m populÃ¡rnÃ­m programovacÃ­m jazyku (Java, C#, Kotlin, Python, PHP,
Javascript, Rust, C++ atd.).</p>
<p>Zkomprimovanou formu tÄ›chto tÃ©mat mÅ¯Å¾ete naleznout v <a href="c/../ruzne/tahak.html">tahÃ¡ku</a>.</p>
<h2><a class="header" href="#navazujÃ­cÃ­-aplikovanÃ¡-tÃ©mata" id="navazujÃ­cÃ­-aplikovanÃ¡-tÃ©mata">NavazujÃ­cÃ­ aplikovanÃ¡ tÃ©mata</a></h2>
<ul>
<li><a href="c/aplikovane_ulohy/tga.html">TGA</a> - jak vytvoÅ™it obrÃ¡zek</li>
<li><a href="c/aplikovane_ulohy/gif.html">GIF</a> - jak vytvoÅ™it animaci</li>
<li><a href="c/aplikovane_ulohy/sdl.html">SDL</a> - jak vytvoÅ™it interaktivnÃ­ grafickou aplikaci Äi hru</li>
<li><a href="c/aplikovane_ulohy/chipmunk.html">Chipmunk</a> - jak simulovat fyzikÃ¡lnÃ­ procesy</li>
</ul>
<h2><a class="header" href="#struktura-textu" id="struktura-textu">Struktura textu</a></h2>
<p>V textu se obÄas budou objevovat ikonky oznaÄujÃ­cÃ­ rÅ¯znÃ© sekce Äi dÅ¯leÅ¾itÃ© pojmy. Zde je jejich vysvÄ›tlenÃ­:</p>
<ul>
<li>ğŸ‹: Sekce oznaÄenÃ© jako <strong>CviÄenÃ­</strong> ğŸ‹ obsahujÃ­ zadÃ¡nÃ­ krÃ¡tkÃ½ch Ãºloh pro procviÄenÃ­ vysvÄ›tlovanÃ© lÃ¡tky. DalÅ¡Ã­ Ãºlohy k
procviÄenÃ­ naleznete takÃ© v kapitole <a href="c/../ulohy/ulohy.html">Ãšlohy</a>.</li>
<li>ğŸ¤”: Sekce oznaÄenÃ© jako <strong>KvÃ­zy</strong> ğŸ¤” obsahujÃ­ ukÃ¡zky C programÅ¯, ve kterÃ½ch dochÃ¡zÃ­ k rÅ¯znÃ½m &quot;zapeklitÃ½m situacÃ­m&quot;.
VaÅ¡Ã­ Ãºlohou je zamyslet se nad tÃ­m, jak takovÃ½to program bude fungovat, a napÅ™. si tipnout, jakÃ½ vÃ½stup vypÃ­Å¡e,
Äi zda obsahuje tzv. nedefinovanÃ© chovÃ¡nÃ­.</li>
<li>ğŸ¤“: Kapitoly oznaÄenÃ© touto ikonou slouÅ¾Ã­ jako doplÅˆujÃ­cÃ­ uÄivo. To nenÃ­ nezbytnÄ› nutnÃ© zcela pochopit, abyste se mohli
v textu posunout dÃ¡le. Pokud tedy nebudete stÃ­hat nebo toho na vÃ¡s bude moc, mÅ¯Å¾ete tyto sekce prozatÃ­m pÅ™eskoÄit, nicmÃ©nÄ›
pozdÄ›ji byste se k nim mÄ›li vrÃ¡tit.</li>
<li>ğŸ’£: OznaÄuje situace, pÅ™i kterÃ½ch dochÃ¡zÃ­ k <a href="c/../ruzne/nedefinovane_chovani.html">nedefinovanÃ©mu chovÃ¡nÃ­</a>. Tyto situace
prostudujte obzvlÃ¡Å¡tÄ› peÄlivÄ›!</li>
<li>ğŸ“¹: OznaÄuje videozÃ¡znam s doplÅˆujÃ­cÃ­m vysvÄ›tlenÃ­m uÄiva.</li>
</ul>
<p><strong>Pouze si o programovÃ¡nÃ­ ÄÃ­st nestaÄÃ­ k tomu, abyste se nauÄili programovat! Proto si co nejvÃ­ce cviÄenÃ­, kvÃ­zÅ¯ a Ãºloh
vypracujte a naprogramujte, jedinÄ› tak se v programovÃ¡nÃ­ zlepÅ¡Ã­te.</strong></p>
<h1><a class="header" href="#zÃ¡klady-syntaxe" id="zÃ¡klady-syntaxe">ZÃ¡klady syntaxe</a></h1>
<p><em>C</em> je (programovacÃ­) jazyk a jako kaÅ¾dÃ½ jazyk mÃ¡ svÃ¡ pravidla, kterÃ¡ je nutno dodrÅ¾ovat.
NapÅ™Ã­klad v ÄeÅ¡tinÄ› musÃ­me dodrÅ¾ovat urÄitÃ¡ pravidla a zvyklosti, abychom byli schopni vÃ½slednÃ½
text pochopit. VÄ›ty <code>jsme, M y mÃ¡ma, tÃ¡ta a</code> nebo <code>.o dku  d! ty z, jsi</code> nedÃ¡vajÃ­ smysl,
protoÅ¾e obsahujÃ­ interpunkÄnÃ­ znamÃ©nka na Å¡patnÃ½ch mÃ­stech, vÄ›tnÃ© Äleny jsou ve Å¡patnÃ©m poÅ™adÃ­
a nÄ›kterÃ¡ slova obsahujÃ­ mezery na mÃ­stech, kam nepatÅ™Ã­. StejnÄ› tak v jazyce <em>C</em> mÅ¯Å¾ete velmi jednoduÅ¡e
napsat program, kterÃ©mu <a href="c/../prostredi/preklad_programu.html">pÅ™ekladaÄ</a> nebude rozumÄ›t a pÅ™eklad potÃ© skonÄÃ­ se
syntaktickou chybou (<em>syntax error</em>). Na syntax <em>C</em> si musÃ­te postupnÄ› zvyknout, potÃ© uÅ¾ podobnÃ© chyby
budete schopni snadno vyÅ™eÅ¡it.</p>
<p>Zde je asi nejkratÅ¡Ã­ moÅ¾nÃ½ program v jazyce <em>C</em>:</p>
<pre><code class="language-c">int main() {
    return 0;
}
</code></pre>
<p>Tento program nic nedÄ›lÃ¡, pouze se zapne a potÃ© vypne. V programu je pouze <a href="c/funkce/funkce.html">funkce</a>
s nÃ¡zvem <code>main</code>. Funkce si popÃ­Å¡eme pozdÄ›ji, prozatÃ­m budeme psÃ¡t kÃ³d vÅ¾dy uvnitÅ™ funkce <code>main</code>,
tj. mezi sloÅ¾enÃ© zÃ¡vorky <code>{</code> <code>}</code>, na Å™Ã¡dky pÅ™ed <code>return 0;</code>. JednotlivÃ© prvky programu si
postupnÄ› vysvÄ›tlÃ­me v nÃ¡sledujÃ­cÃ­ch sekcÃ­ch, prozatÃ­m si vÅ¡ak vÅ¡imnÄ›te, Å¾e <strong>bÃ­lÃ© znaky</strong> (<em>whitespace</em>)<sup class='margin-toggle sidenote-number'>1</sup>
jsou obvykle pÅ™ekladaÄem ignorovÃ¡ny. NapÅ™Ã­klad</p>
<span class='sidenote'><p><sup class='number'>1</sup><a href="https://cs.wikipedia.org/wiki/B%C3%ADl%C3%BD_znak">BÃ­lÃ© znaky</a> jsou (neviditelnÃ©) znaky,
kterÃ© reprezentujÃ­ mezery v textu, tj. odÅ™Ã¡dkovÃ¡nÃ­, mezernÃ­k, tabulÃ¡tor atd.</p>
</span>
<pre><code class="language-c">int 


main()                 {
    
    
    return         0;
}

</code></pre>
<p>reprezentuje ÃºplnÄ› stejnÃ½ program. NicmÃ©nÄ› asi sami uznÃ¡te, Å¾e pokud bychom s bÃ­lÃ½mi znaky naklÃ¡dali
takto nerozvÃ¡Å¾nÄ›, tak by zdrojovÃ½ kÃ³d byl pro lidi Å¡patnÄ› ÄitelnÃ½. IdeÃ¡lnÃ­ je
<a href="c/../prostredi/editor.html#automatick%C3%A9-form%C3%A1tov%C3%A1n%C3%AD-k%C3%B3du">nastavit si automatickÃ© formÃ¡tovÃ¡nÃ­</a> pÅ™Ã­mo v editoru kÃ³du, abyste
nad formÃ¡tovÃ¡nÃ­m vÅ¯bec nemuseli pÅ™emÃ½Å¡let.</p>
<p>BÃ­lÃ© znaky nicmÃ©nÄ› nejsou ignorovÃ¡ny ÃºplnÄ› na vÅ¡ech mÃ­stech. PozdÄ›ji se dozvÃ­me, Å¾e napÅ™Ã­klad v <a href="c/text/retezce.html">Å™etÄ›zcÃ­ch</a>
jsou bÃ­lÃ© znaky brÃ¡ny jako souÄÃ¡st textu. NemÅ¯Å¾eme takÃ© rozdÄ›lovat mezerami nÃ¡zvy (napÅ™. <code>in t</code> nebo
<code>ma in</code>) v programu vÃ½Å¡e by zpÅ¯sobily chybu pÅ™i pÅ™ekladu).</p>
<h3><a class="header" href="#komentÃ¡Å™e" id="komentÃ¡Å™e">KomentÃ¡Å™e</a></h3>
<p>Abychom mohli v nÃ¡sledujÃ­cÃ­ch sekcÃ­ch popisovat kusy kÃ³du, ukÃ¡Å¾eme si teÄ <strong>komentÃ¡Å™e</strong>. JednÃ¡ se
o text ve zdrojovÃ©m kÃ³du, kterÃ½ je urÄen pro programÃ¡tory, a ne pro pÅ™ekladaÄ, kterÃ½ je zcela ignoruje.
Bez komentÃ¡Å™Å¯ bychom nemohli do zdrojovÃ©ho kÃ³du dodÃ¡vat poznÃ¡mky, protoÅ¾e pÅ™ekladaÄ by jinak mÄ›l snahu
je interpretovat jako <em>C</em> kÃ³d. KomentÃ¡Å™e v kÃ³du obvykle poznÃ¡te snadno, protoÅ¾e je vÃ¡Å¡ editor bude vykreslovat
jinou barvou neÅ¾ zbytek kÃ³du.</p>
<p>V <em>C</em> existujÃ­ dva typy komentÃ¡Å™Å¯:</p>
<ul>
<li>Å˜Ã¡dkovÃ© komentÃ¡Å™e - pokud do kÃ³du napÃ­Å¡ete <code>//</code>, tak vÅ¡e za tÄ›mito lomÃ­tky aÅ¾ do konce Å™Ã¡dku se 
bude brÃ¡t jako komentÃ¡Å™.
<pre><code class="language-c">// komentÃ¡Å™ 1
int main() {
    // komentÃ¡Å™ 2
    return 0; // komentÃ¡Å™ 3
}
</code></pre>
</li>
<li>BlokovÃ© komenÃ¡Å™e - pokud do kÃ³du napÃ­Å¡ete <code>/*</code>, tak bude jako komentÃ¡Å™ oznaÄen vÅ¡echen nÃ¡sledujÃ­cÃ­
text, dokud nedojde k ukonÄenÃ­ komentÃ¡Å™e pomocÃ­ <code>*/</code>.
<pre><code class="language-c">int main() {
    /* zde je komentÃ¡Å™
zde taky
a tady taky */
    return 0;
}
</code></pre>
</li>
</ul>
<p>Ze zaÄÃ¡tku je asi jednoduÅ¡Å¡Ã­ pouÅ¾Ã­vat Å™Ã¡dkovÃ© komentÃ¡Å™e, ve VSCode mÅ¯Å¾ete pouÅ¾Ã­t klÃ¡vesovou zkratku
<code>Ctrl + /</code> pro zakomentovÃ¡nÃ­/odkomentovÃ¡nÃ­ Å™Ã¡dku kÃ³du. Pokud vÃ¡m pÅ™ijde nÄ›jakÃ½ kus kÃ³du komplikovanÃ½,
tak si k nÄ›mu zkuste dopsat komentÃ¡Å™, kterÃ½ vysvÄ›tlÃ­, proÄ byl kÃ³d napsÃ¡n prÃ¡vÄ› takto (pÅ™Ã­padnÄ› vyloÅ¾enÄ› popiÅ¡te, co kÃ³d dÄ›lÃ¡).
PorozumÃ­te tak kÃ³du snadnÄ›ji, aÅ¾ se k nÄ›mu napÅ™. za mÄ›sÃ­c vrÃ¡tÃ­te.</p>
<h3><a class="header" href="#klÃ­ÄovÃ¡-slova" id="klÃ­ÄovÃ¡-slova">KlÃ­ÄovÃ¡ slova</a></h3>
<p><strong>KlÃ­ÄovÃ¡ slova</strong> (<em>keywords</em>) jsou vestavÄ›nÃ© nÃ¡zvy, kterÃ½m pÅ™ekladaÄ pÅ™iÅ™azuje speciÃ¡lnÃ­
vÃ½znam. V textovÃ©m editoru je typicky poznÃ¡te tak, Å¾e budou zabarvenÃ¡ jinou barvou neÅ¾ nÃ¡zvy
vytvoÅ™enÃ© programÃ¡torem. NapÅ™Ã­klad v tomto kÃ³du jsou <code>int</code> a <code>return</code> klÃ­ÄovÃ¡ slova:</p>
<pre><code class="language-c">int main() {
    return 0;
}
</code></pre>
<p>BÄ›hem semestru se postupnÄ› nauÄÃ­te, k Äemu se jednotlivÃ¡ klÃ­ÄovÃ¡ slova pouÅ¾Ã­vajÃ­. Jejich kompletnÃ­
seznam mÅ¯Å¾ete najÃ­t napÅ™Ã­klad <a href="https://www.programiz.com/c-programming/list-all-keywords-c-language">zde</a>.</p>
<h3><a class="header" href="#speciÃ¡lnÃ­-znaky" id="speciÃ¡lnÃ­-znaky">SpeciÃ¡lnÃ­ znaky</a></h3>
<p>PÅ™i programovÃ¡nÃ­ (jak uÅ¾ v <em>C</em>, tak i v jinÃ½ch jazycÃ­ch) budete pouÅ¾Ã­vat spousty symbolÅ¯, kterÃ© bÄ›Å¾nÄ›
asi Äasto nevyuÅ¾Ã­vÃ¡te (napÅ™Ã­klad <code>[</code>, <code>]</code>, <code>{</code>, <code>}</code>, <code>&lt;</code>, <code>&gt;</code>, <code>=</code>, <code>%</code>, <code>#</code>, <code>&amp;</code>, <code>*</code>, <code>;</code>, <code>\</code>,
<code>&quot;</code>, <code>'</code>). ObzvlÃ¡Å¡tÄ› pokud pro programovÃ¡nÃ­ budete pouÅ¾Ã­vat Äeskou klÃ¡vesnici, je dobrÃ© si ze zaÄÃ¡tku
najÃ­t nÄ›jakÃ½ tahÃ¡k (napÅ™. <a href="https://github.com/geordi/upr-course/blob/master/assets/cheatsheets/keyboard-cs.pdf">tento</a>),
abyste nemuseli pokaÅ¾dÃ© zdlouhavÄ› vzpomÃ­nat, na kterÃ© klÃ¡vese se danÃ½ znak nachÃ¡zÃ­.</p>
<h3><a class="header" href="#formÃ¡tovÃ¡nÃ­-kÃ³du" id="formÃ¡tovÃ¡nÃ­-kÃ³du">FormÃ¡tovÃ¡nÃ­ kÃ³du</a></h3>
<p>UÅ¾ vÃ­me, Å¾e pÅ™ekladaÄ ignoruje bÃ­lÃ© znaky a celkovÃ© formÃ¡tovÃ¡nÃ­ kÃ³du. NicmÃ©nÄ› programÃ¡torÅ¯m obvykle
velmi zÃ¡leÅ¾Ã­ na tom, jakÃ© mÃ¡ kÃ³d odsazenÃ­, zarovnÃ¡nÃ­, zÃ¡vorkovÃ¡nÃ­ atd. Existuje mnoho
<a href="https://en.wikipedia.org/wiki/Indentation_style">stylÅ¯</a>, pomocÃ­ kterÃ½ch mÅ¯Å¾ete kÃ³d formÃ¡tovat.
NapÅ™Ã­klad programÃ¡toÅ™i se dokÃ¡Å¾ou pohÃ¡dat o tom, zda sloÅ¾enÃ© zÃ¡vorky na zaÄÃ¡tku bloku psÃ¡t na
stejnÃ©m:</p>
<pre><code class="language-c">if (...) {

}
while (...) {

}
</code></pre>
<p>nebo novÃ©m Å™Ã¡dku:</p>
<pre><code class="language-c">if (...)
{
}
while (...)
{
}
</code></pre>
<p>JakÃ½ styl formÃ¡tovÃ¡nÃ­ pouÅ¾ijete je na vÃ¡s, nicmÃ©nÄ› obecnÄ› platnÃ½m pravidlem je, Å¾e byste se mÄ›li
drÅ¾et ve svÃ½ch programech jednotnÃ©ho stylu a nemÃ­chat vÃ­ce stylÅ¯ dohromady.</p>
<p>Pokud budete vyuÅ¾Ã­vat <a href="c/../prostredi/editor.html#automatick%C3%A9-form%C3%A1tov%C3%A1n%C3%AD-k%C3%B3du">automatickÃ© formÃ¡tovÃ¡nÃ­</a> ve vaÅ¡em editoru,
tak toto nemusÃ­te vÅ¯bec Å™eÅ¡it, protoÅ¾e editor bude kÃ³d formÃ¡tovat automaticky za vÃ¡s.</p>
<hr />
<p><strong>CviÄenÃ­</strong> ğŸ‹</p>
<ol>
<li>VytvoÅ™te si ve VS Code soubor pojmenovanÃ½ napÅ™. <code>main.c</code> (<code>File -&gt; New Fileâ€¦</code>) a nakopÃ­rujte nebo napiÅ¡te do nÄ›j
&quot;prÃ¡zdnÃ½&quot; <em>C</em> program ukÃ¡zanÃ½ vÃ½Å¡e. Zkuste program
<a href="c/../prostredi/preklad_programu.html#p%C5%99eklad-prvn%C3%ADho-programu">pÅ™eloÅ¾it</a> a spustit.</li>
<li>Zkuste do kÃ³du pÅ™idat komentÃ¡Å™e nebo bÃ­lÃ© znaky (napÅ™. prÃ¡zdnÃ© Å™Ã¡dky nebo mezery). Otestujte, Å¾e
pÅ™ekladaÄ tyto vÄ›ci pÅ™i pÅ™ekladu ignoruje.</li>
<li>Zkuste v programu zÃ¡mÄ›rnÄ› vloÅ¾it mezeru napÅ™. do slova <code>main</code> nebo <code>int</code>. PodÃ­vejte se, jakou chybovou hlÃ¡Å¡ku vÃ¡m ukÃ¡Å¾e
pÅ™ekladaÄ.</li>
</ol>
<h1><a class="header" href="#vykonÃ¡vÃ¡nÃ­-programÅ¯" id="vykonÃ¡vÃ¡nÃ­-programÅ¯">VykonÃ¡vÃ¡nÃ­ programÅ¯</a></h1>
<p>Jak uÅ¾ vÃ­me, programy jsou <a href="c/../uvod/programovaci_jazyky.html">sekvence pÅ™Ã­kazÅ¯</a> pro poÄÃ­taÄ, kterÃ½ je provÃ¡dÃ­
instrukci po instrukci (resp. Å™Ã¡dek po Å™Ã¡dku). Jakmile poÄÃ­taÄ vykonÃ¡ jeden Å™Ã¡dek vaÅ¡eho programu, tak skoÄÃ­
na Å™Ã¡dek nÃ­Å¾e, dokud nedojde na konec programu. Aby poÄÃ­taÄ vÄ›dÄ›l, kterou instrukci mÃ¡ provÃ©st
jako prvnÃ­, tak mu musÃ­me Å™Ã­ct, kde mÃ¡ zaÄÃ­t. K tomu pÅ™esnÄ› slouÅ¾Ã­ <a href="c/funkce/funkce.html">funkce</a> (pojmenovanÃ½
blok kÃ³du) se speciÃ¡lnÃ­m nÃ¡zvem <code>main</code>:</p>
<pre><code class="language-c">int main() {
    // ZDE
    return 0;
}
</code></pre>
<p>VÃ½Å¡e zmÃ­nÄ›nÃ½ program se po <a href="c/../prostredi/preklad_programu.html">pÅ™ekladu</a> a spuÅ¡tÄ›nÃ­ zaÄne vykonÃ¡vat na prvnÃ­m Å™Ã¡dku
funkce <code>main</code>, a jakmile provede vÅ¡echny Å™Ã¡dky, tak program skonÄÃ­. Tento program je
v podstatÄ› prÃ¡zdnÃ½, takÅ¾e se pouze zapne a vypne. ProzatÃ­m budeme veÅ¡kerÃ½ kÃ³d psÃ¡t dovnitÅ™ funkce
<code>main</code>, mezi sloÅ¾enÃ© zÃ¡vorky (<code>{</code>, <code>}</code>) a pÅ™ed Å™Ã¡dek <code>return 0;</code> (tedy na mÃ­sto komentÃ¡Å™e <code>ZDE</code>).
<a href="c/../ruzne/funkce_main.html">PozdÄ›ji</a> si vysvÄ›tlÃ­me, jak tato funkce funguje, prozatÃ­m to berte tak,
Å¾e v programu vÅ¾dy musÃ­ funkce <code>main</code> bÃ½t, aby poÄÃ­taÄ vÄ›dÄ›l, odkud zaÄÃ­t vykonÃ¡vÃ¡nÃ­ kÃ³du. </p>
<h1><a class="header" href="#pÅ™Ã­kazy" id="pÅ™Ã­kazy">PÅ™Ã­kazy</a></h1>
<p>Programy v <em>C</em> se sklÃ¡dajÃ­ z <strong>pÅ™Ã­kazÅ¯</strong> (<em>statements</em>). PÅ™Ã­kaz Å™Ã­kÃ¡ poÄÃ­taÄi, co mÃ¡ provÃ©st, na
mnohem vyÅ¡Å¡Ã­ Ãºrovni neÅ¾ <a href="c/../uvod/programovaci_jazyky.html">instrukce</a> - jeden C pÅ™Ã­kaz mÅ¯Å¾e bÃ½t pÅ™eloÅ¾en
pÅ™ekladaÄem na desÃ­tky instrukcÃ­ pro procesor. Existuje mnoho rÅ¯znÃ½ch typÅ¯ pÅ™Ã­kazÅ¯, kterÃ© naleznete
v nÃ¡sledujÃ­cÃ­ch sekcÃ­ch. VÄ›tÅ¡ina pÅ™Ã­kazÅ¯ nÄ›jakÃ½m zpÅ¯sobem pracuje s <em>vÃ½razy</em>, zaÄneme tedy jejich popisem.</p>
<h1><a class="header" href="#vÃ½razy" id="vÃ½razy">VÃ½razy</a></h1>
<p>Jak uÅ¾ vyplÃ½vÃ¡ z jeho nÃ¡zvu, hlavnÃ­ funkcÃ­ poÄÃ­taÄe je nÄ›co poÄÃ­tat. JednÃ­m ze
zÃ¡kladnÃ­ch konstrukcÃ­ jazyka <em>C</em> (i jinÃ½ch programovacÃ­ch jazykÅ¯) tak je moÅ¾nost vypoÄÃ­tat rÅ¯znÃ© hodnoty.
NÄ›co, co se dÃ¡ vypoÄÃ­tat (tak, aby vÃ½sledkem byla nÄ›jakÃ¡ hodnota), se nazÃ½vÃ¡ <strong>vÃ½raz</strong> (<em>expression</em>).
PÅ™Ã­kladem asi nejjednoduÅ¡Å¡Ã­ho vÃ½razu je ÄÃ­slo, napÅ™. <code>5</code>. TakovÃ½to vÃ½raz jiÅ¾ nenÃ­ nutnÃ© dÃ¡le vyhodnocovat,
jeho hodnota je prostÄ› <code>5</code>. Pokud v programu pouÅ¾ijete pÅ™Ã­mo hodnotu nÄ›jakÃ©ho ÄÃ­sla (popÅ™. nÄ›Äeho
jinÃ©ho, jak uvidÃ­me pozdÄ›ji), tak se takovÃ½ vÃ½raz oznaÄuje jako <strong>literÃ¡l</strong> (<em>literal</em>).</p>
<p>V <em>C</em> mÅ¯Å¾eme s vÃ½razy provÃ¡dÄ›t rÅ¯znÃ© operace pomocÃ­ <strong>operÃ¡torÅ¯</strong>. MÅ¯Å¾eme napÅ™Ã­klad pouÅ¾Ã­t operÃ¡tor <code>+</code>
s dvÄ›ma vÃ½razy, ÄÃ­mÅ¾ vznikne sloÅ¾itÄ›jÅ¡Ã­ vÃ½raz: <code>5 + 5</code>, kterÃ½ se v programu vyhodnotÃ­ na hodnotu <code>10</code>.
O operÃ¡torech si vÃ­ce povÃ­me v kapitole o <a href="c/datove_typy/celociselne_typy.html#operace-s-%C4%8D%C3%ADseln%C3%BDmi-typy">datovÃ½ch typech</a>.</p>
<h3><a class="header" href="#vÃ½pis-vÃ½razÅ¯" id="vÃ½pis-vÃ½razÅ¯">VÃ½pis vÃ½razÅ¯</a></h3>
<p>Abyste si ze zaÄÃ¡tku mohli jednoduÅ¡e zobrazit hodnoty vÃ½razÅ¯, tak si ukÃ¡Å¾eme kÃ³d, pomocÃ­ kterÃ©ho
mÅ¯Å¾ete vypsat text na vÃ½stup programu (do terminÃ¡lu). K vÃ½pisu textu mÅ¯Å¾ete pouÅ¾Ã­t pÅ™Ã­kaz</p>
<pre><code class="language-c">printf(&quot;&lt;text&gt;&quot;);
</code></pre>
<p>Text, kterÃ½ vloÅ¾Ã­te mezi uvozovky (<code>&quot;</code>) se vypÃ­Å¡e na vÃ½stup programu<sup class='margin-toggle sidenote-number'>2</sup>:</p>
<span class='sidenote'><p><sup class='number'>2</sup>Tento kÃ³d mÅ¯Å¾ete modifikovat i spustit pÅ™Ã­mo v prohlÃ­Å¾eÄi. StaÄÃ­ kliknout na ikonu
<i class="fa fa-play"></i> vpravo nahoÅ™e nebo stisknout <code>Ctrl+Enter</code>.</p>
</span>
<pre><code class="language-c editable">#include &lt;stdio.h&gt;

int main() {
    printf(&quot;Hello world!\n&quot;);
    return 0;
}
</code></pre>
<p>Abyste <code>printf</code> mohli pouÅ¾Ã­t, musÃ­te na zaÄÃ¡tek programu vloÅ¾it Å™Ã¡dek <code>#include &lt;stdio.h&gt;</code>.
Tento Å™Ã¡dek i <code>printf</code> zatÃ­m berte jako &quot;black box&quot;, <a href="c/preprocesor/vkladani_souboru.html">pozdÄ›ji</a> si
vysvÄ›tlÃ­me, jak pÅ™esnÄ› fungujÃ­.</p>
<p>V zadanÃ©m textu mÅ¯Å¾ete pouÅ¾Ã­vat urÄitÃ© speciÃ¡lnÃ­ znaky. NapÅ™Ã­klad sekvence znakÅ¯ <code>\n</code> zpÅ¯sobÃ­, Å¾e
na vÃ½stupu dojde k <strong>odÅ™Ã¡dkovÃ¡nÃ­</strong> (<em>newline</em>), po kterÃ©m se text zaÄne vypisovat na dalÅ¡Ã­m Å™Ã¡dku:</p>
<pre><code class="language-c editable">#include &lt;stdio.h&gt;

int main() {
    printf(&quot;Prvni radek\nDruhy radek&quot;);
    return 0;
}
</code></pre>
<p>Abyste mohli tisknout hodnoty vÃ½razÅ¯, mÅ¯Å¾ete pouÅ¾Ã­t <strong>zÃ¡stupnÃ© znaky</strong> (<em>placeholders</em>). Pokud chcete
vypsat <em>ÄÃ­selnou</em> hodnotu na vÃ½stup programu, staÄÃ­ v textu pouÅ¾Ã­t zÃ¡stupnÃ½ znak <code>%d</code>, za uvozovky
pÅ™idat ÄÃ¡rku a doplnit vÃ½raz na mÃ­sto urÄenÃ© komentÃ¡Å™em:</p>
<pre><code class="language-c editable">#include &lt;stdio.h&gt;

int main() {
    printf(&quot;Cislo: %d\n&quot;, /* Hodnota tohoto vÃ½razu se vypÃ­Å¡e na vÃ½stup */ 1);
    return 0;
}
</code></pre>
<p>KdyÅ¾ chcete vypsat napÅ™Ã­klad vÃ½sledek vyhodnocenÃ­ vÃ½razu <code>10 + 5</code>, tak staÄÃ­ napsat:
<code>printf(&quot;%d\n&quot;, 10 + 5);</code> a na vÃ½stup programu by se mÄ›l vypsat text <code>15</code>.</p>
<p>Pokud chcete vytisknout vÃ­ce hodnot, tak prostÄ› Å™Ã¡dek s <code>printf(â€¦);</code> zkopÃ­rujte a na uvedenÃ© mÃ­sto
vloÅ¾te jinÃ½ vÃ½raz. PoÄÃ­taÄ provÃ¡dÃ­ programy Å™Ã¡dek po Å™Ã¡dku, odshora dolÅ¯. DoplÅˆte na mÃ­sto komentÃ¡Å™e
do programu nÃ­Å¾e nÄ›jakÃ½ vÃ½raz a zkuste uhodnout, co se vypÃ­Å¡e na vÃ½stup po pÅ™eloÅ¾enÃ­ a spuÅ¡tÄ›nÃ­ programu.</p>
<pre><code class="language-c editable">#include &lt;stdio.h&gt;

int main() {
    printf(&quot;%d\n&quot;, 1);
    printf(&quot;%d\n&quot;, /* tady vloÅ¾te vÃ½raz */);
    return 0;
}
</code></pre>
<hr />
<p><strong>CviÄenÃ­</strong> ğŸ‹</p>
<p>Zkuste si na mÃ­sto komentÃ¡Å™e doplnit nÄ›kolik vÃ½razÅ¯ (napÅ™. <code>5 + 8</code>, <code>8 * 3</code>, <code>12 * (2 + 3)</code>),
pÅ™eloÅ¾it program, spustit ho a podÃ­vat se, co vypÃ­Å¡e na vÃ½stup, abyste si vyzkouÅ¡eli vyhodnocovÃ¡nÃ­
vÃ½razÅ¯. <strong>Zkuste to na svÃ©m poÄÃ­taÄi pomocÃ­ <a href="c/../prostredi/editor.html">editoru</a> a <a href="c/../prostredi/preklad_programu.html">pÅ™ekladaÄe</a>,
ne pouze v prohlÃ­Å¾eÄi!</strong></p>
<hr />
<h3><a class="header" href="#datovÃ©-typy" id="datovÃ©-typy">DatovÃ© typy</a></h3>
<p>KaÅ¾dÃ½ vÃ½raz mÃ¡ svÅ¯j datovÃ½ typ, kterÃ½ udÃ¡vÃ¡, jak je hodnota vÃ½razu v programu interpretovÃ¡na a takÃ©
jakÃ© operace mÃ¡ smysl nad vÃ½razem dÄ›lat. VÃ­ce o datovÃ½ch typech a operÃ¡torech se dozvÃ­te v sekci
<a href="c/datove_typy/datove_typy.html">DatovÃ© typy</a>.</p>
<h3><a class="header" href="#pÅ™Ã­kazy-vs-vÃ½razy" id="pÅ™Ã­kazy-vs-vÃ½razy">PÅ™Ã­kazy vs vÃ½razy</a></h3>
<p>Jakmile se budete postupnÄ› uÄit o jednotlivÃ½ch konstrukcÃ­ch jazyka C, je dÅ¯leÅ¾itÃ© uvÄ›domit si, jakÃ½
je rozdÃ­l mezi vÃ½razem (nÄ›co, co se dÃ¡ vypoÄÃ­tat) a pÅ™Ã­kazem, pomocÃ­ kterÃ©ho poÄÃ­taÄi Å™Ã­kÃ¡me, aby
nÄ›co (s nÄ›jakÃ½m vÃ½razem) udÄ›lal (napÅ™Ã­klad vypsal ho na vÃ½stup, zapsal do pamÄ›ti atd.).</p>
<h3><a class="header" href="#vedlejÅ¡Ã­-efekty" id="vedlejÅ¡Ã­-efekty">VedlejÅ¡Ã­ efekty</a></h3>
<p>Pokud chcete pouze vypoÄÃ­tat vÃ½raz (&quot;jen tak&quot;), mimo nÄ›jakÃ½ pÅ™Ã­kaz, staÄÃ­ za nÄ›j dÃ¡t stÅ™ednÃ­k. TÃ­m
ze samostatnÃ©ho vÃ½razu udÄ›lÃ¡te pÅ™Ã­kaz:</p>
<pre><code class="language-c">1 + 1; // vypoÄte se `2`, vÃ½sledek se na nic nepouÅ¾ije
</code></pre>
<p>Toto mÃ¡ smysl dÄ›lat pouze u vÃ½razÅ¯, kterÃ© majÃ­ nÄ›jakÃ½ <strong>vedlejÅ¡Ã­ efekt</strong> (<em>side effect</em>), kterÃ½
zpÅ¯sobÃ­, Å¾e pÅ™i provÃ¡dÄ›nÃ­ vÃ½razu se v programu nÄ›co zmÄ›nÃ­. Jinak by vÃ½raz sÃ¡m o sobÄ› byl vypoÄten,
ale nic dalÅ¡Ã­ho by se nestalo. O vÃ½razech, kterÃ© umÃ­ produkovat vedlejÅ¡Ã­ efekty, se dozvÃ­te v pozdÄ›jÅ¡Ã­ch
sekcÃ­ch.</p>
<h1><a class="header" href="#promÄ›nnÃ©" id="promÄ›nnÃ©">PromÄ›nnÃ©</a></h1>
<p>Aby programy mohly Å™eÅ¡it nÄ›jakÃ½ Ãºkol, tak si tÃ©mÄ›Å™ vÅ¾dy musÃ­ umÄ›t nÄ›co zapamatovat. K tomu
slouÅ¾Ã­ tzv. <strong>promÄ›nnÃ©</strong> (<em>variables</em>). PromÄ›nnÃ© nÃ¡m umoÅ¾ÅˆujÃ­ pracovat s pamÄ›tÃ­ poÄÃ­taÄe (RAM)
intuitivnÃ­m zpÅ¯sobem - ÄÃ¡st pamÄ›ti si pojmenujeme nÄ›jakÃ½m jmÃ©nem a dÃ¡le se na ni tÃ­mto jmÃ©nem
odkazujeme. Do promÄ›nnÃ© potÃ© mÅ¯Å¾eme uloÅ¾it nÄ›jakou hodnotu, ÄÃ­mÅ¾ si ji poÄÃ­taÄ &quot;zapamatuje&quot;. Tuto
hodnotu mÅ¯Å¾eme pozdÄ›ji v programu pÅ™eÄÃ­st anebo ji zmÄ›nit.</p>
<p>PÅ™Ã­klady pouÅ¾itÃ­ promÄ›nnÃ½ch:</p>
<ul>
<li>Ve webovÃ© aplikaci si ÄÃ­selnÃ¡ promÄ›nnÃ¡ pamatuje poÄet nÃ¡vÅ¡tÄ›vnÃ­kÅ¯. PÅ™i zobrazenÃ­ strÃ¡nky
se hodnota promÄ›nnÃ© zvÃ½Å¡Ã­ o 1.</li>
<li>Ve hÅ™e si ÄÃ­selnÃ¡ promÄ›nnÃ¡ pamatuje poÄet Å¾ivotÅ¯ hrÃ¡Äovy postavy. Pokud dojde k zÃ¡sahu postavy
nepÅ™Ã­telem, tak se poÄet Å¾ivotÅ¯ snÃ­Å¾Ã­ o zranÄ›nÃ­ (<em>damage</em>) nepÅ™Ã­telovy zbranÄ›. Pokud hrÃ¡Ä sebere lÃ©kÃ¡rnÃ­Äku,
tak se poÄet jeho Å¾ivotÅ¯ opÄ›t zvÃ½Å¡Ã­.</li>
<li>V terminÃ¡lu si promÄ›nnÃ¡ reprezentujÃ­cÃ­ znaky pamatuje text, kterÃ½ byl zadÃ¡n na klÃ¡vesnici.</li>
</ul>
<h3><a class="header" href="#definice" id="definice">Definice</a></h3>
<p>PromÄ›nnÃ© jsou jednÃ­m z nejzÃ¡kladnÄ›jÅ¡Ã­ch a nejÄastÄ›ji pouÅ¾Ã­vanÃ½ch stavebnÃ­ch kamenÅ¯ vÄ›tÅ¡iny programÅ¯, bÄ›hem
semestru se s nimi budeme setkÃ¡vat neustÃ¡le. NenÃ­ tak nÃ¡hodou, Å¾e jednÃ­m z nejzÃ¡kladnÄ›jÅ¡Ã­ch pÅ™Ã­kazÅ¯
v <em>C</em> je prÃ¡vÄ› vytvoÅ™enÃ­ promÄ›nnÃ©. TÃ­m Å™ekneme poÄÃ­taÄi, aby vyÄlenil (tzv. <strong>naalokoval</strong>) mÃ­sto v pamÄ›ti,
kterÃ© si v programu nÄ›jak pojmenujeme a dÃ¡le se na nÄ›ho pomocÃ­ jeho jmÃ©na mÅ¯Å¾eme odkazovat<sup class='margin-toggle sidenote-number'>1</sup>.</p>
<span class='sidenote'><p><sup class='number'>1</sup>O tom, jak pÅ™esnÄ› tato alokace pamÄ›ti probÃ­hÃ¡, se dozvÃ­te pozdÄ›ji v sekci o
<a href="c/promenne/../prace_s_pameti/automaticka_pamet.html">prÃ¡ci s pamÄ›tÃ­</a>.</p>
</span>
<p>Takto vypadÃ¡ pÅ™Ã­kaz <strong>definice</strong> (vytvoÅ™enÃ­) promÄ›nnÃ© s nÃ¡zvem <code>vek</code> s datovÃ½m typem <code>int</code>:</p>
<pre><code class="language-c">int vek;
</code></pre>
<p>Jakmile promÄ›nnou nadefinujeme, tak z nÃ­ mÅ¯Å¾eme buÄ ÄÃ­st anebo zapisovat pamÄ›Å¥, kterou tato promÄ›nnÃ¡
reprezentuje, pomocÃ­ jejÃ­ho nÃ¡zvu (zde <code>vek</code>).</p>
<h3><a class="header" href="#platnost" id="platnost">Platnost</a></h3>
<p>PromÄ›nnÃ¡ je platnÃ¡ (lze ji pouÅ¾Ã­vat) vÅ¾dy od mÃ­sta (Å™Ã¡dku) definice do konce <strong>bloku</strong>, ve kterÃ©m byla
nadefinovÃ¡na. Bloky jsou kusy kÃ³du ohraniÄenÃ© sloÅ¾enÃ½mi zÃ¡vorkami (<code>{</code> a <code>}</code>):</p>
<pre><code class="language-c">int main() {
    // zde nenÃ­ platnÃ© ani `a`, ani `b`
    int a;
    // zde je platnÃ© pouze `a`

    {
        // zde je platnÃ© pouze `a`
        int b;
        // zde je platnÃ© `a` i `b`
    } // zde konÄÃ­ platnost promÄ›nnÃ© `b`

    // zde je platnÃ© pouze `a`

    return 0;
} // zde konÄÃ­ platnost promÄ›nnÃ© `a`
</code></pre>
<p>VÅ¡imnÄ›te si, Å¾e bloky lze vnoÅ™ovat (lze vytvoÅ™it blok v bloku), a promÄ›nnÃ© jsou platnÃ© i ve vnoÅ™enÃ½ch
blocÃ­ch. Oblast kÃ³du, ve kterÃ© je promÄ›nnÃ¡ validnÃ­, se nazÃ½vÃ¡ <em>(variable) scope</em>.</p>
<h3><a class="header" href="#datovÃ½-typ" id="datovÃ½-typ">DatovÃ½ typ</a></h3>
<p><code>int</code> pÅ™ed nÃ¡zvem promÄ›nnÃ© udÃ¡vÃ¡ jejÃ­ datovÃ½ typ, o kterÃ©m pojednÃ¡vÃ¡ <a href="c/promenne/../datove_typy/datove_typy.html">nÃ¡sledujÃ­cÃ­ kapitola</a>.
ProzatÃ­m si Å™eknÄ›me, Å¾e <code>int</code> je zkratka pro <code>integer</code>, tedy celÃ© ÄÃ­slo. TÃ­m Å™Ã­kÃ¡me programu, Å¾e mÃ¡
tuto promÄ›nnou (resp. pamÄ›Å¥, kterou promÄ›nnÃ¡ reprezentuje) interpretovat jako celÃ© ÄÃ­slo se znamÃ©nkem.</p>
<h3><a class="header" href="#inicializace" id="inicializace">Inicializace</a></h3>
<p>Do promÄ›nnÃ© bychom mÄ›li pÅ™i jejÃ­m vytvoÅ™enÃ­ rovnou uloÅ¾it nÄ›jakÃ½ <em>vÃ½raz</em>, kterÃ½ musÃ­ bÃ½t stejnÃ©ho
datovÃ©ho typu jako je typ promÄ›nnÃ©:</p>
<pre><code class="language-c">int a = 10;
int b = 10 + 15;
</code></pre>
<p>ObecnÃ¡ syntaxe pro definici promÄ›nnÃ© je</p>
<p><code>&lt;datovÃ½ typ&gt; &lt;nÃ¡zev&gt;;</code></p>
<p>popÅ™Ã­padÄ›</p>
<p><code>&lt;datovÃ½ typ&gt; &lt;nÃ¡zev&gt; = &lt;vÃ½raz&gt;;</code></p>
<p>pokud pouÅ¾ijeme inicializaci.</p>
<blockquote>
<p>VÅ¡imnÄ›te si, Å¾e na konci definice promÄ›nnÃ© vÅ¾dy musÃ­ nÃ¡sledovat stÅ™ednÃ­k (<strong>;</strong>).
OpomenutÃ­ stÅ™ednÃ­ku na konci pÅ™Ã­kazu je velmi ÄastÃ¡ chyba, kterÃ¡ Äasto konÄÃ­ tÄ›Å¾ko srozumitelnÃ½mi chybovÃ½mi
hlÃ¡Å¡kami pÅ™i pÅ™ekladu. DÃ¡vejte si tak na stÅ™ednÃ­ky pozor, obzvlÃ¡Å¡tÄ› ze zaÄÃ¡tku.</p>
</blockquote>
<h4><a class="header" href="#vÅ¾dy-inicializujte-promÄ›nnÃ©" id="vÅ¾dy-inicializujte-promÄ›nnÃ©">VÅ¾dy inicializujte promÄ›nnÃ©!</a></h4>
<p>Je opravdu dÅ¯leÅ¾itÃ© do promÄ›nnÃ© vÅ¾dy pÅ™i jejÃ­ definici pÅ™iÅ™adit nÄ›jakou ÃºvodnÃ­ hodnotu. Pokud to
neudÄ›lÃ¡me, tak jejÃ­ hodnota bude <strong>nedefinovanÃ¡</strong> (<em>undefined</em>). ÄŒtenÃ­ hodnoty takovÃ©to nedefinovanÃ© promÄ›nnÃ©
zpÅ¯sobuje <a href="c/promenne/../../ruzne/nedefinovane_chovani.html"><strong>nedefinovanÃ© chovÃ¡nÃ­</strong></a> (<em>undefined behaviour</em>, <em>UB</em>)<sup class='margin-toggle sidenote-number'>2</sup> programu.
Pokud k tomu dojde, tak si pÅ™ekladaÄ s vaÅ¡Ã­m programem mÅ¯Å¾e udÄ›lat, co se mu zachce, a vÃ¡Å¡ program se potÃ© mÅ¯Å¾e chovat nepÅ™edvÃ­datelnÄ›.</p>
<span class='sidenote'><p><sup class='number'>2</sup>Situace, kterÃ© mÅ¯Å¾ou zpÅ¯sobit <a href="c/promenne/../../ruzne/nedefinovane_chovani.html">nedefinovanÃ© chovÃ¡nÃ­</a>, budou dÃ¡le v textu oznaÄenÃ© pomocÃ­ ikony
ğŸ’£.</p>
</span>
<p><strong>Proto vÅ¾dy dÃ¡vejte promÄ›nnÃ½m iniciÃ¡lnÃ­ hodnotu!</strong></p>
<h3><a class="header" href="#ÄŒtenÃ­" id="ÄŒtenÃ­">ÄŒtenÃ­</a></h3>
<p>Pokud v programu pouÅ¾ijeme nÃ¡zev platnÃ© promÄ›nnÃ©, tak vytvoÅ™Ã­me vÃ½raz, kterÃ½ se vyhodnotÃ­ jako jejÃ­
souÄasnÃ¡ hodnota:</p>
<pre><code class="language-c editable">#include &lt;stdio.h&gt;

int main() {
    int a = 5;
    int b = a;  // hodnota `b` je 5
    int c = b + a + 1;  // hodnota `c` je 11

    printf(&quot;a = %d, b krat 2 = %d, c = %d&quot;, a, b * 2, c);

    return 0;
}
</code></pre>
<p>PromÄ›nnou (resp. jejÃ­ nÃ¡zev) tak lze pouÅ¾Ã­t kdekoliv, kde je oÄekÃ¡vÃ¡n vÃ½raz (pokud sedÃ­ datovÃ© typy).
Pro vÃ½pis hodnot promÄ›nnÃ½ch na vÃ½stup programu mÅ¯Å¾ete pouÅ¾Ã­t <code>printf</code>.
Hodnoty promÄ›nnÃ½ch mÅ¯Å¾ete zkoumat takÃ© krokovÃ¡nÃ­m pomocÃ­ <a href="c/promenne/../../prostredi/ladeni.html#krokov%C3%A1n%C3%AD">debuggeru</a>.</p>
<h3><a class="header" href="#zÃ¡pis" id="zÃ¡pis">ZÃ¡pis</a></h3>
<p>Pokud by promÄ›nnÃ¡ mÄ›la pouze svou pÅ¯vodnÃ­ hodnotu, tak by nebyla moc uÅ¾iteÄnÃ¡. Hodnoty promÄ›nnÃ½ch
naÅ¡tÄ›stÃ­ jde mÄ›nit. MÅ¯Å¾eme k tomu pouÅ¾Ã­t vÃ½raz <strong>pÅ™iÅ™azenÃ­</strong> (<em>assignment</em>):</p>
<pre><code class="language-c editable">#include &lt;stdio.h&gt;

int main() {
    int a = 5;  // hodnota `a` je 5
    printf(&quot;%d\n&quot;, a);

    a = 8;      // hodnota `a` je nynÃ­ 8
    printf(&quot;%d\n&quot;, a);

    return 0;
}
</code></pre>
<p>ObecnÃ¡ syntaxe pro pÅ™iÅ™azenÃ­ do promÄ›nnÃ© je</p>
<p><code>&lt;nÃ¡zev promÄ›nnÃ©&gt; = &lt;vÃ½raz&gt;</code></p>
<p>OpÄ›t musÃ­ platit, Å¾e vÃ½raz musÃ­ bÃ½t stejnÃ©ho typu<sup class='margin-toggle sidenote-number'>3</sup>, jako je promÄ›nnÃ¡, do kterÃ© pÅ™iÅ™azujeme. Na konci
Å™Ã¡dku takÃ© nesmÃ­ chybÄ›t stÅ™ednÃ­k. PÅ™iÅ™azenÃ­ je pÅ™Ã­klad vÃ½razu, kterÃ½ mÃ¡ <a href="c/promenne/../prikazy_vyrazy.html#vedlej%C5%A1%C3%AD-efekty">vedlejÅ¡Ã­ efekt</a>.
Abychom z nÄ›j udÄ›lali pÅ™Ã­kaz, musÃ­me za nÄ›j dÃ¡t stÅ™ednÃ­k <code>;</code>.</p>
<span class='sidenote'><p><sup class='number'>3</sup><em>C</em> umoÅ¾Åˆuje automatickÃ© (tzv. <strong>implicitnÃ­</strong>) konverze mezi nÄ›kterÃ½mi datovÃ½mi typy, takÅ¾e typ vÃ½razu
nemusÃ­ bÃ½t nutnÄ› vÅ¾dy stejnÃ½. Tyto konverze se nicmÃ©nÄ› Äasto chovajÃ­ neintuitivnÄ› a pÅ™ekladaÄ vÃ¡s pÅ™ed nimi
obvykle nijak nevaruje, i kdyÅ¾ vrÃ¡tÃ­ vÃ½sledek, kterÃ½ nedÃ¡vÃ¡ smysl. SnaÅ¾te se tak ze zaÄÃ¡tku opravdu vÅ¾dy
pouÅ¾Ã­vat odpovÃ­dajÃ­cÃ­ typy. VÃ­ce se dozvÃ­te v sekci o <a href="c/promenne/../datove_typy/datove_typy.html">datovÃ½ch typech</a>. </p>
</span>
<blockquote>
<p><strong>Jak pÅ™iÅ™azenÃ­ funguje?</strong> PoÄÃ­taÄ se podÃ­vÃ¡, na jakÃ© adrese v pamÄ›ti danÃ¡ promÄ›nnÃ¡ leÅ¾Ã­, a zapÃ­Å¡e do
pamÄ›ti hodnotu vÃ½razu, kterÃ½ do promÄ›nnÃ© zapisujeme, ÄÃ­mÅ¾ zmÄ›nÃ­ jejÃ­ hodnotu v pamÄ›ti. Z toho vyplÃ½vÃ¡,
Å¾e dÃ¡vÃ¡ smysl zapisovat hodnoty pouze do nÄ›Äeho, co mÃ¡ adresu v pamÄ›ti<sup class='margin-toggle sidenote-number'>4</sup>. NapÅ™Ã­klad pÅ™Ã­kaz <code>5 = 8;</code> nedÃ¡vÃ¡ smysl. <code>5</code>
je vÃ½raz, ÄÃ­selnÃ¡ hodnota, kterÃ¡ nemÃ¡ Å¾Ã¡dnou adresu v pamÄ›ti, nemÅ¯Å¾eme tak do nÃ­ nic zapsat. StejnÄ› tak
jako nedÃ¡vÃ¡ smysl Å™Ã­ct <code>ÄŒÃ­slo 5 odteÄ bude mÃ­t hodnotu 8</code>.</p>
<span class='sidenote'><p><sup class='number'>4</sup>ZatÃ­m znÃ¡me pouze promÄ›nnÃ©, pozdÄ›ji si vÅ¡ak ukÃ¡Å¾eme <a href="c/promenne/../prace_s_pameti/ukazatele.html">dalÅ¡Ã­ moÅ¾nosti</a>, jak vytvoÅ™it
&quot;nÄ›co, co mÃ¡ adresu v pamÄ›ti&quot;, a co tak pÅ¯jde pouÅ¾Ã­t na levÃ© stranÄ› vÃ½razu pÅ™iÅ™azenÃ­ <code>=</code>.</p>
</span></blockquote>
<h3><a class="header" href="#kde-vytvÃ¡Å™et-promÄ›nnÃ©" id="kde-vytvÃ¡Å™et-promÄ›nnÃ©">Kde vytvÃ¡Å™et promÄ›nnÃ©?</a></h3>
<p>PromÄ›nnou vÅ¾dy vytvÃ¡Å™ejte (deklarujte) aÅ¾ na mÃ­stÄ› v programu, kde ji opravdu budete poprvÃ© potÅ™ebovat. Bude pak mnohem
jasnÄ›jÅ¡Ã­, k Äemu se promÄ›nnÃ¡ vyuÅ¾Ã­vÃ¡, kde opravdu zaÄÃ­nÃ¡ jejÃ­ <a href="c/promenne/promenne.html#platnost">platnost</a>, a kde naopak jeÅ¡tÄ› nenÃ­ potÅ™eba.
Pokud byste vÅ¡echny promÄ›nnÃ© vytvoÅ™ili na zaÄÃ¡tku funkce (bloku kÃ³du, napÅ™. <code>main</code>)<sup class='margin-toggle sidenote-number'>5</sup>, tak nebude zÅ™ejmÃ©, k Äemu vlastnÄ›
jednotlivÃ© promÄ›nnÃ© jsou, a mÅ¯Å¾e se vÃ¡m jednoduÅ¡Å¡eji stÃ¡t, Å¾e promÄ›nnou omylem pouÅ¾ijete v kusu kÃ³du, se kterÃ½m nesouvisÃ­.</p>
<span class='sidenote'><p><sup class='number'>5</sup>Pokud uÅ¾ jste se s jazykem <em>C</em> dÅ™Ã­ve setkali, moÅ¾nÃ¡ jste byli pÅ™esvÄ›dÄeni, Å¾e musÃ­te vÅ¡echny promÄ›nnÃ© deklarovat
jiÅ¾ na zaÄÃ¡tku kaÅ¾dÃ© funkce. VÄ›zte, Å¾e tomu tak nenÃ­ jiÅ¾ zhruba 25 let, od standardu <code>C99</code> :)</p>
</span>
<h3><a class="header" href="#definice-vÃ­ce-promÄ›nnÃ½ch-najednou" id="definice-vÃ­ce-promÄ›nnÃ½ch-najednou">Definice vÃ­ce promÄ›nnÃ½ch najednou</a></h3>
<p>Pokud potÅ™ebujete vytvoÅ™it vÃ­ce promÄ›nnÃ½ch stejnÃ©ho datovÃ©ho typu, mÅ¯Å¾ete pouÅ¾Ã­t vÃ­ce nÃ¡zvÅ¯
oddÄ›lenÃ½ch ÄÃ¡rkou za datovÃ½m typem promÄ›nnÃ©. Takto napÅ™Ã­klad lze vytvoÅ™it tÅ™i celoÄÃ­selnÃ© promÄ›nnÃ©
s nÃ¡zvy <code>x</code>, <code>y</code> a <code>z</code>:</p>
<pre><code class="language-c">int x = 1, y = 2, z = 3;
</code></pre>
<blockquote>
<p>DoporuÄujeme vÅ¡ak tento zpÅ¯sob tvorby vÃ­ce promÄ›nnÃ½ch spÃ­Å¡e nepouÅ¾Ã­vat, aby byl kÃ³d pÅ™ehlednÄ›jÅ¡Ã­.</p>
</blockquote>
<hr />
<p><strong>CviÄenÃ­</strong> ğŸ‹</p>
<ol>
<li>Zkuste napsat program, kterÃ½ vytvoÅ™Ã­ nÄ›kolik promÄ›nnÃ½ch, pÅ™eÄte a zmÄ›nÃ­ jejich hodnoty
a pak je vypÃ­Å¡e na vÃ½stup programu (k vÃ½pisu vyuÅ¾ijte <code>printf</code>, kterÃ½ jsme si jiÅ¾ ukÃ¡zali <a href="c/promenne/../prikazy_vyrazy.html#v%C3%BDpis-v%C3%BDraz%C5%AF">dÅ™Ã­ve</a>).</li>
<li>PouÅ¾ijte <a href="c/promenne/../../prostredi/ladeni.html#krokov%C3%A1n%C3%AD">debugger</a>, abyste se interaktivnÄ› za bÄ›hu programu
podÃ­vali, jakÃ© jsou hodnoty jednotlivÃ½ch promÄ›nnÃ½ch a jak se mÄ›ni v Äase po provedenÃ­ pÅ™iÅ™azenÃ­.</li>
</ol>
<p>VÃ­ce Ãºloh naleznete <a href="c/promenne/../../ulohy/promenne.html">zde</a>.</p>
<hr />
<p><strong>KvÃ­z</strong> ğŸ¤”</p>
<ol>
<li>
<p>Co vypÃ­Å¡e nÃ¡sledujÃ­cÃ­ program?</p>
<pre><code class="language-c editable mainbody">#include &lt;stdio.h&gt;

int main() {
    int a = 5;
    printf(&quot;a\n&quot;);

    return 0;
}
</code></pre>
<details>
 <summary>OdpovÄ›Ä</summary>
<p>Program vypÃ­Å¡e znak <code>a</code>, jelikoÅ¾ vÅ¡e uvnitÅ™ uvozovek se bere jako text. Aby program vypsal
hodnotu promÄ›nnÃ© <code>a</code>, museli bychom pouÅ¾Ã­t napÅ™. pÅ™Ã­kaz <code>printf(&quot;a=%d\n&quot;, a);</code>.</p>
</details>
</li>
<li>
<p>Co vypÃ­Å¡e nÃ¡sledujÃ­cÃ­ program?</p>
<pre><code class="language-c editable mainbody">#include &lt;stdio.h&gt;

int main() {
    int a = 5;
    printf(&quot;%d\n&quot;, a);
    a = 8;

    return 0;
}
</code></pre>
<details>
 <summary>OdpovÄ›Ä</summary>
<p>Program vypÃ­Å¡e znak <code>5</code>, protoÅ¾e v dobÄ›, kdy promÄ›nnou vypisujeme, tak je jejÃ­ hodnota <code>5</code>.
Po vypsÃ¡nÃ­ promÄ›nnÃ© sice jejÃ­ hodnotu zmÄ›nÃ­me na <code>8</code>, ale potÃ© uÅ¾ ji nevypÃ­Å¡eme a program skonÄÃ­.</p>
</details>
</li>
<li>
<p>Co vypÃ­Å¡e nÃ¡sledujÃ­cÃ­ program?</p>
<pre><code class="language-c editable mainbody">#include &lt;stdio.h&gt;

int main() {
    int a = 5;
    a + 1;
    printf(&quot;%d\n&quot;, a);

    return 0;
}
</code></pre>
<details>
 <summary>OdpovÄ›Ä</summary>
<p>Program vypÃ­Å¡e znak <code>5</code>. Provedeme sice vÃ½raz <code>a + 1</code>, kterÃ½ se vyhodnotÃ­ jako <code>6</code>, ale vÃ½sledek
tohoto vÃ½razu se &quot;zahodÃ­&quot;, nijak tedy neovlivnÃ­ dalÅ¡Ã­ chovÃ¡nÃ­ programu. Abychom zmÄ›nili hodnotu
promÄ›nnÃ© <code>a</code>, museli bychom vÃ½sledek tohoto vÃ½razu zpÄ›t do promÄ›nnÃ© uloÅ¾it: <code>a = a + 1;</code>.
VyzkouÅ¡ejte si to.</p>
</details>
</li>
<li>
<p>Co vypÃ­Å¡e nÃ¡sledujÃ­cÃ­ program?</p>
<pre><code class="language-c editable mainbody">#include &lt;stdio.h&gt;

int main() {
    int a = 5;
    int b = a;
    a = 8;

    printf(&quot;%d\n&quot;, a);
    printf(&quot;%d\n&quot;, b);

    return 0;
}
</code></pre>
<details>
 <summary>OdpovÄ›Ä</summary>
<p>Program vypÃ­Å¡e:</p>
<pre><code>8
5
</code></pre>
<p>PÅ™i definici promÄ›nnÃ© <code>b</code> jsme ji inicializovali hodnotou promÄ›nnÃ© <code>a</code>. VÃ½raz <code>a</code> se tedy
vyhodnotil jako hodnota <code>5</code>, kterÃ¡ byla uloÅ¾ena do promÄ›nnÃ© <code>b</code>. DÃ¡le vÅ¡ak uÅ¾ spolu promÄ›nnÃ©
nesouvisÃ­, zmÄ›na hodnoty promÄ›nnÃ© <code>a</code> tedy nijak neovlivnÃ­ hodnotu uloÅ¾enou v promÄ›nnÃ© <code>b</code>.</p>
</details>
</li>
<li>
<p>Co vypÃ­Å¡e nÃ¡sledujÃ­cÃ­ program?</p>
<pre><code class="language-c editable mainbody">#include &lt;stdio.h&gt;

int main() {
    printf(&quot;%d\n&quot;, a);
    int a = 5;

    return 0;
}
</code></pre>
<details>
 <summary>OdpovÄ›Ä</summary>
<p>PÅ™eklad programu skonÄÃ­ s chybou (<code>use of undeclared identifier 'a'</code>), protoÅ¾e se snaÅ¾Ã­me ÄÃ­st
hodnotu promÄ›nnÃ©, kterÃ¡ na danÃ©m Å™Ã¡dku zatÃ­m nebyla nadefinovÃ¡na. PromÄ›nnou <code>a</code> mÅ¯Å¾eme zaÄÃ­t
pouÅ¾Ã­vat aÅ¾ potÃ©, co ji nadefinujeme, tj. za Å™Ã¡dkem <code>int a = 5;</code>.</p>
</details>
</li>
<li>
<p>Co vypÃ­Å¡e nÃ¡sledujÃ­cÃ­ program?</p>
<pre><code class="language-c editable mainbody">#include &lt;stdio.h&gt;

int main() {
    a = 5;
    printf(&quot;%d\n&quot;, a);

    return 0;
}
</code></pre>
<details>
 <summary>OdpovÄ›Ä</summary>
<p>PÅ™eklad programu skonÄÃ­ s chybou (<code>use of undeclared identifier 'a'</code>), protoÅ¾e se snaÅ¾Ã­me zapsat
vÃ½raz <code>5</code> do promÄ›nnÃ©, kterÃ¡ neexistuje. PÅ™ed prvnÃ­m pouÅ¾itÃ­m promÄ›nnÃ© ji vÅ¾dy nejprve musÃ­me
nadefinovat: <code>int a = 5;</code>.</p>
</details>
</li>
<li>
<p>Co vypÃ­Å¡e nÃ¡sledujÃ­cÃ­ program?</p>
<pre><code class="language-c editable mainbody">#include &lt;stdio.h&gt;

int main() {
    int a = 1;
    int b = a = 5;
    printf(&quot;%d\n&quot;, a);
    printf(&quot;%d\n&quot;, b);

    return 0;
}
</code></pre>
<details>
 <summary>OdpovÄ›Ä</summary>
<p>Program vypÃ­Å¡e:</p>
<pre><code>5
5
</code></pre>
<p>VÃ½raz pÅ™iÅ™azenÃ­ (<code>&lt;promenna&gt; = &lt;vyraz&gt;</code>) se vyhodnotÃ­ jako pÅ™iÅ™azenÃ¡ hodnota (<code>&lt;vyraz&gt;</code>), a takto
vyhodnocenÃ½ vÃ½raz lze dÃ¡le v programu pouÅ¾Ã­t a napÅ™. pÅ™iÅ™adit do jinÃ© promÄ›nnÃ©. PÅ™iÅ™azenÃ­ se
vyhodnotÃ­ nÃ¡sledovnÄ›:</p>
<pre><code class="language-c">int b = a = 5;
// int b = 5;
</code></pre>
<p>NicmÃ©nÄ› jak asi sami uznÃ¡te, takovÃ½to zÃ¡pis je dosti zmateÄnÃ½ a nemusÃ­ bÃ½t na prvnÃ­ pohled jasnÃ©,
jak se takovÃ½to vÃ½raz vyhodnotÃ­. Proto vÃ½sledek vÃ½razu pÅ™iÅ™azenÃ­ radÄ›ji dÃ¡le nepouÅ¾Ã­vejte a
pÅ™iÅ™azenÃ­ vÅ¾dy pouÅ¾Ã­vejte na samostatnÃ©m Å™Ã¡dku se stÅ™ednÃ­kem.</p>
</details>
</li>
<li>
<p>Co vypÃ­Å¡e nÃ¡sledujÃ­cÃ­ program?</p>
<pre><code class="language-c editable mainbody">#include &lt;stdio.h&gt;

int main() {
    int a = 1;
    5 = a + 1;
    printf(&quot;%d\n&quot;, a);

    return 0;
}
</code></pre>
<details>
 <summary>OdpovÄ›Ä</summary>
<p>PÅ™eklad programu skonÄÃ­ s chybou <code>expression is not assignable</code>. SnaÅ¾Ã­me se zde uloÅ¾it hodnotu
vÃ½razu <code>a + 1</code> na nÄ›jakÃ© mÃ­sto v pamÄ›ti, ale <code>5</code> Å¾Ã¡dnÃ© takovÃ© mÃ­sto neoznaÄuje, <code>5</code> je prostÄ›
ÄÃ­selnÃ½ literÃ¡l s hodnotou <code>5</code>, kterÃ½ nemÅ¯Å¾eme pÅ™epsat Äi zmÄ›nit.</p>
</details>
</li>
<li>
<p>Co vypÃ­Å¡e nÃ¡sledujÃ­cÃ­ program?</p>
<pre><code class="language-c editable mainbody">#include &lt;stdio.h&gt;

int main() {
    int a;
    printf(&quot;%d\n&quot;, a + 1);

    return 0;
}
</code></pre>
<details>
 <summary>OdpovÄ›Ä</summary>
<p>Tento program obsahuje <a href="c/promenne/../../ruzne/nedefinovane_chovani.html"><strong>nedefinovanÃ© chovÃ¡nÃ­</strong></a> ğŸ’£, protoÅ¾e Äteme
hodnotu promÄ›nnÃ©, kterÃ¡ nebyla inicializovÃ¡na, a jejÃ­ hodnota je tedy nedefinovanÃ¡. Nelze tak urÄit, co
tento program provede, pÅ™ekladaÄ jej mÅ¯Å¾e pÅ™eloÅ¾it na totÃ¡lnÃ­ nesmysl. TakovÃ½to program je Å¡patnÄ› a nemÃ¡
smysl zkoumat, co provede, je potÅ™eba jej nejprve opravit tak, Å¾e promÄ›nnou <code>a</code> nainicializujeme.</p>
</details>
</li>
<li>
<p>Co vypÃ­Å¡e nÃ¡sledujÃ­cÃ­ program?</p>
<pre><code class="language-c editable mainbody">#include &lt;stdio.h&gt;

int main() {
    int a = a + 1;
    printf(&quot;%d\n&quot;, a);

    return 0;
}
</code></pre>
<details>
<summary>OdpovÄ›Ä</summary>
<p>Tento program obsahuje <a href="c/promenne/../../ruzne/nedefinovane_chovani.html"><strong>nedefinovanÃ© chovÃ¡nÃ­</strong></a> ğŸ’£, stejnÄ› jako pÅ™edchozÃ­
ukÃ¡zka. PÅ™i inicializaci promÄ›nnÃ© <code>a</code> pouÅ¾Ã­vÃ¡me jejÃ­ hodnotu, kterÃ¡ ale v tÃ© dobÄ› nenÃ­ definovanÃ¡. Je to jako kdybychom napsali</p>
<pre><code class="language-c">int a;
a = a + 1;
</code></pre>
</details>
</li>
<li>
<p>Co vypÃ­Å¡e nÃ¡sledujÃ­cÃ­ program?</p>
<pre><code class="language-c editable mainbody">#include &lt;stdio.h&gt;

int main() {
    printf(&quot;cislo: %d\n&quot;);

    return 0;
}
</code></pre>
<details>
<summary>OdpovÄ›Ä</summary>
<p>Tento program obsahuje <a href="c/promenne/../../ruzne/nedefinovane_chovani.html"><strong>nedefinovanÃ© chovÃ¡nÃ­</strong></a> ğŸ’£. Pokud pÅ™i pouÅ¾itÃ­
pÅ™Ã­kazu <code>printf</code> v textu mezi uvozovkami pouÅ¾ijeme zÃ¡stupnÃ½ znak (<code>%d</code>), musÃ­me za kaÅ¾dÃ½ takovÃ½to pouÅ¾itÃ½
znak pÅ™edat tÃ©to <em>funkci</em> takÃ© nÄ›jakÃ½ celoÄÃ­selnÃ½ vÃ½raz. V opaÄnÃ©m pÅ™Ã­padÄ› bude chovÃ¡nÃ­ programu nedefinovanÃ©.</p>
</details>
</li>
</ol>
<h1><a class="header" href="#globÃ¡lnÃ­-promÄ›nnÃ©" id="globÃ¡lnÃ­-promÄ›nnÃ©">GlobÃ¡lnÃ­ promÄ›nnÃ©</a></h1>
<p>PromÄ›nnÃ©, kterÃ© jsme si ukÃ¡zali, byly vytvÃ¡Å™eny uvnitÅ™ <a href="c/promenne/../funkce/funkce.html">funkcÃ­</a> (tj. ne na nejvyÅ¡Å¡Ã­
Ãºrovni souboru). TakovÃ©to promÄ›nnÃ© se nazÃ½vajÃ­ <strong>lokÃ¡lnÃ­ promÄ›nnÃ©</strong>. Pokud chceme, aby k nÄ›jakÃ©
promÄ›nnÃ© byl pÅ™Ã­stup odkudkoliv v programu, tak mÅ¯Å¾eme vytvoÅ™it promÄ›nnou na Ãºrovni souboru.
TakovÃ©to promÄ›nnÃ© se nazÃ½vajÃ­ <strong>globÃ¡lnÃ­</strong>.</p>
<p>V rÃ¡mci jednoho souboru lze globÃ¡lnÃ­ promÄ›nnou pouÅ¾Ã­t od mÃ­sta, kde je definovÃ¡na, aÅ¾ po
konec souboru:</p>
<pre><code class="language-c editable">#include &lt;stdio.h&gt;

// zde nelze pouÅ¾Ã­t promÄ›nnou `globalni_promenna`

int globalni_promenna = 1;

// zde lze pouÅ¾Ã­t promÄ›nnou `globalni_promenna`

int main() {
    // zde lze pouÅ¾Ã­t promÄ›nnou `globalni_promenna`

    globalni_promenna += 1;
    printf(&quot;%d\n&quot;, globalni_promenna);

    return 0;
}

void funkce2() {
    // zde lze pouÅ¾Ã­t promÄ›nnou `globalni_promenna`
    printf(&quot;%d\n&quot;, globalni_promenna);
}
</code></pre>
<h3><a class="header" href="#iniciÃ¡lnÃ­-hodnota" id="iniciÃ¡lnÃ­-hodnota">IniciÃ¡lnÃ­ hodnota</a></h3>
<p>NarozdÃ­l od lokÃ¡lnÃ­ch promÄ›nnÃ½ch, globÃ¡lnÃ­ promÄ›nnÃ© se nainicializujÃ­ na hodnotu <code>0</code><sup class='margin-toggle sidenote-number'>1</sup>, i kdyÅ¾
jim Å¾Ã¡dnou ÃºvodnÃ­ hodnotu nedÃ¡te. I tak je ale dobrÃ½m zvykem ÃºvodnÃ­ hodnotu takovÃ½mto promÄ›nnÃ½m dÃ¡t,
aby Å¡lo jasnÄ› vidÄ›t, Å¾e absence ÃºvodnÃ­ hodnoty nenÃ­ pouze nedopatÅ™enÃ­m ze strany programÃ¡tora.</p>
<span class='sidenote'><p><sup class='number'>1</sup>Je to zajiÅ¡tÄ›no tÃ­m, Å¾e jsou uloÅ¾eny v sekci spustitelnÃ©ho souboru nazÃ½vanÃ©
<a href="https://en.wikipedia.org/wiki/.bss"><code>.bss</code></a>. Po spuÅ¡tÄ›nÃ­ programu jsou tak automaticky vynulovÃ¡ny.</p>
</span>
<h3><a class="header" href="#nepouÅ¾Ã­vÃ¡nÃ­-globÃ¡lnÃ­ch-promÄ›nnÃ½ch" id="nepouÅ¾Ã­vÃ¡nÃ­-globÃ¡lnÃ­ch-promÄ›nnÃ½ch">(Ne)pouÅ¾Ã­vÃ¡nÃ­ globÃ¡lnÃ­ch promÄ›nnÃ½ch</a></h3>
<p>GlobÃ¡lnÃ­ promÄ›nnÃ© jsou zde zmÃ­nÄ›ny pro Ãºplnost, nicmÃ©nÄ› doporuÄujeme je pouÅ¾Ã­vat spÃ­Å¡e zÅ™Ã­dka,
obzvlÃ¡Å¡tÄ› pokud pÅ¯jde o globÃ¡lnÃ­ promÄ›nnÃ©, kterÃ© pÅ¯jde mÄ›nit (tj. pokud to nebudou
<a href="c/promenne/konstanty.html">konstanty</a>). ObecnÄ› Å™eÄeno, na ÄÃ­m vÃ­ce mÃ­stech je promÄ›nnÃ¡ dostupnÃ¡, tÃ­m sloÅ¾itÄ›jÅ¡Ã­
je pÅ™emÃ½Å¡lenÃ­ nad tÃ­m, jak pÅ™esnÄ› s nÃ­ pracovat, proto je lepÅ¡Ã­ pouÅ¾Ã­vat promÄ›nnÃ© lokÃ¡lnÃ­, pokud to
jde. </p>
<p>KdyÅ¾ je promÄ›nnÃ¡ globÃ¡lnÃ­, tak je k nÃ­ pÅ™Ã­stup v podstatÄ› odkudkoliv v programu. To sice znÃ­
neÅ¡kodnÄ›, ba i uÅ¾iteÄnÄ›, nicmÃ©nÄ› pÅ™inÃ¡Å¡Ã­ to s sebou znaÄnÃ© nevÃ½hody, pokud lze promÄ›nnou zÃ¡roveÅˆ
mÄ›nit. Jakmile totiÅ¾ lze promÄ›nnou odkudkoliv zmÄ›nit, snadno se vÃ¡m mÅ¯Å¾e stÃ¡t, Å¾e nÄ›jakÃ½ kus programu
vÃ¡m bude hodnotu takovÃ©to promÄ›nnÃ© mÄ›nit &quot;pod rukama&quot;, a bude obtÃ­Å¾nÃ© najÃ­t kÃ³d, kterÃ½ danou promÄ›nnou
zmÄ›nil (a takÃ© dÅ¯vod, proÄ ji zmÄ›nil).</p>
<blockquote>
<p>GlobÃ¡lnÃ­ promÄ›nnÃ© takÃ© mohou zpÅ¯sobovat problÃ©my, pokud ve vaÅ¡em problÃ©mu budete vyuÅ¾Ã­vat vÃ­ce jader
procesoru. Tzv. paralelnÃ­ programy nicmÃ©nÄ› nebudeme v tomto pÅ™edmÄ›tu Å™eÅ¡it, vÃ­ce se o nich dozvÃ­te
napÅ™Ã­klad v pÅ™edmÄ›tu <a href="http://poli.cs.vsb.cz/edu/apps/">Architektury poÄÃ­taÄÅ¯ a paralelnÃ­ch systÃ©mÅ¯</a>.</p>
</blockquote>
<h1><a class="header" href="#konstanty" id="konstanty">Konstanty</a></h1>
<p>V urÄitÃ½ch pÅ™Ã­padech mÅ¯Å¾eme chtÃ­t mÃ­t promÄ›nnÃ© s konstantnÃ­ hodnotou, kterÃ© by se nemÄ›ly v prÅ¯bÄ›hu
programu mÄ›nit. TakovÃ© promÄ›nnÃ© se nazÃ½vajÃ­ <strong>konstanty</strong> (<em>constants</em>).</p>
<p>Abychom zamezili nechtÄ›nÃ© zmÄ›nÄ› hodnoty konstanty, mÅ¯Å¾eme datovÃ½ typ promÄ›nnÃ© oznaÄit
<a href="c/promenne/../syntaxe.html#kl%C3%AD%C4%8Dov%C3%A1-slova">klÃ­ÄovÃ½m slovem</a> <code>const</code>, kterÃ½ umÃ­stÃ­me pÅ™ed<sup class='margin-toggle sidenote-number'>1</sup> nÃ¡zev datovÃ©ho typu.
Pokud bychom se snaÅ¾ili o zmÄ›nu promÄ›nnÃ© s takovÃ½mto datovÃ½m typem, pÅ™ekladaÄ nÃ¡m to nedovolÃ­.</p>
<span class='sidenote'><p><sup class='number'>1</sup>ModifikÃ¡tor <code>const</code> lze umÃ­stit i za datovÃ½ typ. NÄ›kteÅ™Ã­ programÃ¡toÅ™i o umÃ­stÄ›nÃ­ tohoto
modifikÃ¡toru vedou
<a href="https://mariusbancila.ro/blog/2018/11/23/join-the-east-const-revolution">vÃ¡Å¡nivÃ© diskuze</a>. DÅ¯leÅ¾itÃ©
hlavnÄ› je, abyste ve volbÄ› umÃ­stÄ›nÃ­ modifikÃ¡torÅ¯ byli konzistentnÃ­ a pouÅ¾Ã­vali je na vÅ¡ech mÃ­stech
stejnÄ›.</p>
</span>
<pre><code class="language-c editable mainbody">int main() {
    const int a = 5;
    a = a + 1; // chyba, nelze pÅ™eloÅ¾it

    return 0;
}
</code></pre>
<p>PouÅ¾itÃ­ konstant mÅ¯Å¾e mÃ­t nÄ›kolik dÅ¯vodÅ¯:</p>
<ul>
<li>
<p>V programech nÄ›kdy opakovanÄ› pouÅ¾Ã­vÃ¡me konstantnÃ­ hodnoty, kterÃ© majÃ­ pevnÄ› danou hodnotu. PÅ™i
ÄtenÃ­ zdrojovÃ©ho kÃ³du nemusÃ­ bÃ½t jasnÃ©, co takovÃ©ho hodnoty znamenajÃ­ (v takovÃ©m pÅ™Ã­padÄ› se hanlivÄ›
oznaÄujÃ­ jako &quot;magickÃ© konstanty&quot;). Abychom takovÃ©ho hodnoty pojmenovali, mÅ¯Å¾eme je uloÅ¾it do
konstantnÃ­ promÄ›nnÃ©. PÅ™i ÄtenÃ­ programu pak bude zÅ™ejmÃ©, co reprezentujÃ­. Porovnejte variantu
s nepopsanÃ½mi ÄÃ­selnÃ½mi hodnotami:</p>
<pre><code class="language-c">float vypocti_cenu(float cena) {
    return cena * (1 + 0.21);
}
float vypocti_odvod(float celkova_cena, bool dph) {
    if (dph) {
        return celkova_cena * 0.21;
    } else {
        return 0;
    }
}
</code></pre>
<p>s variantou vyuÅ¾Ã­vajÃ­cÃ­ pojmenovanÃ© konstanty:</p>
<pre><code class="language-c">const float DPH = 0.21f;

float vypocti_cenu(float cena) {
    return cena * (1 + DPH);
}
float vypocti_odvod(float celkova_cena, bool dph) {
    if (dph) {
        return celkova_cena * DPH;
    } else {
        return 0;
    }
}
</code></pre>
<p>DruhÃ¡ varianta kÃ³du je jistÄ› ÄitelnÄ›jÅ¡Ã­.</p>
</li>
<li>
<p>V urÄitÃ½ch pÅ™Ã­padech, napÅ™Ã­klad u konstantnÃ­ch <a href="c/promenne/../text/retezce.html">Å™etÄ›zcÅ¯</a>, jsou data uloÅ¾ena v oblasti
pamÄ›ti, kterou nelze mÄ›nit. PomocÃ­ <code>const</code> si mÅ¯Å¾eme pohlÃ­dat, Å¾e se takovÃ¡to pamÄ›Å¥ opravdu nezmÄ›nÃ­.</p>
</li>
</ul>
<h1><a class="header" href="#sloÅ¾enÃ½-zÃ¡pis" id="sloÅ¾enÃ½-zÃ¡pis">SloÅ¾enÃ½ zÃ¡pis</a></h1>
<p>ÄŒasto potÅ™ebujeme hodnotu promÄ›nnÃ© pouze trochu poupravit, a ne do nÃ­ vyloÅ¾enÄ› zapsat novou hodnotu.
BÄ›Å¾nÃ¡ je napÅ™Ã­klad operace zvÃ½Å¡enÃ­ hodnoty promÄ›nnÃ© o <code>1</code> (tzv. <strong>inkrementace</strong> promÄ›nnÃ©).
K tomu mÅ¯Å¾eme pouÅ¾Ã­t tento pÅ™Ã­kaz:</p>
<pre><code class="language-c">pocet = pocet + 1; // zvÃ½Å¡enÃ­ hodnoty promÄ›nnÃ© `pocet` o 1
</code></pre>
<p>nicmÃ©nÄ› to je docela zdlouhavÃ©. Proto <em>C</em> nabÃ­zÃ­ tzv. operÃ¡tory <strong>sloÅ¾enÃ©ho zÃ¡pisu</strong> (<em>compound
assignment</em>). Tyto operÃ¡tory jsou spojenÃ© z normÃ¡lnÃ­ho operÃ¡toru (napÅ™. <code>+</code>) a operÃ¡toru <code>=</code>, napÅ™Ã­klad:</p>
<ul>
<li><code>+=</code></li>
<li><code>-=</code></li>
<li><code>*=</code></li>
<li><code>/=</code></li>
</ul>
<p>SloÅ¾enÃ½ zÃ¡pis</p>
<pre><code class="language-c">&lt;promÄ›nnÃ¡&gt; &lt;operÃ¡tor&gt;= &lt;vÃ½raz&gt;;
</code></pre>
<p>je ekvivalentnÃ­ pÅ™Ã­kazu</p>
<pre><code class="language-c">&lt;promÄ›nnÃ¡&gt; = &lt;promÄ›nnÃ¡&gt; &lt;operÃ¡tor&gt; &lt;vÃ½raz&gt;;
</code></pre>
<p>NapÅ™Ã­klad:</p>
<pre><code class="language-c">int pocet = 0;
pocet += 1;   // stejnÃ© jako pocet = pocet + 1;
pocet *= 3;   // stejnÃ© jako pocet = pocet * 3; 
</code></pre>
<p>StejnÄ› jako <a href="c/promenne/promenne.html#z%C3%A1pis">zÃ¡pis</a> je sloÅ¾enÃ½ zÃ¡pis pÅ™Ã­kladem vÃ½razu s
<a href="c/promenne/../prikazy_vyrazy.html#vedlej%C5%A1%C3%AD-efekty">vedlejÅ¡Ã­m efektem</a>.</p>
<h3><a class="header" href="#inkrementace-a-dekrementace" id="inkrementace-a-dekrementace">Inkrementace a dekrementace</a></h3>
<p>SpeciÃ¡lnÃ­m pÅ™Ã­padem sloÅ¾enÃ©ho zÃ¡pisu je tzv. <strong>inkrementace</strong> (zvÃ½Å¡enÃ­ hodnoty promÄ›nnÃ© o jedniÄku)
a <strong>dekrementace</strong> (snÃ­Å¾enÃ­ hodnoty promÄ›nnÃ© o jedniÄku). Tyto operace jsou tak ÄastÃ©, Å¾e <em>C</em> obsahuje
speciÃ¡lnÃ­ &quot;zkratky&quot; pro jejich provedenÃ­. Aby to nebylo tak jednoduchÃ©, tak tyto zkratky
existujÃ­ ve dvou variantÃ¡ch:</p>
<ul>
<li><em>PostfixovÃ¡</em>: <code>&lt;promÄ›nnÃ¡&gt;++</code>. Tento vÃ½raz se nejprve vyhodnotÃ­ jako hodnota danÃ© promÄ›nnÃ©, a
<strong>potÃ©</strong> (provede vedlejÅ¡Ã­ efekt, kterÃ½) zvÃ½Å¡Ã­ hodnotu promÄ›nnÃ© o jedniÄku. Zkuste uhodnout, co vypÃ­Å¡e nÃ¡sledujÃ­cÃ­ program:
<pre><code class="language-c editable mainbody">#include &lt;stdio.h&gt;

int main() {
    int a = 1;
    int b = a++;
    printf(&quot;%d\n&quot;, a);
    printf(&quot;%d\n&quot;, b);

    return 0;
}
</code></pre>
</li>
<li><em>PrefixovÃ¡</em>: <code>++&lt;promÄ›nnÃ¡&gt;</code>. Tento vÃ½raz <strong>nejprve</strong> zvÃ½Å¡Ã­ hodnotu promÄ›nnÃ©, a aÅ¾ potÃ© se vyhodnotÃ­
jako (novÃ¡, jiÅ¾ zvÃ½Å¡enÃ¡) hodnota danÃ© promÄ›nnÃ©. Zkuste uhodnout, co vypÃ­Å¡e nÃ¡sledujÃ­cÃ­ program:
<pre><code class="language-c editable mainbody">#include &lt;stdio.h&gt;

int main() {
    int a = 1;
    int b = ++a;
    printf(&quot;%d\n&quot;, a);
    printf(&quot;%d\n&quot;, b);

    return 0;
}
</code></pre>
</li>
</ul>
<p>Dekrementace se chovÃ¡ totoÅ¾nÄ› jako inkrementace, pouze s tÃ­m rozdÃ­lem, Å¾e sniÅ¾uje hodnotu
promÄ›nnÃ© o <code>1</code> a mÃ­sto <code>++</code> pouÅ¾Ã­vÃ¡ <code>--</code>.</p>
<p>Inkrementace a dekrementace jsou opÄ›t pÅ™Ã­klady vÃ½razÅ¯ s vedlejÅ¡Ã­m efektem.</p>
<blockquote>
<p>Tyto zkratky jsou sice uÅ¾iteÄnÃ©, ale takÃ© mÅ¯Å¾ou vyÃºstit v pÅ™ekvapivÃ© chovÃ¡nÃ­ dÃ­ky zpÅ¯sobu, kterÃ½m
jsou vyhodnocovÃ¡ny. Ze zaÄÃ¡tku je radÅ¡i vyuÅ¾Ã­vejte pouze v situacÃ­ch, kdy budou pouÅ¾ity jako pÅ™Ã­kaz,
kterÃ½ zmÄ›nÃ­ hodnotu promÄ›nnÃ© (<code>i++;</code>). Jinak Å™eÄeno, radÄ›ji se moc nespolÃ©hejte na hodnotu, na
kterou se inkrementace/dekrementace vyhodnotÃ­.</p>
</blockquote>
<h1><a class="header" href="#pojmenovÃ¡vÃ¡nÃ­-promÄ›nnÃ½ch" id="pojmenovÃ¡vÃ¡nÃ­-promÄ›nnÃ½ch">PojmenovÃ¡vÃ¡nÃ­ promÄ›nnÃ½ch</a></h1>
<p>V <em>C</em> existujÃ­ urÄitÃ¡ pravidla pro pojmenovÃ¡nÃ­ promÄ›nnÃ½ch:</p>
<ul>
<li>PromÄ›nnÃ© se nesmÃ­ jmenovat stejnÄ› jako <a href="c/promenne/../syntaxe.html#kl%C3%AD%C4%8Dov%C3%A1-slova">klÃ­ÄovÃ¡ slova</a>, jinak by
pÅ™ekladaÄ neumÄ›l rozliÅ¡it, co je nÃ¡zev promÄ›nnÃ© a co klÃ­ÄovÃ© slovo (napÅ™Ã­klad <code>int int;</code>).</li>
<li>NÃ¡zev promÄ›nnÃ© mÅ¯Å¾e obsahovat pouze malÃ¡ (<code>a-z</code>) a velkÃ¡ (<code>A-Z</code>) pÃ­smena anglickÃ© abecedy, ÄÃ­slice
(<code>0-9</code>) a podtrÅ¾Ã­tko (<code>_</code>).</li>
<li>NÃ¡zev promÄ›nnÃ© nesmÃ­ zaÄÃ­nat ÄÃ­slicÃ­, tj. <code>5x</code> nenÃ­ validnÃ­ nÃ¡zev promÄ›nnÃ©.</li>
</ul>
<p>V programech je nutnÃ© neustÃ¡le pÅ™iÅ™azovat nÄ›Äemu nÃ¡zev, coÅ¾ zdaleka nenÃ­ tak jednoduchÃ©, jak se
mÅ¯Å¾e na prvnÃ­ pohled zdÃ¡t. KromÄ› vÃ½Å¡e zmÃ­nÄ›nÃ½ch pravidel je zÃ¡roveÅˆ vhodnÃ© volit nÃ¡zvy tak, aby byly
pÅ™ehlednÃ© pro vÃ¡s (a ostatnÃ­ programÃ¡tory, kteÅ™Ã­ vÃ¡Å¡ zdrojovÃ½ kÃ³d budou ÄÃ­st). NÃ¡zvy promÄ›nnÃ½ch jako
<code>a</code> nebo <code>x</code> jsou nicneÅ™Ã­kajÃ­cÃ­ a kÃ³d s podobnÃ½mi nÃ¡zvy je pak sloÅ¾itÄ›jÅ¡Ã­ pochopit. Porovnejte
nÃ¡sledujÃ­cÃ­ dva Ãºseky kÃ³du, kterÃ© se liÅ¡Ã­ pouze v pouÅ¾itÃ½ch nÃ¡zvech promÄ›nnÃ½ch:</p>
<pre><code class="language-c">int c = 1337;
int x = c - y;
int d = x * z;

// vs

int zakladni_cena = 1337;
int zlevnena_cena = zakladni_cena - sleva;
int finalni_cena = zlevnena_cena * dph;
</code></pre>
<p>I kdyÅ¾ je druhÃ¡ varianta delÅ¡Ã­, tak jde okamÅ¾itÄ› poznat, co program poÄÃ­tÃ¡, narozdÃ­l od prvnÃ­ varianty.</p>
<h3><a class="header" href="#vÃ­ceslovnÃ©-nÃ¡zvy" id="vÃ­ceslovnÃ©-nÃ¡zvy">VÃ­ceslovnÃ© nÃ¡zvy</a></h3>
<p>Existuje nÄ›kolik zabÄ›hlÃ½ch stylistickÃ½ch zpÅ¯sobÅ¯ pro zÃ¡pis nÃ¡zvÅ¯ v <em>C</em>, kterÃ© obsahujÃ­ vÃ­ce slov. Zde
je seznam nejpouÅ¾Ã­vanÄ›jÅ¡Ã­ch konvencÃ­:</p>
<ul>
<li><strong>Camel case</strong>: <code>mujUcet</code>, <code>prvniKlikUzivatele</code></li>
<li><strong>Pascal case</strong>: <code>MujUcet</code>, <code>PrvniKlikUzivatele</code></li>
<li><strong>Snake case</strong>: <code>muj_ucet</code>, <code>prvni_klik_uzivatele</code></li>
<li><strong>Screaming snake case</strong>: <code>MUJ_UCET</code>, <code>PRVNI_KLIK_UZIVATELE</code></li>
</ul>
<p>RÅ¯znÃ© konstrukce <em>C</em> mÅ¯Å¾ou vyuÅ¾Ã­vat rÅ¯znÃ© styly, napÅ™Ã­klad ÄastÃ¡ konvence je pouÅ¾itÃ­ <code>snake_case</code>
pro nÃ¡zvy <a href="c/promenne/promenne.html">promÄ›nnÃ½ch</a> a <a href="c/promenne/../funkce/funkce.html">funkcÃ­</a> a <code>PascalCase</code> pro nÃ¡zvy
<a href="c/promenne/../struktury/struktury.html">struktur</a>. KterÃ½ styl budete pouÅ¾Ã­vat zÃ¡leÅ¾Ã­ na vaÅ¡Ã­ osobnÃ­ preferenci,
nicmÃ©nÄ› dÅ¯leÅ¾itÃ© je zejmÃ©na drÅ¾et se jednotnÃ©ho stylu a nekombinovat rÅ¯znÃ© styly (pro stejnÃ½
typ konstrukcÃ­) v jednom programu.</p>
<h3><a class="header" href="#ÄŒeÅ¡tina-nebo-angliÄtina" id="ÄŒeÅ¡tina-nebo-angliÄtina">ÄŒeÅ¡tina nebo angliÄtina?</a></h3>
<p>Pokud vÃ¡m to pÅ™ijde pÅ™ehlednÄ›jÅ¡Ã­, tak ze zaÄÃ¡tku mÅ¯Å¾ete pouÅ¾Ã­vat ÄeskÃ© nÃ¡zvy<sup class='margin-toggle sidenote-number'>1</sup> pro nÃ¡zvy promÄ›nnÃ½ch
a dalÅ¡Ã­ch konstrukcÃ­. MÅ¯Å¾e tak pro vÃ¡s bÃ½t snadnÄ›jÅ¡Ã­ odliÅ¡it, kterou ÄÃ¡st kÃ³du jste vytvoÅ™ili vy (ta
bude mÃ­t ÄeskÃ½ nÃ¡zev), a co je naopak vestavÄ›nÃ¡ souÄÃ¡st <em>C</em> (napÅ™. <code>int</code>). </p>
<span class='sidenote'><p><sup class='number'>1</sup>Bez diakritiky.</p>
</span>
<p>NicmÃ©nÄ›, jak uÅ¾ bylo naznaÄeno v <a href="c/promenne/../../uvod/uvod.html">Ãºvodu</a>, primÃ¡rnÃ­m jazykem programovÃ¡nÃ­ je
angliÄtina. Pokud byste se nÄ›kdy setkali s cizÃ­m kÃ³dem a museli ho pochopit Äi upravit, urÄitÄ› ocenÃ­te,
kdyÅ¾ bude v angliÄtinÄ›, neÅ¾ kdyby byl napÅ™Ã­klad ve finÅ¡tinÄ›. StejnÄ› tak pokud budete sdÃ­let svÅ¯j
kÃ³d online, mÅ¯Å¾ete s nÃ­m oslovit mnohem Å¡irÅ¡Ã­ skupinu programÃ¡torÅ¯, kdyÅ¾ bude v angliÄtinÄ›, neÅ¾ kdyby
byl v ÄeÅ¡tinÄ›.</p>
<p>Jakmile se tedy v programovÃ¡nÃ­ trochu aklimatizujete, pouÅ¾Ã­vejte ve vÅ¡ech svÃ½ch programech radÄ›ji
anglickÃ© nÃ¡zvy.</p>
<h1><a class="header" href="#datovÃ©-typy-1" id="datovÃ©-typy-1">DatovÃ© typy</a></h1>
<p><a href="c/datove_typy/../../uvod/pamet.html">PamÄ›Å¥</a> poÄÃ­taÄe pracuje s jednotlivÃ½mi <em>byty</em>, nicmÃ©nÄ› pro lidi
je Å¾Ã¡doucÃ­ pouÅ¾Ã­vat popis dat v pamÄ›ti na mnohem vyÅ¡Å¡Ã­ Ãºrovni abstrakce, aby se nÃ¡m o datech
jednoduÅ¡Å¡eji pÅ™emÃ½Å¡lelo. Pokud programujeme textovÃ½ editor, chceme se bavit o znacÃ­ch, odstavcÃ­ch,
fontech Äi barvÃ¡ch, pokud programujeme poÄÃ­taÄovou hru, chceme se bavit o zbranÃ­ch, brnÄ›nÃ­, kouzlech
Äi pixelech.</p>
<p>PÅ™esnÄ› k tomu slouÅ¾Ã­ <strong>datovÃ© typy</strong>, kterÃ© popisujÃ­, jak budeme interpretovat konkrÃ©tnÃ­ hodnoty
danÃ©ho typu v pamÄ›ti, kolik bytÅ¯ budou zabÃ­rat a jakÃ© operace nad nimi budeme moct provÃ¡dÄ›t. Jazyk
Nejprve se podÃ­vÃ¡me na nÄ›kolik datovÃ½ch typÅ¯, kterÃ© jsou vestavÄ›nÃ© v jazyce <em>C</em>, a
<a href="c/datove_typy/../struktury/struktury.html">pozdÄ›ji</a> si ukÃ¡Å¾eme, jak si vytvoÅ™it svÃ© vlastnÃ­ datovÃ© typy.</p>
<h1><a class="header" href="#celoÄÃ­selnÃ©-datovÃ©-typy" id="celoÄÃ­selnÃ©-datovÃ©-typy">CeloÄÃ­selnÃ© datovÃ© typy</a></h1>
<p>Asi nejpÅ™irozenÄ›jÅ¡Ã­m a nejpouÅ¾Ã­vanÄ›jÅ¡Ã­m datovÃ½m typem ve vÄ›tÅ¡inÄ› programovacÃ­ch jazykÅ¯ jsou (celÃ¡)
ÄÃ­sla. Tyto ÄÃ­selnÃ© datovÃ© typy nÃ¡m umoÅ¾ÅˆujÃ­ pracovat s celÃ½mi ÄÃ­sly, kterÃ© majÃ­ typicky jednotky
(1 - 8) bytÅ¯<sup class='margin-toggle sidenote-number'>1</sup>. PoÄet bytÅ¯ udÃ¡vÃ¡, jak velkÃ½ rozsah mohou hodnoty danÃ©ho typu obsahovat. NapÅ™Ã­klad
ÄÃ­slo s 2 byty (16 bity) bez znamÃ©nka mÅ¯Å¾e obsahovat hodnoty 0 aÅ¾ 2<sup>16</sup>-1. ÄŒÃ­m vÃ­ce bytÅ¯,
tÃ­m vÃ­ce zabere hodnota danÃ©ho typu mÃ­sta v pamÄ›ti.</p>
<span class='sidenote'><p><sup class='number'>1</sup>I kdyÅ¾ 8 bytÅ¯ (64 bitÅ¯) mÅ¯Å¾e znÃ­t jako mÃ¡lo, tak pomocÃ­ takovÃ©ho ÄÃ­sla mÅ¯Å¾eme vyjÃ¡dÅ™it 2<sup>64</sup>
(neboli <code>18 446 744 073 709 551 616</code>) rÅ¯znÃ½ch hodnot, coÅ¾ pro naprostou vÄ›tÅ¡inu bÄ›Å¾nÃ©ho pouÅ¾itÃ­ ÄÃ­sel
bohatÄ› staÄÃ­.</p>
</span>
<p>U celÃ½ch ÄÃ­selnÃ½ch typÅ¯ se rozliÅ¡uje, zda jsou <strong>signed</strong> (se znamÃ©nkem) nebo <strong>unsigned</strong> (bez
znamÃ©nka, nezÃ¡pornÃ©). Tato vlastnost udÃ¡vÃ¡, jakÃ© hodnoty mÅ¯Å¾e typ nabÃ½vat
(tj. jestli mohou bÃ½t i zÃ¡pornÃ© nebo ne). NapÅ™Ã­klad ÄÃ­slem o velikosti jednoho bytu mÅ¯Å¾eme
reprezentovat 256 rÅ¯znÃ½ch hodnot:</p>
<ul>
<li>Pokud ho budeme interpretovat bez znamÃ©nka, tak mÅ¯Å¾e uchovÃ¡vat hodnoty 0 aÅ¾ 255.</li>
<li>Pokud ho budeme interpretovat se znamÃ©nkem, tak mÅ¯Å¾e uchovÃ¡vat hodnoty -128 aÅ¾ 127.</li>
</ul>
<p><em>C</em> obsahuje nÄ›kolik zÃ¡kladnÃ­ch typÅ¯ celoÄÃ­selnÃ½ch promÄ›nnÃ½ch, kterÃ© se liÅ¡Ã­ v tom, kolik majÃ­ bytÅ¯ a
jestli jsou znamÃ©nkovÃ© nebo ne. Pokud pÅ™ed nÃ¡zev typu napÃ­Å¡eme <code>signed</code>, bude se jednat o znamÃ©nkovÃ½
typ, pokud pouÅ¾ijeme <code>unsigned</code>, tak pouÅ¾ijeme typ bez znamÃ©nka. VÄ›tÅ¡ina typÅ¯ je implicitnÄ› se
znamÃ©nkem, tj. <code>int</code> je to samÃ© jako <code>signed int</code>. V nÃ¡sledujÃ­cÃ­ tabulce je seznam nejÄastÄ›jÅ¡Ã­ch
celoÄÃ­selnÃ½ch typÅ¯<sup class='margin-toggle sidenote-number'>2</sup>:</p>
<span class='sidenote'><p><sup class='number'>2</sup>PoÄet bytÅ¯ (a znamÃ©nkovost u typu <code>char</code>) zÃ¡leÅ¾Ã­ na kombinaci pouÅ¾itÃ©ho hardwaru,
operaÄnÃ­ho systÃ©mu a pÅ™ekladaÄe. Zde jsou uvedeny hodnoty, se kterÃ½mi se mÅ¯Å¾ete
nejÄastÄ›ji setkat na 64-bitovÃ©m x86 LinuxovÃ©m systÃ©mu s pÅ™ekladaÄem GCC pÅ™i pouÅ¾itÃ­
<a href="https://cs.wikipedia.org/wiki/Dvojkov%C3%BD_dopln%C4%9Bk">dvojkovÃ©ho doplÅˆku</a>.</p>
</span><table><thead><tr><th>NÃ¡zev</th><th align="center">PoÄet bytÅ¯</th><th align="center">Rozsah hodnot</th><th align="center">Se znamÃ©nkem</th></tr></thead><tbody>
<tr><td><code>char</code> nebo<br /><code>signed char</code></td><td align="center">1</td><td align="center">[-128; 127]</td><td align="center"><i class="fa fa-check"></i></td></tr>
<tr><td><code>unsigned char</code></td><td align="center">1</td><td align="center">[0; 255]</td><td align="center"><i class="fa fa-times"></i></td></tr>
<tr><td><code>short</code> nebo<br /><code>signed short</code></td><td align="center">2</td><td align="center">[-32 768; 32 767]</td><td align="center"><i class="fa fa-check"></i></td></tr>
<tr><td><code>unsigned short</code></td><td align="center">2</td><td align="center">[0; 65 535]</td><td align="center"><i class="fa fa-times"></i></td></tr>
<tr><td><strong><code>int</code></strong> nebo<br /><code>signed int</code></td><td align="center">4</td><td align="center">[-2 147 483 648; 2 147 483 647]</td><td align="center"><i class="fa fa-check"></i></td></tr>
<tr><td><code>unsigned int</code></td><td align="center">4</td><td align="center">[0; 4 294 967 295]</td><td align="center"><i class="fa fa-times"></i></td></tr>
<tr><td><code>long</code> nebo<br /><code>signed long</code></td><td align="center">8</td><td align="center">[-9 223 372 036 854 775 808;<br />9 223 372 036 854 775 807]</td><td align="center"><i class="fa fa-check"></i></td></tr>
<tr><td><code>unsigned long</code></td><td align="center">8</td><td align="center">[0; 18 446 744 073 709 551 615]</td><td align="center"><i class="fa fa-times"></i></td></tr>
</tbody></table>
<p>KaÅ¾dÃ½ vestavÄ›nÃ½ datovÃ½ typ (<code>char</code>, <code>short</code>, <code>int</code>) a modifikÃ¡tor znamÃ©nkovosti (<code>signed</code>, <code>unsigned</code>)
je zÃ¡roveÅˆ klÃ­ÄovÃ½m slovem.</p>
<p>Pokud ze zaÄÃ¡tku nebudete vÄ›dÄ›t, kterÃ½ typ zvolit, tak pro zÃ¡kladnÃ­ aritmetickÃ© operace pouÅ¾Ã­vejte
ze zaÄÃ¡tku typy se znamÃ©nkem s 4 byty, tedy <code>int</code>. Tento typ je takÃ© implicitnÄ› pouÅ¾it, kdyÅ¾ v programu
pouÅ¾ijete ÄÃ­selnÃ½ vÃ½raz, napÅ™Ã­klad vÃ½raz <code>1</code> mÃ¡ datovÃ½ typ <code>int</code><sup class='margin-toggle sidenote-number'>3</sup>.</p>
<span class='sidenote'><p><sup class='number'>3</sup>Pouze pokud by vÃ½raz neÅ¡el reprezentovat typem <code>int</code>, pouÅ¾ije se ÄÃ­selnÃ½ typ s vÃ­ce byty.</p>
</span>
<blockquote>
<p>Typ <code>char</code> je speciÃ¡lnÃ­ v tom, Å¾e zÃ¡roveÅˆ bÄ›Å¾nÄ› reprezentuje textovÃ© znaky v
<a href="https://www.asciitable.com/">ASCII</a> kÃ³dovÃ¡nÃ­. VÃ­ce o reprezentaci textu v programech se dozvÃ­te
v sekci o <a href="c/datove_typy/../text/retezce.html">Å™etÄ›zcÃ­ch</a>.</p>
</blockquote>
<h3><a class="header" href="#operace-s-ÄÃ­selnÃ½mi-typy" id="operace-s-ÄÃ­selnÃ½mi-typy">Operace s ÄÃ­selnÃ½mi typy</a></h3>
<p><em>C</em> umoÅ¾Åˆuje provÃ¡dÄ›t operace nad vestavÄ›nÃ½mi datovÃ½mi typy pomocÃ­ tzv. <strong>operÃ¡torÅ¯</strong>. PÅ™i prÃ¡ci s
vÃ½razy celoÄÃ­selnÃ½ch typÅ¯ lze provÃ¡dÄ›t bÄ›Å¾nÃ© aritmetickÃ© operace <code>+</code>, <code>-</code>, <code>/</code>, <code>*</code> nebo <code>%</code> (zbytek
po dÄ›lenÃ­). NapÅ™Ã­klad <code>5 + 8</code> nebo <code>2 * 16</code> tak bude obvykle fungovat tak, jak byste oÄekÃ¡vali. Je si
ale tÅ™eba dÃ¡t pozor na nÄ›kolik zrÃ¡dnÃ½ch vÄ›cÃ­:</p>
<ul>
<li>PÅ™i dÄ›lenÃ­ dvou celoÄÃ­selnÃ½ch ÄÃ­sel pomocÃ­ operÃ¡toru <code>/</code> dochÃ¡zÃ­ k celoÄÃ­selnÃ©mu dÄ›lenÃ­, tj. napÅ™Ã­klad
vÃ½sledek vÃ½razu <code>5 / 2</code> je <code>2</code>, a ne <code>2.5</code>. Pokud chcete provÃ¡dÄ›t dÄ›lenÃ­ desetinnÃ½ch ÄÃ­sel, musÃ­te
pouÅ¾Ã­t <a href="c/datove_typy/desetinne_typy.html">odpovÃ­dajÃ­cÃ­</a> datovÃ½ typ. Zkuste si to:
<pre><code class="language-c editable mainbody">#include &lt;stdio.h&gt;
int main() {
    printf(&quot;%d\n&quot;, 5 / 2);
    return 0;
}
</code></pre>
</li>
<li>JelikoÅ¾ majÃ­ ÄÃ­sla v poÄÃ­taÄi omezenou pÅ™esnost (typicky nÄ›kolik jednotek bytÅ¯), tak mÅ¯Å¾e pÅ™i matematickÃ½ch
operacÃ­ch dojÃ­t k tzv. <strong>pÅ™eteÄenÃ­</strong> (<em>overflow</em>). NapÅ™Ã­klad pokud vynÃ¡sobÃ­me jednobytovÃ© ÄÃ­slo <code>50</code>
hodnotou <code>10</code>, tak bychom oÄekÃ¡vali vÃ½sledek <code>500</code>, nicmÃ©nÄ› tak velkÃ© ÄÃ­slo nelze v jednom bytu reprezentovat.
VÃ½sledkem mÃ­sto toho bude <code>244</code> (<code>500 % 256</code>), pokud se jednÃ¡ o ÄÃ­slo bez znamÃ©nka, nebo <code>-12</code>, pokud
jde o ÄÃ­slo se znamÃ©nkem. PodobnÃ© vÃ½sledky jsou silnÄ› neintuitivnÃ­, pokud tedy vÃ¡Å¡ program vrÃ¡cÃ­ zvlÃ¡Å¡tnÃ­
ÄÃ­selnÃ½ vÃ½sledek, zkontrolujte si, jestli neprovÃ¡dÃ­te operace, pÅ™i kterÃ½ch mohlo dojÃ­t k pÅ™eteÄenÃ­.</li>
<li><em>C</em> provÃ¡dÃ­ <a href="https://www.guru99.com/c-type-casting.html">implicitnÃ­ konverze</a> mezi datovÃ½mi typy,
kterÃ© mohou zmÄ›nit datovÃ½ typ vÃ½razÅ¯, kterÃ© pouÅ¾Ã­vÃ¡te, bez vaÅ¡eho vÄ›domÃ­. Je tak (obzvlÃ¡Å¡tÄ› ze zaÄÃ¡tku)
vhodnÃ© ujistit se, Å¾e provÃ¡dÃ­te operace mezi stejnÃ½mi datovÃ½mi typy.</li>
<li>StejnÄ› jako v matematice, tak i v <em>C</em> zÃ¡leÅ¾Ã­ u operÃ¡torÅ¯ na jejich prioritÄ› a asociativitÄ›.
Seznam vÅ¡ech operÃ¡torÅ¯ spolu s jejich prioritiou naleznete <a href="https://en.cppreference.com/w/c/language/operator_precedence">zde</a>.
NapÅ™Ã­klad vÃ½sledek vÃ½razu <code>1 + 2 * 3</code> je <code>7</code>, a ne <code>9</code>. Pokud budete chtÃ­t prioritu ovlivnit, mÅ¯Å¾ete
vÃ½razy <strong>uzÃ¡vorkovat</strong>, abyste jim dali vÄ›tÅ¡Ã­ pÅ™ednost: <code>(1 + 2) * 3</code> se vyhodnotÃ­ jako <code>9</code>.</li>
</ul>
<p>KromÄ› zÃ¡kladnÃ­ch aritmetickÃ½ch operacÃ­ <em>C</em> podporuje takÃ© <a href="https://cs.wikipedia.org/wiki/Bitov%C3%A1_operace">bitovÃ© operace</a>:</p>
<ul>
<li>AND: operÃ¡tor <code>&amp;</code></li>
<li>OR: operÃ¡tor <code>|</code></li>
<li>XOR: operÃ¡tor <code>^</code></li>
</ul>
<blockquote>
<p>Zkuste si procviÄit, jestli sprÃ¡vnÄ› rozumÃ­te, jak <em>C</em> vyhodnocuje vÃ½razy, na
<a href="c/datove_typy/../../ruzne/vyhodnocovani_vyrazu.html">tÃ©to</a> strÃ¡nce.</p>
</blockquote>
<hr />
<p><strong>CviÄenÃ­</strong> ğŸ‹</p>
<p>Zkuste napsat jednoduchÃ½ program, kterÃ½ vypoÄÃ­tÃ¡ rÅ¯znÃ© matematickÃ© vÃ½razy a vypÃ­Å¡e
je na vÃ½stup. VyhodnocovÃ¡nÃ­ vÃ½razÅ¯ si mÅ¯Å¾ete procviÄit <a href="c/datove_typy/../../ruzne/vyhodnocovani_vyrazu.html">zde</a>
nebo <a href="c/datove_typy/../../ulohy/promenne.html">zde</a>. </p>
<hr />
<h3><a class="header" href="#tabulka-aritmetickÃ½ch-operÃ¡torÅ¯" id="tabulka-aritmetickÃ½ch-operÃ¡torÅ¯">Tabulka aritmetickÃ½ch operÃ¡torÅ¯</a></h3>
<p>Zde je pro pÅ™ehlednost tabulka se zÃ¡kladnÃ­mi aritmetickÃ½mi operÃ¡tory.
DatovÃ½ typ vÃ½sledku tÄ›chto operÃ¡torÅ¯ zÃ¡leÅ¾Ã­ na datovÃ©m typu jejich parametrÅ¯.</p>
<table><thead><tr><th align="center">OperÃ¡tor</th><th align="center">Popis</th><th align="center">PÅ™Ã­klad</th></tr></thead><tbody>
<tr><td align="center"><code>+</code></td><td align="center">SeÄtenÃ­</td><td align="center"><code>1 + 5</code></td></tr>
<tr><td align="center"><code>-</code></td><td align="center">OdeÄtenÃ­</td><td align="center"><code>2.3 - 4.8</code></td></tr>
<tr><td align="center"><code>*</code></td><td align="center">NÃ¡sobenÃ­</td><td align="center"><code>3 * 8</code></td></tr>
<tr><td align="center"><code>/</code></td><td align="center">DÄ›lenÃ­</td><td align="center"><code>4 / 2</code></td></tr>
<tr><td align="center"><code>%</code></td><td align="center">Zbytek po dÄ›lenÃ­ (modulo)</td><td align="center"><code>5 % 2</code></td></tr>
<tr><td align="center"><code>&amp;</code></td><td align="center">BitovÃ½ souÄin</td><td align="center"><code>12 &amp; 4</code></td></tr>
<tr><td align="center"><code>|</code></td><td align="center">BitovÃ½ souÄet</td><td align="center"><code>12 | 4</code></td></tr>
<tr><td align="center"><code>~</code></td><td align="center">BitovÃ¡ negace</td><td align="center"><code>~8</code></td></tr>
<tr><td align="center"><code>^</code></td><td align="center">BitovÃ½ XOR</td><td align="center"><code>14 ^ 18</code></td></tr>
<tr><td align="center"><code>&lt;&lt;</code></td><td align="center">BitovÃ½ posun doleva</td><td align="center"><code>137 &lt;&lt; 2</code></td></tr>
<tr><td align="center"><code>&gt;&gt;</code></td><td align="center">BitovÃ½ posun doprava</td><td align="center"><code>140 &gt;&gt; 3</code></td></tr>
</tbody></table>
<p>O dalÅ¡Ã­ch typech operÃ¡torÅ¯ se postupnÄ› dozvÃ­te bÄ›hem semestru.
PlnÃ½ seznam <em>C</em> operÃ¡torÅ¯ naleznete <a href="https://en.cppreference.com/w/c/language/operator_precedence">zde</a>.</p>
<h3><a class="header" href="#hexadecimÃ¡lnÃ­-a-oktÃ¡lnÃ­-zÃ¡pis-ÄÃ­sel" id="hexadecimÃ¡lnÃ­-a-oktÃ¡lnÃ­-zÃ¡pis-ÄÃ­sel">HexadecimÃ¡lnÃ­ a oktÃ¡lnÃ­ zÃ¡pis ÄÃ­sel</a></h3>
<p>V <em>C</em> mÅ¯Å¾ete zapisovat ÄÃ­selnÃ© hodnoty takÃ© pomocÃ­ oktÃ¡lnÃ­ (osmiÄkovÃ©) Äi hexadecimÃ¡lnÃ­ (Å¡estnÃ¡ctkovÃ©)
soustavy. ÄŒÃ­sla zaÄÃ­najÃ­cÃ­ na <code>0</code> budou interpretovÃ¡na jako osmiÄkovÃ¡ soustava, ÄÃ­sla zaÄÃ­najÃ­cÃ­ na
<code>0x</code> budou interpretovÃ¡na jako Å¡estnÃ¡ctkovÃ¡ soustava:</p>
<pre><code class="language-c editable mainbody">#include &lt;stdio.h&gt;

int main() {
    int a = 13;     // hodnota 13
    int b = 015;    // hodnota 13
    int c = 0xD;    // hodnota 13
    printf(&quot;%d\n&quot;, a);
    printf(&quot;%d\n&quot;, b);
    printf(&quot;%d\n&quot;, c);

    return 0;
}
</code></pre>
<hr />
<p><strong>KvÃ­z</strong> ğŸ¤”</p>
<ol>
<li>
<p>Co vypÃ­Å¡e nÃ¡sledujÃ­cÃ­ program?</p>
<pre><code class="language-c editable mainbody">#include &lt;stdio.h&gt;

int main() {
    printf(&quot;%d\n&quot;, 1 + 3 * 8 - 2);

    return 0;
}
</code></pre>
<details>
 <summary>OdpovÄ›Ä</summary>
<p>Program vypÃ­Å¡e <code>23</code>.</p>
</details>
</li>
<li>
<p>Co vypÃ­Å¡e nÃ¡sledujÃ­cÃ­ program?</p>
<pre><code class="language-c editable mainbody">#include &lt;stdio.h&gt;

int main() {
    int a = 1 + 4 * 2;
    int b = a + 2 * a;
    printf(&quot;%d\n&quot;, (b + 1) * 2);

    return 0;
}
</code></pre>
<details>
 <summary>OdpovÄ›Ä</summary>
<p>Program vypÃ­Å¡e <code>56</code>.</p>
</details>
</li>
</ol>
<h1><a class="header" href="#desetinnÃ©-ÄÃ­selnÃ©-typy" id="desetinnÃ©-ÄÃ­selnÃ©-typy">DesetinnÃ© ÄÃ­selnÃ© typy</a></h1>
<p>Pokud budete chtÃ­t provÃ¡dÄ›t vÃ½poÄty s desetinnÃ½mi ÄÃ­sly, tak mÅ¯Å¾ete vyuÅ¾Ã­t datovÃ© typy s tzv.
<strong>plovoucÃ­ Å™Ã¡dovou ÄÃ¡rkou</strong> (<em>floating point numbers</em>). Hodnoty tÄ›chto datovÃ½ch typÅ¯ umoÅ¾ÅˆujÃ­ pracovat
s ÄÃ­sly, kterÃ© se sklÃ¡dajÃ­ z celÃ© a z desetinnÃ© ÄÃ¡sti. DÃ­ky
tomu, jak jsou <a href="https://cs.wikipedia.org/wiki/Pohybliv%C3%A1_%C5%99%C3%A1dov%C3%A1_%C4%8D%C3%A1rka">navrÅ¾ena</a>,
tato ÄÃ­sla dokÃ¡Å¾Ã­ reprezentovat jak velmi malÃ©, tak velmi velkÃ© hodnoty (za cenu menÅ¡Ã­ pÅ™esnosti
desetinnÃ© ÄÃ¡sti).</p>
<p>V <em>C</em> jsou dva zÃ¡kladnÃ­ vestavÄ›nÃ© datovÃ© typy pro prÃ¡ci s desetinnÃ½mi ÄÃ­sly, kterÃ© se liÅ¡Ã­ velikostÃ­
(a tedy i tÃ­m, jak pÅ™esnÄ› dokÃ¡Å¾Ã­ desetinnÃ¡ ÄÃ­sla reprezentovat). Oba dva typy jsou znamÃ©nkovÃ©:</p>
<table><thead><tr><th>NÃ¡zev</th><th align="center">PoÄet bytÅ¯</th><th align="center">Rozsah hodnot</th><th align="center">PÅ™esnost</th><th align="center">Se znamÃ©nkem</th></tr></thead><tbody>
<tr><td><code>float</code></td><td align="center">4</td><td align="center">[-3.4x10<sup>38</sup>; 3.4x10<sup>38</sup>]</td><td align="center">~7 des. mÃ­st</td><td align="center"><i class="fa fa-check"></i></td></tr>
<tr><td><code>double</code></td><td align="center">8</td><td align="center">[-1.7x10<sup>308</sup>; 1.7x10 <sup>308</sup>]</td><td align="center">~16 des. mÃ­st</td><td align="center"><i class="fa fa-check"></i></td></tr>
</tbody></table>
<p>Slovo <code>double</code> pochÃ¡zÃ­ z pojmu &quot;double precision&quot;, tedy dvojitÃ¡ pÅ™esnost (typ <code>float</code> se takÃ© nÄ›kdy
oznaÄuje pomocÃ­ &quot;single precision&quot;).</p>
<p>Pokud chcete v programu vytvoÅ™it vÃ½raz datovÃ©ho typu <code>double</code>, staÄÃ­ napsat desetinnÃ© ÄÃ­slo (jako
desetinnÃ½ oddÄ›lovaÄ se pouÅ¾Ã­vÃ¡ teÄka, ne ÄÃ¡rka): <code>10.5</code>, <code>-0.73</code>. Pokud chcete vytvoÅ™it vÃ½raz typu
<code>float</code>, tak za toto ÄÃ­slo jeÅ¡tÄ› pÅ™idejte znak <code>f</code>: <code>10.5f</code>, <code>-0.73f</code>.</p>
<h3><a class="header" href="#formÃ¡tovanÃ½-vÃ½stup-desetinnÃ½ch-ÄÃ­sel" id="formÃ¡tovanÃ½-vÃ½stup-desetinnÃ½ch-ÄÃ­sel">FormÃ¡tovanÃ½ vÃ½stup desetinnÃ½ch ÄÃ­sel</a></h3>
<p>Pokud chcete vytisknout na vÃ½stup hodnotu datovÃ©ho typu <code>float</code> nebo <code>double</code>, mÅ¯Å¾ete pouÅ¾Ã­t
<a href="c/datove_typy/../prikazy_vyrazy.html#v%C3%BDpis-v%C3%BDraz%C5%AF">zÃ¡stupnÃ½ znak</a> <code>%f</code>:</p>
<pre><code class="language-c">printf(&quot;Desetinne cislo: %f\n&quot;, 1.0);
</code></pre>
<p>JednoduchÃ© pouÅ¾itÃ­ zÃ¡stupnÃ©ho znaku <code>%f</code> vÅ¡ak zpÅ¯sobÃ­, Å¾e se desetinnÃ© ÄÃ­slo vypÃ­Å¡e v rozvoji,
tj. pro ÄÃ­slo <code>1.0</code> se vypÃ­Å¡e do termÃ­nÃ¡lu <code>1.000000</code>.</p>
<p>Abychom mohli specifikovat, kolik ÄÃ­slic chceme vypsat za desetinnou teÄkou, musÃ­me k zÃ¡stupnÃ©mu znaku
doplnit formÃ¡tovÃ¡nÃ­. Pro datovÃ½ typ <code>float</code> a <code>double</code> pouÅ¾Ã­vÃ¡me nÃ¡sledujÃ­cÃ­ syntaxi:</p>
<pre><code class="language-c">printf(&quot;Desetinne cislo: %.2f\n&quot;, 1.0);
</code></pre>
<p>kde pÅ™ed zÃ¡stupnÃ½ znak <code>f</code> napÃ­Å¡eme <code>.</code> a doplnÃ­me poÅ¾adovanÃ½m poÄtem ÄÃ­slic za desetinnou teÄkou.
Takto specifikovanÃ½ Å™etÄ›zec se zÃ¡stupnÃ½m znakem jiÅ¾ vytiskne ÄÃ­slo <code>1.00</code>.</p>
<h3><a class="header" href="#pÅ™esnost-desetinnÃ½ch-ÄÃ­sel" id="pÅ™esnost-desetinnÃ½ch-ÄÃ­sel">PÅ™esnost desetinnÃ½ch ÄÃ­sel</a></h3>
<p>Je tÅ™eba si uvÄ›domit, Å¾e desetinnÃ¡ ÄÃ­sla v poÄÃ­taÄi majÃ­ pouze koneÄnou pÅ™esnost a jsou reprezentovÃ¡na
v dvojkovÃ© soustavÄ›:</p>
<ul>
<li>V poÄÃ­taÄi nelze reprezentovat iracionÃ¡lnÃ­ ÄÃ­sla s nekoneÄnou pÅ™esnostÃ­. Pokud tedy chcete do pamÄ›ti
uloÅ¾it napÅ™Ã­klad hodnotu <code>Ï€</code>, budete ji muset zaokrouhlit.</li>
<li>KvÅ¯li pouÅ¾itÃ­ dvojkovÃ© soustavy nÄ›kterÃ© desetinnÃ© hodnoty nelze vyjÃ¡dÅ™it pÅ™esnÄ›. NapÅ™Ã­klad ÄÃ­slo
\( \frac{1}{3} \) lze v desÃ­tkovÃ© soustavÄ› vyjÃ¡dÅ™it zlomkem, ale v dvojkovÃ© soustavÄ› toto ÄÃ­slo
mÃ¡ nekoneÄnÃ½ desetinnÃ½ rozvoj (<code>0.010101â€¦</code>) a opÄ›t tedy nelze vyjÃ¡dÅ™it pÅ™esnÄ›:
<pre><code class="language-c editable mainbody">#include &lt;stdio.h&gt;
int main() {
    printf(&quot;%f\n&quot;, 1.0 / 3.0);
    return 0;
}
</code></pre>
</li>
</ul>
<h3><a class="header" href="#konverze-na-celÃ©-ÄÃ­slo" id="konverze-na-celÃ©-ÄÃ­slo">Konverze na celÃ© ÄÃ­slo</a></h3>
<p>Pokud budete <a href="c/datove_typy/konverze.html">konvertovat</a> desetinnÃ© ÄÃ­slo na celÃ© ÄÃ­slo, tak dojde k &quot;useknutÃ­&quot;
desetinnÃ© ÄÃ¡sti:</p>
<pre><code class="language-c editable mainbody">#include &lt;stdio.h&gt;
int main() {
    printf(&quot;%d\n&quot;, (int) 1.6);
    printf(&quot;%d\n&quot;, (int) -1.6);
    return 0;
}
</code></pre>
<p>Toto chovÃ¡nÃ­ odpovÃ­dÃ¡ zaokrouhlenÃ­ k nule, tj. kladnÃ¡ ÄÃ­sla se zaokrouhlÃ­ dolÅ¯ a zÃ¡pornÃ¡ ÄÃ­sla nahoru.</p>
<hr />
<p><strong>KvÃ­z</strong> ğŸ¤”</p>
<ol>
<li>
<p>Co vypÃ­Å¡e nÃ¡sledujÃ­cÃ­ program?</p>
<pre><code class="language-c editable mainbody">#include &lt;stdio.h&gt;

int main() {
    printf(&quot;%d\n&quot;, 1.5);

    return 0;
}
</code></pre>
<details>
 <summary>OdpovÄ›Ä</summary>
<p>Tento program obsahuje <a href="c/datove_typy/../../ruzne/nedefinovane_chovani.html"><strong>nedefinovanÃ© chovÃ¡nÃ­</strong></a> ğŸ’£. Pokud pÅ™i pouÅ¾itÃ­ pÅ™Ã­kazu
<code>printf</code> v textu mezi uvozovkami pouÅ¾ijeme zÃ¡stupnÃ½ znak <code>%d</code>, musÃ­me za ÄÃ¡rkou pÅ™edat vÃ½raz datovÃ©ho typu celÃ©ho
ÄÃ­sla. Zde jsme ale pÅ™edali vÃ½raz datovÃ©ho typu desetinnÃ©ho ÄÃ­sla.</p>
</details>
</li>
<li>
<p>Co vypÃ­Å¡e nÃ¡sledujÃ­cÃ­ program?</p>
<pre><code class="language-c editable mainbody">#include &lt;stdio.h&gt;

int main() {
    float a = 2.0f;
    float b = 5.0f;
    int c = b / a;
    printf(&quot;%d\n&quot;, c);

    return 0;
}
</code></pre>
<details>
 <summary>OdpovÄ›Ä</summary>
<p>Program vypÃ­Å¡e <code>2</code>, protoÅ¾e vÃ½raz desetinnÃ©ho ÄÃ­selnÃ©ho typu <code>b / a</code>, kterÃ½ se vyhodnotil na
<code>2.5</code>, byl potÃ© uloÅ¾en do promÄ›nnÃ© celoÄÃ­selnÃ©ho typu, kterÃ¡ si z nÄ›j ponechala pouze celou ÄÃ¡st,
tj. <code>2</code>.</p>
</details>
</li>
</ol>
<h1><a class="header" href="#pravdivostnÃ­-typy" id="pravdivostnÃ­-typy">PravdivostnÃ­ typy</a></h1>
<p>PoslednÃ­m zÃ¡kladnÃ­m datovÃ½m typem, kterÃ½ si ukÃ¡Å¾eme, je pravdivostnÃ­ typ
<strong><a href="https://cs.wikipedia.org/wiki/Boolean">BooleovskÃ© logiky</a></strong>. Hodnoty tohoto datovÃ©ho typu majÃ­
pouze dvÄ› moÅ¾nÃ© varianty - <strong>pravda</strong> (<em>true</em>) nebo <strong>nepravda</strong> (<em>false</em>). Tento typ se hodÃ­
zejmÃ©na pro rÅ¯znÃ© logickÃ© operace, napÅ™Ã­klad porovnÃ¡vÃ¡nÃ­ hodnot (<code>Je a menÅ¡Ã­ neÅ¾ b?</code> - <code>ano</code>/<code>ne</code>).</p>
<p>V <em>C</em> se BooleovskÃ½ datovÃ½ typ nazÃ½vÃ¡ <code>_Bool</code>. NicmÃ©nÄ› tento nÃ¡zev je docela krkolomnÃ½, obvykle se
proto pouÅ¾Ã­vÃ¡ spÃ­Å¡e nÃ¡zev <code>bool</code>. Abyste ho mohli pouÅ¾Ã­t, tak na zaÄÃ¡tek programu musÃ­te vloÅ¾it Å™Ã¡dek
<code>#include &lt;stdbool.h&gt;</code>. <a href="c/datove_typy/../preprocesor/vkladani_souboru.html">PozdÄ›ji</a> si vysvÄ›tlÃ­me, co tento Å™Ã¡dek
dÄ›lÃ¡.</p>
<pre><code class="language-c editable mainbody">#include &lt;stdbool.h&gt;
#include &lt;stdio.h&gt;

int main() {
    bool venku_je_hezky = true;
    bool upr_je_slozite = false;

    printf(&quot;%d\n&quot;, venku_je_hezky);
    printf(&quot;%d\n&quot;, upr_je_slozite);

    return 0;
}
</code></pre>
<p>Jak lze v ukÃ¡zce vÃ½Å¡e vidÄ›t, <code>true</code> reprezentuje pravdivÃ½ BooleovskÃ½ vÃ½raz a <code>false</code> nepravdivÃ½
BooleovskÃ½ vÃ½raz a <code>bool</code> hodnoty lze vytisknout na vÃ½stup stejnÃ½m zpÅ¯sobem jako celoÄÃ­selnÃ© hodnoty.<sup class='margin-toggle sidenote-number'>1</sup>
Hodnoty BooleovskÃ©ho typu obvykle zabÃ­rajÃ­ v pamÄ›ti jeden <em>byte</em>.</p>
<span class='sidenote'><p><sup class='number'>1</sup>PÅ™i vÃ½pisu dojde ke <a href="c/datove_typy/pravdivostni_typy.html#konverze">konverzi</a> <code>bool</code>u na celÃ© ÄÃ­slo.</p>
</span>
<h3><a class="header" href="#logickÃ©-operace" id="logickÃ©-operace">LogickÃ© operace</a></h3>
<p>V (BooleovskÃ©) logice existujÃ­ tÅ™i zÃ¡kladnÃ­ operÃ¡tory:</p>
<ul>
<li><strong>logickÃ½ souÄin</strong> (<em>AND</em>): <code>platÃ­ X a zÃ¡roveÅˆ Y</code></li>
<li><strong>logickÃ½ souÄet</strong> (<em>OR</em>): <code>platÃ­ X nebo Y</code></li>
<li><strong>logickÃ¡ negace</strong> (<em>NOT</em>): <code>neplatÃ­ X</code></li>
</ul>
<p>Tyto logickÃ© operace lze v <em>C</em> pouÅ¾Ã­t pomocÃ­ nÃ¡sledujÃ­cÃ­ch operÃ¡torÅ¯:</p>
<ul>
<li><strong>AND</strong>: <code>&amp;&amp;</code></li>
<li><strong>OR</strong>: <code>||</code></li>
<li><strong>NOT</strong>: <code>!</code></li>
</ul>
<p>Tyto operÃ¡tory mÅ¯Å¾ete pouÅ¾Ã­t mezi dvÄ›ma vÃ½razy datovÃ©ho typu <code>bool</code>. NapÅ™Ã­klad:</p>
<pre><code class="language-c">bool je_muz = true;
bool je_zena = false;
bool je_clovek = je_muz || je_zena; // true || false -&gt; true

bool je_rodic = true;
bool je_otec = je_rodic &amp;&amp; je_muz;  // true &amp;&amp; true -&gt; true
bool je_matka = je_rodic &amp;&amp; !je_otec; // true &amp;&amp; !true -&gt; true &amp;&amp; false -&gt; false
</code></pre>
<p>Pro pÅ™ipomenutÃ­, zde je pravdivostnÃ­ tabulka tÄ›chto logickÃ½ch operÃ¡torÅ¯:</p>
<table><thead><tr><th><code>X</code></th><th align="center"><code>Y</code></th><th align="center"><code>X &amp;&amp; Y</code></th><th align="center"><code>X || Y</code></th><th align="center"><code>!X</code></th></tr></thead><tbody>
<tr><td><code>false</code></td><td align="center"><code>false</code></td><td align="center"><code>false</code></td><td align="center"><code>false</code></td><td align="center"><code>true</code></td></tr>
<tr><td><code>false</code></td><td align="center"><code>true</code></td><td align="center"><code>false</code></td><td align="center"><code>true</code></td><td align="center"><code>true</code></td></tr>
<tr><td><code>true</code></td><td align="center"><code>false</code></td><td align="center"><code>false</code></td><td align="center"><code>true</code></td><td align="center"><code>false</code></td></tr>
<tr><td><code>true</code></td><td align="center"><code>true</code></td><td align="center"><code>true</code></td><td align="center"><code>true</code></td><td align="center"><code>false</code></td></tr>
</tbody></table>
<h3><a class="header" href="#porovnÃ¡vÃ¡nÃ­-hodnot" id="porovnÃ¡vÃ¡nÃ­-hodnot">PorovnÃ¡vÃ¡nÃ­ hodnot</a></h3>
<p>PÅ™i programovÃ¡nÃ­ Äasto potÅ™ebujete porovnat hodnoty mezi sebou:</p>
<ul>
<li><code>MÃ¡ Jarda vÃ­ce bodÅ¯ neÅ¾ Kamil?</code></li>
<li><code>MÃ¡ uÅ¾ivatelovo heslo vÃ­ce neÅ¾ 5 znakÅ¯?</code></li>
<li><code>MÃ¡ Lenka na ÃºÄtu alespoÅˆ 100 dolarÅ¯?</code></li>
</ul>
<p>K tomu slouÅ¾Ã­ Å¡est zÃ¡kladnÃ­ch porovnÃ¡vacÃ­ch operÃ¡torÅ¯:</p>
<ul>
<li><strong>RovnÃ¡ se</strong><sup class='margin-toggle sidenote-number'>2</sup>: <code>==</code><span class='sidenote'><p><sup class='number'>2</sup>Zde si dÃ¡vejte velkÃ½ pozor na rozdÃ­l mezi <code>=</code> (pÅ™iÅ™azenÃ­ hodnoty) a <code>==</code> (porovnÃ¡nÃ­ dvou hodnot).
ZÃ¡mÄ›na tÄ›chto dvou operÃ¡torÅ¯ je Äastou <a href="c/datove_typy/../../caste_chyby/caste_chyby.html#z%C3%A1m%C4%9Bna--a-">zaÄÃ¡teÄnickou chybou</a>
a vede k obtÃ­Å¾nÄ› nalezitelnÃ½m chybÃ¡m.</p>
</span></li>
<li><strong>NerovnÃ¡ se</strong>: <code>!=</code></li>
<li><strong>VÄ›tÅ¡Ã­</strong>: <code>&gt;</code></li>
<li><strong>VÄ›tÅ¡Ã­ nebo rovno</strong>: <code>&gt;=</code></li>
<li><strong>MenÅ¡Ã­</strong>: <code>&lt;</code></li>
<li><strong>MenÅ¡Ã­ nebo rovno</strong>: <code>&lt;=</code></li>
</ul>
<p>PorovnÃ¡vat mezi sebou mÅ¯Å¾ete libovolnÃ© hodnoty dvou stejnÃ½ch datovÃ½ch typÅ¯. VÃ½sledkem porovnÃ¡nÃ­
je vÃ½raz datovÃ©ho typu <code>bool</code>:</p>
<pre><code class="language-c">int jarda_body = 13;
int kamil_body = 10;

bool remiza = jarda_body == kamil_body; // false
bool vyhra_jardy = jarda_body &gt; kamil_body; // true

int delka_hesla = 8;
bool heslo_moc_kratke = delka_hesla &lt;= 5; // false
</code></pre>
<p>DÃ¡vejte si ovÅ¡em pozor na to, Å¾e pouze operÃ¡tory <code>==</code> a <code>!=</code> lze pouÅ¾Ã­t univerzÃ¡lnÄ› na vÅ¡echny datovÃ© typy.
NapÅ™Ã­klad pouÅ¾Ã­t <code>&lt;</code> pro porovnÃ¡nÃ­ dvou BooleovskÃ½ch hodnot obvykle nedÃ¡vÃ¡ valnÃ½ smysl, operÃ¡tory
<code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code> a <code>&gt;=</code> jsou obvykle vyuÅ¾Ã­vÃ¡ny pouze pro porovnÃ¡vÃ¡nÃ­ ÄÃ­sel.</p>
<p>PorovnÃ¡vÃ¡nÃ­ hodnot mÅ¯Å¾ete zkombinovat s logickÃ½mi operÃ¡tory pro vyhodnocenÃ­ komplexnÃ­ch pravdivostnÃ­ch
vÃ½razÅ¯:</p>
<pre><code class="language-c editable mainbody">#include &lt;stdbool.h&gt;
#include &lt;stdio.h&gt;

int main() {
    int delka_hesla = 8;
    bool email_overen = false;
    int rok_narozeni = 1994;

    bool uzivatel_validni = delka_hesla &gt;= 9 &amp;&amp; (email_overen || rok_narozeni &gt; 1990); // false
    bool uzivatel_validni2 = delka_hesla &gt;= 9 &amp;&amp; email_overen || rok_narozeni &gt; 1990; // true

    printf(&quot;%d\n&quot;, uzivatel_validni);
    printf(&quot;%d\n&quot;, uzivatel_validni2);

    return 0;
}
</code></pre>
<p>Zde je opÄ›t tÅ™eba dÃ¡vat si pozor na <a href="https://en.cppreference.com/w/c/language/operator_precedence">prioritu operÃ¡torÅ¯</a>
(napÅ™Ã­klad <code>&amp;&amp;</code> mÃ¡ vÄ›tÅ¡Ã­ prioritu neÅ¾ <code>||</code>) a v pÅ™Ã­padÄ› potÅ™eby vÃ½razy uzÃ¡vorkovat. Pokud si zkusÃ­te
pÅ™eloÅ¾it tento program, tak vÃ¡s dokonce pÅ™ekladaÄ bude varovat pÅ™ed tÃ­m, Å¾e jste vÃ½raz neuzÃ¡vorkovali a
mÅ¯Å¾e tak vracet jinÃ½ vÃ½sledek, neÅ¾ oÄekÃ¡vÃ¡te.</p>
<h3><a class="header" href="#tabulka-logickÃ½ch-operÃ¡torÅ¯" id="tabulka-logickÃ½ch-operÃ¡torÅ¯">Tabulka logickÃ½ch operÃ¡torÅ¯</a></h3>
<p>Zde je pro pÅ™ehlednost tabulka s logickÃ½mi operÃ¡tory.
DatovÃ½ typ vÃ½sledku je u tÄ›chto operÃ¡torÅ¯ vÅ¾dy <code>bool</code>.</p>
<table><thead><tr><th align="center">OperÃ¡tor</th><th align="center">Popis</th><th align="center">PÅ™Ã­klad</th></tr></thead><tbody>
<tr><td align="center"><code>&amp;&amp;</code></td><td align="center">LogickÃ½ souÄin (AND)</td><td align="center"><code>a == b &amp;&amp; c &gt;= d</code></td></tr>
<tr><td align="center"><code>||</code></td><td align="center">LogickÃ½ souÄet (OR)</td><td align="center"><code>a &lt; b || c == d</code></td></tr>
<tr><td align="center"><code>!</code></td><td align="center">LogickÃ¡ negace (NOT)</td><td align="center"><code>!(a &gt; b &amp;&amp; c &lt; d)</code></td></tr>
<tr><td align="center"><code>==</code></td><td align="center">RovnÃ¡ se</td><td align="center"><code>a == 5</code></td></tr>
<tr><td align="center"><code>!=</code></td><td align="center">NerovnÃ¡ se</td><td align="center"><code>a != 5</code></td></tr>
<tr><td align="center"><code>&gt;</code></td><td align="center">VÄ›tÅ¡Ã­ neÅ¾</td><td align="center"><code>a &gt; 5</code></td></tr>
<tr><td align="center"><code>&gt;=</code></td><td align="center">VÄ›tÅ¡Ã­ nebo rovno neÅ¾</td><td align="center"><code>a &gt;= 5</code></td></tr>
<tr><td align="center"><code>&lt;</code></td><td align="center">MenÅ¡Ã­ neÅ¾</td><td align="center"><code>a &lt; 5</code></td></tr>
<tr><td align="center"><code>&lt;=</code></td><td align="center">MenÅ¡Ã­ nebo rovno neÅ¾</td><td align="center"><code>a &lt;= 5</code></td></tr>
</tbody></table>
<h3><a class="header" href="#zkrÃ¡cenÃ©-vyhodnocovÃ¡nÃ­" id="zkrÃ¡cenÃ©-vyhodnocovÃ¡nÃ­">ZkrÃ¡cenÃ© vyhodnocovÃ¡nÃ­</a></h3>
<p>PÅ™i vyhodnocovÃ¡nÃ­ BooleovskÃ½ch vÃ½razÅ¯ s logickÃ½mi operÃ¡tory se v <em>C</em> pouÅ¾Ã­vÃ¡ tzv. <strong>zkrÃ¡cenÃ© vyhodnocovÃ¡nÃ­</strong>
(<em>short-circuit evaluation</em>). NapÅ™Ã­klad pokud se vyhodnocuje vÃ½raz <code>a || b</code>, tak mÅ¯Å¾e dojÃ­t k nÃ¡sledujÃ­cÃ­
situaci:</p>
<ul>
<li>PoÄÃ­taÄ vÅ¡e provÃ¡dÃ­ v sekvenÄnÃ­ch krocÃ­ch, tj. nejprve vyhodnotÃ­ <code>a</code>.</li>
<li>Pokud mÃ¡ vÃ½raz <code>a</code> hodnotu <code>true</code>, tak uÅ¾ je jasnÃ©, Å¾e celÃ½ vÃ½raz <code>a || b</code> bude mÃ­t hodnotu <code>true</code>.</li>
<li>K vyhodnocenÃ­ vÃ½razu <code>b</code> tak uÅ¾ nedojde, protoÅ¾e je to zbyteÄnÃ©.</li>
</ul>
<p>Toto chovÃ¡nÃ­ mÅ¯Å¾e urychlit provÃ¡dÄ›nÃ­ programu, protoÅ¾e pÅ™eskakuje provÃ¡dÄ›nÃ­ zbyteÄnÃ½ch pÅ™Ã­kazÅ¯,
nicmÃ©nÄ› mÅ¯Å¾e takÃ© zpÅ¯sobit neÄekanÃ© chyby. Pokud by napÅ™Ã­klad vyhodnocenÃ­ vÃ½razu <code>b</code> obsahovalo nÄ›jakÃ©
<a href="c/datove_typy/../prikazy_vyrazy.html#vedlej%C5%A1%C3%AD-efekty">vedlejÅ¡Ã­ efekty</a>, kterÃ© se projevÃ­ pÅ™i jeho provedenÃ­ (napÅ™Ã­klad
zmÄ›na hodnoty v pamÄ›ti), tak mÅ¯Å¾e bÃ½t problematickÃ©, pokud se vyhodnocenÃ­ tohoto vÃ½razu zcela
pÅ™eskoÄÃ­. Pokud si pamatujete na <a href="c/datove_typy/../promenne/slozeny_zapis.html#inkrementace-a-dekrementace">inkrementaci</a>,
tak ta je jednÃ­m z pÅ™Ã­padÅ¯ vÃ½razÅ¯, kterÃ© majÃ­ vedlejÅ¡Ã­ efekt (zmÄ›nu hodnoty promÄ›nnÃ©).</p>
<h3><a class="header" href="#konverze" id="konverze">Konverze</a></h3>
<p>Pokud se pokusÃ­te o pÅ™evod celÃ©ho Äi desetinnÃ©ho ÄÃ­sla na <code>bool</code>, tak mÅ¯Å¾ou nastat dvÄ› varianty:</p>
<ul>
<li>Pokud je ÄÃ­slo nenulovÃ©, vÃ½sledkem bude <code>true</code>.</li>
<li>Pokud je ÄÃ­slo nula, vÃ½sledkem bude <code>false</code>.</li>
</ul>
<p>V opaÄnÃ©m smÄ›ru (konverze <code>bool</code> u na ÄÃ­slo) dojde k nÃ¡sledujÃ­cÃ­ konverzi:</p>
<ul>
<li><code>true</code> se pÅ™evede na <code>1</code></li>
<li><code>false</code> se pÅ™evede na <code>0</code></li>
</ul>
<hr />
<p><strong>KvÃ­z</strong> ğŸ¤”</p>
<ol>
<li>
<p>Co vypÃ­Å¡e nÃ¡sledujÃ­cÃ­ program?</p>
<pre><code class="language-c editable mainbody">#include &lt;stdio.h&gt;
#include &lt;stdbool.h&gt;

int main() {
    int pocet_zidli = 14;
    int pocet_lidi = 8;
    int pocet_znicenych_zidli = 4;

    bool dostatek_zidli = (pocet_zidli - pocet_znicenych_zidli) &gt;= pocet_lidi;
    bool dostatek_lidi = pocet_lidi &gt;= 6;
    bool party_pripravena = dostatek_zidli &amp;&amp; dostatek_lidi;

    printf(&quot;Party: %d\n&quot;, party_pripravena);

    return 0;
}
</code></pre>
<details>
 <summary>OdpovÄ›Ä</summary>
<p>Program vypÃ­Å¡e <code>Party: 1</code>.</p>
</details>
</li>
<li>
<p>Co vypÃ­Å¡e nÃ¡sledujÃ­cÃ­ program?</p>
<pre><code class="language-c editable mainbody">#include &lt;stdio.h&gt;
#include &lt;stdbool.h&gt;

int main() {
    int a = 5;
    int b = 4;

    bool x = a &gt;= 3 || (b = 8);

    printf(&quot;a=%d\n&quot;, a);
    printf(&quot;b=%d\n&quot;, b);
    printf(&quot;x=%d\n&quot;, x);

    return 0;
}
</code></pre>
<details>
 <summary>OdpovÄ›Ä</summary>
<p>Program vypÃ­Å¡e:</p>
<pre><code>a=5
b=4
x=1
</code></pre>
<p>VÃ½raz pÅ™iÅ™azenÃ­ <code>b = 8</code> se neprovede kvÅ¯li <a href="c/datove_typy/pravdivostni_typy.html#zkr%C3%A1cen%C3%A9-vyhodnocov%C3%A1n%C3%AD">zkrÃ¡cenÃ©mu vyhodnocovÃ¡nÃ­</a>,
hodnota promÄ›nnÃ© <code>b</code> se tak nezmÄ›nÃ­. RadÄ›ji nepouÅ¾Ã­vejte vÃ½razy obsahujÃ­cÃ­ vedlejÅ¡Ã­ efekty v
kombinaci s <code>||</code> a <code>&amp;&amp;</code>.</p>
</details>
</li>
</ol>
<h1><a class="header" href="#explicitnÃ­-konverze" id="explicitnÃ­-konverze">ExplicitnÃ­ konverze</a></h1>
<p>NÄ›kdy potÅ™ebujete pÅ™evÃ©st hodnoty mezi rÅ¯znÃ½mi datovÃ½mi typy. K tomu slouÅ¾Ã­ <strong>operÃ¡tor pÅ™etypovÃ¡nÃ­</strong>
(<em>cast operator</em>), kterÃ½ mÃ¡ syntaxi <code>(&lt;datovÃ½ typ&gt;) &lt;vÃ½raz&gt;</code> a pÅ™evede vÃ½raz na danÃ½ datovÃ½ typ.
NapÅ™Ã­klad <code>(short) 1</code> pÅ™evede vÃ½raz <code>1</code> z typu <code>int</code> na <code>short</code>. Je dobrÃ© si uvÄ›domit, k Äemu mÅ¯Å¾e
dojÃ­t pÅ™i pÅ™evodu mezi rÅ¯znÃ½mi datovÃ½mi typy:</p>
<ul>
<li>Pokud je cÃ­lovÃ½ datovÃ½ typ menÅ¡Ã­ a pÅ™evÃ¡dÄ›nou hodnotu v nÄ›m nelze reprezentovat, tak dojde k
oseknutÃ­ hodnoty. V dÅ¯sledku zpÅ¯sobu reprezentace hodnot v poÄÃ­taÄi takovÃ¡to operace odpovÃ­dÃ¡
zbytku po dÄ›lenÃ­:
<pre><code class="language-c">unsigned short a = 256;
(unsigned char) a // hodnota tohoto vÃ½razu je 0 (256 % 256)
</code></pre>
</li>
<li>Pokud pÅ™evÃ¡dÃ­te znamÃ©nkovÃ½ typ na bezznamÃ©nkovÃ½ a hodnota pÅ™evÃ¡dÄ›nÃ©ho vÃ½razu je zÃ¡pornÃ¡, tak nedojde
k intuitivnÃ­mu pouÅ¾itÃ­ absolutnÃ­ hodnoty<sup class='margin-toggle sidenote-number'>1</sup>. V dÅ¯sledku zpÅ¯sobu reprezentace hodnot v poÄÃ­taÄi takovÃ¡to
operace odpovÃ­dÃ¡ pÅ™iÄtenÃ­ danÃ© hodnoty k maximÃ¡lnÃ­ moÅ¾nÃ© hodnotÄ› cÃ­lovÃ©ho typu:
<pre><code class="language-c">signed char c = -50;
(unsigned char) c // hodnota tohoto vÃ½razu je 206 (256 - 50)
</code></pre>
<span class='sidenote'><p><sup class='number'>1</sup>K tomu mÅ¯Å¾ete pouÅ¾Ã­t napÅ™Ã­klad funkci <a href="https://devdocs.io/c/numeric/math/abs">abs</a>.</p>
</span></li>
</ul>
<h2><a class="header" href="#pÅ™evod-z-desetinnÃ©-hodnoty-na-celoÄÃ­selnou-hodnotu" id="pÅ™evod-z-desetinnÃ©-hodnoty-na-celoÄÃ­selnou-hodnotu">PÅ™evod z desetinnÃ© hodnoty na celoÄÃ­selnou hodnotu</a></h2>
<p>ÄŒasto se hodÃ­ pÅ™evÃ¡dÄ›t mezi desetinnÃ½mi a celoÄÃ­selnÃ½mi typy. PÅ™i pÅ™evodu z desetinnÃ© hodnoty na celoÄÃ­selnou dojde k
zaokrouhlenÃ­ smÄ›rem k nule:</p>
<pre><code class="language-c editable mainbody">#include &lt;stdio.h&gt;

int main() {
  float a = 5.8;
  float b = -7.2;

  printf(&quot;Kladne cislo zaokrouhlene: %d\n&quot;, (int) a);
  printf(&quot;Zaporne cislo zaokrouhlene: %d\n&quot;, (int) b);
  return 0;
}
</code></pre>
<p>Pokud se chcete dozvÄ›dÄ›t vÃ­ce o tom, proÄ konverze mezi typy fungujÃ­ tak, jak fungujÃ­, tak se podÃ­vejte
na to, jak funguje <a href="https://cs.wikipedia.org/wiki/Dvojkov%C3%BD_dopln%C4%9Bk">dvojkovÃ½ doplnÄ›k</a>.</p>
<h1><a class="header" href="#Å˜Ã­zenÃ­-toku" id="Å˜Ã­zenÃ­-toku">Å˜Ã­zenÃ­ toku</a></h1>
<p>Pokud by poÄÃ­taÄe program vÅ¾dy pouze vykonaly od zaÄÃ¡tku do konce a provedly pokaÅ¾dÃ© ty stejnÃ©
operace, tak by nebyly moc uÅ¾iteÄnÃ©. Sice by zvlÃ¡dly nÄ›co rychle vypoÄÃ­tat, ale uÅ¾ ne se rozhodovat,
jakou operaci majÃ­ provÃ©st, nebo nÄ›jakou operaci provÃ¡dÄ›t opakovanÄ›, coÅ¾ jsou velmi uÅ¾iteÄnÃ© vlastnosti.</p>
<p>Instrukce programu se bÄ›Å¾nÄ› vykonÃ¡vajÃ­ (&quot;teÄou&quot;) jedna po druhÃ© (&quot;odshora dolÅ¯&quot;). <em>C</em> obsahuje pÅ™Ã­kazy
pro tzv. <strong>Å™Ã­zenÃ­ toku</strong> (<em>control flow</em>), kterÃ© mÅ¯Å¾ou toto vykonÃ¡vÃ¡nÃ­ instrukcÃ­ ovlivnit:</p>
<ul>
<li><a href="c/rizeni_toku/podminky.html">PodmÃ­nky</a> umoÅ¾ÅˆujÃ­ vykonat kus kÃ³du, pouze pokud platÃ­ nÄ›jakÃ½ vÃ½raz (BooleovskÃ©ho typu).
DÃ­ky tomu se mÅ¯Å¾e program rozhodnout, zda mÃ¡ nÄ›jakou operaci provÃ©st, nebo ne, v zÃ¡vislosti na vstupu.</li>
<li><a href="c/rizeni_toku/cykly.html">Cykly</a> umoÅ¾ÅˆujÃ­ vykonÃ¡vat kus kÃ³du opakovanÄ›. DÃ­ky tomu mÅ¯Å¾eme napÅ™Ã­klad provÃ©st nÄ›jakou
operaci pro vÅ¡echny prvky ze vstupu programu anebo ji provÃ¡dÄ›t, dokud nedojde ke splnÄ›nÃ­ nÄ›jakÃ© podmÃ­nky.</li>
</ul>
<blockquote>
<p>AÄ se to moÅ¾nÃ¡ nezdÃ¡, tak pouÅ¾itÃ­ vÃ½razÅ¯, promÄ›nnÃ½ch, podmÃ­nek a cyklÅ¯ bohatÄ› staÄÃ­ k tomu, abyste
byli schopni napsat libovolnÃ½ poÄÃ­taÄovÃ½ program. PomocÃ­ tÄ›chto tÅ™Ã­ jednoduchÃ½ch konstrukcÃ­ byste
tak teoreticky mohli vytvoÅ™it tÅ™eba textovÃ½ editor, hru nebo i celÃ½ operaÄnÃ­ systÃ©m. NicmÃ©nÄ›, pokud
bychom vyuÅ¾Ã­vali pouze tyto konstrukce, tak ve vÄ›tÅ¡Ã­ch programech by bylo sloÅ¾itÃ© se zorientovat a
byly by takÃ© dost neefektivnÃ­. V nÃ¡sledujÃ­cÃ­ch sekcÃ­ch se tak dozvÃ­te o nÄ›kolika dalÅ¡Ã­ch konstrukcÃ­ch,
kterÃ© vÃ¡m mÅ¯Å¾ou programovÃ¡nÃ­ usnadnit.</p>
</blockquote>
<h1><a class="header" href="#podmÃ­nky" id="podmÃ­nky">PodmÃ­nky</a></h1>
<p>V programech se Äasto potÅ™ebujeme rozhodnout, co by se mÄ›lo stÃ¡t v zÃ¡vislosti na hodnotÄ› nÄ›jakÃ©ho
vÃ½razu:</p>
<ul>
<li>Pokud uÅ¾ivatel nakoupil zboÅ¾Ã­ v poslednÃ­m tÃ½dnu, odeÅ¡li mu e-mail.</li>
<li>Zadal uÅ¾ivatel sprÃ¡vnÃ© heslo? Pokud ano, tak ho pÅ™esmÄ›ruj na jeho profil. Pokud ne, tak zobraz chybovou hlÃ¡Å¡ku.</li>
<li>JakÃ© mÃ¡ uÅ¾ivatel konto? Pokud kladnÃ©, tak ho vykresli zelenou barvou, pokud zÃ¡pornÃ©, tak Äervenou a
pokud nulovÃ©, tak Äernou.</li>
</ul>
<p>V <em>C</em> mÅ¯Å¾eme provÃ¡dÄ›t takovÃ¡to rozhodnutÃ­ pomocÃ­ <strong>podmÃ­nÄ›nÃ½ch pÅ™Ã­kazÅ¯</strong> (<em>conditional statements</em>)
<a href="c/rizeni_toku/if.html"><code>if</code></a> a <a href="c/rizeni_toku/switch.html"><code>switch</code></a>, pÅ™Ã­padnÄ› pomocÃ­ <a href="c/rizeni_toku/ternarni_operator.html">ternÃ¡rnÃ­ho operÃ¡toru</a>.</p>
<h1><a class="header" href="#pÅ™Ã­kaz-if" id="pÅ™Ã­kaz-if">PÅ™Ã­kaz <code>if</code></a></h1>
<p>ZÃ¡kladnÃ­m pÅ™Ã­kazem pro tzv. <strong>podmÃ­nÄ›nÃ© vykonÃ¡nÃ­</strong> kÃ³du je pÅ™Ã­kaz <code>if</code>:</p>
<pre><code class="language-c">if (&lt;vÃ½raz typu bool&gt;) {
    // blok kÃ³du
}
</code></pre>
<p>Pokud se vÃ½raz v zÃ¡vorce za <code>if</code> vyhodnotÃ­ jako <code>true</code> (pravda), tak se provede
<a href="c/rizeni_toku/../promenne/promenne.html#platnost">blok</a> kÃ³du za zÃ¡vorkou tak, jak jste zvyklÃ­, a potÃ© bude program
dÃ¡le pokraÄovat za pÅ™Ã­kazem <code>if</code>. Pokud se vÅ¡ak vÃ½raz vyhodnotÃ­ jako <code>false</code> (nepravda), tak se blok
kÃ³du za zÃ¡vorkou vÅ¯bec neprovede. V nÃ¡sledujÃ­cÃ­m programu zkuste zmÄ›nit vÃ½raz uvnitÅ™ zÃ¡vorek za <code>if</code>
tak, aby se blok v podmÃ­nce vykonal:</p>
<pre><code class="language-c editable mainbody">#include &lt;stdio.h&gt;

int main() {
    int delka_hesla = 5;

    printf(&quot;Kontroluji heslo...\n&quot;);
    if (delka_hesla &gt; 5) {
        printf(&quot;Heslo je dostatecne dlouhe\n&quot;);
    }
    printf(&quot;Kontrola hesla dokoncena\n&quot;);

    return 0;
}
</code></pre>
<p>BooleovskÃ© vÃ½razy pouÅ¾itÃ© v podmÃ­nÄ›nÃ½ch pÅ™Ã­kazech se oznaÄujÃ­ jako <strong>podmÃ­nky</strong> (<em>conditions</em>), protoÅ¾e
podmiÅˆujÃ­ vykonÃ¡vÃ¡nÃ­ programu.</p>
<blockquote>
<p>AnglickÃ© slovo <code>if</code> znamenÃ¡ v ÄeÅ¡tinÄ› <code>JestliÅ¾e</code>. VÅ¡imnÄ›te si tak, Å¾e kÃ³d vÃ½Å¡e mÅ¯Å¾ete pÅ™eÄÃ­st jako
vÄ›tu, kterÃ¡ bude mÃ­t stejnÃ½ vÃ½znam jako uvedenÃ½ <em>C</em> kÃ³d: <code>JestliÅ¾e je dÃ©lka hesla vÄ›tÅ¡Ã­ neÅ¾ pÄ›t, tak (proveÄ kÃ³d v bloku)</code>.</p>
</blockquote>
<h3><a class="header" href="#provÃ¡dÄ›nÃ­-alternativ" id="provÃ¡dÄ›nÃ­-alternativ">ProvÃ¡dÄ›nÃ­ alternativ</a></h3>
<p>ÄŒasto v programu chceme provÃ©st <em>prÃ¡vÄ› jednu</em> ze dvou (nebo vÃ­ce) alternativ, opÄ›t v zÃ¡vislosti na hodnotÄ›
nÄ›jakÃ©ho vÃ½razu (podmÃ­nky). To sice mÅ¯Å¾eme provÃ©st pomocÃ­ nÄ›kolika <code>if</code> pÅ™Ã­kazÅ¯ za sebou:</p>
<pre><code class="language-c">if (body &gt; 90) { znamka = 1; }
if (body &lt;= 90 &amp;&amp; body &gt; 80) { znamka = 2; }
if (body &lt;= 80 &amp;&amp; body &gt; 50) { znamka = 3; }
...
</code></pre>
<p>NicmÃ©nÄ› to mÅ¯Å¾e bÃ½t Äasto dosti &quot;ukecanÃ©&quot;, protoÅ¾e se musÃ­me v kaÅ¾dÃ© podmÃ­nce ujistit, Å¾e jiÅ¾ nebyla
splnÄ›na pÅ™edchozÃ­ podmÃ­nka, jinak by se mohla provÃ©st vÃ­ce neÅ¾ jedna alternativa.</p>
<p>Jazyk <em>C</em> tak umoÅ¾Åˆuje pÅ™idat k pÅ™Ã­kazu <code>if</code> dalÅ¡Ã­ pÅ™Ã­kaz, kterÃ½ se provede pouze v pÅ™Ã­padÄ›, Å¾e podmÃ­nka
&quot;<code>if</code>u&quot; nenÃ­ splnÄ›na. Takto lze Å™etÄ›zit vÃ­ce podmÃ­nek za sebou, kdy v kaÅ¾dÃ© nÃ¡sledujÃ­cÃ­ podmÃ­nce vÃ­me,
Å¾e Å¾Ã¡dnÃ¡ z pÅ™edchozÃ­ch nebyla splnÄ›na. DosÃ¡hneme toho tak, Å¾e za blokem podmÃ­nky <code>if</code> pouÅ¾ijeme klÃ­ÄovÃ©
slovo <code>else</code> (&quot;v opaÄnÃ©m pÅ™Ã­padÄ›&quot;):</p>
<pre><code class="language-c">if (&lt;vÃ½raz typu bool&gt;) {
    // blok kÃ³du
} else ...
</code></pre>
<p>Pokud za blok podmÃ­nky <code>if</code> pÅ™idÃ¡te <code>else</code>, tak se program zaÄne vykonÃ¡vat za <code>else</code>, pokud vÃ½raz
podmÃ­nky nenÃ­ splnÄ›n. Za <code>else</code> pak mÅ¯Å¾e nÃ¡sledovat:</p>
<ul>
<li>
<p>Blok kÃ³du, kterÃ½ se rovnou provede:</p>
<pre><code class="language-c">if (body &gt; 90) {
    // blok A
} else {
    // blok B
}
// X
</code></pre>
<p>Pokud platÃ­ <code>body &gt; 90</code>, provede se blok A, pokud ne, tak se provede blok B. V obou pÅ™Ã­padech
bude dÃ¡le program vykonÃ¡vat kÃ³d od bodu <code>X</code>.</p>
</li>
<li>
<p>DalÅ¡Ã­ <code>if</code> podmÃ­nka, kterÃ¡ je opÄ›t vyhodnocena. TakovÃ½chto podmÃ­nek mÅ¯Å¾e nÃ¡sledovat libovolnÃ½ poÄet:</p>
<pre><code class="language-c">if (body &gt; 90) {
    // blok A, vÃ­ce neÅ¾ 90 bodÅ¯
} else if (body &gt; 80) {
    // blok B, mÃ©nÄ› neÅ¾ 91 bodÅ¯, ale vÃ­ce neÅ¾ 80 bodÅ¯
} else if (body &gt; 70) {
    // blok C, mÃ©nÄ› neÅ¾ 81 bodÅ¯, ale vÃ­ce neÅ¾ 70 bodÅ¯
}
// X
</code></pre>
<p>TakovÃ©to spojenÃ© podmÃ­nky se vyhodnocujÃ­ postupnÄ› shora dolÅ¯. PrvnÃ­ podmÃ­nka <code>if</code>, jejÃ­Å¾ vÃ½raz
je vyhodnocen jako <code>true</code>, zpÅ¯sobÃ­, Å¾e se provede blok tÃ©to podmÃ­nky, a nÃ¡slednÄ› program pokraÄuje
za celou spojenou podmÃ­nkou (bod <code>X</code>).</p>
<p>Na konec spojenÃ© podmÃ­nky mÅ¯Å¾ete opÄ›t vloÅ¾it klÃ­ÄovÃ© slovo <code>else</code> s blokem bez podmÃ­nky. Tento blok
se provede pouze, pokud Å¾Ã¡dnÃ¡ z pÅ™edchozÃ­ch podmÃ­nek nenÃ­ splnÄ›na:</p>
<pre><code class="language-c">if (body &gt; 90) {
    // blok A, vÃ­ce neÅ¾ 90 bodÅ¯
} else if (body &gt; 80) {
    // blok B, mÃ©nÄ› neÅ¾ 90 bodÅ¯, ale vÃ­ce neÅ¾ 80 bodÅ¯
} else {
    // blok C, mÃ©nÄ› neÅ¾ 81 bodÅ¯
}
</code></pre>
<blockquote>
<p>VÅ¡imnÄ›te si, Å¾e tento kÃ³d opÄ›t mÅ¯Å¾eme pÅ™eÄÃ­st jako intuitivnÃ­ vÄ›tu. Pokud je poÄet
bodÅ¯ vyÅ¡Å¡Ã­, neÅ¾ 90, tak proveÄ A. V opaÄnÃ©m pÅ™Ã­padÄ›, pokud je vyÅ¡Å¡Ã­ neÅ¾ 80, tak proveÄ B. Jinak
proveÄ C.</p>
</blockquote>
</li>
</ul>
<hr />
<p><strong>CviÄenÃ­</strong> ğŸ‹</p>
<p>Upravte nÃ¡sledujÃ­cÃ­ program, aby vypsal:</p>
<ul>
<li><code>Student uspel s vyznamenanim</code>, pokud je hodnota promÄ›nnÃ© <code>body</code> vÄ›tÅ¡Ã­ neÅ¾ <code>90</code>.</li>
<li><code>Student uspel</code>, pokud je hodnota promÄ›nnÃ© <code>body</code> v (uzavÅ™enÃ©m) intervalu <code>[51, 90]</code>.</li>
<li><code>Student neuspel</code>, pokud je hodnota promÄ›nnÃ© <code>body</code> menÅ¡Ã­ neÅ¾ <code>51</code>.</li>
</ul>
<pre><code class="language-c editable mainbody">#include &lt;stdio.h&gt;

int main() {
    int body = 50;

    printf(&quot;Student uspel\n&quot;);

    return 0;
}
</code></pre>
<hr />
<h3><a class="header" href="#vnoÅ™ovÃ¡nÃ­-podmÃ­nek" id="vnoÅ™ovÃ¡nÃ­-podmÃ­nek">VnoÅ™ovÃ¡nÃ­ podmÃ­nek</a></h3>
<p>NÄ›kdy potÅ™ebujeme vyhodnotit sloÅ¾itou podmÃ­nku (nebo sadu podmÃ­nek). JelikoÅ¾ <code>if</code> je <em>pÅ™Ã­kaz</em>
a bloky kÃ³du mohou obsahovat libovolnÃ© pÅ™Ã­kazy, tak vÃ¡m nic nebrÃ¡nÃ­ v tom pÅ™Ã­kazy <code>if</code> <em>vnoÅ™ovat</em>:</p>
<pre><code class="language-c editable mainbody">#include &lt;stdio.h&gt;

int main() {
    int delka_hesla = 4;
    int delka_jmena = 3;
    if (delka_hesla &gt; 5) {
        if (delka_jmena &gt; 3) {
            printf(&quot;Uzivatel byl zaregistrovan\n&quot;);
        } else {
            printf(&quot;Uzivatelske jmeno neni dostatecne dlouhe\n&quot;);
        }
    } else {
        printf(&quot;Heslo neni dostatecne dlouhe\n&quot;);
    }

    return 0;
}
</code></pre>
<hr />
<p><strong>CviÄenÃ­</strong> ğŸ‹</p>
<p>Upravte hodnotu promÄ›nnÃ½ch <code>delka_hesla</code> a <code>delka_jmena</code> v programu vÃ½Å¡e tak, aby program
vypsal <code>Uzivatel byl zaregistrovan</code>. NemÄ›Åˆte v programu nic jinÃ©ho.</p>
<hr />
<h4><a class="header" href="#vynechÃ¡nÃ­-sloÅ¾enÃ½ch-zÃ¡rovek" id="vynechÃ¡nÃ­-sloÅ¾enÃ½ch-zÃ¡rovek">VynechÃ¡nÃ­ sloÅ¾enÃ½ch zÃ¡rovek</a></h4>
<p>Za <code>if</code> nebo <code>else</code> mÅ¯Å¾ete vynechat sloÅ¾enÃ© zÃ¡vorky (<code>{</code>, <code>}</code>). V takovÃ©m pÅ™Ã­padÄ› se bude podmÃ­nka
vztahovat k (jednomu) pÅ™Ã­kazu nÃ¡sledujÃ­cÃ­mu za <code>if/else</code>:</p>
<pre><code class="language-c">if (body &gt; 80) printf(&quot;Student uspel\n&quot;);
else printf(&quot;Student neuspel\n&quot;);
</code></pre>
<blockquote>
<p>ZejmÃ©na ze zaÄÃ¡tku za podmÃ­nkami vÅ¾dy vÅ¡ak radÄ›ji pouÅ¾Ã­vejte sloÅ¾enÃ© zÃ¡vorky, abyste pÅ™edeÅ¡li pÅ™Ã­padnÃ½m
<a href="c/rizeni_toku/../../caste_chyby/caste_chyby.html#st%C5%99edn%C3%ADk-za-for-while-nebo-if">chybÃ¡m</a> a uÄinili kÃ³d pÅ™ehlednÄ›jÅ¡Ã­m.</p>
</blockquote>
<hr />
<p><strong>KvÃ­z</strong> ğŸ¤”</p>
<ol>
<li>
<p>Co vypÃ­Å¡e nÃ¡sledujÃ­cÃ­ program?</p>
<pre><code class="language-c editable mainbody">#include &lt;stdio.h&gt;

int main() {
    int a = 2;
    if (a &gt;= 3) {
      printf(&quot;a &gt;= 3\n&quot;);
    } else if (a &gt;= 2) {
      printf(&quot;a &gt;= 2\n&quot;);
    } else if (a &gt;= 1) {
      printf(&quot;a &gt;= 1\n&quot;);
    }

    return 0;
}
</code></pre>
<details>
 <summary>OdpovÄ›Ä</summary>
<p>Program vypÃ­Å¡e <code>a &gt;= 2</code>. PÅ™Ã­kaz <code>if</code>, za kterÃ½m nÃ¡sleduje sada nÃ¡vaznÃ½ch pÅ™Ã­kazÅ¯ <code>else if</code>,
pÅ™Ã­padnÄ› na poslednÃ­ pozici <code>else</code>, se vyhodnocuje shora dolÅ¯. Provede se blok kÃ³du prvnÃ­ho <code>if</code>u,
jehoÅ¾ podmÃ­nka (vÃ½raz v zÃ¡vorce) se vyhodnotÃ­ jako <code>true</code>, coÅ¾ je v tomto pÅ™Ã­padÄ› podmÃ­nka <code>else if (a &gt;= 2)</code>.
I kdyÅ¾ jistÄ› platÃ­ i podmÃ­nka <code>a &gt;= 1</code>, tak blok kÃ³du za poslednÃ­m <code>else if</code> se zde neprovede, protoÅ¾e
se uÅ¾ provedl blok kÃ³du za dÅ™Ã­vÄ›jÅ¡Ã­ podmÃ­nkou.</p>
</details>
</li>
<li>
<p>Co vypÃ­Å¡e nÃ¡sledujÃ­cÃ­ program?</p>
<pre><code class="language-c editable mainbody">#include &lt;stdio.h&gt;

int main() {
    int a = 2;
    if (a &gt;= 3) {
      printf(&quot;a &gt;= 3\n&quot;);
    } else if (a &gt;= 2) {
      printf(&quot;a &gt;= 2\n&quot;);
    } if (a &gt;= 1) {
      printf(&quot;a &gt;= 1\n&quot;);
    }

    return 0;
}
</code></pre>
<details>
 <summary>OdpovÄ›Ä</summary>
<p>Program vypÃ­Å¡e:</p>
<pre><code>a &gt;= 2
a &gt;= 1
</code></pre>
<p>VÅ¡imnÄ›te si, Å¾e pÅ™ed poslednÃ­m pÅ™Ã­kazem <code>if</code> nenÃ­ <code>else</code>! To znamenÃ¡, Å¾e se jednÃ¡ o nezÃ¡vislÃ½
pÅ™Ã­kaz <code>if</code>, kterÃ½ nijak nesouvisÃ­ s prvnÃ­m pÅ™Ã­kazem <code>if</code> nad nÃ­m. KvÅ¯li toho se tento pÅ™Ã­kaz
provede, i kdyÅ¾ byl pÅ™edtÃ­m proveden blok za podmÃ­nkou <code>else if (a &gt;= 2)</code>.</p>
<p>V bÄ›Å¾nÃ©m programu by byl tento kÃ³d formÃ¡tovÃ¡n spÃ­Å¡e nÃ¡sledovnÄ›:</p>
<pre><code class="language-c">int a = 2;
if (a &gt;= 3) {
  printf(&quot;a &gt;= 3\n&quot;);
} else if (a &gt;= 2) {
  printf(&quot;a &gt;= 2\n&quot;);
}

if (a &gt;= 1) {
  printf(&quot;a &gt;= 1\n&quot;);
}
</code></pre>
<p>S tÃ­mto formÃ¡tovÃ¡nÃ­m je mnohem jednoduÅ¡Å¡Ã­ rozpoznat, Å¾e spolu tyto dva pÅ™Ã­kazy <code>if</code> nesouvisÃ­.</p>
</details>
</li>
<li>
<p>Co vypÃ­Å¡e nÃ¡sledujÃ­cÃ­ program?</p>
<pre><code class="language-c editable mainbody">#include &lt;stdio.h&gt;

int main() {
    int a = 1;
    int b = 4;

    if (a &gt; 1) {
      if (b == 4) {
         printf(&quot;b == 4\n&quot;);
      } else {
         printf(&quot;b != 4\n&quot;);
      }
    }

    return 0;
}
</code></pre>
<details>
 <summary>OdpovÄ›Ä</summary>
<p>Tento program nevypÃ­Å¡e nic. PodmÃ­nka <code>a &gt; 1</code> se vyhodnotÃ­ jako <code>false</code>, takÅ¾e blok kÃ³du za touto
podmÃ­nkou se vÅ¯bec nevykonÃ¡.</p>
</details>
</li>
<li>
<p>Co vypÃ­Å¡e nÃ¡sledujÃ­cÃ­ program?</p>
<pre><code class="language-c editable mainbody">#include &lt;stdio.h&gt;

int main() {
    int a = 1;
    if (a = 2) {
      printf(&quot;a se rovna dvoum\n&quot;);
    }

    return 0;
}
</code></pre>
<details>
 <summary>OdpovÄ›Ä</summary>
<p>Tento program vypÃ­Å¡e <code>a se rovna dvoum</code>. Pozor na to, Å¾e operÃ¡tor pÅ™iÅ™azenÃ­ <code>[x] = [y]</code> pÅ™iÅ™adÃ­
vÃ½raz <code>[y]</code> do <code>[x]</code>, a vyhodnotÃ­ se jako hodnota <code>[y]</code>. V tomto pÅ™Ã­padÄ› se tedy do promÄ›nnÃ©
<code>a</code> uloÅ¾Ã­ hodnota <code>2</code>, a jelikoÅ¾ <code>2</code> se po <a href="c/rizeni_toku/../datove_typy/pravdivostni_typy.html#konverze">pÅ™evodu</a>
na <code>bool</code> vyhodnotÃ­ jako pravda (<code>true</code>), se tÄ›lo pÅ™Ã­kazu <code>if</code> provede. ZÃ¡mÄ›na pÅ™iÅ™azenÃ­ (<code>=</code>)
a <code>==</code> (porovnÃ¡nÃ­) je Äastou <a href="c/rizeni_toku/../../caste_chyby/caste_chyby.html#z%C3%A1m%C4%9Bna--a-">zaÄÃ¡teÄnickou chybou</a>.</p>
</details>
</li>
</ol>
<h1><a class="header" href="#pÅ™Ã­kaz-switch" id="pÅ™Ã­kaz-switch">PÅ™Ã­kaz <code>switch</code></a></h1>
<blockquote>
<p>ğŸ¤“ Tato sekce obsahuje doplÅˆujÃ­cÃ­ uÄivo. Pokud je toho na vÃ¡s moc, mÅ¯Å¾ete ji prozatÃ­m pÅ™eskoÄit
a vrÃ¡tit se k nÃ­ pozdÄ›ji.</p>
</blockquote>
<p>V pÅ™Ã­padÄ›, Å¾e byste chtÄ›li provÃ©st rozliÅ¡nÃ½ kÃ³d v zÃ¡vislosti na hodnotÄ› nÄ›jakÃ©ho vÃ½razu,
a tento vÃ½raz (napÅ™. hodnota promÄ›nnÃ©) mÅ¯Å¾e nabÃ½vat vÄ›tÅ¡Ã­ho mnoÅ¾stvÃ­ rÅ¯znÃ½ch hodnot, tak mÅ¯Å¾e bÃ½t
zdlouhavÃ© pouÅ¾Ã­t spoustu <code>if</code>Å¯:</p>
<pre><code class="language-c">if (a == 0) {
    ...
}
else if (a == 1) {
    ...
}
else if (a == 2) {
    ...
}
...
</code></pre>
<p>Jako jistÃ¡ zkratka mÅ¯Å¾e slouÅ¾it pÅ™Ã­kaz <code>switch</code>. Ten mÃ¡ nÃ¡sledujÃ­cÃ­ syntaxi:</p>
<pre><code class="language-c">switch (&lt;vÃ½raz&gt;) {
    case &lt;hodnota A&gt;: &lt;blok kÃ³du&gt;
    case &lt;hodnota B&gt;: &lt;blok kÃ³du&gt;
    case &lt;hodnota C&gt;: &lt;blok kÃ³du&gt;
    ...
}
</code></pre>
<p>Tento pÅ™Ã­kaz vyhodnotÃ­ vÃ½raz v zÃ¡vorce za klÃ­ÄovÃ½m slovem <code>switch</code>. Pokud se v bloku kÃ³du za zÃ¡vorkou
nachÃ¡zÃ­ klÃ­ÄovÃ© slovo <code>case</code> nÃ¡sledovanÃ© hodnotou odpovÃ­dajÃ­cÃ­ hodnotÄ› vÃ½razu, tak program zaÄne vykonÃ¡vat
blok kÃ³du, kterÃ½ nÃ¡sleduje za tÃ­mto <code>case</code>. DÃ¡le se program bude vykonÃ¡vat sekvenÄnÄ› aÅ¾ do bloku <code>switch</code>e
(pÅ™i tomto vykonÃ¡vÃ¡nÃ­ uÅ¾ se klÃ­ÄovÃ¡ slovo <code>case</code> i hodnoty za nÃ­m ignorujÃ­)<sup class='margin-toggle sidenote-number'>1</sup>.</p>
<span class='sidenote'><p><sup class='number'>1</sup>Toto chovÃ¡nÃ­ se anglicky oznaÄuje jako <em>fallthrough</em>.</p>
</span>
<p>Tento program vypÃ­Å¡e <code>52</code>, protoÅ¾e pÅ™edanÃ½ vÃ½raz mÃ¡ hodnotu <code>5</code>, takÅ¾e program skoÄÃ­ na blok za
<code>case 5</code> a dÃ¡le pokraÄuje sekvenÄnÄ› aÅ¾ do konce bloku <code>switch</code> pÅ™Ã­kazu.</p>
<pre><code class="language-c editable mainbody">#include &lt;stdio.h&gt;

int main() {
    switch (5) {
        case 0: printf(&quot;0&quot;);
        case 1: printf(&quot;1&quot;);
        case 5: printf(&quot;5&quot;);
        case 2: printf(&quot;2&quot;);
    }

    return 0;
}
</code></pre>
<h2><a class="header" href="#klÃ­ÄovÃ©-slovo-default" id="klÃ­ÄovÃ©-slovo-default">KlÃ­ÄovÃ© slovo <code>default</code></a></h2>
<p>Do bloku kÃ³du pÅ™Ã­kazu <code>switch</code> lze pÅ™edat i blok pojmenovanÃ½ <code>default</code>, na kterÃ½ program skoÄÃ­ v
pÅ™Ã­padÄ›, Å¾e se nenalezne Å¾Ã¡dnÃ½ <code>case</code> s odpovÃ­dajÃ­cÃ­ hodnotou:</p>
<pre><code class="language-c editable mainbody">#include &lt;stdio.h&gt;

int main() {
    switch (10) {
        case 0: printf(&quot;0&quot;);
        case 1: printf(&quot;1&quot;);
        case 5: printf(&quot;5&quot;);
        case 2: printf(&quot;2&quot;);
        default: printf(&quot;nenalezeno&quot;);
    }

    return 0;
}
</code></pre>
<h2><a class="header" href="#klÃ­ÄovÃ©-slovo-break" id="klÃ­ÄovÃ©-slovo-break">KlÃ­ÄovÃ© slovo <code>break</code></a></h2>
<p>Velmi Äasto chceme provÃ©st pouze jeden blok kÃ³du u jednoho <code>case</code> a nepokraÄovat po nÄ›m aÅ¾ do konce
celÃ©ho <code>switch</code> bloku. BÄ›Å¾nÄ› se tedy za kaÅ¾dÃ½m <code>case</code> blokem pouÅ¾Ã­vÃ¡ pÅ™Ã­kaz <code>break</code>, kterÃ½ ukonÄÃ­
provÃ¡dÄ›nÃ­ celÃ©ho <code>switch</code> pÅ™Ã­kazu:</p>
<pre><code class="language-c editable mainbody">#include &lt;stdio.h&gt;

int main() {
    switch (1) {
        case 0: printf(&quot;0&quot;); break;
        case 1: printf(&quot;1&quot;); break;
        case 2: printf(&quot;2&quot;); break;
        default: printf(&quot;nenalezeno&quot;);
    }

    return 0;
}
</code></pre>
<h2><a class="header" href="#hodnota-za-case" id="hodnota-za-case">Hodnota za <code>case</code></a></h2>
<p>Hodnota za klÃ­ÄovÃ½m slovem <code>case</code> musÃ­ bÃ½t konstantnÃ­, jinak Å™eÄeno musÃ­ to bÃ½t hodnota znÃ¡mÃ¡ jiÅ¾ v
dobÄ› pÅ™ekladu programu, napÅ™. <a href="c/rizeni_toku/../prikazy_vyrazy.html#v%C3%BDrazy">literÃ¡l</a>. Za <code>case</code> tak nelze dÃ¡t napÅ™.
vÃ½raz obsahujÃ­cÃ­ nÃ¡zev promÄ›nnÃ©.</p>
<h2><a class="header" href="#pouÅ¾itÃ­-pÅ™Ã­kazu-switch" id="pouÅ¾itÃ­-pÅ™Ã­kazu-switch">PouÅ¾itÃ­ pÅ™Ã­kazu <code>switch</code></a></h2>
<p>VÃ½raz v zÃ¡vorce za <code>switch</code> vestavÄ›nÃ½ datovÃ½ typ, v podstatÄ› se zde dÃ¡ pouÅ¾Ã­t pouze celÃ© ÄÃ­slo.
Nelze jej pouÅ¾Ã­t napÅ™. na porovnÃ¡vÃ¡nÃ­ <a href="c/rizeni_toku/../struktury/struktury.html">struktur</a> Äi <a href="c/rizeni_toku/../text/retezce.html">Å™etÄ›zcÅ¯</a>.
Jeho chovÃ¡nÃ­ takÃ© mÅ¯Å¾e bÃ½t matoucÃ­, pokud se za jednotlivÃ½mi <code>case</code> konstrukcemi nepouÅ¾ije pÅ™Ã­kaz
<code>break</code>. Proto tak doporuÄujeme ze zaÄÃ¡tku pouÅ¾Ã­vat pro podmÃ­nÄ›nÃ© vykonÃ¡vÃ¡nÃ­ spÃ­Å¡e pÅ™Ã­kaz <a href="c/rizeni_toku/if.html"><code>if</code></a>.</p>
<h1><a class="header" href="#ternÃ¡rnÃ­-operÃ¡tor" id="ternÃ¡rnÃ­-operÃ¡tor">TernÃ¡rnÃ­ operÃ¡tor</a></h1>
<blockquote>
<p>ğŸ¤“ Tato sekce obsahuje doplÅˆujÃ­cÃ­ uÄivo. Pokud je toho na vÃ¡s moc, mÅ¯Å¾ete ji prozatÃ­m pÅ™eskoÄit
a vrÃ¡tit se k nÃ­ pozdÄ›ji.</p>
</blockquote>
<p>ObÄas se nÃ¡m mÅ¯Å¾e hodit vytvoÅ™it vÃ½raz, kterÃ½ bude mÃ­t hodnotu jednoho ze dvou konkrÃ©tnÃ­ch vÃ½razÅ¯,
v zÃ¡vislosti na hodnotÄ› nÄ›jakÃ© podmÃ­nky. NapÅ™Ã­klad pokud bychom chtÄ›li pÅ™iÅ™adit minimum ze dvou
hodnot do promÄ›nnÃ©, tak to mÅ¯Å¾eme napsat takto:</p>
<pre><code class="language-c">int a = 1;
int b = 5;

int c = 0;
if (a &lt; b) {
    c = a;
} else {
    c = b;
}
</code></pre>
<p>VÅ¡imnÄ›te si, Å¾e do promÄ›nnÃ© <code>c</code> uklÃ¡dÃ¡me buÄ vÃ½raz <code>a</code> nebo vÃ½raz <code>b</code>, v zÃ¡vislosti na tom, jakÃ¡ je
hodnota podmÃ­nky <code>a &lt; b</code>.</p>
<p>JelikoÅ¾ je tato situace relativnÄ› ÄastÃ¡, a jejÃ­ vyÅ™eÅ¡enÃ­ pomocÃ­ pÅ™Ã­kazu <code>if</code> je relativnÄ› zdlouhavÃ©,
tak jazyk <code>C</code> obsahuje zkratku v podobÄ› <strong>ternÃ¡rnÃ­ho operÃ¡toru</strong> (<em>ternary operator</em>). Tento vÃ½raz
mÃ¡ nÃ¡sledujÃ­cÃ­ syntaxi:</p>
<pre><code class="language-c">&lt;vÃ½raz X typu bool&gt; ? &lt;vÃ½raz A&gt; : &lt;vÃ½raz B&gt;
</code></pre>
<p>Pokud je vÃ½raz <code>X</code> pravdivÃ½, tak se ternÃ¡rnÃ­ operÃ¡tor vyhodnotÃ­ jako hodnota vÃ½razu <code>A</code>, v opaÄnÃ©m
pÅ™Ã­padÄ› se vyhodnotÃ­ jako hodnota vÃ½razu <code>B</code>. Uhodnete, co vypÃ­Å¡e nÃ¡sledujÃ­cÃ­ program?</p>
<pre><code class="language-c editable mainbody">#include &lt;stdio.h&gt;

int main() {
    int a = 1;
    int b = 5;
    int c = (a &gt;= b) ? a - b : a + b;
    printf(&quot;%d\n&quot;, c);

    return 0;
}
</code></pre>
<h1><a class="header" href="#cykly" id="cykly">Cykly</a></h1>
<p>Ve svÃ½ch programech budete Äasto chtÃ­t provÃ¡dÄ›t nÄ›jakou operaci opakovanÄ›, napÅ™Ã­klad:</p>
<ul>
<li>Pro kaÅ¾dÃ½ zÃ¡znam v databÃ¡zi vypiÅ¡ Å™Ã¡dek do souboru.</li>
<li>PoÅ¡li zprÃ¡vu kaÅ¾dÃ©mu ÃºÄastnÃ­kovi chatu.</li>
<li>NaÄÃ­tej Å™Ã¡dky ze souboru, dokud nedojdeÅ¡ na konec souboru.</li>
</ul>
<p>Pokud bychom vÅ¾dy pouze pÅ™idÃ¡vali novÃ© pÅ™Ã­kazy pod sebe, tak, jak to zatÃ­m znÃ¡me, abychom nÄ›jakÃ½ pÅ™Ã­kaz
provedli vÃ­cekrÃ¡t, tak by naÅ¡e programy jednak byly nejspÃ­Å¡e dost dlouhÃ©. NejspÃ­Å¡e bychom bychom
neustÃ¡le kopÃ­rovali (&quot;copy-pastovali&quot;) velmi podobnÃ½ kÃ³d:</p>
<pre><code class="language-c">printf(&quot;0\n&quot;);
printf(&quot;1\n&quot;);
printf(&quot;2\n&quot;);
...
</code></pre>
<p>coÅ¾ by vedlo k nepÅ™ehlednÃ½m programÅ¯m<sup class='margin-toggle sidenote-number'>1</sup>. Pokud bychom navÃ­c naÅ¡li v programu chybu, museli bychom ji
opravit na vÅ¡ech mÃ­stech, kam jsme kÃ³d zkopÃ­rovali.</p>
<span class='sidenote'><p><sup class='number'>1</sup>PÅ™edstavte si, Å¾e chcete na vÃ½stup programu nebo do souboru vypsat tÅ™eba tisÃ­c rÅ¯znÃ½ch Å™Ã¡dkÅ¯ textu.</p>
</span>
<p>Ani s kopÃ­rovÃ¡nÃ­m kÃ³du bychom si vÅ¡ak nevystaÄili, pokud bychom potÅ™ebovali provÃ¡dÄ›t kÃ³d opakovanÄ›
v zÃ¡vislosti na vstupu programu. PÅ™edstavte si situaci, kdy nÃ¡m uÅ¾ivatel na vstup programu zadÃ¡ ÄÃ­slo,
kolikrÃ¡t mÃ¡ nÃ¡Å¡ program vypsat nÄ›jakÃ½ Å™Ã¡dek textu na vÃ½stup. UÅ¾ivatel se pÅ™i kaÅ¾dÃ©m spuÅ¡tÄ›nÃ­ programu
mÅ¯Å¾e rozhodnout pro jinÃ© ÄÃ­slo, <code>0</code>, <code>1</code>, <code>42</code>, <code>1000</code>. Program vÅ¡ak zÅ¯stÃ¡vÃ¡ stÃ¡le stejnÃ½ - uÅ¾ pÅ™i
tvorbÄ› (psanÃ­) programu se musÃ­me rozhodnout, kolik pÅ™Ã­kazÅ¯ pro vÃ½pis do nÄ›j vloÅ¾Ã­me. PotÃ© se program
<a href="c/rizeni_toku/../../prostredi/preklad_programu.html">pÅ™eloÅ¾Ã­</a> na spustitelnÃ½ soubor a potÃ© uÅ¾ naÅ¡i volbu nemÅ¯Å¾eme
jednoduÅ¡e zmÄ›nit. TakovÃ½to program bychom tedy zatÃ­m (pouze pomocÃ­ promÄ›nnÃ½ch a podmÃ­nek) nemÄ›li jak
naprogramovat. </p>
<p>Proto programovacÃ­ jazyky nabÃ­zÃ­ tzv. <strong>cykly</strong> (<em>loops</em>), pomocÃ­ kterÃ½ch mÅ¯Å¾eme jednoduÅ¡e Å™Ã­ct
poÄÃ­taÄi, aby urÄitÃ½ blok kÃ³du opakoval, kolikrÃ¡t budeme chtÃ­t. DÃ­ky tomu mÅ¯Å¾e program i s pouze
nÄ›kolika mÃ¡lo Å™Ã¡dky kÃ³du Å™Ã­ct poÄÃ­taÄi, aby provedl spoustu instrukcÃ­. Jazyk <em>C</em> nabÃ­zÃ­ dva zÃ¡kladnÃ­
typy cyklÅ¯, <a href="c/rizeni_toku/while.html">while</a> a <a href="c/rizeni_toku/for.html">for</a>.</p>
<blockquote>
<p>DalÅ¡Ã­ motivacÃ­ pro vyuÅ¾itÃ­ cyklÅ¯ je to, Å¾e modernÃ­ procesory poÄÃ­taÄÅ¯ majÃ­ bÄ›Å¾nÄ› frekvence od
1 do 4 GHz, takÅ¾e za vteÅ™inu zvlÃ¡dnou provÃ©st nÄ›kolik miliard
<a href="https://cs.wikipedia.org/wiki/Hodinov%C3%BD_sign%C3%A1l">taktÅ¯</a> a bÄ›hem kaÅ¾dÃ©ho taktu navÃ­c aÅ¾
<a href="https://cs.wikipedia.org/wiki/Superskal%C3%A1rn%C3%AD_architektura">desÃ­tky</a> rÅ¯znÃ½ch operacÃ­.
JistÄ› si dovedete pÅ™edstavit, Å¾e s pouze sekvenÄnÃ­m zÃ¡pisem kÃ³du bychom tento potenciÃ¡l nemohli
naplno vyuÅ¾Ã­t. I kdyÅ¾ jeden Å™Ã¡dek <em>C</em> kÃ³du mÅ¯Å¾e bÃ½t pÅ™eloÅ¾en aÅ¾ na desÃ­tky procesorovÃ½ch instrukcÃ­,
tak i kdybychom zvlÃ¡dli napsat program se stovkami milionÅ¯ Å™Ã¡dek, poÅ™Ã¡d bychom takovÃ½mto programem
&quot;zabavili&quot; procesor na pouhou vteÅ™inu. BÄ›Å¾Ã­cÃ­ programy tak obvykle trÃ¡vÃ­ vÄ›tÅ¡inu Äasu prÃ¡vÄ›
provÃ¡dÄ›nÃ­m nÄ›jakÃ©ho cyklu.</p>
</blockquote>
<h1><a class="header" href="#cyklus-while" id="cyklus-while">Cyklus <code>while</code></a></h1>
<p>NejjednoduÅ¡Å¡Ã­m cyklem v <em>C</em> je cyklus <code>while</code> (&quot;dokud&quot;):</p>
<pre><code class="language-c">while (&lt;vÃ½raz typu bool&gt;) {
    // blok cyklu
}
</code></pre>
<p>Funguje nÃ¡sledovnÄ›:</p>
<ol>
<li>Nejprve se vyhodnotÃ­ (BooleovskÃ½) vÃ½raz v zÃ¡vorce za <code>while</code> a provede se bod 2.</li>
<li>Pokud:
<ul>
<li>Je vÃ½raz pravdivÃ½, tak se provede blok<sup class='margin-toggle sidenote-number'>1</sup> cyklu a dÃ¡le se pokraÄuje opÄ›t bodem 1.<span class='sidenote'><p><sup class='number'>1</sup><a href="c/rizeni_toku/../promenne/promenne.html#platnost">Blok</a> cyklu se takÃ© Äasto nazÃ½vÃ¡ jako <strong>tÄ›lo</strong> (<em>body</em>) cyklu.</p>
</span></li>
<li>NenÃ­ vÃ½raz pravdivÃ½, tak se provede bod 3.</li>
</ul>
</li>
<li>Program pokraÄuje za cyklem <code>while</code>.</li>
</ol>
<p>Jinak Å™eÄeno, dokud bude splnÄ›nÃ¡ podmÃ­nka za <code>while</code>, tak se budou opakovanÄ› provÃ¡dÄ›t pÅ™Ã­kazy uvnitÅ™
tÄ›la cyklu. VyzkouÅ¡ejte si to na nÃ¡sledujÃ­cÃ­m pÅ™Ã­kladu:</p>
<pre><code class="language-c editable mainbody">#include &lt;stdio.h&gt;

int main() {
    int pocet = 0;
    while (pocet &lt; 5) {
        printf(&quot;Telo cyklu se provedlo, hodnota promenne pocet=%d\n&quot;, pocet);
        pocet = pocet + 1;
    }
    return 0;
}
</code></pre>
<p>Tento kÃ³d opÄ›t mÅ¯Å¾eme pÅ™eÄÃ­st jako vÄ›tu: <code>Dokud je hodnota promÄ›nnÃ© pocet menÅ¡Ã­ neÅ¾ pÄ›t, provÃ¡dÄ›j tÄ›lo cyklu</code>. Jedno vykonÃ¡nÃ­ tÄ›la cyklu se nazÃ½vÃ¡ <strong>iterace</strong>. Cyklus v ukÃ¡zce vÃ½Å¡e tedy provede pÄ›t iteracÃ­,
protoÅ¾e se tÄ›lo cyklu provede pÄ›tkrÃ¡t.</p>
<p>Pokud vÃ½raz za <code>while</code> nenÃ­ vyhodnocen jako pravdivÃ½ v momentÄ›, kdy se <code>while</code> zaÄne vykonÃ¡vat, tak
se tÄ›lo cyklu nemusÃ­ provÃ©st ani jednou (tj. bude mÃ­t nula iteracÃ­).</p>
<h3><a class="header" href="#nekoneÄnÃ½-cyklus" id="nekoneÄnÃ½-cyklus">NekoneÄnÃ½ cyklus</a></h3>
<p>Je dÅ¯leÅ¾itÃ© dÃ¡vat si pozor na to, aby cyklus, kterÃ½ pouÅ¾ijeme, nebyl nechtÄ›nÄ› <strong>nekoneÄnÃ½</strong>
(<em>infinite loop</em>), jinak by nÃ¡Å¡ program nikdy neskonÄil. Zkuste v kÃ³du vÃ½Å¡e zakomentovat nebo odstranit
Å™Ã¡dek <code>pocet = pocet + 1;</code> a zkuste program spustit. JelikoÅ¾ se hodnota promÄ›nnÃ© <code>pocet</code> nebude nijak
mÄ›nit, tak vÃ½raz <code>pocet &lt; 5</code> bude stÃ¡le pravdivÃ½ a cyklus se tak bude provÃ¡dÄ›t neustÃ¡le dokola.
TÃ©to situaci se lidovÄ› Å™Ã­kÃ¡ &quot;zacyklenÃ­&quot;<sup class='margin-toggle sidenote-number'>2</sup>.</p>
<span class='sidenote'><p><sup class='number'>2</sup>Pokud program spouÅ¡tÃ­te v terminÃ¡lu a zacyklÃ­ se, mÅ¯Å¾ete ho pÅ™eruÅ¡it pomocÃ­ klÃ¡vesovÃ© zkratky <code>Ctrl + C</code>.
Pokud jej spustÃ­te v prohlÃ­Å¾eÄi, tak potÃ© radÅ¡i restartujte tuto strÃ¡nku pomocÃ­ <code>F5</code> :)</p>
</span>
<blockquote>
<p>Pokud se vÃ¡m nÄ›kdy stalo, Å¾e se program, kterÃ½ jste zrovna pouÅ¾Ã­vali, &quot;zaseknul&quot; a pÅ™estal reagovat
na vÃ¡Å¡ vstup, mohlo to bÃ½t prÃ¡vÄ› napÅ™Ã­klad tÃ­m, Å¾e v nÄ›m nechtÄ›nÄ› doÅ¡lo k provedenÃ­ nekoneÄnÃ©ho
cyklu (doÅ¡lo k zacyklenÃ­).</p>
</blockquote>
<h3><a class="header" href="#Å˜Ã­dÃ­cÃ­-promÄ›nnÃ¡" id="Å˜Ã­dÃ­cÃ­-promÄ›nnÃ¡">Å˜Ã­dÃ­cÃ­ promÄ›nnÃ¡</a></h3>
<p>ProvÃ©st ÃºplnÄ› identickÃ½ kÃ³d opakovanÄ› se nÄ›kdy hodÃ­, ale vÄ›tÅ¡inou chceme provÃ©st v tÄ›le cyklu trochu
jinÃ© pÅ™Ã­kazy, v zÃ¡vislosti na tom, kterÃ¡ iterace se zrovna vykonÃ¡vÃ¡.
K tomu mÅ¯Å¾eme pouÅ¾Ã­t promÄ›nnou, kterÃ¡ si budeme pamatovat, v jakÃ© iteraci cyklu
se nachÃ¡zÃ­me, a podle nÃ­ se potÃ© provede odpovÃ­dajÃ­cÃ­ operace. TakovÃ¡to promÄ›nnÃ¡ se obvykle oznaÄuje
jako <strong>Å™Ã­dÃ­cÃ­ promÄ›nnÃ¡</strong> (<em>index variable</em>).</p>
<p>NapÅ™Ã­klad pokud chceme nÄ›co provÃ©st pouze v prvnÃ­ iteraci cyklu, mÅ¯Å¾eme pouÅ¾Ã­t
pÅ™Ã­kaz <a href="c/rizeni_toku/if.html">if</a> s podmÃ­nkou, ve kterÃ© zkontrolujeme aktuÃ¡lnÃ­ hodnotu Å™Ã­dÃ­cÃ­ promÄ›nnÃ©:</p>
<pre><code class="language-c editable mainbody">#include &lt;stdio.h&gt;

int main() {
    int i = 0;
    while (i &lt; 5) {
        if (i == 0) {
            printf(&quot;Prvni iterace\n&quot;);
        }
        printf(&quot;Hodnota i=%d\n&quot;, i);
        i += 1;
    }
    return 0;
}
</code></pre>
<p>Å˜Ã­dÃ­cÃ­ promÄ›nnÃ¡ je zde <code>i</code> - tento nÃ¡zev se pro Å™Ã­dÃ­cÃ­ promÄ›nnÃ© pro jednoduchost Äasto pouÅ¾Ã­vÃ¡.</p>
<hr/>
<p><strong>CviÄenÃ­</strong> ğŸ‹</p>
<p>Upravte kÃ³d vÃ½Å¡e tak, aby program vypsal <code>Posledni iterace</code> pÅ™i provÃ¡dÄ›nÃ­ poslednÃ­
iterace cyklu. Zkuste potÃ© kÃ³d upravit tak, aby fungoval pro libovolnÃ½ poÄet iteracÃ­ (tj.
aÅ¥ uÅ¾ bude poÄet iteracÃ­ libovolnÃ½, kÃ³d v tÄ›le i podmÃ­nce samotnÃ©ho cyklu musÃ­ zÅ¯stat stejnÃ½).</p>
<hr/>
<h3><a class="header" href="#Å˜Ã­zenÃ­-toku-cyklu" id="Å˜Ã­zenÃ­-toku-cyklu">Å˜Ã­zenÃ­ toku cyklu</a></h3>
<p>V cyklech mÅ¯Å¾ete vyuÅ¾Ã­t dva speciÃ¡lnÃ­ pÅ™Ã­kazy, kterÃ© fungujÃ­ pouze uvnitÅ™ tÄ›la (bloku kÃ³du) nÄ›jakÃ©ho
cyklu:</p>
<ul>
<li>PÅ™Ã­kaz <code>continue;</code> zpÅ¯sobÃ­, Å¾e se pÅ™estane vykonÃ¡vat tÄ›lo cyklu, a program bude pokraÄovat ve
vykonÃ¡vÃ¡nÃ­ na zaÄÃ¡tku cyklu (tedy u <code>while</code> na vyhodnocenÃ­ vÃ½razu). <code>continue</code> lze chÃ¡pat jako skok
na dalÅ¡Ã­ iteraci cyklu. Zkuste uhodnout, co vypÃ­Å¡e nÃ¡sledujÃ­cÃ­ kÃ³d:
<pre><code class="language-c editable mainbody">#include &lt;stdio.h&gt;

int main() {
    int pocet = 0;
    while (pocet &lt; 10) {
        pocet = pocet + 1;

        if (pocet &lt; 5) {
            continue;
        }

        printf(&quot;Hodnota: %d\n&quot;, pocet); 
    }

    return 0;
}
</code></pre>
</li>
<li>PÅ™Ã­kaz <code>break;</code> zpÅ¯sobÃ­, Å¾e se cyklus pÅ™estane vykonÃ¡vat a program zaÄne vykonÃ¡vat kÃ³d, kterÃ½
nÃ¡sleduje za cyklem. Cyklus se tak zcela pÅ™eruÅ¡Ã­. Zkuste uhodnout, co vypÃ­Å¡e nÃ¡sledujÃ­cÃ­ kÃ³d:
<pre><code class="language-c editable mainbody">#include &lt;stdio.h&gt;

int main() {
    int pocet = 0;
    while (pocet &lt; 10) {
        if (pocet * 2 &gt; 12) {
            break;
        }

        printf(&quot;Hodnota: %d\n&quot;, pocet);
        pocet = pocet + 1;
    }

    return 0;
}
</code></pre>
</li>
</ul>
<details>
<summary>Tip pro nÃ¡vrh cyklÅ¯ while</summary>
<p>PÅ™Ã­kaz <code>break</code> lze takÃ© nÄ›kdy pouÅ¾Ã­t k usnadnÄ›nÃ­ nÃ¡vrhu cyklÅ¯. Pokud potÅ™ebujete napsat <code>while</code> cyklus
s nÄ›jakou sloÅ¾itou podmÃ­nkou ukonÄenÃ­, ze kterÃ© se vÃ¡m motÃ¡ hlava, zkuste nejprve vytvoÅ™it &quot;nekoneÄnÃ½&quot;
cyklus pomocÃ­ <code>while (1) { â€¦ }</code>, dÃ¡le vytvoÅ™te tÄ›lo cyklu a aÅ¾ nakonec vymyslete podmÃ­nku,
kterÃ¡ cyklus ukonÄÃ­ pomocÃ­ pÅ™Ã­kazu <code>break</code>:</p>
<pre><code class="language-c editable mainbody">#include &lt;stdio.h&gt;

int main() {
    int pocet = 0;
    int pocet2 = 1;
    while (1) {
        printf(&quot;Hodnota: %d\n&quot;, pocet);
        pocet = pocet + 1;
        pocet2 += pocet * 2;

        if (pocet &gt; 10) break;
        if (pocet2 &gt; 64) break;
    }

    return 0;
}
</code></pre>
<p>NemusÃ­te tak hned ze zaÄÃ¡tku vymÃ½Å¡let vÃ½raz pro <code>while</code>, na ÄemÅ¾ byste se mohli zaseknout. </p>
<p>MÃ­sto <code>while (1)</code> mÅ¯Å¾ete pouÅ¾Ã­t takÃ© <code>while (true)</code>. NezapomeÅˆte ale na
<a href="c/rizeni_toku/../datove_typy/pravdivostni_typy.html">vloÅ¾enÃ­ Å™Ã¡dku</a></p>
<pre><code class="language-c">#include &lt;stdbool.h&gt;
</code></pre>
<p>na zaÄÃ¡tek programu!</p>
</details>
<h3><a class="header" href="#vnoÅ™ovÃ¡nÃ­-cyklÅ¯" id="vnoÅ™ovÃ¡nÃ­-cyklÅ¯">VnoÅ™ovÃ¡nÃ­ cyklÅ¯</a></h3>
<p>StejnÄ› jako podmÃ­nky, i cykly jsou pÅ™Ã­kazy, a mÅ¯Å¾ete je tak pouÅ¾Ã­vat libovolnÄ› v blocÃ­ch <em>C</em> kÃ³du
a takÃ© je <a href="c/rizeni_toku/if.html#vno%C5%99ov%C3%A1n%C3%AD-podm%C3%ADnek">vnoÅ™ovat</a>. ChovÃ¡nÃ­ vnoÅ™enÃ½ch cyklÅ¯ mÅ¯Å¾e bÃ½t ze zaÄÃ¡tku
trochu neintuitivnÃ­, proto je dobrÃ© si je procviÄit. Zkuste si pomocÃ­
<a href="c/rizeni_toku/../../prostredi/ladeni.html#krokov%C3%A1n%C3%AD">debuggeru</a> krokovat nÃ¡sledujÃ­cÃ­ kÃ³d, abyste pochopili, jak se
provÃ¡dÃ­, a zkuste odhadnout, jakÃ½ch hodnot budou postupnÄ› nabÃ½vat promÄ›nnÃ© <code>i</code> a <code>j</code>. PotÃ© odkomentujte
vÃ½pisy <code>printf</code> a ovÄ›Å™te, jestli byl vÃ¡Å¡ odhad sprÃ¡vnÃ½:</p>
<pre><code class="language-c editable mainbody">#include &lt;stdio.h&gt;

int main() {
    int i = 0;
    while (i &lt; 3) {
        // printf(&quot;i: %d\n&quot;, i);
        int j = 0;
        while (j &lt; 4) {
            // printf(&quot;  j: %d\n&quot;, j);
            j = j + 1;
        }

        i = i + 1;
    }
    printf(&quot;Konec programu\n&quot;);

    return 0;
}
</code></pre>
<p>Pro kaÅ¾dou iteraci &quot;vnÄ›jÅ¡Ã­ho&quot; <code>while</code> cyklu se provedou ÄtyÅ™i iterace &quot;vnitÅ™nÃ­ho&quot; <code>while</code> cyklu.
Dohromady se tak provede celkem <code>3 * 4</code> iteracÃ­.</p>
<h3><a class="header" href="#cyklus-do-while" id="cyklus-do-while">Cyklus <code>do while</code></a></h3>
<p>Cyklus <code>while</code> mÃ¡ takÃ© alternativu zvanou <code>do while</code>. Tento cyklus mÃ¡ nÃ¡sledujÃ­cÃ­ syntaxi:</p>
<pre><code class="language-c">do {
    // tÄ›lo cyklu
}
while (&lt;vÃ½raz typu bool&gt;);
</code></pre>
<p>Tento kÃ³d mÅ¯Å¾eme ÄÃ­st jako <code>ProvÃ¡dÄ›j &lt;tÄ›lo cyklu&gt;, dokud platÃ­ &lt;vÃ½raz&gt;</code>.</p>
<p>JedinÃ½ rozdÃ­l mezi <code>while</code> a <code>do while</code> je ten, Å¾e v cyklu <code>do while</code> se vÃ½raz, kterÃ½ urÄuje, jestli
se mÃ¡ provÃ©st dalÅ¡Ã­ iterace cyklu, vyhodnocuje aÅ¾ na konci cyklu. TÄ›lo cyklu tak bude pokaÅ¾dÃ© provedeno
alespoÅˆ jednou (i kdyby byl vÃ½raz od zaÄÃ¡tku nepravdivÃ½).</p>
<p>Pokud pro to nemÃ¡te zvlÃ¡Å¡tnÃ­ dÅ¯vod, asi nenÃ­ tÅ™eba tento typ cyklu pouÅ¾Ã­vat.</p>
<hr />
<p><strong>KvÃ­z</strong> ğŸ¤”</p>
<ol>
<li>
<p>Co vypÃ­Å¡e nÃ¡sledujÃ­cÃ­ program?</p>
<pre><code class="language-c editable mainbody">#include &lt;stdio.h&gt;
#include &lt;stdbool.h&gt;

int main() {
    int a = 0;
    int b = 8;

    while (true) {
      if (a &gt; 2) {
        printf(&quot;Hodnota a = %d\n&quot;, a);
      }

      a = a + 2;

      if (a &gt;= b) {
        break;
      }
    }

    return 0;
}
</code></pre>
<details>
 <summary>OdpovÄ›Ä</summary>
<p>Program vypÃ­Å¡e:</p>
<pre><code>Hodnota a = 4
Hodnota a = 6
</code></pre>
<p>V kaÅ¾dÃ© iteraci cyklu se hodnota promÄ›nnÃ© <code>a</code> zvÃ½Å¡Ã­ o dvojku. Pokud je na zaÄÃ¡tku iterace hodnota
<code>a</code> vÄ›tÅ¡Ã­, neÅ¾ dva, tak se vypÃ­Å¡e jejÃ­ hodnota. V ÄtvrtÃ© iteraci cyklu se hodnota promÄ›nnÃ© <code>a</code>
zvÃ½Å¡Ã­ na osm. PotÃ© se podmÃ­nka pÅ™Ã­kazu <code>if</code> vyhodnotÃ­ jako <code>true</code>, takÅ¾e se provede pÅ™Ã­kaz
<code>break</code>, kterÃ½ provÃ¡dÄ›nÃ­ cyklu ukonÄÃ­. Hodnota promÄ›nnÃ© <code>a</code> se tak vypÃ­Å¡e pouze dvakrÃ¡t.</p>
</details>
</li>
<li>
<p>Co vypÃ­Å¡e nÃ¡sledujÃ­cÃ­ program?</p>
<pre><code class="language-c editable mainbody">#include &lt;stdio.h&gt;
#include &lt;stdbool.h&gt;

int main() {
    int a = 0;
    int b = 8;

    while (true) {
      if (a &gt; 2) {
        printf(&quot;Hodnota a = %d\n&quot;, a);
      }

      if (a &gt;= b) {
        break;
      }
      a = a + 2;
    }

    return 0;
}
</code></pre>
<details>
 <summary>OdpovÄ›Ä</summary>
<p>Program vypÃ­Å¡e:</p>
<pre><code>Hodnota a = 4
Hodnota a = 6
Hodnota a = 8
</code></pre>
<p>V kaÅ¾dÃ© iteraci cyklu se hodnota promÄ›nnÃ© <code>a</code> zvÃ½Å¡Ã­ o dvojku. Pokud je na zaÄÃ¡tku iterace hodnota
<code>a</code> vÄ›tÅ¡Ã­, neÅ¾ dva, tak se vypÃ­Å¡e jejÃ­ hodnota. V pÃ¡tÃ© iteraci cyklu je hodnota promÄ›nnÃ© <code>a</code>
osm, takÅ¾e se cyklus ukonÄÃ­ pÅ™Ã­kazem <code>break</code>. VÅ¡imnÄ›te si rozdÃ­lu poÅ™adÃ­ pÅ™Ã­kazu <code>if</code> a zvÃ½Å¡enÃ­
hodnoty promÄ›nnÃ© <code>a</code> v tomto a pÅ™edchozÃ­m pÅ™Ã­kladu.</p>
</details>
</li>
<li>
<p>Co vypÃ­Å¡e nÃ¡sledujÃ­cÃ­ program?</p>
<pre><code class="language-c editable mainbody">#include &lt;stdio.h&gt;

int main() {
    int a = 0;
    int b = 6;

    while (a &gt; b) {
      printf(&quot;Hodnota b = %d\n&quot;, b);
      b = b + 1;
    }

    return 0;
}
</code></pre>
<details>
 <summary>OdpovÄ›Ä</summary>
<p>Program nevypÃ­Å¡e nic, protoÅ¾e podmÃ­nka <code>a &gt; b</code> se vyhodnotÃ­ jako <code>false</code>. TÄ›lo cyklu se tak
neprovede ani jednou.</p>
</details>
</li>
</ol>
<h1><a class="header" href="#cyklus-for" id="cyklus-for">Cyklus <code>for</code></a></h1>
<p>V programech velmi Äasto potÅ™ebujeme vykonat nÄ›jakÃ½ blok kÃ³du pÅ™esnÄ› <code>n</code>-krÃ¡t:</p>
<ul>
<li>Projdi <code>n</code> Å™Ã¡dkÅ¯ ze vstupnÃ­ho souboru a seÄti jejich hodnoty.</li>
<li>PoÅ¡li zprÃ¡vu vÅ¡em <code>n</code> ÃºÄastnÃ­kÅ¯m chatu.</li>
<li>VystÅ™el pÅ™esnÄ› tÅ™ikrÃ¡t ze zbranÄ›.</li>
</ul>
<p>I kdyÅ¾ pomocÃ­ cyklu <code>while</code> mÅ¯Å¾eme vyjÃ¡dÅ™it provedenÃ­ <code>n</code> iteracÃ­, je to relativnÄ› zdlouhavÃ©,
protoÅ¾e je k tomu potÅ™eba alespoÅˆ tÅ™Ã­ Å™Ã¡dkÅ¯ kÃ³du:</p>
<ul>
<li>Inicializace cyklu: vytvoÅ™enÃ­ Å™Ã­dÃ­cÃ­ promÄ›nnÃ©, kterÃ¡ se bude kontrolovat v cyklu</li>
<li>Kontrola vÃ½razu: kontrola, jestli uÅ¾ Å™Ã­dÃ­cÃ­ promÄ›nnÃ¡ dosÃ¡hla poÅ¾adovanÃ© hodnoty</li>
<li>Operace na konci cyklu: zmÄ›na hodnoty Å™Ã­dÃ­cÃ­ promÄ›nnÃ©</li>
</ul>
<pre><code class="language-c">int i = 0; // inicializace Å™Ã­dÃ­cÃ­ promÄ›nnÃ©
while (i &lt; 10) { // kontrola hodnoty Å™Ã­dÃ­cÃ­ promÄ›nnÃ©
    // tÄ›lo cyklu
    i += 1; // zmÄ›na hodnoty Å™Ã­dÃ­cÃ­ promÄ›nnÃ©
}
</code></pre>
<p>Cyklus <code>for</code> existuje, aby tuto Äastou situaci zjednoduÅ¡il. KÃ³d vÃ½Å¡e by se dal pomocÃ­ cyklu <code>for</code>
pÅ™epsat takto:</p>
<pre><code class="language-c">for (int i = 0; i &lt; 10; i += 1) {
    // tÄ›lo cyklu
}
</code></pre>
<p>Jak lze vidÄ›t, <code>for</code> cyklus v sobÄ› kombinuje inicializaci cyklu, kontrolu vÃ½razu a provedenÃ­ pÅ™Ã­kazu
po kaÅ¾dÃ© iteraci. ObecnÃ¡ syntaxe tohoto cyklu vypadÃ¡ takto:</p>
<pre><code class="language-c">for (&lt;pÅ™Ã­kaz A&gt;; &lt;vÃ½raz typu bool&gt;; &lt;pÅ™Ã­kaz B&gt;) {
    // tÄ›lo cyklu
}
</code></pre>
<p>TakovÃ½to cyklus se vykonÃ¡ nÃ¡sledovnÄ›:</p>
<ol>
<li>Jakmile se cyklus zaÄne vykonÃ¡vat, nejprve se provede pÅ™Ã­kaz <code>A</code>. Zde se typicky vytvoÅ™Ã­
Å™Ã­dÃ­cÃ­ promÄ›nnÃ¡ s nÄ›jakou poÄÃ¡teÄnÃ­ hodnotou.</li>
<li>Zkontroluje se vÃ½raz. Pokud nenÃ­ pravdivÃ½, cyklus konÄÃ­ a program pokraÄuje za cyklem <code>for</code>.
Pokud je pravdivÃ½, provede se tÄ›lo cyklu a program pokraÄuje bodem 3.</li>
<li>Provede se pÅ™Ã­kaz <code>B</code> a program pokraÄuje bodem 2.</li>
</ol>
<blockquote>
<p>VÃ½raz v pÅ™Ã­kazu <code>for</code> mÅ¯Å¾e chybÄ›t, v takovÃ©m pÅ™Ã­padÄ› se poklÃ¡dÃ¡ automaticky za <code>true</code>. ZÃ¡roveÅˆ platÃ­,
Å¾e stÅ™ednÃ­kem (<code>;</code>) lze vyjÃ¡dÅ™it tzv. <em>prÃ¡zdnÃ½ pÅ™Ã­kaz</em>, kterÃ½ nic neprovede. VÅ¡echny tÅ™i ÄÃ¡sti cyklu
<code>for</code> tak mÅ¯Å¾ou chybÄ›t, v tom pÅ™Ã­padÄ› se pak jednÃ¡ o <a href="c/rizeni_toku/while.html#nekone%C4%8Dn%C3%BD-cyklus">nekoneÄnÃ½ cyklus</a>:</p>
<pre><code class="language-c">for (;;) {
   ...
}
</code></pre>
</blockquote>
<hr/>
<p><strong>CviÄenÃ­</strong> ğŸ‹</p>
<ul>
<li>NapiÅ¡te program, kterÃ½ pomocÃ­ cyklu <code>for</code> na vÃ½stup vypÃ­Å¡e ÄÃ­sla od 0 do 9 (vÄetnÄ›).</li>
<li>VypiÅ¡te na vÃ½stup Å™Ã¡dek <code>Licha iterace</code> v kaÅ¾dÃ© lichÃ© iteraci cyklu a Å™Ã¡dek <code>Suda iterace</code> v kaÅ¾dÃ©
sudÃ© iteraci tohoto cyklu.</li>
</ul>
<hr/>
<p><strong>KvÃ­z</strong> ğŸ¤”</p>
<ol>
<li>
<p>Co vypÃ­Å¡e nÃ¡sledujÃ­cÃ­ program?</p>
<pre><code class="language-c editable mainbody">#include &lt;stdio.h&gt;

int main() {
    int a = 5;
    for (; a &gt;= 0; a = a - 1) {
       printf(&quot;iterace %d\n&quot;, a);
    }
    printf(&quot;a = %d\n&quot;, a);

    return 0;
}
</code></pre>
<details>
 <summary>OdpovÄ›Ä</summary>
<p>Program vypÃ­Å¡e:</p>
<pre><code class="language-c">iterace 5
iterace 4
iterace 3
iterace 2
iterace 1
iterace 0
a = -1
</code></pre>
<p>PÅ™i poslednÃ­ iteraci cyklu se hodnota promÄ›nnÃ© <code>a</code> zmenÅ¡Ã­ z <code>0</code> na <code>-1</code>, potÃ© uÅ¾ se podmÃ­nka cyklu
vyhodnotÃ­ na <code>false</code> a cyklus skonÄÃ­.</p>
<p>VÅ¡imnÄ›te si, Å¾e definice a inicializace Å™Ã­dÃ­cÃ­ promÄ›nnÃ© je mimo cyklus, jinak bychom k tÃ©to promÄ›nnÃ©
po ukonÄenÃ­ provÃ¡dÄ›nÃ­ cyklu jiÅ¾ nemÄ›li pÅ™Ã­stup. Definice Å™Ã­dÃ­cÃ­ promÄ›nnÃ© pÅ™ed cyklem se nÃ¡m mÅ¯Å¾e
obÄas hodit, pokud bychom s hodnotou Å™Ã­dÃ­cÃ­ promÄ›nnÃ© chtÄ›li pracovat dÃ¡le za cyklem (napÅ™Ã­klad
abychom zjistili, kolik iteracÃ­ cyklus provedl).</p>
</details>
</li>
<li>
<p>Co vypÃ­Å¡e nÃ¡sledujÃ­cÃ­ program?</p>
<pre><code class="language-c editable mainbody">#include &lt;stdio.h&gt;

int main() {
    for (int a = 0; a &lt;= 5; a = a + 1) {
       printf(&quot;iterace %d\n&quot;, a);
       if (a &lt;= 2) {
         a = a + 1;
       }
    }

    return 0;
}
</code></pre>
<details>
 <summary>OdpovÄ›Ä</summary>
<p>Program vypÃ­Å¡e:</p>
<pre><code class="language-c">iterace 0
iterace 2
iterace 4
iterace 5
</code></pre>
<p>Pokud je pÅ™i provÃ¡dÄ›nÃ­ iterace cyklu hodnota <code>a</code> menÅ¡Ã­ nebo rovno dvÄ›ma, tak se hodnota <code>a</code> v
iteraci zvÃ½Å¡Ã­ o jedniÄku dvakrÃ¡t (jednou uvnitÅ™ pÅ™Ã­kazu <code>if</code> a jednou na konci iterace cyklu <code>for</code>).</p>
</details>
</li>
<li>
<p>Co vypÃ­Å¡e nÃ¡sledujÃ­cÃ­ program?</p>
<pre><code class="language-c editable mainbody">#include &lt;stdio.h&gt;

int main() {
    for (int a = 0; a = 5; a = a + 1) {
       printf(&quot;iterace %d\n&quot;, a);
    }

    return 0;
}
</code></pre>
<details>
 <summary>OdpovÄ›Ä</summary>
<p>Program bude neustÃ¡le vypisovat hodnotu promÄ›nnÃ© <code>a</code>, protoÅ¾e vÃ½raz <code>a = 5</code> se vyhodnotÃ­
jako <code>5</code>, a toto ÄÃ­slo se pÅ™i <a href="c/rizeni_toku/../datove_typy/pravdivostni_typy.html#konverze">pÅ™evodu</a> na <code>bool</code>
vyhodnotÃ­ jako pravda (<code>true</code>), takÅ¾e tento cyklus je nekoneÄnÃ½. ZÃ¡mÄ›na pÅ™iÅ™azenÃ­ (<code>=</code>)
a <code>==</code> (porovnÃ¡nÃ­) je Äastou <a href="c/rizeni_toku/../../caste_chyby/caste_chyby.html#z%C3%A1m%C4%9Bna--a-">zaÄÃ¡teÄnickou chybou</a>.</p>
</details>
</li>
</ol>
<h1><a class="header" href="#funkce" id="funkce">Funkce</a></h1>
<p>ZatÃ­m jsme veÅ¡kerÃ½ kÃ³d psali pouze na jedno mÃ­sto v programu, do <a href="c/funkce/../../ruzne/funkce_main.html">&quot;mainu&quot;</a>.
Jakmile programy zaÄnou bÃ½t vÄ›tÅ¡Ã­ a vÄ›tÅ¡Ã­, tak zaÄne takÃ© bÃ½t neustÃ¡le tÄ›Å¾Å¡Ã­ a tÄ›Å¾Å¡Ã­ se v nich zorientovat
a udrÅ¾et je celÃ© v hlavÄ›, abychom nad nimi mohli pÅ™emÃ½Å¡let. ZÃ¡roveÅˆ se nÃ¡m v programu brzy zaÄnou
objevovat Ãºseky kÃ³du, kterÃ© jsou tÃ©mÄ›Å™ totoÅ¾nÃ©, ale liÅ¡Ã­ se v drobnÃ½ch detailech. ChtÄ›li bychom tak
mÃ­t moÅ¾nost takovÃ½to kÃ³d napsat pouze jednou a tyto mÄ›nÃ­cÃ­ se detaily do nÄ›j pouze &quot;dosadit&quot;.
K rozdÄ›lenÃ­ kÃ³du programu do sady ucelenÃ½ch ÄÃ¡stÃ­ a jejich parametrizaci slouÅ¾Ã­ <strong>funkce</strong> (<em>functions</em>).</p>
<p>Funkce je pojmenovanÃ½ blok kÃ³du, na kterÃ½ se mÅ¯Å¾eme odkÃ¡zat v jinÃ© ÄÃ¡sti programu a vykonat tak
kÃ³d, kterÃ½ se ve funkci nachÃ¡zÃ­. S jednou funkcÃ­ uÅ¾ jsme se setkali. JednÃ¡ se o funkci <code>main</code>, jejÃ­Å¾
kÃ³d je proveden pÅ™i spuÅ¡tÄ›nÃ­ programu. My si nicmÃ©nÄ› mÅ¯Å¾eme vytvoÅ™it vlastnÃ­ funkce. Zde je
pÅ™Ã­klad vytvoÅ™enÃ­, tj. <strong>definice</strong> (<em>definition</em>) jednoduchÃ© funkce s nÃ¡zvem<sup class='margin-toggle sidenote-number'>1</sup> <code>vypis_text</code>:</p>
<span class='sidenote'><p><sup class='number'>1</sup>Pravidla pro pojmenovÃ¡vÃ¡nÃ­ funkcÃ­ jsou totoÅ¾nÃ¡ s pravidly pro
<a href="c/funkce/../promenne/pojmenovavani.html">pojmenovÃ¡vÃ¡nÃ­ promÄ›nnÃ½ch</a>.</p>
</span>
<pre><code class="language-c">void vypis_text() {
    printf(&quot;Ahoj\n&quot;);
}
</code></pre>
<p>PÅ™ed nÃ¡zvem funkce je nutnÃ© uvÃ©st datovÃ½ typ (zde je uveden typ <code>void</code>). <a href="c/funkce/funkce.html#n%C3%A1vratov%C3%A1-hodnota-funkc%C3%AD">NÃ­Å¾e</a>
bude vysvÄ›tleno, k Äemu tento typ slouÅ¾Ã­.</p>
<p>Tento blok<sup class='margin-toggle sidenote-number'>2</sup> kÃ³du se pÅ™eloÅ¾Ã­ na instrukce a bude existovat v pÅ™eloÅ¾enÃ©m programu stejnÄ› jako funkce
<code>main</code>, nicmÃ©nÄ› sÃ¡m o sobÄ› se nezaÄne provÃ¡dÄ›t. Abychom kÃ³d tÃ©to funkce provedli, musÃ­me ji tzv.
<strong>zavolat</strong> (<em>call</em>). To provedeme tak, Å¾e napÃ­Å¡eme nÃ¡zev tÃ©to funkce a za nÄ›j dÃ¡me
zÃ¡vorky (<code>()</code>):</p>
<span class='sidenote'><p><sup class='number'>2</sup>StejnÄ› jako u <a href="c/funkce/../rizeni_toku/while.html">cyklÅ¯</a> se bloku kÃ³du funkce Äasto Å™Ã­kÃ¡ <strong>tÄ›lo funkce</strong> (<em>function body</em>).</p>
</span>
<pre><code class="language-c editable mainbody">#include &lt;stdio.h&gt;

void vypis_text() {
    printf(&quot;Ahoj\n&quot;);
}
int main() {
    vypis_text(); // zavolÃ¡nÃ­ funkce vypis_text
    return 0;
}
</code></pre>
<p>ZavolÃ¡nÃ­ funkce je vÃ½raz, pÅ™i jehoÅ¾ vyhodnocenÃ­ dojde k provedenÃ­ kÃ³du funkce, kterÃ¡ se volÃ¡.
KdyÅ¾ se v programu nahoÅ™e ve funkci <code>main</code> vykonÃ¡ Å™Ã¡dek <code>vypis_text();</code>, tak se zaÄne vykonÃ¡vat kÃ³d
funkce <code>vypis_text</code>. Jakmile se pÅ™Ã­kazy z tÃ©to funkce vykonajÃ­, tak program bude pokraÄovat ve funkci
<code>main</code>.</p>
<p>PomocÃ­ volÃ¡nÃ­ funkcÃ­ mÅ¯Å¾eme mÃ­t kus kÃ³du v programu zapsÃ¡n pouze jednou ve funkci, a potÃ© ho
mÅ¯Å¾eme spouÅ¡tÄ›t z rÅ¯znÃ½ch ÄÃ¡stÃ­ programu, podle toho, kdy se nÃ¡m to zrovna bude hodit.</p>
<blockquote>
<p>Funkce <code>main</code> je zavolÃ¡na pÅ™i spuÅ¡tÄ›nÃ­ programu, ÄÃ­mÅ¾ dojde k tomu, Å¾e se zaÄnou vykonÃ¡vat jejÃ­
pÅ™Ã­kazy.</p>
</blockquote>
<h2><a class="header" href="#parametrizace-funkcÃ­" id="parametrizace-funkcÃ­">Parametrizace funkcÃ­</a></h2>
<p>FunkcÃ­m mÅ¯Å¾eme pÅ™iÅ™adit vstupy zvanÃ© <strong>parametry</strong> (<em>parameters</em>). Parametry jsou promÄ›nnÃ© dostupnÃ©
uvnitÅ™ funkce, jejichÅ¾ hodnotu nastavujeme pÅ™i zavolÃ¡nÃ­ danÃ© funkce. NapÅ™Ã­klad nÃ¡sledujÃ­cÃ­ funkce
<code>vypis_cislo</code> mÃ¡ parametr <code>cislo</code> s datovÃ½m typem <code>int</code>.</p>
<pre><code class="language-c editable">#include &lt;stdio.h&gt;

void vypis_cislo(int cislo) {
    printf(&quot;Cislo: %d\n&quot;, cislo);
}
int main() {
    vypis_cislo(5);
    return 0;
}
</code></pre>
<p>PÅ™i zavolÃ¡nÃ­ funkce musÃ­me pro kaÅ¾dÃ½ jejÃ­ parametr do zÃ¡vorek dÃ¡t hodnotu odpovÃ­dajÃ­cÃ­ho datovÃ©ho typu.
Zde je jedinÃ½ parameter typu <code>int</code>, takÅ¾e pÅ™i zavolÃ¡nÃ­ tÃ©to funkce musÃ­me do zÃ¡vorek dÃ¡t jednu hodnotu
datovÃ©ho typu <code>int</code>: <code>vypis_cislo(5)</code>. PÅ™ed spuÅ¡tÄ›nÃ­m pÅ™Ã­kazÅ¯ ve funkci dojde k tomu, Å¾e se kaÅ¾dÃ½
parametr nastavÃ­ na hodnotu pÅ™edanou pÅ™i volÃ¡nÃ­ funkce<sup class='margin-toggle sidenote-number'>3</sup>. PÅ™i zavolÃ¡nÃ­ <code>vypis_cislo(5)</code> si tak mÅ¯Å¾ete
pÅ™edstavit, Å¾e se vykonÃ¡ nÃ¡sledujÃ­cÃ­ kÃ³d:</p>
<span class='sidenote'><p><sup class='number'>3</sup>Hodnoty (vÃ½razy) pÅ™edÃ¡vanÃ© pÅ™i volÃ¡nÃ­ funkce se nazÃ½vajÃ­ <strong>argumenty</strong> (<em>arguments</em>). PÅ™i
volÃ¡nÃ­ <code>vypis_cislo(5)</code> se tedy do parametru <code>cislo</code> nastavÃ­ hodnota argumentu <code>5</code>.</p>
</span>
<pre><code class="language-c">{
    // nastavenÃ­ hodnot parametrÅ¯
    int cislo = 5;

    // tÄ›lo funkce
    printf(&quot;Cislo: %d\n&quot;, cislo); 
}
</code></pre>
<p>Je dÅ¯leÅ¾itÃ© si uvÄ›domit, Å¾e pÅ™i kaÅ¾dÃ©m zavolÃ¡nÃ­ funkce mÅ¯Å¾eme pouÅ¾Ã­t rÅ¯znÃ© hodnoty argumentÅ¯:</p>
<pre><code class="language-c editable">#include &lt;stdio.h&gt;

void vypis_cislo(int cislo) {
    printf(&quot;Cislo: %d\n&quot;, cislo);
    if (cislo &lt; 0) {
        printf(&quot;Predane cislo je zaporne\n&quot;);
    } else {
        printf(&quot;Predane cislo je nezaporne\n&quot;);
    }
}
int main() {
    vypis_cislo(5);
    vypis_cislo(1 + 8);

    int x = -10;
    vypis_cislo(x);

    return 0;
}
</code></pre>
<p>ParametrÅ¯ mohou funkce brÃ¡t libovolnÃ½ poÄet, nicmÃ©nÄ› obvykle se pouÅ¾Ã­vajÃ­ jednotky (maximÃ¡lnÄ› cca 5)
parametrÅ¯, aby funkce a jejÃ­ pouÅ¾Ã­vÃ¡nÃ­ (volÃ¡nÃ­) nebylo pÅ™Ã­liÅ¡ sloÅ¾itÃ©. JednotlivÃ© parametry jsou
oddÄ›leny v definici funkce i v jejÃ­m volÃ¡nÃ­ ÄÃ¡rkami:</p>
<pre><code class="language-c editable">#include &lt;stdio.h&gt;

void vypis_cisla(int a, int b) {
    printf(&quot;Cislo a: %d\n&quot;, a);
    printf(&quot;Cislo b: %d\n&quot;, b);
}
int main() {
    vypis_cisla(5 + 5, 11 * 2);
    return 0;
}
</code></pre>
<p>PomocÃ­ parametrÅ¯ mÅ¯Å¾eme vytvoÅ™it kÃ³d, kterÃ½ nenÃ­ &quot;zadrÃ¡tovanÃ½&quot; na konkrÃ©tnÃ­ hodnoty, ale umÃ­ pracovat
s libovolnou hodnotou vstupu. DÃ­ky toho lze takovou funkci vyuÅ¾Ã­t v rÅ¯znÃ½ch situacÃ­ch bez toho, abychom
jejÃ­ kÃ³d museli kopÃ­rovat. PÅ™Ã­klady pouÅ¾itÃ­ parametrÅ¯ funkcÃ­:</p>
<ul>
<li>Funkci <code>vypis_ctverec</code>, kterÃ¡ pÅ™ijme jako parametr ÄÃ­slo <code>n</code> a vypÃ­Å¡e na vÃ½stup Ätverec tvoÅ™enÃ½
znaky <code>x</code> o stranÄ› <code>n</code>.</li>
<li>Funkci <code>vykresli_pixel</code>, kterÃ¡ pÅ™ijme jako parametry souÅ™adnici na obrazovce a barvu a vykreslÃ­
na obrazovce na danÃ© pozici pixel s odpovÃ­dajÃ­cÃ­ barvou.</li>
</ul>
<hr />
<p><strong>CviÄenÃ­</strong> ğŸ‹</p>
<p>Zkuste naprogramovat funkci <code>vypis_ctverec</code>. DalÅ¡Ã­ zadÃ¡nÃ­ jednoduchÃ½ch funkcÃ­ naleznete
<a href="c/funkce/../../ulohy/funkce.html">zde</a>.</p>
<hr />
<h2><a class="header" href="#nÃ¡vratovÃ¡-hodnota-funkcÃ­" id="nÃ¡vratovÃ¡-hodnota-funkcÃ­">NÃ¡vratovÃ¡ hodnota funkcÃ­</a></h2>
<p>Nejenom, Å¾e funkce mohou pÅ™ijÃ­mat vstup, ale umÃ­ takÃ© vracet vÃ½stup. DatovÃ½ typ uvedenÃ½ pÅ™ed nÃ¡zvem
funkce udÃ¡vÃ¡, jakÃ©ho typu bude tzv. <strong>nÃ¡vratovÃ¡ hodnota</strong> (<em>return value</em>) danÃ© funkce. V pÅ™Ã­kladech
vÃ½Å¡e jsme vidÄ›li datovÃ½ typ <code>void</code>. Tento datovÃ½ typ je speciÃ¡lnÃ­, protoÅ¾e Å™Ã­kÃ¡, Å¾e funkce nebude
vracet <em>nic</em>. Pokud funkce mÃ¡ nÃ¡vratovÃ½ typ <code>void</code>, tak nevracÃ­ Å¾Ã¡dnou hodnotu - pokud zavolÃ¡me
takovouto funkci, tak se sice provede jejÃ­ kÃ³d, ale vÃ½raz zavolÃ¡nÃ­ nevrÃ¡tÃ­ Å¾Ã¡dnou hodnotu:</p>
<pre><code class="language-c editable">void funkce() {}

int main() {
    // chyba pÅ™i pÅ™ekladu, funkce nic nevracÃ­
    int x = funkce();
    return 0;
}
</code></pre>
<p>ÄŒasto bychom nicmÃ©nÄ› chtÄ›li funkci, kterÃ¡ pÅ™ijme nÄ›jakÃ© hodnoty (parametry), vypoÄte nÄ›jakou hodnotu
a potÃ© ji vrÃ¡tÃ­. Toho mÅ¯Å¾eme dosÃ¡hnout tak, Å¾e funkci dÃ¡me nÃ¡vratovÃ½ typ jinÃ½ neÅ¾ <code>void</code> a potÃ©
ve funkci pouÅ¾ijeme pÅ™Ã­kaz <code>return &lt;vÃ½raz&gt;;</code>. PÅ™i provedenÃ­ tohoto vÃ½razu
se pÅ™estane funkce vykonÃ¡vat a jejÃ­ volÃ¡nÃ­ se vyhodnotÃ­ hodnotou pÅ™edanÃ©ho vÃ½razu. Zde je pÅ™Ã­klad
funkce, kterÃ¡ bere jako vstup jedno ÄÃ­slo a spoÄÃ­tÃ¡ jeho tÅ™etÃ­ mocninu:</p>
<pre><code class="language-c editable">#include &lt;stdio.h&gt;

int treti_mocnina(int cislo) {
   return cislo * cislo * cislo;
}
int main() {
   printf(&quot;%d\n&quot;, treti_mocnina(5 + 1));
   return 0;
}
</code></pre>
<blockquote>
<p>Jak probÃ­hÃ¡ vyhodnocovÃ¡nÃ­ funkcÃ­ si mÅ¯Å¾ete procviÄit <a href="c/funkce/../../ruzne/vyhodnocovani_vyrazu.html">zde</a>.</p>
</blockquote>
<p>PÅ™Ã­kazÅ¯ <code>return</code> mÅ¯Å¾e bÃ½t ve funkci vÃ­ce:</p>
<pre><code class="language-c">int absolutni_hodnota(int cislo) {
    if (cislo &gt;= 0) {
        return cislo;
    }
    return -cislo;
}
</code></pre>
<p>NicmÃ©nÄ› je dÅ¯leÅ¾itÃ© si uvÄ›domit, Å¾e po provedenÃ­ pÅ™Ã­kazu <code>return</code> uÅ¾ funkce dÃ¡le nebude pokraÄovat:</p>
<pre><code class="language-c">int zvetsi(int cislo) {
    return cislo + 1;
    printf(&quot;Provadi se funkce zvetsi\n&quot;); // tento Å™Ã¡dek se nikdy neprovede
}
</code></pre>
<blockquote>
<p>Pokud mÃ¡ funkce jakÃ½koliv jinÃ½ nÃ¡vratovÃ½ typ neÅ¾ <code>void</code>, tak v nÃ­ musÃ­ bÃ½t vÅ¾dy proveden pÅ™Ã­kaz
<code>return</code>! Pokud k tomu nedojde, tak program mÅ¯Å¾e zaÄÃ­t vykazovat <a href="c/funkce/../../ruzne/nedefinovane_chovani.html">nedefinovanÃ© chovÃ¡nÃ­</a>
ğŸ’£ a mÅ¯Å¾e se tak chovat nepÅ™edvÃ­datelnÄ›. NapÅ™Ã­klad nÃ¡sledujÃ­cÃ­ funkce je Å¡patnÄ›, protoÅ¾e pokud hodnota
parametru <code>cislo</code> bude nezÃ¡pornÃ¡, tak se ve funkci neprovede pÅ™Ã­kaz <code>return</code>:</p>
<pre><code class="language-c">int absolutni_hodnota(int cislo) {
    if (cislo &lt; 0) {
      return -cislo;
    }
}
</code></pre>
</blockquote>
<p>Pokud mÃ¡ funkce nÃ¡vratovÃ½ typ <code>void</code>, tak jejÃ­ provÃ¡dÄ›nÃ­ mÅ¯Å¾eme ukonÄit pomocÃ­ pÅ™Ã­kazu <code>return;</code>
(zde nepÅ™edÃ¡vÃ¡me Å¾Ã¡dnÃ½ vÃ½raz, protoÅ¾e funkce nic nevracÃ­).</p>
<h2><a class="header" href="#syntaxe" id="syntaxe">Syntaxe</a></h2>
<p>Syntaxe funkcÃ­ v <em>C</em> vypadÃ¡ takto:</p>
<pre><code class="language-c">&lt;datovÃ½ typ&gt; &lt;nÃ¡zev funkce&gt;(&lt;dat. typ par. 1&gt; &lt;nÃ¡zev par. 1&gt;, &lt;dat. typ par. 2&gt; &lt;nÃ¡zev par. 2&gt;, â€¦) {
    // blok kÃ³du
} 
</code></pre>
<p>DatovÃ©mu typu, nÃ¡zvu funkce a jejÃ­m parametrÅ¯m se dohromady Å™Ã­kÃ¡ <strong>signatura</strong> (<em>signature</em>) funkce.
Abychom vÄ›dÄ›li, jak s danou funkcÃ­ pracovat (jak ji volat), tak nÃ¡m staÄÃ­ znÃ¡t jejÃ­ signaturu,
nemusÃ­me nutnÃ© znÃ¡t obsah jejÃ­ho tÄ›la.<sup class='margin-toggle sidenote-number'>4</sup></p>
<span class='sidenote'><p><sup class='number'>4</sup>Tento fakt bude dÅ¯leÅ¾itÃ½ <a href="c/funkce/../modularizace/pouzivani_kodu_z_jinych_souboru.html#deklarace-vs-definice">pozdÄ›ji</a>.</p>
</span>
<h2><a class="header" href="#vÃ½hody-funkcÃ­" id="vÃ½hody-funkcÃ­">VÃ½hody funkcÃ­</a></h2>
<p>Zde je pro zopakovÃ¡nÃ­ uveden pÅ™ehled vÃ½hod pouÅ¾Ã­vÃ¡nÃ­ funkcÃ­:</p>
<ul>
<li><strong>ZnovupouÅ¾itelnost kÃ³du</strong> Pokud chcete stejnÃ½ kÃ³d pouÅ¾Ã­t na vÃ­ce mÃ­stech programu, nemusÃ­te ho
&quot;copy-pastovat&quot;. StaÄÃ­ ho vloÅ¾it do funkce a tu potÃ© opakovanÄ› volat.</li>
<li><strong>Parametrizace kÃ³du</strong> Pokud chcete spouÅ¡tÄ›t stejnÃ½ kÃ³d s rÅ¯znÃ½mi vstupnÃ­mi hodnotami, staÄÃ­ udÄ›lat
funkci, kterÃ¡ danÃ© hodnoty pÅ™ijme jako parametry (a pÅ™Ã­padnÄ› vrÃ¡tÃ­ vÃ½sledek vÃ½poÄtu jako svou
nÃ¡vratovou hodnotu).</li>
<li><strong>Abstrakce</strong> KdyÅ¾ rozdÄ›lÃ­te logiku programu do sady funkcÃ­, tak si znaÄnÄ› usnadnÃ­te pÅ™emÃ½Å¡lenÃ­ nad
celÃ½m programem. JednotlivÃ© funkce budete moct testovat a pÅ™emÃ½Å¡let nad nimi separÃ¡tnÄ›, nezÃ¡visle na
zbytku programu. PomocÃ­ pouÅ¾Ã­vÃ¡nÃ­ funkcÃ­ takÃ© bude mnohem pÅ™ehlednÄ›jÅ¡Ã­ ÄtenÃ­ programu, protoÅ¾e bude
staÄit ÄÃ­st, co se provÃ¡dÃ­ (kterÃ¡ funkce se volÃ¡) a ne jak se to provÃ¡dÃ­ (jakÃ© pÅ™Ã­kazy jsou v tÄ›le
funkce). TakovÃ½hle kÃ³d pak lze ÄÃ­st tÃ©mÄ›Å™ jako vÄ›tu v pÅ™irozenÃ©m jazyce:
<pre><code class="language-c">int zivot = vrat_zivoty_hrace(id_hrace);
zivot = zivot - vypocti_zraneni_prisery(id_prisery);
nastav_zivoty_hrace(id_hrace, zivot);
</code></pre>
</li>
<li><strong>SdÃ­lenÃ­ kÃ³du</strong> Pokud budete chtÃ­t pouÅ¾Ã­t kÃ³d, kterÃ½ napsal nÄ›kdo jinÃ½, tak toho mÅ¯Å¾ete dosÃ¡hnout
prÃ¡vÄ› pouÅ¾Ã­vÃ¡nÃ­m funkcÃ­, kterÃ© vÃ¡m nÄ›kdo <a href="c/funkce/../modularizace/knihovny.html">nasdÃ­lÃ­</a>.</li>
</ul>
<h2><a class="header" href="#umÃ­stÄ›nÃ­-funkcÃ­" id="umÃ­stÄ›nÃ­-funkcÃ­">UmÃ­stÄ›nÃ­ funkcÃ­</a></h2>
<p>Funkce v <em>C</em> musÃ­me psÃ¡t vÅ¾dy na nejvyÅ¡Å¡Ã­ Ãºrovni souboru. V <em>C</em> tedy napÅ™Ã­klad nenÃ­ moÅ¾nÃ© definovat
funkci uvnitÅ™ jinÃ© funkce:</p>
<pre><code class="language-c editable readonly">int main() {
    int test() { }
}
</code></pre>
<p>DÅ¯leÅ¾itÃ© je ale takÃ© to, kam pÅ™esnÄ› funkci ve zdrojovÃ©m kÃ³du umÃ­stÃ­te. Abyste mohli nÄ›jakou funkci
zavolat, tak jejÃ­ definice se musÃ­ v kÃ³du nachÃ¡zet nad Å™Ã¡dkem, kde funkci volÃ¡te. Tento kÃ³d tak nebude
fungovat:</p>
<pre><code class="language-c">int main() {
    vypis_text();
    return 0;
}
void vypis_text() {
    // ...
}
</code></pre>
<p>ProÄ tomu tak je, a jak lze toto pravidlo obejÃ­t, si Å™ekneme
<a href="c/funkce/../modularizace/pouzivani_kodu_z_jinych_souboru.html#deklarace-vs-definice">pozdÄ›ji</a>. </p>
<h2><a class="header" href="#proÄ-nÃ¡zev-funkce" id="proÄ-nÃ¡zev-funkce">ProÄ nÃ¡zev &quot;funkce&quot;?</a></h2>
<p>MoÅ¾nÃ¡ vÃ¡s napadlo, Å¾e nÃ¡zev funkce znÃ­ podobnÄ› jako <a href="https://matematika.cz/co-je-to-funkce">funkce</a>
v matematice. NenÃ­ to nÃ¡hoda, funkce v programech se tak opravdu dajÃ­ ÄÃ¡steÄnÄ› chÃ¡pat â€“ berou nÄ›jakÃ½
vstup (parametry) a vracejÃ­ vÃ½stup (nÃ¡vratovou hodnotu). NapÅ™Ã­klad nÃ¡sledujÃ­cÃ­ matematickou funkci:</p>
<p>\( f(x) = 2 * x \)</p>
<p>mÅ¯Å¾eme v <em>C</em> naprogramovat takto:</p>
<pre><code class="language-c">int f(int x) {
    return 2 * x;
}
</code></pre>
<p>Aby ale funkce v <em>C</em> splÅˆovala poÅ¾adavky matematickÃ© funkce, musÃ­ bÃ½t splnÄ›no nÄ›kolik podmÃ­nek:</p>
<ul>
<li>Funkce nesmÃ­ mÃ­t Å¾Ã¡dnÃ© <a href="c/funkce/../prikazy_vyrazy.html#vedlej%C5%A1%C3%AD-efekty">vedlejÅ¡Ã­ efekty</a>. To znamenÃ¡, Å¾e by
mÄ›la pouze provÃ©st vÃ½poÄet na zÃ¡kladÄ› vstupnÃ­ch parametrÅ¯ a vrÃ¡tit vypoÄtenou hodnotu. NemÄ›la by
ÄÃ­st ani modifikovat <a href="c/funkce/../promenne/globalni_promenne.html">globÃ¡lnÃ­ promÄ›nnÃ©</a> nebo napÅ™Ã­klad pracovat
se soubory na disku Äi komunikovat po sÃ­ti.</li>
<li>Funkce musÃ­ mÃ­t nÃ¡vratovÃ½ typ jinÃ½ neÅ¾ <code>void</code>, aby vracela nÄ›jakou hodnotu. Z toho takÃ© vyplÃ½vÃ¡,
Å¾e funkce s nÃ¡vratovÃ½m typem <code>void</code> by mÄ›la mÃ­t nÄ›jakÃ© vedlejÅ¡Ã­ efekty, jinak by totiÅ¾ nemÄ›lo
smysl ji volat (protoÅ¾e nic nevracÃ­).</li>
<li>Pokud je funkce zavolÃ¡na se stejnÃ½mi hodnotami parametrÅ¯, musÃ­ vÅ¾dy vrÃ¡tit stejnou nÃ¡vratovou
hodnotu. TÃ©to vlastnosti se Å™Ã­kÃ¡ <em>idempotence</em>. JelikoÅ¾ jsou poÄÃ­taÄe deterministickÃ©, tato
vlastnost by mÄ›la bÃ½t triviÃ¡lnÄ› splnÄ›na, pokud funkce neobsahuje Å¾Ã¡dnÃ© vedlejÅ¡Ã­ efekty.</li>
</ul>
<p>Funkce splÅˆujÃ­cÃ­ tyto vlastnosti se nazÃ½vajÃ­ <em>ÄistÃ©</em> (<em>pure</em>). S takovÃ½mito funkcemi je jednoduÅ¡Å¡Ã­
pracovat a pÅ™emÃ½Å¡let nad tÃ­m, co dÄ›lajÃ­, protoÅ¾e si mÅ¯Å¾eme bÃ½t jistÃ­, Å¾e nemodifikujÃ­ okolnÃ­ stav
programu a pouze spoÄÃ­tajÃ­ vÃ½sledek v zÃ¡vislosti na svÃ½ch parametrech. Pokud to tedy jde, snaÅ¾te se
funkce psÃ¡t tÃ­mto stylem (samozÅ™ejmÄ› ne vÅ¾dy je to moÅ¾nÃ©).</p>
<p>V pÅ™edmÄ›tu
<a href="http://behalek.cs.vsb.cz/wiki/index.php/Functional_programming/cs">FunkcionÃ¡lnÃ­ programovÃ¡nÃ­</a>
budete pracovat s funkcionÃ¡lnÃ­mi programovacÃ­mi jazyky, ve kterÃ½ch je prÃ¡vÄ› vÄ›tÅ¡ina funkcÃ­ ÄistÃ½ch.</p>
<hr />
<p><strong>KvÃ­z</strong> ğŸ¤”</p>
<ol>
<li>
<p>Co vypÃ­Å¡e nÃ¡sledujÃ­cÃ­ program?</p>
<pre><code class="language-c editable">#include &lt;stdio.h&gt;

void zmen_cislo(int cislo) {
    cislo = 5;
}

int main() {
    int cislo = 8;
    zmen_cislo(cislo);
    printf(&quot;%d\n&quot;, cislo);

    return 0;
}
</code></pre>
<details>
 <summary>OdpovÄ›Ä</summary>
<p>Program vypÃ­Å¡e <code>8</code>. PÅ™i volÃ¡nÃ­ <code>zmen_cislo</code> se uvnitÅ™ tÃ©to funkce vytvoÅ™Ã­ novÃ¡ lokÃ¡lnÃ­ promÄ›nnÃ¡
pro parametr <code>cislo</code> a uloÅ¾Ã­ se do nÃ­ hodnota z odpovÃ­dajÃ­cÃ­ho pÅ™edanÃ©ho argumentu. ZmÄ›na hodnoty
tohoto parametru uvnitÅ™ <code>zmen_cislo</code> nijak neovlivnÃ­ promÄ›nnou <code>cislo</code> uvnitÅ™ funkce <code>main</code>.</p>
<p>MÅ¯Å¾ete si to pÅ™edstavit tak, Å¾e se pÅ™i zavolÃ¡nÃ­ tÃ©to funkce provedl cca takovÃ½to kÃ³d:</p>
<pre><code class="language-c">{
  // nastavenÃ­ parametru
  int cislo = 8;

  // kÃ³d funkce
  cislo = 5;
}
</code></pre>
<p>To, Å¾e se zde parametr jmenuje stejnÄ› jako promÄ›nnÃ¡, kterou pÅ™edÃ¡vÃ¡me jako argument, nemÃ¡ Å¾Ã¡dnÃ½
speciÃ¡lnÃ­ vÃ½znam. Funkci jsme mohli klidnÄ› zavolat napÅ™. takto: <code>zmen_cislo(1 + 9)</code>. Z toho je zÅ™ejmÃ©,
Å¾e zmÄ›na hodnoty parametru nijak neovlivnÃ­ pÅ™edanÃ½ argument.</p>
<blockquote>
<p>Mimochodem, tÃ­m, Å¾e <code>zmen_cislo</code> nic nevracÃ­ a nemÃ¡ Å¾Ã¡dnÃ½ vedlejÅ¡Ã­ efekt, tak v podstatÄ› ani nemÃ¡
Å¾Ã¡dnÃ½ smysl. Je to pouze ukÃ¡zka.</p>
</blockquote>
</details>
</li>
<li>
<p>Co vypÃ­Å¡e nÃ¡sledujÃ­cÃ­ program?</p>
<pre><code class="language-c editable">#include &lt;stdio.h&gt;

void vytvor_promennou() {
    int x = 5;
}

int main() {
    vytvor_promennou();
    printf(&quot;%d\n&quot;, x);

    return 0;
}
</code></pre>
<details>
 <summary>OdpovÄ›Ä</summary>
<p>Tento program se nepÅ™eloÅ¾Ã­, protoÅ¾e uvnitÅ™ funkce <code>main</code> neexistuje promÄ›nnÃ¡ s nÃ¡zvem <code>x</code>.
LokÃ¡lnÃ­ promÄ›nnÃ© jsou dostupnÃ© pouze v rÃ¡mci <a href="c/funkce/../promenne/promenne.html#platnost">bloku</a>, ve kterÃ©m
byly nadefinovÃ¡ny. PromÄ›nnou <code>x</code> tak lze pouÅ¾Ã­t pouze v kÃ³du uvnitÅ™ funkce <code>vytvor_promennou</code>.</p>
</details>
</li>
<li>
<p>Co vypÃ­Å¡e nÃ¡sledujÃ­cÃ­ program?</p>
<pre><code class="language-c editable">#include &lt;stdio.h&gt;

void vypis_soucet(int x) {
    int soucet = x + b;
    printf(&quot;%d\n&quot;, soucet);
}

int main() {
    int a = 5;
    int b = 8;

    vypis_soucet(a);

    return 0;
}
</code></pre>
<details>
 <summary>OdpovÄ›Ä</summary>
<p>Tento program se nepÅ™eloÅ¾Ã­, protoÅ¾e uvnitÅ™ funkce <code>vypis_soucet</code> neexistuje promÄ›nnÃ¡ s nÃ¡zvem
<code>b</code>. Na Å™Ã¡dku, kde funkci volÃ¡me, sice existuje promÄ›nnÃ¡ <code>b</code> uvnitÅ™ funkce <code>main</code>, ale to s tÃ­m 
nijak nesouvisÃ­ - co kdybychom <code>vypis_soucet</code> volali z nÄ›jakÃ©ho jinÃ©ho mÃ­sta programu, kde
by Å¾Ã¡dnÃ¡ promÄ›nnÃ¡ <code>b</code> neexistovala? Funkce mÃ¡ pÅ™Ã­stup pouze ke svÃ½m lokÃ¡lnÃ­m promÄ›nnÃ½m a parametrÅ¯m
(pÅ™Ã­padnÄ› takÃ© jeÅ¡tÄ› ke <a href="c/funkce/../promenne/globalni_promenne.html">globÃ¡lnÃ­m</a> promÄ›nnÃ½m). Pokud chceme
nÄ›jakou hodnotu z jednÃ© funkce pouÅ¾Ã­t v jinÃ© funkci, musÃ­me ji pÅ™edat jako parametr:</p>
<pre><code class="language-c">void vypis_soucet(int x, int b) {
    int soucet = x + b;
    printf(&quot;%d\n&quot;, soucet);
}

int main() {
    int a = 5;
    int b = 8;

    vypis_soucet(a, b);

    return 0;
}
</code></pre>
</details>
</li>
<li>
<p>Co vypÃ­Å¡e nÃ¡sledujÃ­cÃ­ program?</p>
<pre><code class="language-c editable">#include &lt;stdio.h&gt;

int vrat_cislo(int x) {
    return x;
}

int main() {
    int cislo = 5;
    vrat_cislo(cislo) = 8;
    printf(&quot;%d\n&quot;, cislo);

    return 0;
}
</code></pre>
<details>
 <summary>OdpovÄ›Ä</summary>
<p>Tento program se nepÅ™eloÅ¾Ã­, protoÅ¾e se snaÅ¾Ã­me provÃ©st operaci pÅ™iÅ™azenÃ­ (<code>=</code>), ale na levÃ© stranÄ›
od rovnÃ­tka nenÃ­ mÃ­sto v pamÄ›ti (napÅ™. promÄ›nnÃ¡), do kterÃ© bychom mohli hodnotu <code>8</code> zapsat.
VolÃ¡nÃ­ funkce je vÃ½raz, kterÃ½ se vyhodnotÃ­ jako nÃ¡vratovÃ¡ hodnota, kterou tato funkce vrÃ¡tÃ­.
Je to jako bychom napsali toto:</p>
<pre><code class="language-c">5 = 8;
</code></pre>
<p>CoÅ¾ zÅ™ejmÄ› nedÃ¡vÃ¡ smysl, a proto se program nepÅ™eloÅ¾Ã­.</p>
</details>
</li>
<li>
<p>Co vypÃ­Å¡e nÃ¡sledujÃ­cÃ­ program?</p>
<pre><code class="language-c editable">#include &lt;stdio.h&gt;

int umocni(int x) {
    return x * x;
}

int main() {
    int cislo = 5;
    umocni(cislo);
    printf(&quot;%d\n&quot;, cislo);

    return 0;
}
</code></pre>
<details>
 <summary>OdpovÄ›Ä</summary>
<p>Program vypÃ­Å¡e <code>5</code>. VolÃ¡nÃ­ funkce <code>umocni</code> sice vrÃ¡tÃ­ hodnotu <code>25</code>, ale tato hodnota se okamÅ¾itÄ›
&quot;zahodÃ­&quot;, protoÅ¾e ji nikam neuloÅ¾Ã­me. Hodnota promÄ›nnÃ© <code>cislo</code> se tak nezmÄ›nÃ­. Aby program vypsal
<code>25</code>, tak bychom museli nÃ¡vratovou hodnotu z volÃ¡nÃ­ funkce uloÅ¾it zpÄ›t do promÄ›nnÃ© <code>cislo</code>:</p>
<pre><code class="language-c">cislo = umocni(cislo);
</code></pre>
</details>
</li>
<li>
<p>Co vypÃ­Å¡e nÃ¡sledujÃ­cÃ­ program?</p>
<pre><code class="language-c editable">#include &lt;stdio.h&gt;

void vypis_cislo(int x) {
    if (x &lt; 0) {
        return;
    }
    printf(&quot;cislo = %d\n&quot;, x);
}

int main() {
    vypis_cislo(1);
    vypis_cislo(-1);

    return 0;
}
</code></pre>
<details>
 <summary>OdpovÄ›Ä</summary>
<p>Program vypÃ­Å¡e <code>cislo = 1</code>. PÅ™i volÃ¡nÃ­ <code>vypis_cislo(-1)</code> bude splnÄ›na podmÃ­nka uvnitÅ™ <code>vypis_cislo</code>,
takÅ¾e dojde k ukonÄenÃ­ provÃ¡dÄ›nÃ­ funkce pÅ™Ã­kazem <code>return;</code> a nedojde tak k vypsÃ¡nÃ­ tohoto
zÃ¡pornÃ©ho ÄÃ­sla.</p>
</details>
</li>
<li>
<p>Co vypÃ­Å¡e nÃ¡sledujÃ­cÃ­ program?</p>
<pre><code class="language-c editable">#include &lt;stdio.h&gt;

int vypocet(int x) {
    if (x &gt; 5) {
        return x + 1;
    }
    return x * 2;
}

int main() {
    int a = 6;
    int b = 4;
    int c = vypocet(vypocet(a) + vypocet(b));
    printf(&quot;%d\n&quot;, c);

    return 0;
}
</code></pre>
<details>
 <summary>OdpovÄ›Ä</summary>
<p>Program vypÃ­Å¡e <code>16</code>. NenÃ­ zde Å¾Ã¡dnÃ¡ zrada :) Nejprve se vyhodnotÃ­ <code>vypocet(a)</code> na <code>7</code>, potÃ©
<code>vypocet(b)</code> na <code>8</code>, a potÃ© se zavolÃ¡ <code>vypocet(7 + 8)</code>, kterÃ½ se vyhodnotÃ­ na <code>16</code>. VyhodnocovÃ¡nÃ­
vÃ½razÅ¯ a volÃ¡nÃ­ funkcÃ­ si mÅ¯Å¾ete procviÄit <a href="c/funkce/../../ruzne/vyhodnocovani_vyrazu.html">zde</a>.</p>
</details>
</li>
<li>
<p>Co vypÃ­Å¡e nÃ¡sledujÃ­cÃ­ program?</p>
<pre><code class="language-c editable">#include &lt;stdio.h&gt;

int cislo = 1;

void uprav_promennou() {
    cislo = 2;
}

int main() {
    printf(&quot;%d\n&quot;, cislo);
    uprav_promennou();
    printf(&quot;%d\n&quot;, cislo);

    return 0;
}
</code></pre>
<details>
 <summary>OdpovÄ›Ä</summary>
<p>Program vypÃ­Å¡e:</p>
<pre><code>1
2
</code></pre>
<p>JelikoÅ¾ je promÄ›nnÃ¡ <code>cislo</code> globÃ¡lnÃ­, tak k nÃ­ majÃ­ pÅ™Ã­stup funkce <code>uprav_promennou</code> i <code>main</code>.
ZmÄ›na tÃ©to promÄ›nnÃ© ve funkci <code>uprav_promennou</code> se tedy promÃ­tne, kdyÅ¾ budeme ÄÃ­st hodnotu tÃ©to
promÄ›nnÃ© ve funkci <code>main</code>.</p>
</details>
</li>
</ol>
<h1><a class="header" href="#rekurze" id="rekurze">Rekurze</a></h1>
<blockquote>
<p>ğŸ¤“ Tato sekce obsahuje doplÅˆujÃ­cÃ­ uÄivo. Pokud je toho na vÃ¡s moc, mÅ¯Å¾ete ji prozatÃ­m pÅ™eskoÄit
a vrÃ¡tit se k nÃ­ pozdÄ›ji.</p>
</blockquote>
<p>Pokud funkce obsahuje volÃ¡nÃ­ sama sebe, tak tuto situaci nazÃ½vÃ¡me <strong>rekurzÃ­</strong> (<em>recursion</em>).
Pro Å™eÅ¡enÃ­ nÄ›kterÃ½ch problÃ©mÅ¯ mÅ¯Å¾e bÃ½t pÅ™irozenÃ© rozdÄ›lovat je na ÄÃ­m dÃ¡l tÃ­m menÅ¡Ã­ podproblÃ©my,
dokud se nedostaneme k podproblÃ©mu, kterÃ½ je dostateÄnÄ› jednoduchÃ½, abychom ho vyÅ™eÅ¡ili rovnou.
Toto mÅ¯Å¾eme modelovat prÃ¡vÄ› rekurzÃ­, kdy volÃ¡me stejnou funkci s rÅ¯znÃ½mi argumenty, dokud se
nedostaneme k hodnotÃ¡m, pro kterÃ© umÃ­me problÃ©m vyÅ™eÅ¡it jednoduÅ¡e, a v ten moment rekurzi ukonÄÃ­me.</p>
<p>JednÃ­m z jednoduchÃ½ch problÃ©mÅ¯, na kterÃ©m mÅ¯Å¾eme rekurzi demonstrovat, je vÃ½poÄet
<a href="https://cs.wikipedia.org/wiki/Faktori%C3%A1l">faktoriÃ¡lu</a>. FaktoriÃ¡l lze nadefinovat napÅ™Ã­klad takto:</p>
<p>\(n! = n * (n - 1)!\)</p>
<p>VidÃ­me, Å¾e tato samotnÃ¡ definice je &quot;rekurzivnÃ­&quot;: pro vÃ½poÄet faktoriÃ¡lu <code>n</code> musÃ­me znÃ¡t hodnotu
faktoriÃ¡lu <code>n - 1</code>. VÃ½poÄet faktoriÃ¡lu mÅ¯Å¾eme provÃ©st napÅ™Ã­klad nÃ¡sledujÃ­cÃ­ funkcÃ­:</p>
<pre><code class="language-c">int faktorial(int n) {
    if (n &lt;= 1) return 1;
    return n * faktorial(n - 1);
}
</code></pre>
<p>Pokud je parametr <code>n</code> menÅ¡Ã­ neÅ¾ <code>1</code>, umÃ­me faktoriÃ¡l vypoÄÃ­tat triviÃ¡lnÄ›. Pokud ne, tak spoÄteme
faktoriÃ¡l <code>n - 1</code> a vynÃ¡sobÃ­me ho hodnotou <code>n</code>. Je dÅ¯leÅ¾itÃ© si uvÄ›domit, v jakÃ©m poÅ™adÃ­ zde probÃ­hÃ¡
vÃ½poÄet. NapÅ™Ã­klad pÅ™i volÃ¡nÃ­ <code>factorial(4)</code>:</p>
<ol>
<li>ZavolÃ¡ se <code>factorial(4)</code>.</li>
<li><code>factorial(4)</code> zavolÃ¡ <code>factorial(3)</code>.</li>
<li><code>factorial(3)</code> zavolÃ¡ <code>factorial(2)</code>.</li>
<li><code>factorial(2)</code> zavolÃ¡ <code>factorial(1)</code>.</li>
<li><code>factorial(1)</code> vrÃ¡tÃ­ <code>1</code>.</li>
<li><code>factorial(2)</code> vrÃ¡tÃ­ <code>2 * 1</code>.</li>
<li><code>factorial(3)</code> vrÃ¡tÃ­ <code>3 * 2 * 1</code>.</li>
<li><code>factorial(4)</code> vrÃ¡tÃ­ <code>4 * 3 * 2 * 1</code>.</li>
</ol>
<p>Nejprve tak dojde k vypoÄtenÃ­ <code>factorial(1)</code>, potÃ© <code>factorial(2)</code> atd. VÃ½poÄet je tak v jistÃ©m
smyslu &quot;otoÄen&quot;. Zkuste si vÃ½poÄet faktoriÃ¡lu <a href="c/funkce/../../prostredi/ladeni.html#krokov%C3%A1n%C3%AD">odkrokovat</a>, abyste
si ujasnili, jak vÃ½poÄet probÃ­hÃ¡.</p>
<h2><a class="header" href="#pÅ™eteÄenÃ­-zÃ¡sobnÃ­ku" id="pÅ™eteÄenÃ­-zÃ¡sobnÃ­ku">PÅ™eteÄenÃ­ zÃ¡sobnÃ­ku</a></h2>
<p>Je dÅ¯leÅ¾itÃ© dÃ¡vat si pozor na to, abychom vÅ¾dy ve funkci mÄ›li podmÃ­nku, kterÃ¡ rekurzi ukonÄÃ­.
Jinak by se funkce volala &quot;donekoneÄna&quot;, dokud by nakonec nedoÅ¡lo k
<a href="c/funkce/../../caste_chyby/pametove_chyby.html#stack-overflow">pÅ™eteÄenÃ­ zÃ¡sobnÃ­ku</a>.</p>
<h1><a class="header" href="#funkce-standardnÃ­-knihovny" id="funkce-standardnÃ­-knihovny">Funkce standardnÃ­ knihovny</a></h1>
<p>KdyÅ¾ uÅ¾ nynÃ­ vÃ­me, co jsou to <a href="c/funkce/funkce.html">funkce</a>, tak si mÅ¯Å¾eme vysvÄ›tlit, odkud
se berou nÄ›kterÃ© funkce, kterÃ© jsme doposud pouÅ¾Ã­vali, i kdyÅ¾ jsme je sami nenapsali.</p>
<p>NapÅ™Ã­klad vÃ½raz <code>printf(&quot;â€¦&quot;)</code> je volÃ¡nÃ­ funkce s nÃ¡zvem <code>printf</code>. Tato funkce pochÃ¡zÃ­ ze
<strong>standardnÃ­ knihovny C</strong> (<em>C standard library</em>). JednÃ¡ se o sadu uÅ¾iteÄnÃ½ch funkcÃ­, kterÃ© jsou tak
Äasto vyuÅ¾Ã­vanÃ©, Å¾e jsou implicitnÄ› pÅ™ekladaÄem pÅ™idÃ¡ny k vaÅ¡emu programu, abyste je mohli jednoduÅ¡e
vyuÅ¾Ã­vat a nemuseli ztrÃ¡cet Äas jejich psanÃ­m v kaÅ¾dÃ©m programu od nuly.</p>
<p>Tyto funkce se starajÃ­ napÅ™Ã­klad o nÃ¡sledujÃ­cÃ­ oblasti:</p>
<ul>
<li>ÄŒtenÃ­ ze vstupu programu a zÃ¡pis na vÃ½stup programu (napÅ™Ã­klad funkce <code>printf</code>)</li>
<li><a href="c/funkce/../prace_s_pameti/dynamicka_pamet.html">DynamickÃ¡ alokace</a> pamÄ›ti</li>
<li>ÄŒtenÃ­ a zÃ¡pis <a href="c/funkce/../soubory/soubory.html">souborÅ¯</a> na disku</li>
<li><a href="c/funkce/../../ruzne/nahodna_cisla.html">GenerovÃ¡nÃ­ nÃ¡hodnÃ½ch ÄÃ­sel</a></li>
<li><a href="c/funkce/../text/text.html">PrÃ¡ce s textem</a></li>
<li><a href="https://devdocs.io/c/chrono">PrÃ¡ce s Äasem a datem</a></li>
</ul>
<p>a mnoho dalÅ¡Ã­ch.</p>
<p>Abychom mohli tyto funkce pouÅ¾Ã­vat, potÅ™ebujeme do naÅ¡ich programÅ¯ vloÅ¾it kÃ³d, kterÃ½ obsahuje
signatury tÄ›chto funkcÃ­. Toho dosÃ¡hneme pomocÃ­ pouÅ¾itÃ­ <a href="c/funkce/../preprocesor/preprocesor.html">preprocesoru</a>
â€“ zde se dozvÃ­te, jak funguje pÅ™Ã­kaz <code>#include &lt;â€¦&gt;</code>, kterÃ½ jsme doposud pouÅ¾Ã­vali jako &quot;black box&quot;.</p>
<p>Seznam funkcÃ­ dostupnÃ½ch v standardnÃ­ knihovnÄ› mÅ¯Å¾ete naleznout napÅ™Ã­klad
<a href="https://devdocs.io/c/">zde</a>.</p>
<p>Jak je standardnÃ­ knihovna <em>C</em> pÅ™ipojena k vaÅ¡im programÅ¯m a jak si vytvoÅ™it vlastnÃ­ knihovnu se
dozvÃ­me pozdÄ›ji v sekci o <a href="c/funkce/../modularizace/knihovny.html">knihovnÃ¡ch</a>.</p>
<h1><a class="header" href="#preprocesor" id="preprocesor">Preprocesor</a></h1>
<p>NeÅ¾ je vÃ¡Å¡ zdrojovÃ½ soubor pÅ™eloÅ¾en na strojovÃ© instrukce, tak jej
<a href="c/preprocesor/../../prostredi/preklad_programu.html">pÅ™ekladaÄ</a> nejprve proÅ¾ene tzv. <strong>preprocesorem</strong>
(<em>preprocessor</em>). Tento program nedÄ›lÃ¡ nic jinÃ©ho, neÅ¾ Å¾e projde vÃ¡Å¡ zdrojovÃ½ kÃ³d a zpracuje Å™Ã¡dky
se speciÃ¡lnÃ­mi pÅ™Ã­kazy zaÄÃ­najÃ­cÃ­mi na <code>#</code>.</p>
<p>UkÃ¡Å¾eme si dva typy pÅ™Ã­kazÅ¯, kterÃ© preprocesor umÃ­ zpracovÃ¡vat:</p>
<ul>
<li><a href="c/preprocesor/vkladani_souboru.html">VklÃ¡dÃ¡nÃ­ souborÅ¯</a> do vaÅ¡eho kÃ³du (<code>#include</code>)</li>
<li>VytvÃ¡Å™enÃ­ <a href="c/preprocesor/makra.html">maker</a> (<code>#define</code>)</li>
</ul>
<p>Pokud si chcete ovÄ›Å™it, jak vypadÃ¡ vÃ¡Å¡ zdrojovÃ½ soubor potÃ©, co jej zpracuje preprocesor, ale pÅ™edtÃ­m,
neÅ¾ je pÅ™eloÅ¾en na strojovÃ© instrukce, mÅ¯Å¾ete k tomu pouÅ¾Ã­t tento pÅ™Ã­kaz<sup class='margin-toggle sidenote-number'>1</sup>:</p>
<span class='sidenote'><p><sup class='number'>1</sup>MÃ­sto <code>main.c</code> doplÅˆte nÃ¡zev zdrojovÃ©ho souboru, kterÃ½ chcete zpracovat preprocesorem.</p>
</span>
<pre><code class="language-bash">$ gcc -P -E main.c
</code></pre>
<h1><a class="header" href="#vklÃ¡dÃ¡nÃ­-souborÅ¯" id="vklÃ¡dÃ¡nÃ­-souborÅ¯">VklÃ¡dÃ¡nÃ­ souborÅ¯</a></h1>
<p>PÅ™Ã­kaz <code>#include</code> slouÅ¾Ã­ ke vloÅ¾enÃ­ obsahu jinÃ©ho souboru do vaÅ¡eho zdrojovÃ©ho kÃ³du. Tento pÅ™Ã­kaz
existuje ve dvou variantÃ¡ch:</p>
<pre><code class="language-c">#include &lt;cesta k souboru&gt;
#include &quot;cesta k souboru&quot;
</code></pre>
<p>RozdÃ­l mezi nimi je popsÃ¡n <a href="c/preprocesor/vkladani_souboru.html#rozd%C3%ADl-mezi-include--a-include-">nÃ­Å¾e</a>.</p>
<p>Jakmile preprocesor narazÃ­ na tento pÅ™Ã­kaz, tak se pokusÃ­ najÃ­t soubor na uvedenÃ© cestÄ›, zpracuje
jeho obsah (tj. vyhodnotÃ­ pÅ™Ã­padnÃ© dalÅ¡Ã­ pÅ™Ã­kazy jako <code>#include</code>, kterÃ© v nÄ›m mohou bÃ½t) a potÃ© jeho
obsah vloÅ¾Ã­ na mÃ­sto, kde je <code>#include</code> pouÅ¾it. JednÃ¡ se o prostÃ© textovÃ© nahrazenÃ­ (<code>Ctrl+C -&gt; Ctrl+V</code>).</p>
<p>Tento pÅ™Ã­kaz slouÅ¾Ã­ k tomu, abychom mohli pouÅ¾Ã­vat stejnÃ½ kÃ³d ve vÃ­ce souborech bez toho, abychom
jej museli neustÃ¡le ruÄnÄ› kopÃ­rovat. ProzatÃ­m budeme vklÃ¡dat do naÅ¡eho kÃ³du zejmÃ©na soubory
obsahujÃ­cÃ­ rÅ¯znÃ© funkce <a href="c/preprocesor/../funkce/stdlib.html">standardnÃ­ knihovny <em>C</em></a>. PozdÄ›ji si ukÃ¡Å¾eme, jak
vytvoÅ™it vlastnÃ­ soubory, kterÃ© lze vklÃ¡dat, a vytvÃ¡Å™et tak <em>C</em> programy sestÃ¡vajÃ­cÃ­ se z
<a href="c/preprocesor/../modularizace/modularizace.html">vÃ­ce zdrojovÃ½ch souborÅ¯</a>.</p>
<p>Zkuste si napÅ™Ã­klad tento zdrojovÃ½ soubor pojmenovat jako <code>main.c</code> a pomocÃ­ pÅ™Ã­kazu <code>gcc -P -E main.c</code>
v terminÃ¡lu zjistit, jak vypadÃ¡ potÃ©, co na nÄ›j byl aplikovÃ¡n preprocesor:</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int main() {
    printf(&quot;Hello world\n&quot;);
    return 0;
}
</code></pre>
<details>
<summary>VÃ½stup mÅ¯Å¾e vypadat napÅ™Ã­klad takto</summary>
<pre><code class="language-c">typedef long unsigned int size_t;
typedef __builtin_va_list __gnuc_va_list;
typedef unsigned char __u_char;
typedef unsigned short int __u_short;
typedef unsigned int __u_int;
typedef unsigned long int __u_long;
typedef signed char __int8_t;
typedef unsigned char __uint8_t;
typedef signed short int __int16_t;
typedef unsigned short int __uint16_t;
typedef signed int __int32_t;
typedef unsigned int __uint32_t;
typedef signed long int __int64_t;
typedef unsigned long int __uint64_t;
typedef __int8_t __int_least8_t;
typedef __uint8_t __uint_least8_t;
typedef __int16_t __int_least16_t;
typedef __uint16_t __uint_least16_t;
typedef __int32_t __int_least32_t;
typedef __uint32_t __uint_least32_t;
typedef __int64_t __int_least64_t;
typedef __uint64_t __uint_least64_t;
typedef long int __quad_t;
typedef unsigned long int __u_quad_t;
typedef long int __intmax_t;
typedef unsigned long int __uintmax_t;
typedef unsigned long int __dev_t;
typedef unsigned int __uid_t;
typedef unsigned int __gid_t;
typedef unsigned long int __ino_t;
typedef unsigned long int __ino64_t;
typedef unsigned int __mode_t;
typedef unsigned long int __nlink_t;
typedef long int __off_t;
typedef long int __off64_t;
typedef int __pid_t;
typedef struct { int __val[2]; } __fsid_t;
typedef long int __clock_t;
typedef unsigned long int __rlim_t;
typedef unsigned long int __rlim64_t;
typedef unsigned int __id_t;
typedef long int __time_t;
typedef unsigned int __useconds_t;
typedef long int __suseconds_t;
typedef long int __suseconds64_t;
typedef int __daddr_t;
typedef int __key_t;
typedef int __clockid_t;
typedef void * __timer_t;
typedef long int __blksize_t;
typedef long int __blkcnt_t;
typedef long int __blkcnt64_t;
typedef unsigned long int __fsblkcnt_t;
typedef unsigned long int __fsblkcnt64_t;
typedef unsigned long int __fsfilcnt_t;
typedef unsigned long int __fsfilcnt64_t;
typedef long int __fsword_t;
typedef long int __ssize_t;
typedef long int __syscall_slong_t;
typedef unsigned long int __syscall_ulong_t;
typedef __off64_t __loff_t;
typedef char *__caddr_t;
typedef long int __intptr_t;
typedef unsigned int __socklen_t;
typedef int __sig_atomic_t;
typedef struct
{
  int __count;
  union
  {
    unsigned int __wch;
    char __wchb[4];
  } __value;
} __mbstate_t;
typedef struct _G_fpos_t
{
  __off_t __pos;
  __mbstate_t __state;
} __fpos_t;
typedef struct _G_fpos64_t
{
  __off64_t __pos;
  __mbstate_t __state;
} __fpos64_t;
struct _IO_FILE;
typedef struct _IO_FILE __FILE;
struct _IO_FILE;
typedef struct _IO_FILE FILE;
struct _IO_FILE;
struct _IO_marker;
struct _IO_codecvt;
struct _IO_wide_data;
typedef void _IO_lock_t;
struct _IO_FILE
{
  int _flags;
  char *_IO_read_ptr;
  char *_IO_read_end;
  char *_IO_read_base;
  char *_IO_write_base;
  char *_IO_write_ptr;
  char *_IO_write_end;
  char *_IO_buf_base;
  char *_IO_buf_end;
  char *_IO_save_base;
  char *_IO_backup_base;
  char *_IO_save_end;
  struct _IO_marker *_markers;
  struct _IO_FILE *_chain;
  int _fileno;
  int _flags2;
  __off_t _old_offset;
  unsigned short _cur_column;
  signed char _vtable_offset;
  char _shortbuf[1];
  _IO_lock_t *_lock;
  __off64_t _offset;
  struct _IO_codecvt *_codecvt;
  struct _IO_wide_data *_wide_data;
  struct _IO_FILE *_freeres_list;
  void *_freeres_buf;
  size_t __pad5;
  int _mode;
  char _unused2[15 * sizeof (int) - 4 * sizeof (void *) - sizeof (size_t)];
};
typedef __gnuc_va_list va_list;
typedef __off_t off_t;
typedef __ssize_t ssize_t;
typedef __fpos_t fpos_t;
extern FILE *stdin;
extern FILE *stdout;
extern FILE *stderr;
extern int remove (const char *__filename) __attribute__ ((__nothrow__ , __leaf__));
extern int rename (const char *__old, const char *__new) __attribute__ ((__nothrow__ , __leaf__));
extern int renameat (int __oldfd, const char *__old, int __newfd,
       const char *__new) __attribute__ ((__nothrow__ , __leaf__));
extern FILE *tmpfile (void) ;
extern char *tmpnam (char *__s) __attribute__ ((__nothrow__ , __leaf__)) ;
extern char *tmpnam_r (char *__s) __attribute__ ((__nothrow__ , __leaf__)) ;
extern char *tempnam (const char *__dir, const char *__pfx)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__malloc__)) ;
extern int fclose (FILE *__stream);
extern int fflush (FILE *__stream);
extern int fflush_unlocked (FILE *__stream);
extern FILE *fopen (const char *__restrict __filename,
      const char *__restrict __modes) ;
extern FILE *freopen (const char *__restrict __filename,
        const char *__restrict __modes,
        FILE *__restrict __stream) ;
extern FILE *fdopen (int __fd, const char *__modes) __attribute__ ((__nothrow__ , __leaf__)) ;
extern FILE *fmemopen (void *__s, size_t __len, const char *__modes)
  __attribute__ ((__nothrow__ , __leaf__)) ;
extern FILE *open_memstream (char **__bufloc, size_t *__sizeloc) __attribute__ ((__nothrow__ , __leaf__)) ;
extern void setbuf (FILE *__restrict __stream, char *__restrict __buf) __attribute__ ((__nothrow__ , __leaf__));
extern int setvbuf (FILE *__restrict __stream, char *__restrict __buf,
      int __modes, size_t __n) __attribute__ ((__nothrow__ , __leaf__));
extern void setbuffer (FILE *__restrict __stream, char *__restrict __buf,
         size_t __size) __attribute__ ((__nothrow__ , __leaf__));
extern void setlinebuf (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__));
extern int fprintf (FILE *__restrict __stream,
      const char *__restrict __format, ...);
extern int printf (const char *__restrict __format, ...);
extern int sprintf (char *__restrict __s,
      const char *__restrict __format, ...) __attribute__ ((__nothrow__));
extern int vfprintf (FILE *__restrict __s, const char *__restrict __format,
       __gnuc_va_list __arg);
extern int vprintf (const char *__restrict __format, __gnuc_va_list __arg);
extern int vsprintf (char *__restrict __s, const char *__restrict __format,
       __gnuc_va_list __arg) __attribute__ ((__nothrow__));
extern int snprintf (char *__restrict __s, size_t __maxlen,
       const char *__restrict __format, ...)
     __attribute__ ((__nothrow__)) __attribute__ ((__format__ (__printf__, 3, 4)));
extern int vsnprintf (char *__restrict __s, size_t __maxlen,
        const char *__restrict __format, __gnuc_va_list __arg)
     __attribute__ ((__nothrow__)) __attribute__ ((__format__ (__printf__, 3, 0)));
extern int vdprintf (int __fd, const char *__restrict __fmt,
       __gnuc_va_list __arg)
     __attribute__ ((__format__ (__printf__, 2, 0)));
extern int dprintf (int __fd, const char *__restrict __fmt, ...)
     __attribute__ ((__format__ (__printf__, 2, 3)));
extern int fscanf (FILE *__restrict __stream,
     const char *__restrict __format, ...) ;
extern int scanf (const char *__restrict __format, ...) ;
extern int sscanf (const char *__restrict __s,
     const char *__restrict __format, ...) __attribute__ ((__nothrow__ , __leaf__));
extern int fscanf (FILE *__restrict __stream, const char *__restrict __format, ...) __asm__ (&quot;&quot; &quot;__isoc99_fscanf&quot;) ;
extern int scanf (const char *__restrict __format, ...) __asm__ (&quot;&quot; &quot;__isoc99_scanf&quot;) ;
extern int sscanf (const char *__restrict __s, const char *__restrict __format, ...) __asm__ (&quot;&quot; &quot;__isoc99_sscanf&quot;) __attribute__ ((__nothrow__ , __leaf__));
extern int vfscanf (FILE *__restrict __s, const char *__restrict __format,
      __gnuc_va_list __arg)
     __attribute__ ((__format__ (__scanf__, 2, 0))) ;
extern int vscanf (const char *__restrict __format, __gnuc_va_list __arg)
     __attribute__ ((__format__ (__scanf__, 1, 0))) ;
extern int vsscanf (const char *__restrict __s,
      const char *__restrict __format, __gnuc_va_list __arg)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__format__ (__scanf__, 2, 0)));
extern int vfscanf (FILE *__restrict __s, const char *__restrict __format, __gnuc_va_list __arg) __asm__ (&quot;&quot; &quot;__isoc99_vfscanf&quot;)
     __attribute__ ((__format__ (__scanf__, 2, 0))) ;
extern int vscanf (const char *__restrict __format, __gnuc_va_list __arg) __asm__ (&quot;&quot; &quot;__isoc99_vscanf&quot;)
     __attribute__ ((__format__ (__scanf__, 1, 0))) ;
extern int vsscanf (const char *__restrict __s, const char *__restrict __format, __gnuc_va_list __arg) __asm__ (&quot;&quot; &quot;__isoc99_vsscanf&quot;) __attribute__ ((__nothrow__ , __leaf__))
     __attribute__ ((__format__ (__scanf__, 2, 0)));
extern int fgetc (FILE *__stream);
extern int getc (FILE *__stream);
extern int getchar (void);
extern int getc_unlocked (FILE *__stream);
extern int getchar_unlocked (void);
extern int fgetc_unlocked (FILE *__stream);
extern int fputc (int __c, FILE *__stream);
extern int putc (int __c, FILE *__stream);
extern int putchar (int __c);
extern int fputc_unlocked (int __c, FILE *__stream);
extern int putc_unlocked (int __c, FILE *__stream);
extern int putchar_unlocked (int __c);
extern int getw (FILE *__stream);
extern int putw (int __w, FILE *__stream);
extern char *fgets (char *__restrict __s, int __n, FILE *__restrict __stream)
     __attribute__ ((__access__ (__write_only__, 1, 2)));
extern __ssize_t __getdelim (char **__restrict __lineptr,
                             size_t *__restrict __n, int __delimiter,
                             FILE *__restrict __stream) ;
extern __ssize_t getdelim (char **__restrict __lineptr,
                           size_t *__restrict __n, int __delimiter,
                           FILE *__restrict __stream) ;
extern __ssize_t getline (char **__restrict __lineptr,
                          size_t *__restrict __n,
                          FILE *__restrict __stream) ;
extern int fputs (const char *__restrict __s, FILE *__restrict __stream);
extern int puts (const char *__s);
extern int ungetc (int __c, FILE *__stream);
extern size_t fread (void *__restrict __ptr, size_t __size,
       size_t __n, FILE *__restrict __stream) ;
extern size_t fwrite (const void *__restrict __ptr, size_t __size,
        size_t __n, FILE *__restrict __s);
extern size_t fread_unlocked (void *__restrict __ptr, size_t __size,
         size_t __n, FILE *__restrict __stream) ;
extern size_t fwrite_unlocked (const void *__restrict __ptr, size_t __size,
          size_t __n, FILE *__restrict __stream);
extern int fseek (FILE *__stream, long int __off, int __whence);
extern long int ftell (FILE *__stream) ;
extern void rewind (FILE *__stream);
extern int fseeko (FILE *__stream, __off_t __off, int __whence);
extern __off_t ftello (FILE *__stream) ;
extern int fgetpos (FILE *__restrict __stream, fpos_t *__restrict __pos);
extern int fsetpos (FILE *__stream, const fpos_t *__pos);
extern void clearerr (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__));
extern int feof (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__)) ;
extern int ferror (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__)) ;
extern void clearerr_unlocked (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__));
extern int feof_unlocked (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__)) ;
extern int ferror_unlocked (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__)) ;
extern void perror (const char *__s);
extern int fileno (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__)) ;
extern int fileno_unlocked (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__)) ;
extern FILE *popen (const char *__command, const char *__modes) ;
extern int pclose (FILE *__stream);
extern char *ctermid (char *__s) __attribute__ ((__nothrow__ , __leaf__));
extern void flockfile (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__));
extern int ftrylockfile (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__)) ;
extern void funlockfile (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__));
extern int __uflow (FILE *);
extern int __overflow (FILE *, int);

int main() {
    printf(&quot;Hello world\n&quot;);
    return 0;
}
</code></pre>
</details>
<p>Asi je zÅ™ejmÃ©, Å¾e by nebylo praktickÃ© kopÃ­rovat ruÄnÄ› vÅ¡echen tento kÃ³d pokaÅ¾dÃ©, kdyÅ¾ bychom chtÄ›li
nÄ›co vytisknout na vÃ½stup programu.</p>
<h2><a class="header" href="#relativnÃ­-cesta" id="relativnÃ­-cesta">RelativnÃ­ cesta</a></h2>
<p>Cesta k souboru zadÃ¡vanÃ¡ v <code>#include</code> by mÄ›la bÃ½t relativnÃ­, tj. nenÃ­ dobrÃ½ nÃ¡pad pouÅ¾Ã­vat nÄ›co
podobnÃ©ho:</p>
<pre><code class="language-c">#include &quot;C:/Users/Kamil/Desktop/upr/muj_soubor.h&quot;
</code></pre>
<p>TakovÃ½to program by totiÅ¾ jistÄ› nefungoval na jinÃ©m, neÅ¾ vaÅ¡em poÄÃ­taÄi. Z kterÃ©ho adresÃ¡Å™e se tato
relativnÃ­ cesta vyhodnotÃ­ je popsÃ¡no nÃ­Å¾e.</p>
<h2><a class="header" href="#rozdÃ­l-mezi-include--a-include-" id="rozdÃ­l-mezi-include--a-include-">RozdÃ­l mezi <code>#include &lt;â€¦&gt;</code> a <code>#include &quot;â€¦&quot;</code></a></h2>
<p>RozdÃ­l mezi tÄ›mito variantami nenÃ­ pevnÄ› definovÃ¡n, nicmÃ©nÄ› vÄ›tÅ¡ina preprocesorÅ¯ (resp. pÅ™ekladaÄÅ¯)
funguje takto:</p>
<ul>
<li>
<p><code>#include &lt;â€¦&gt;</code> nejprve vyhledÃ¡ zadanou cestu v tzv. systÃ©movÃ½ch cestÃ¡ch. JednÃ¡ se o znÃ¡mÃ© adresÃ¡Å™e,
ve kterÃ½ch jsou uloÅ¾eny jak soubory standardnÃ­ knihovny <em>C</em>, tak i dalÅ¡Ã­ch knihoven, kterÃ© mÃ¡te
v systÃ©mu nainstalovanÃ©. Pouze pokud se zde danÃ½ soubor nenalezne, tak se cesta vyhodnotÃ­ relativnÄ›
k zdrojovÃ©mu souboru, ve kterÃ©m byl <code>#include</code> pouÅ¾it.</p>
<p>Seznam systÃ©movÃ½ch cest si mÅ¯Å¾ete vypsat pomocÃ­ pÅ™Ã­kazu <code>echo | gcc -E -Wp,-v -</code> v LinuxovÃ©m
terminÃ¡lu. Do tohoto seznamu mÅ¯Å¾ete takÃ© pÅ™idat dodateÄnÃ© adresÃ¡Å™e, pokud <code>gcc</code> pÅ™edÃ¡te parametr
<code>-I</code>. VÃ­ce se dozvÃ­te v sekci o <a href="c/preprocesor/../modularizace/knihovny.html">knihovnÃ¡ch</a>.</p>
<p>Pokud se soubor, kterÃ½ chcete do vaÅ¡eho kÃ³du vloÅ¾it, nachÃ¡zÃ­ v externÃ­ knihovnÄ›, kterÃ¡ nepatÅ™Ã­
do vaÅ¡eho projektu, je bÄ›Å¾nÃ© pouÅ¾Ã­vat prÃ¡vÄ› <code>#include &lt;&gt;</code>.</p>
</li>
<li>
<p><code>#include &quot;â€¦&quot;</code> se nedÃ­vÃ¡ do systÃ©movÃ½ch cest, ale rovnou hledÃ¡ zadanou cestu relativnÄ› k souboru,
ve kterÃ©m byl <code>#include</code> pouÅ¾it. Tuto formu pouÅ¾Ã­vejte, pokud budete vklÃ¡dat soubory z vaÅ¡eho
projektu.</p>
</li>
</ul>
<h1><a class="header" href="#makra" id="makra">Makra</a></h1>
<blockquote>
<p>ğŸ¤“ Tato sekce obsahuje doplÅˆujÃ­cÃ­ uÄivo. Pokud je toho na vÃ¡s moc, mÅ¯Å¾ete ji prozatÃ­m pÅ™eskoÄit
a vrÃ¡tit se k nÃ­ pozdÄ›ji.</p>
</blockquote>
<p>ObÄas mÅ¯Å¾eme chtÃ­t v programech pouÅ¾Ã­t stejnou hodnotu na vÃ­ce mÃ­stech. V takovÃ©m pÅ™Ã­padÄ› se hodÃ­
danou hodnotu pojmenovat, aby bylo zÅ™ejmÃ©, co reprezentuje. ZÃ¡roveÅˆ by bylo uÅ¾iteÄnÃ© ji nadefinovat
pouze na jednom mÃ­stÄ›, abychom jejÃ­ hodnotu mohli jednoduÅ¡e upravit bez toho, abychom pÅ™i tom
museli upravovat vÅ¡echna mÃ­sta, kde danou hodnotu pouÅ¾Ã­vÃ¡me.</p>
<p>PomocÃ­ pÅ™Ã­kazu <code>#define &lt;nÃ¡zev&gt; &lt;hodnota&gt;</code> mÅ¯Å¾eme vytvoÅ™it <strong>makro</strong> (<em>macro</em>) s danÃ½m nÃ¡zvem a
hodnotou. Pokud preprocesor v kÃ³du od Å™Ã¡dku s <code>#define</code> do konce zdrojovÃ©ho souboru narazÃ­ na nÃ¡zev
makra, tak tento nÃ¡zev nahradÃ­ hodnotou makra (opÄ›t se jednÃ¡ o prostÃ© textovÃ© nahrazenÃ­, tedy
<code>Ctrl+C -&gt; Ctrl+V</code>). Zkuste si napÅ™Ã­klad, co vypÃ­Å¡e tento program:</p>
<pre><code class="language-c editable">#include &lt;stdio.h&gt;

#define CENA 25

int main() {
    printf(&quot;Cena je %d\n&quot;, CENA);
    printf(&quot;Dvojnasobek ceny je %d\n&quot;, CENA * 2);

    return 0;
}
</code></pre>
<p>PÅ™edstavte si, Å¾e hodnotu tohoto makra pouÅ¾Ã­vÃ¡me v programu na stovkÃ¡ch mÃ­st. Pokud bychom ji
potÅ™ebovali zmÄ›nit, tak staÄÃ­ zmÄ›nit jeden Å™Ã¡dek s <code>#define</code> a preprocesor se potÃ© postarÃ¡ o to,
Å¾e se hodnota aktualizuje na vÅ¡ech pouÅ¾itÃ½ch mÃ­stech.</p>
<p>Makra jsou dle konvence obvykle pojmenovÃ¡na s &quot;caps-lockem&quot;, tedy velkÃ½mi pÃ­smeny (respektive stylem
<a href="c/preprocesor/../promenne/pojmenovavani.html#v%C3%ADceslovn%C3%A9-n%C3%A1zvy">screaming snake case</a>).</p>
<p>Je tÅ™eba brÃ¡t na vÄ›domÃ­, Å¾e preprocesor opravdu dÄ›lÃ¡ pouhÃ© textovÃ© nahrazenÃ­. NapÅ™Ã­klad nÃ¡sledujÃ­cÃ­
kÃ³d tak nedÃ¡vÃ¡ smysl:</p>
<pre><code class="language-c">#define CENA 25
int main() {
    CENA = 0;
    return 0;
}
</code></pre>
<p>protoÅ¾e po spuÅ¡tÄ›nÃ­ preprocesoru se z nÄ›j stane tento (nesmyslnÃ½) kÃ³d:</p>
<pre><code class="language-c">int main() {
    25 = 0;
    return 0;
}
</code></pre>
<h2><a class="header" href="#makra-s-parametry" id="makra-s-parametry">Makra s parametry</a></h2>
<p>Makra mohou takÃ© obsahovat parametry:</p>
<pre><code class="language-c">#define &lt;nÃ¡zev_makra&gt;(&lt;param1&gt;, &lt;param2&gt;, â€¦) &lt;hodnota_makra&gt;
</code></pre>
<p>Tyto parametry mÅ¯Å¾ete pouÅ¾Ã­t pro definici hodnoty. NicmÃ©nÄ› je opÄ›t tÅ™eba dÃ¡t pozor na to, Å¾e
preprocesor pracuje pouze s textem, nerozumÃ­ jazyku <em>C</em>. Parametry tak jsou pÅ™edÃ¡vÃ¡ny ÄistÄ› jako
text, je tak potÅ™eba dÃ¡vat si pozor na nÄ›kolik vÄ›cÃ­:</p>
<ul>
<li>
<p><strong>Priorita operÃ¡torÅ¯</strong> Pokud bychom chtÄ›li vytvoÅ™it napÅ™Ã­klad makro pro vÃ½poÄet druhÃ© mocniny,
mÅ¯Å¾eme ho napsat takto:</p>
<pre><code class="language-c">#define MOCNINA(a) a * a
</code></pre>
<p>Pokud vÅ¡ak takovÃ©to makro pouÅ¾ijeme s nÄ›jakÃ½m komplexnÃ­m vÃ½razem, nemusÃ­me dosÃ¡hnout kÃ½Å¾enÃ©ho
vÃ½sledku kvÅ¯li priority operÃ¡torÅ¯:</p>
<pre><code class="language-c editable mainbody">#include &lt;stdio.h&gt;

#define MOCNINA(a) a * a

int main() {
    printf(&quot;%d\n&quot;, MOCNINA(1 + 1));
    return 0;
}
</code></pre>
<p>Å˜Ã¡dek s <code>printf</code> totiÅ¾ preprocesor zmÄ›nÃ­ na <code>printf(&quot;%d\n&quot;, 1 + 1 * 1 + 1);</code>, coÅ¾ jistÄ› nenÃ­ to,
co jsme chtÄ›li. Proto je dobrÃ© pÅ™i pouÅ¾itÃ­ maker s parametry obalovat jednotlivÃ© parametry
zÃ¡vorkami:</p>
<pre><code class="language-c">#define MOCNINA(a) (a) * (a)
</code></pre>
<p>Pak by zde jiÅ¾ doÅ¡lo k ÃºpravÄ› na <code>printf(&quot;%d\n&quot;, (1 + 1) * (1 + 1));</code>, coÅ¾ vrÃ¡tÃ­ druhou mocninu
vÃ½razu <code>1 + 1</code>, tedy <code>4</code>.</p>
</li>
<li>
<p><strong>VedlejÅ¡Ã­ efekty</strong> Pokud majÃ­ argumenty pÅ™edÃ¡vanÃ© do makra nÄ›jakÃ©
<a href="c/preprocesor/../prikazy_vyrazy.html#vedlej%C5%A1%C3%AD-efekty">vedlejÅ¡Ã­ efekty</a>, je tÅ™eba si dÃ¡vat pozor na to, Å¾e makro mÅ¯Å¾e
jednoduÅ¡e takovÃ½to argument rozkopÃ­rovat a tÃ­m pÃ¡dem vedlejÅ¡Ã­ efekt provÃ©st vÃ­cekrÃ¡t. NapÅ™Ã­klad pÅ™i
pouÅ¾itÃ­ makra <code>MOCNINA</code> vÃ½Å¡e by zde doÅ¡lo k dvojnÃ¡sobenÃ© inkrementaci promÄ›nnÃ© <code>x</code>:</p>
<pre><code class="language-c editable mainbody">#include &lt;stdio.h&gt;

#define MOCNINA(a) a * a

int main() {
    int x = 0;
    int mocnina = MOCNINA(x++);
    printf(&quot;x=%d, mocnina=%d\n&quot;, x, mocnina);

    return 0;
}
</code></pre>
<p>Do maker tak radÅ¡i nedÃ¡vejte argumenty, kterÃ© zpÅ¯sobujÃ­ vedlejÅ¡Ã­ efekty.</p>
</li>
</ul>
<h2><a class="header" href="#makra-vs-globÃ¡lnÃ­-promÄ›nnÃ©" id="makra-vs-globÃ¡lnÃ­-promÄ›nnÃ©">Makra vs globÃ¡lnÃ­ promÄ›nnÃ©</a></h2>
<p><a href="c/preprocesor/../promenne/globalni_promenne.html">GlobÃ¡lnÃ­ promÄ›nnÃ©</a> jsou takÃ© pojmenovanÃ© hodnoty definovanÃ© na
jednom mÃ­stÄ›, proÄ tedy potÅ™ebujeme makra? Je to z nÄ›kolika dÅ¯vodÅ¯:</p>
<ul>
<li>Makra s parametry umoÅ¾ÅˆujÃ­ definici hodnot Äi textu zÃ¡vislou na pouÅ¾itÃ½ch parametrech, coÅ¾
globÃ¡lnÃ­ promÄ›nnÃ© neumoÅ¾ÅˆujÃ­.</li>
<li>KonstantnÃ­ globÃ¡lnÃ­ promÄ›nnÃ© nelze pouÅ¾Ã­t napÅ™Ã­klad pro urÄenÃ­ velikosti statickÃ½ch
<a href="c/preprocesor/../pole/pole.html">polÃ­</a>.</li>
<li>GlobÃ¡lnÃ­ promÄ›nnÃ© zabÃ­rajÃ­ mÃ­sto v pamÄ›ti programu a zÃ¡roveÅˆ zvyÅ¡ujÃ­ velikost spustitelnÃ©ho
souboru, protoÅ¾e v nÄ›m musÃ­ bÃ½t uloÅ¾ena jejich iniciÃ¡lnÃ­ hodnota
(pokud to tedy <a href="c/preprocesor/../promenne/globalni_promenne.html#inici%C3%A1ln%C3%AD-hodnota">nenÃ­ <code>0</code></a>). Makra se pouze textovÄ›
nahradÃ­ bÄ›hem pÅ™ekladu programu, takÅ¾e samy o sobÄ› Å¾Ã¡dnou pamÄ›Å¥ nezabÃ­rajÃ­.</li>
</ul>
<p>NicmÃ©nÄ›, makra jsou obÄas problÃ©movÃ¡ kvÅ¯li toho, Å¾e se nahrazujÃ­ ÄistÄ› jako text. <strong>Pokud je to tedy
moÅ¾nÃ©, zkuste radÄ›ji pouÅ¾Ã­t pro definici konstant v kÃ³du konstantnÃ­ globÃ¡lnÃ­ promÄ›nnÃ©.</strong></p>
<h2><a class="header" href="#podmÃ­nÄ›nÃ½-pÅ™eklad" id="podmÃ­nÄ›nÃ½-pÅ™eklad">PodmÃ­nÄ›nÃ½ pÅ™eklad</a></h2>
<p>Makra mohou takÃ© bÃ½t pouÅ¾ity k tzv. <strong>podmÃ­nÄ›nÃ©mu pÅ™ekladu</strong> (<em>conditional compilation</em>). PomocÃ­
pÅ™Ã­kazÅ¯ preprocesoru jako <code>#ifdef</code> nebo <code>#if</code> mÅ¯Å¾ete pÅ™eloÅ¾it kus kÃ³du pouze, pokud je nadefinovanÃ©
urÄitÃ© makro (popÅ™Ã­padÄ› pouze pokud mÃ¡ urÄitou hodnotu). Toho se bÄ›Å¾nÄ› vyuÅ¾Ã­vÃ¡ napÅ™Ã­klad pro tvorbu
programÅ¯, kterÃ© jsou kompatibilnÃ­ s vÃ­ce operaÄnÃ­mi systÃ©my (napÅ™. jedna funkce mÅ¯Å¾e mÃ­t jinou
implementaci pro Linux a jinou pro Windows).</p>
<p>V UPR se s podmÃ­nÄ›nÃ½m pÅ™ekladem nesetkÃ¡me, vÃ­ce se o nÄ›m mÅ¯Å¾ete dozvÄ›dÄ›t napÅ™Ã­klad
<a href="https://docs.microsoft.com/en-us/cpp/preprocessor/hash-if-hash-elif-hash-else-and-hash-endif-directives-c-cpp">zde</a>.</p>
<h1><a class="header" href="#prÃ¡ce-s-pamÄ›tÃ­" id="prÃ¡ce-s-pamÄ›tÃ­">PrÃ¡ce s pamÄ›tÃ­</a></h1>
<p>V sekci o <a href="c/prace_s_pameti/../../uvod/pamet.html">pamÄ›ti</a> jsme se dozvÄ›dÄ›li, Å¾e operaÄnÃ­ pamÄ›Å¥ poÄÃ­taÄe lze adresovat
pomocÃ­ ÄÃ­selnÃ½ch adres. ProzatÃ­m jsme nicmÃ©nÄ› v naÅ¡ich programech s Å¾Ã¡dnÃ½mi adresami explicitnÄ›
nepracovali, pouze jsme vytvÃ¡Å™eli promÄ›nnÃ©, jejichÅ¾ pamÄ›Å¥ byla spravovÃ¡na automaticky. V tÃ©to sekci
se dozvÃ­te zÃ¡klady toho, jak tzv. <strong>sprÃ¡va pamÄ›ti</strong> (<em>memory management</em>) funguje.</p>
<blockquote>
<p>PrÃ¡ce s pamÄ›tÃ­ je asi nejklÃ­ÄovÄ›jÅ¡Ã­ ÄÃ¡stÃ­ jazyka <em>C</em>. Je potÅ™eba ji sprÃ¡vnÄ› pochopit, jinak
vaÅ¡e programy nebudou sprÃ¡vnÄ› fungovat a nebudete schopni odhalit, proÄ tomu tak je. VÄ›nujte tedy
tÃ©to kapitole zvlÃ¡Å¡tnÃ­ pozornost.</p>
</blockquote>
<h2><a class="header" href="#adresnÃ­-prostor-programu" id="adresnÃ­-prostor-programu">AdresnÃ­ prostor programu</a></h2>
<p>KdyÅ¾ spustÃ­te svÅ¯j program, tak pro nÄ›j operaÄnÃ­ systÃ©m vytvoÅ™Ã­ tzv. <strong>adresnÃ­ prostor</strong>
(<em>address space</em>), coÅ¾ je oblast pamÄ›ti, se kterou program mÅ¯Å¾e pracovat.<sup class='margin-toggle sidenote-number'>1</sup> Tato oblast je typicky
rozdÄ›lena na nÄ›kolik ÄÃ¡stÃ­, z nichÅ¾ kaÅ¾dÃ¡ slouÅ¾Ã­ pro rÅ¯znÃ© typy dat:</p>
<span class='sidenote'><p><sup class='number'>1</sup>DÃ­ky mechanismu
<a href="https://cs.wikipedia.org/wiki/Virtu%C3%A1ln%C3%AD_pam%C4%9B%C5%A5">virtuÃ¡lnÃ­ pamÄ›ti</a> je tento
prostor soukromÃ½ pro vÃ¡Å¡ bÄ›Å¾Ã­cÃ­ program - ostatnÃ­ bÄ›Å¾Ã­cÃ­ programy do nÄ›j nemajÃ­ pÅ™Ã­stup, pokud jim
to explicitnÄ› nepovolÃ­te.<br /><br />
ObrÃ¡zek adresnÃ­ho prostoru je pouze ilustrativnÃ­, rÅ¯znÃ© operaÄnÃ­ systÃ©my Äi bÄ›hovÃ¡ prostÅ™edÃ­ mohou
umÃ­sÅ¥ovat jednotlivÃ© oblasti v adresnÃ­m prostoru rÅ¯znÄ›.</p>
</span><div style="display: flex; justify-content: center;">
    <img src="c/prace_s_pameti/../../static/img/address_space.png" alt="AdresnÃ­ prostor bÄ›Å¾Ã­cÃ­ho programu" width="300px" />
</div>
<ul>
<li><strong>ZÃ¡sobnÃ­k</strong> Tato ÄÃ¡st uchovÃ¡vÃ¡ automaticky spravovanÃ¡ data, zejmÃ©na lokÃ¡lnÃ­ promÄ›nnÃ© a parametry
funkcÃ­. Tuto oblast popisuje sekce o <a href="c/prace_s_pameti/automaticka_pamet.html">automatickÃ© pamÄ›ti</a>.</li>
<li><strong>Halda</strong> Tuto ÄÃ¡st mÅ¯Å¾ete vyuÅ¾Ã­t k dynamickÃ© alokaci pamÄ›ti. To nÃ¡m umoÅ¾ÅˆujÃ­
<a href="c/prace_s_pameti/ukazatele.html">ukazatele</a>, dÃ­ky kterÃ½m mÅ¯Å¾eme explicitnÄ› pracovat s adresami v pamÄ›ti. Tuto oblast
adresnÃ­ho prostoru popisuje sekce o <a href="c/prace_s_pameti/dynamicka_pamet.html">dynamickÃ© pamÄ›ti</a>.</li>
<li><strong>GlobÃ¡lnÃ­ data</strong> Tato ÄÃ¡st obsahuje <a href="c/prace_s_pameti/../promenne/globalni_promenne.html">globÃ¡lnÃ­ promÄ›nnÃ©</a>,
kterÃ© Å¾ijÃ­ po celou dobu bÄ›hu programu.</li>
<li><strong>Instrukce programu</strong> Do tÃ©to ÄÃ¡sti pamÄ›ti se pÅ™i spuÅ¡tÄ›nÃ­ programu zkopÃ­rujÃ­ jeho instrukce
ze spustitelnÃ©ho souboru na disku. NachÃ¡zÃ­ se tak v nÃ­ pÅ™eloÅ¾enÃ½ kÃ³d
<a href="c/prace_s_pameti/../funkce/funkce.html">funkcÃ­</a> vaÅ¡eho programu. Procesor potÃ© Äte instrukce, kterÃ© mÃ¡ vykonat, prÃ¡vÄ›
z tÃ©to ÄÃ¡sti pamÄ›ti. Tato pamÄ›Å¥ je obvykle chrÃ¡nÄ›na proti zÃ¡pisu a slouÅ¾Ã­ pouze pro ÄtenÃ­.</li>
</ul>
<h1><a class="header" href="#automatickÃ¡-pamÄ›Å¥" id="automatickÃ¡-pamÄ›Å¥">AutomatickÃ¡ pamÄ›Å¥</a></h1>
<p>ZatÃ­m jsme pouÅ¾Ã­vali (lokÃ¡lnÃ­) promÄ›nnÃ©, kterÃ© vznikajÃ­ a zanikajÃ­ uvnitÅ™ funkcÃ­. Nemuseli jsme se
tedy nijak starat o to, kde existujÃ­ v pamÄ›ti. LokÃ¡lnÃ­ promÄ›nnÃ© se uklÃ¡dajÃ­ do oblasti v pamÄ›ti,
kterou nazÃ½vÃ¡me <strong>zÃ¡sobnÃ­k</strong> (<em>stack</em>). KaÅ¾dÃ½ bÄ›Å¾Ã­cÃ­ program mÃ¡ vyhrazen urÄitou oblast
adresovatelnÃ© pamÄ›ti, kterÃ¡ je pouÅ¾ita prÃ¡vÄ› jako zÃ¡sobnÃ­k.</p>
<p>PÅ™i kaÅ¾dÃ©m zavolÃ¡nÃ­ funkce vznikne na zÃ¡sobnÃ­ku tzv. <strong>zÃ¡sobnÃ­kovÃ½ rÃ¡mec</strong> (<em>stack frame</em>).
V tomto rÃ¡mci je vyhrazena (tzv. <strong>naalokovÃ¡na</strong>) pamÄ›Å¥ pro lokÃ¡lnÃ­ promÄ›nnÃ© volanÃ© funkce a takÃ© pro
jejÃ­ <a href="c/prace_s_pameti/../funkce/funkce.html#parametrizace-funkc%C3%AD">parametry</a>. RÃ¡mec vznikÃ¡ pÅ™i kaÅ¾dÃ©m zavolÃ¡nÃ­ funkce,
v jednu chvÃ­li tak na zÃ¡sobnÃ­ku mÅ¯Å¾e existovat vÃ­ce rÃ¡mcÅ¯ (s rÅ¯znÃ½mi hodnotami promÄ›nnÃ½ch a parametrÅ¯)
pro stejnou funkci. RÃ¡mce vznikajÃ­ v pamÄ›ti za sebou, a jsou uvolnÄ›ny v momentÄ›, kdy se jejich
funkce dokonÄÃ­.<sup class='margin-toggle sidenote-number'>1</sup></p>
<span class='sidenote'><p><sup class='number'>1</sup>RÃ¡mce tak mohou vznikat nebo zanikat pouze na konci zÃ¡sobnÃ­ku, ne uprostÅ™ed. Proto se tato
oblast nazÃ½vÃ¡ zÃ¡sobnÃ­k, podle
<a href="https://cs.wikipedia.org/wiki/Z%C3%A1sobn%C3%ADk_(datov%C3%A1_struktura)">datovÃ© struktury</a>, kterÃ¡
mÃ¡ tuto vlastnost.</p>
</span>
<p>PÅ™i zavolÃ¡nÃ­ funkce se do pamÄ›ti urÄenÃ© pro jednotlivÃ© parametry v rÃ¡mci nakopÃ­rujÃ­ hodnoty pÅ™edanÃ½ch
argumentÅ¯. Jakmile funkce skonÄÃ­, tak je rÃ¡mec, a tedy i pamÄ›Å¥ obsahujÃ­cÃ­ lokÃ¡lnÃ­ promÄ›nnÃ© a parametry
danÃ© funkce, uvolnÄ›n<sup class='margin-toggle sidenote-number'>2</sup>.</p>
<span class='sidenote'><p><sup class='number'>2</sup>UvolnÄ›nÃ­ zde znamenÃ¡ pouze to, Å¾e program bude poklÃ¡dat danou pamÄ›Å¥ za volnou k dalÅ¡Ã­mu pouÅ¾itÃ­.
Pokud tak napÅ™Ã­klad funkce bude mÃ­t lokÃ¡lnÃ­ promÄ›nnou s hodnotou <code>5</code> a vykonÃ¡nÃ­ funkce skonÄÃ­, tato
hodnota v pamÄ›ti zÅ¯stane, dokud nebude pÅ™epsÃ¡na pÅ™Ã­Å¡tÃ­m zavolÃ¡nÃ­m funkce.</p>
</span>
<p>V nÃ¡sledujÃ­cÃ­ animaci mÅ¯Å¾ete vidÄ›t sekvenci volÃ¡nÃ­ funkcÃ­. Ve sloupci vpravo je zobrazen stav
zÃ¡sobnÃ­ku pÅ™i provÃ¡dÄ›nÃ­ tohoto programu:</p>
<ul>
<li>Å edÃ© obdÃ©lnÃ­ky oznaÄujÃ­ zÃ¡sobnÃ­kovÃ© rÃ¡mce.</li>
<li>ModrÃ© obdÃ©lnÃ­ky znÃ¡zorÅˆujÃ­ hodnoty parametrÅ¯ v rÃ¡mci.</li>
<li>ÄŒervenÃ© obdÃ©lnÃ­ky znÃ¡zorÅˆujÃ­ hodnoty lokÃ¡lnÃ­ch promÄ›nnÃ½ch v rÃ¡mci. MÅ¯Å¾ete si
vÅ¡imnout, Å¾e lokÃ¡lnÃ­ promÄ›nnÃ© majÃ­
<a href="c/prace_s_pameti/../promenne/promenne.html#v%C5%BEdy-inicializujte-prom%C4%9Bnn%C3%A9">nedefinovanou hodnotu</a>, dokud do nich nenÃ­
nÄ›jakÃ¡ hodnota zapsÃ¡na, nicmÃ©nÄ› pamÄ›Å¥ pro nÄ› jiÅ¾ existuje od zaÄÃ¡tku provÃ¡dÄ›nÃ­ funkce.</li>
<li>OranÅ¾ovÃ¡ Å¡ipka oznaÄuje, kterÃ½ Å™Ã¡dek programu je prÃ¡vÄ› provÃ¡dÄ›n.</li>
</ul>
<p>PomocÃ­ Å¡ipek v levÃ©m hornÃ­m rohu animace se mÅ¯Å¾ete postupnÄ› proklikat prÅ¯bÄ›hem vykonÃ¡nÃ­ tohoto programu.
Uhodnotete, jakÃ© ÄÃ­slo tento program vypÃ­Å¡e?</p>
<div style="height: 450px">
    <upr-slideshow src="../../static/animations/stack/stack-" to="15" extension="png"></upr-slideshow>
</div>
<p>V animaci si mÅ¯Å¾ete vÅ¡imnout, Å¾e rÃ¡mce vÅ¾dy vznikajÃ­ a zanikajÃ­ pouze na konci zÃ¡sobnÃ­ku.<sup class='margin-toggle sidenote-number'>3</sup>
Pokud byste si chtÄ›li tento program spustit lokÃ¡lnÄ›, tak jeho zdrojovÃ½ kÃ³d je dostupnÃ½ nÃ­Å¾e.</p>
<span class='sidenote'><p><sup class='number'>3</sup>Z <a href="https://stackoverflow.com/questions/2035568/why-do-stacks-typically-grow-downwards">historickÃ½ch</a>
dÅ¯vodÅ¯ zÃ¡sobnÃ­k roste &quot;dolÅ¯&quot;, tj. novÃ© rÃ¡mce se vytvÃ¡Å™ejÃ­ na niÅ¾Å¡Ã­ adrese v pamÄ›ti.</p>
</span><details>
<summary>ZdrojovÃ½ kÃ³d programu</summary>
<pre><code class="language-c editable">#include &lt;stdio.h&gt;

int fun1(int par) {
    int res = par * 2;
    if (res &lt; 50) {
        return fun1(res);
    }
    else { return res; }
}
int fun2(int a, int b) {
    int x = a + b * 2;
    int y = fun1(x);
    return x + y;
}
int main() {
    printf(&quot;%d\n&quot;, fun2(5, 6));
    return 0;
}
</code></pre>
</details>
<h2><a class="header" href="#vÃ½hody-automatickÃ©-pamÄ›ti" id="vÃ½hody-automatickÃ©-pamÄ›ti">VÃ½hody automatickÃ© pamÄ›ti</a></h2>
<p>PouÅ¾Ã­vÃ¡nÃ­ automatickÃ© pamÄ›ti mÃ¡ znaÄnÃ© vÃ½hody:</p>
<ul>
<li>NemusÃ­me se starat o to, jak je pamÄ›Å¥ alokovÃ¡na a uvolÅˆovÃ¡na, vÅ¡e za nÃ¡s Å™eÅ¡Ã­ pÅ™ekladaÄ, kterÃ½
generuje instrukce pro vytvÃ¡Å™enÃ­ a uvolÅˆovÃ¡nÃ­ rÃ¡mcÅ¯ pÅ™i volÃ¡nÃ­/dokonÄenÃ­ provÃ¡dÄ›nÃ­ funkce.</li>
<li>Alokace i uvolnÄ›nÃ­ pamÄ›ti je velmi rychlÃ¡. Jde v podstatÄ› o provedenÃ­ jedinÃ© instrukce, kterÃ¡ si
pamatuje, kde zrovna zÃ¡sobnÃ­k &quot;konÄÃ­&quot; v pamÄ›ti.</li>
</ul>
<p>Pokud tedy nepotÅ™ebujete Å¾Ã¡dnou sloÅ¾itÄ›jÅ¡Ã­ funkcionalitu, prvnÃ­ volbou by mÄ›lo bÃ½t prÃ¡vÄ› pouÅ¾itÃ­
automatickÃ© pamÄ›ti (tedy lokÃ¡lnÃ­ch promÄ›nnÃ½ch).</p>
<h2><a class="header" href="#nevÃ½hody-automatickÃ©-pamÄ›ti" id="nevÃ½hody-automatickÃ©-pamÄ›ti">NevÃ½hody automatickÃ© pamÄ›ti</a></h2>
<p>AutomatickÃ¡ pamÄ›Å¥ je sice velmi uÅ¾iteÄnÃ¡, nicmÃ©nÄ› nÄ›kdy potÅ™ebujeme pouÅ¾Ã­t i jinÃ© typy pamÄ›ti,
protoÅ¾e automatickÃ¡ pamÄ›Å¥ mÃ¡ i urÄitÃ© nedostatky:</p>
<ul>
<li>MaximÃ¡lnÃ­ velikost zÃ¡sobnÃ­ku je omezena<sup class='margin-toggle sidenote-number'>4</sup>. NemÅ¯Å¾eme tak na nÄ›m naalokovat vÄ›tÅ¡Ã­ mnoÅ¾stvÃ­ pamÄ›ti.<span class='sidenote'><p><sup class='number'>4</sup>Obvykle jde o jednotky KiB nebo MiB.</p>
</span></li>
<li>PoÄet a velikost lokÃ¡lnÃ­ch promÄ›nnÃ½ch je &quot;zadrÃ¡tovÃ¡na&quot; do programu bÄ›hem jeho pÅ™ekladu. NemÅ¯Å¾eme
tak naalokovat pamÄ›Å¥ s velikostÃ­ zÃ¡vislou na vstupu programu. NapÅ™Ã­klad pokud uÅ¾ivatel zadÃ¡
ÄÃ­slo <code>n</code> a my bychom chtÄ›li vytvoÅ™it pamÄ›Å¥ pro <code>n</code> ÄÃ­sel, tak
<a href="https://mrlvsb.github.io/upr-skripta/c/pole/staticka_pole.html#konstantn%C3%AD-velikost-statick%C3%A9ho-pole">obvykle nestaÄÃ­</a>
pouÅ¾itÃ­ zÃ¡sobnÃ­ku.</li>
<li>PamÄ›Å¥ lokÃ¡lnÃ­ch promÄ›nnÃ½ch a parametrÅ¯ je uvolnÄ›na pÅ™i dokonÄenÃ­ provÃ¡dÄ›nÃ­ funkce. JedinÃ½m zpÅ¯sobem,
jak pÅ™edat hodnotu z volÃ¡nÃ­ funkce, je pomocÃ­ nÃ¡vratovÃ© hodnoty. Takto lze vrÃ¡tit pouze jednu
hodnotu a nelze jednoduÅ¡e sdÃ­let pamÄ›Å¥ mezi funkcemi, protoÅ¾e pamÄ›Å¥ lokÃ¡lnÃ­ch promÄ›nnÃ½ch je po dokonÄenÃ­
volÃ¡nÃ­ funkce uvolnÄ›na a nelze ji tak pouÅ¾Ã­t z volajÃ­cÃ­ funkce.</li>
<li>Argumenty pÅ™edÃ¡vanÃ© do funkcÃ­ se kopÃ­rujÃ­ do zÃ¡sobnÃ­kovÃ©ho rÃ¡mce volanÃ© funkce a nÃ¡vratovÃ¡ hodnota
se zase kopÃ­ruje zpÄ›t do rÃ¡mce volajÃ­cÃ­ funkce. Toto kopÃ­rovÃ¡nÃ­ mÅ¯Å¾e bÃ½t zbyteÄnÄ› pomalÃ© pro hodnoty
zabÃ­rajÃ­cÃ­ velkÃ½ poÄet bytÅ¯. </li>
</ul>
<p>Abychom mohli alokovat vÄ›tÅ¡Ã­ mnoÅ¾stvÃ­ pamÄ›ti Äi jednoduÅ¡Å¡eji sdÃ­let hodnoty promÄ›nnÃ½ch mezi funkcemi,
tak musÃ­me mÃ­t moÅ¾nost alokovat a uvolÅˆovat pamÄ›Å¥ manuÃ¡lnÄ›. K tomu ale nejprve potÅ™ebujeme vÄ›dÄ›t,
jak pracovat pÅ™Ã­mo s adresami v pamÄ›ti, k ÄemuÅ¾ slouÅ¾Ã­ <a href="c/prace_s_pameti/ukazatele.html">ukazatele</a>.</p>
<h1><a class="header" href="#ukazatele" id="ukazatele">Ukazatele</a></h1>
<p>Abychom v <em>C</em> mohli manuÃ¡lnÄ› pracovat s pamÄ›tÃ­, potÅ™ebujeme mÃ­t moÅ¾nost odkazovat se na jednotlivÃ©
hodnoty v pamÄ›ti pomocÃ­ <a href="c/prace_s_pameti/../../uvod/pamet.html#adresov%C3%A1n%C3%AD-pam%C4%9Bti">adres</a>. Adresa je ÄÃ­slo, takÅ¾e
bychom mohli pro popis adres pouÅ¾Ã­vat napÅ™Ã­klad datovÃ½ typ <code>unsigned int</code><sup class='margin-toggle sidenote-number'>1</sup>. To by ale nebyl dobrÃ½
nÃ¡pad, protoÅ¾e tento datovÃ½ typ neumoÅ¾Åˆuje provÃ¡dÄ›t operace, kterÃ© bychom s adresami chtÄ›li dÄ›lat
(naÄÃ­st hodnotu z adresy Äi zapsat hodnotu na adresu), a naopak umoÅ¾Åˆuje provÃ¡dÄ›t operace, kterÃ© s
adresami dÄ›lat nechceme (napÅ™Ã­klad nÃ¡sobenÃ­ Äi dÄ›lenÃ­ adres obvykle nedÃ¡vÃ¡ valnÃ½ smysl).</p>
<span class='sidenote'><p><sup class='number'>1</sup>NejniÅ¾Å¡Ã­ moÅ¾nÃ¡ adresa je <code>0</code>, takÅ¾e zÃ¡pornÃ© hodnoty nemÃ¡ cenu reprezentovat.</p>
</span>
<p>Z tohoto dÅ¯vodu <em>C</em> obsahuje datovÃ½ typ, kterÃ½ je interpretovÃ¡n jako adresa v pamÄ›ti bÄ›Å¾Ã­cÃ­ho
programu. NazÃ½vÃ¡ se <strong>ukazatel</strong> (<em>pointer</em>). KromÄ› toho, Å¾e reprezentuje adresu, tak kaÅ¾dÃ½ datovÃ½
typ ukazatele takÃ© obsahuje informaci o tom, jakÃ½ typ hodnoty by mÄ›l bÃ½t uloÅ¾en v pamÄ›ti na adrese
obsaÅ¾enÃ© v ukazateli. PotÃ© Å™Ã­kÃ¡me, Å¾e ukazatel &quot;ukazuje na&quot; danÃ½ datovÃ½ typ.</p>
<p>Abychom vytvoÅ™ili datovÃ½ typ ukazatele, vezmeme datovÃ½ typ, na kterÃ½ bude ukazovat, a pÅ™idÃ¡me za nÄ›j
hvezdiÄku (<code>*</code>). Takto napÅ™Ã­klad vypadÃ¡ promÄ›nnÃ¡ datovÃ©ho typu &quot;ukazatel na <code>int</code>&quot;<sup class='margin-toggle sidenote-number'>2</sup>:</p>
<span class='sidenote'><p><sup class='number'>2</sup>Je jedno, jestli hvÄ›zdiÄku napÃ­Å¡ete k datovÃ©mu typu (<code>int* p</code>) anebo k nÃ¡zvu promÄ›nnÃ©
(<code>int *p</code>), bÃ­lÃ© znaky jsou zde ignorovÃ¡ny. Pozor vÅ¡ak na vytvÃ¡Å™enÃ­ vÃ­ce ukazatelÅ¯ na
<a href="c/prace_s_pameti/ukazatele.html#definice-v%C3%ADce-ukazatel%C5%AF-najednou">jednom Å™Ã¡dku</a>.</p>
</span>
<pre><code class="language-c">int* ukazatel;
</code></pre>
<p>Je dÅ¯leÅ¾itÃ© si uvÄ›domit, co tato promÄ›nnÃ¡ reprezentuje. DatovÃ½ typ <code>int*</code> zde Å™Ã­kÃ¡, Å¾e v promÄ›nnÃ©
<code>ukazatel</code> bude uloÅ¾eno ÄÃ­slo, kterÃ© budeme interpretovat jako adresu. V pamÄ›ti na tÃ©to adrese potÃ©
bude leÅ¾et ÄÃ­slo, kterÃ© budeme interpretovat jako datovÃ½ typ <code>int</code> (celÃ© ÄÃ­slo se znamÃ©nkem).</p>
<p>Ukazatele lze libovolnÄ› &quot;vnoÅ™ovat&quot;, tj. mÅ¯Å¾eme mÃ­t napÅ™Ã­klad &quot;ukazatel na ukazatel na celÃ© ÄÃ­slo&quot;
(<code>int**</code>). Ukazatel ale i tehdy bude prostÄ› ÄÃ­slo, akorÃ¡t ho budeme interpretovat jako adresu jinÃ©
adresy. Pro procviÄenÃ­ je nÃ­Å¾e uvedeno nÄ›kolik datovÃ½ch typÅ¯ spolu s tÃ­m, jak je interpretujeme.</p>
<ul>
<li><code>int</code> - interpretujeme jako celÃ© ÄÃ­slo</li>
<li><code>int*</code> - interpretujeme jako adresu, na kterÃ© je uloÅ¾eno celÃ© ÄÃ­slo</li>
<li><code>float*</code> - interpretujeme jako adresu, na kterÃ© je uloÅ¾eno desetinnÃ© ÄÃ­slo</li>
<li><code>int**</code> - interpretujeme jako adresu, na kterÃ© je uloÅ¾ena adresa, na kterÃ© je uloÅ¾eno celÃ© ÄÃ­slo</li>
</ul>
<p>NÄ›kdy chceme pouÅ¾Ã­t &quot;univerzÃ¡lnÃ­&quot; ukazatel, kterÃ½ prostÄ› obsahuje adresu, bez toho, abychom striktnÄ›
urÄovali, jak interpretovat hodnotu na danÃ© adrese. V tom pÅ™Ã­padÄ› mÅ¯Å¾eme pouÅ¾Ã­t datovÃ½ typ <code>void*</code>.</p>
<blockquote>
<p>Velikost vÅ¡ech ukazatelÅ¯ v programu je obvykle stejnÃ¡ a je dÃ¡na pouÅ¾itÃ½m operaÄnÃ­m systÃ©mem a
pÅ™ekladaÄem. Ukazatele musÃ­ bÃ½t dostateÄnÄ› velkÃ©, aby zvlÃ¡dly reprezentovat libovolnou adresu,
kterÃ¡ se v programu mÅ¯Å¾e vyskytnout. Na vaÅ¡em poÄÃ­taÄi to bude nejspÃ­Å¡e <strong>8 bytÅ¯</strong>, protoÅ¾e
pravdÄ›podobnÄ› pouÅ¾Ã­vÃ¡te 64-bitovÃ½ systÃ©m.</p>
</blockquote>
<h2><a class="header" href="#inicializace-ukazatele" id="inicializace-ukazatele">Inicializace ukazatele</a></h2>
<p>JelikoÅ¾ pÅ™ed spuÅ¡tÄ›nÃ­m programu nevÃ­me, na jakÃ© adrese budou uloÅ¾eny hodnoty, kterÃ© nÃ¡s budou
zajÃ­mat, tak obvykle nedÃ¡vÃ¡ smysl inicializovat ukazatel na konkrÃ©tnÃ­ adresu (napÅ™. <code>int* p = 5;</code>).
Pro inicializaci ukazatele tak existuje nÄ›kolik standardnÃ­ch moÅ¾nostÃ­:</p>
<ul>
<li>
<p><strong>Inicializace na nulu</strong> Pokud chceme vytvoÅ™it &quot;prÃ¡zdnÃ½&quot; ukazatel, kterÃ½ zatÃ­m neukazuje na
Å¾Ã¡dnou validnÃ­ adresu, tak se dle konvence inicializuje na hodnotu <code>0</code>. TakovÃ©mu ukazateli se pak
Å™Ã­kÃ¡ <strong>nulovÃ½ ukazatel</strong> (<em>null pointer</em>). JelikoÅ¾ datovÃ½ typ vÃ½razu <code>0</code> je <code>int</code>, tak pÅ™ed
pÅ™iÅ™azenÃ­m tÃ©to hodnoty do ukazatele jej musÃ­me
<a href="c/prace_s_pameti/../datove_typy/konverze.html">pÅ™etypovat</a> na datovÃ½ typ cÃ­lovÃ©ho
ukazatele:</p>
<pre><code class="language-c">float* p = (float*) 0;
</code></pre>
<p>JelikoÅ¾ tento typ inicializace je velmi ÄastÃ½, <a href="c/prace_s_pameti/../funkce/stdlib.html">standardnÃ­ knihovna <em>C</em></a>
obsahuje <a href="c/prace_s_pameti/../preprocesor/makra.html">makro</a> <code>NULL</code>, kterÃ© konverzi nuly na ukazatel provede za
vÃ¡s. MÅ¯Å¾ete jej najÃ­t napÅ™Ã­klad v souboru <code>stdlib.h</code>:</p>
<pre><code class="language-c">#include &lt;stdlib.h&gt;
// ...
float* p = NULL;
</code></pre>
</li>
<li>
<p><strong>VyuÅ¾itÃ­ alokaÄnÃ­ funkce</strong> Pokud budete alokovat pamÄ›Å¥ <a href="c/prace_s_pameti/dynamicka_pamet.html">manuÃ¡lnÄ›</a>, tak
pouÅ¾ijete funkce, kterÃ© vÃ¡m vrÃ¡tÃ­ adresu jako svou nÃ¡vratovou hodnotu.</p>
</li>
<li>
<p><strong>VyuÅ¾itÃ­ operÃ¡toru adresy</strong> Pokud chcete ukazatel nastavit na adresu jiÅ¾ existujÃ­cÃ­ hodnoty v
pamÄ›ti, mÅ¯Å¾ete pouÅ¾Ã­t <strong>operÃ¡tor adresy</strong> (<em>address-of operator</em>). Ten mÃ¡ syntaxi <code>&amp;&lt;promÄ›nnÃ¡&gt;</code>.
Tento operÃ¡tor se vyhodnotÃ­ jako adresa pÅ™edanÃ© promÄ›nnÃ©<sup class='margin-toggle sidenote-number'>3</sup>:</p>
<span class='sidenote'><p><sup class='number'>3</sup>VÅ¡imnÄ›te si, Å¾e pro vÃ½pis ukazatelÅ¯ ve funkci <code>printf</code> se pouÅ¾Ã­vÃ¡ <code>%p</code> mÃ­sto <code>%d</code>.</p>
</span>
<pre><code class="language-c editable mainbody">#include &lt;stdio.h&gt;

int main() {
    int x = 1;
    int* p = &amp;x;

    printf(&quot;%d\n&quot;, x);  // hodnota promÄ›nnÃ© x
    printf(&quot;%p\n&quot;, p);  // adresa v pamÄ›ti, kde je uloÅ¾ena promÄ›nnÃ¡ x

    return 0;
}
</code></pre>
<p>VÃ½raz pÅ™edanÃ½ operÃ¡toru <code>&amp;</code> se musÃ­ vyhodnotit na nÄ›co, co mÃ¡ adresu v pamÄ›ti (vÄ›tÅ¡inou to bude
<a href="c/prace_s_pameti/../promenne/promenne.html">promÄ›nnÃ¡</a>). NedÃ¡vÃ¡ tedy smysl pouÅ¾Ã­t nÄ›co jako <code>&amp;5</code>, protoÅ¾e 5 je
ÄÃ­slo, kterÃ© nemÃ¡ samo o sobÄ› Å¾Ã¡dnou adresu v pamÄ›ti.</p>
<p>PÅ™i pouÅ¾itÃ­ tohoto operÃ¡toru je takÃ© tÅ™eba dÃ¡vat si pozor na to, aby hodnota v pamÄ›ti, jejÃ­Å¾
adresu pouÅ¾itÃ­m <code>&amp;</code> zÃ­skÃ¡me, stÃ¡le existovala, kdyÅ¾ se budeme pozdÄ›ji snaÅ¾it k tÃ©to adrese
pomocÃ­ ukazatele pÅ™istoupit. V opaÄnÃ©m pÅ™Ã­padu by mohlo dojÃ­t k
<a href="c/prace_s_pameti/../../caste_chyby/pametove_chyby.html#segmentation-fault">pamÄ›Å¥ovÃ© chybÄ›</a> ğŸ’£.</p>
</li>
</ul>
<h2><a class="header" href="#pÅ™Ã­stup-k-pamÄ›ti-pomocÃ­-ukazatele" id="pÅ™Ã­stup-k-pamÄ›ti-pomocÃ­-ukazatele">PÅ™Ã­stup k pamÄ›ti pomocÃ­ ukazatele</a></h2>
<p>KdyÅ¾ uÅ¾ mÃ¡me v ukazateli uloÅ¾enou nÄ›jakou (validnÃ­) adresu v pamÄ›ti, tak k tÃ©to pamÄ›ti mÅ¯Å¾eme
pÅ™istoupit pomocÃ­ operÃ¡toru <strong>dereference</strong>. Ten mÃ¡ syntaxi <code>*&lt;vÃ½raz typu ukazatel&gt;</code>. PÅ™i pouÅ¾itÃ­
tohoto operÃ¡toru na ukazateli program pÅ™eÄte adresu v ukazateli, podÃ­vÃ¡ se do pamÄ›ti a naÄte hodnotu
uloÅ¾enou na tÃ©to adrese. Podle toho, na jakÃ½ datovÃ½ typ ukazatel ukazuje, se naÄte odpovÃ­dajÃ­cÃ­
poÄet bytÅ¯ z pamÄ›ti:</p>
<pre><code class="language-c editable mainbody">#include &lt;stdio.h&gt;

int main() {
    int cislo = 1;
    int* ukazatel = &amp;cislo;

    printf(&quot;%p\n&quot;, ukazatel);
    printf(&quot;%d\n&quot;, *ukazatel);
    printf(&quot;%d\n&quot;, cislo);

    return 0;
}
</code></pre>
<p>V tomto programu se do promÄ›nnÃ© <code>ukazatel</code> uloÅ¾Ã­ adresa promÄ›nnÃ© <code>cislo</code>, a potÃ© dojde k naÄtenÃ­
hodnoty (<code>*ukazatel</code>) tÃ©to promÄ›nnÃ© z pamÄ›ti pÅ™es adresu uloÅ¾enou v ukazateli.</p>
<details>
  <summary>InteraktivnÃ­ vizualizace kÃ³du</summary>
<iframe width="750" height="500" frameborder="0" src="https://pythontutor.com/iframe-embed.html#code=%23include%20%3Cstdio.h%3E%0A%0Aint%20main%28%29%20%7B%0A%20%20%20%20int%20cislo%20%3D%201%3B%0A%20%20%20%20int*%20ukazatel%20%3D%20%26cislo%3B%0A%0A%20%20%20%20printf%28%22%25p%5Cn%22,%20ukazatel%29%3B%0A%20%20%20%20printf%28%22%25d%5Cn%22,%20*ukazatel%29%3B%0A%20%20%20%20printf%28%22%25d%5Cn%22,%20cislo%29%3B%0A%0A%20%20%20%20return%200%3B%0A%7D%0A&codeDivHeight=400&codeDivWidth=350&curInstr=5&origin=opt-frontend.js&py=c_gcc9.3.0&rawInputLstJSON=%5B%5D"> </iframe>
</details>
<p>Pokud chceme do adresy uloÅ¾enÃ© v ukazateli naopak nÄ›jakou hodnotu zapsat, tak mÅ¯Å¾eme operÃ¡tor
dereference pouÅ¾Ã­t takÃ© na levÃ© stranÄ› operÃ¡toru <a href="c/prace_s_pameti/../promenne/promenne.html#z%C3%A1pis">zÃ¡pisu</a>:</p>
<pre><code class="language-c editable mainbody">#include &lt;stdio.h&gt;

int main() {
    int cislo = 1;
    int* ukazatel = &amp;cislo;
    *ukazatel = 5;

    printf(&quot;%d\n&quot;, cislo);

    return 0;
}
</code></pre>
<p>Tento program vypÃ­Å¡e <code>5</code>, protoÅ¾e jsme pomocÃ­ ukazatele zmÄ›nili hodnotu na adrese v pamÄ›ti, kde leÅ¾Ã­
promÄ›nnÃ¡ <code>cislo</code>. KdyÅ¾ pÅ™i vÃ½pisu potÃ© naÄteme hodnotu promÄ›nnÃ© <code>cislo</code>, tak uÅ¾ v nÃ­ bude upravenÃ¡
hodnota.</p>
<details>
  <summary>InteraktivnÃ­ vizualizace kÃ³du</summary>
<iframe width="750" height="500" frameborder="0" src="https://pythontutor.com/iframe-embed.html#code=%23include%20%3Cstdio.h%3E%0A%0Aint%20main%28%29%20%7B%0A%20%20%20%20int%20cislo%20%3D%201%3B%0A%20%20%20%20int*%20ukazatel%20%3D%20%26cislo%3B%0A%20%20%20%20*ukazatel%20%3D%205%3B%0A%0A%20%20%20%20printf%28%22%25d%5Cn%22,%20cislo%29%3B%0A%0A%20%20%20%20return%200%3B%0A%7D&codeDivHeight=400&codeDivWidth=350&curInstr=0&origin=opt-frontend.js&py=c_gcc9.3.0&rawInputLstJSON=%5B%5D"> </iframe>
</details>
<p>Pokud provÃ¡dÃ­te operace s pÅ™Ã­mo s promÄ›nnou ukazatele, budete vÅ¾dy pracovat &quot;pouze&quot; s adresou,
kterÃ¡ je v nÄ›m uloÅ¾ena. Pokud chcete naÄÃ­st nebo zmÄ›nit hodnotu, kterÃ¡ leÅ¾Ã­ v pamÄ›ti na adrese
uloÅ¾enÃ© v ukazateli, musÃ­te pouÅ¾Ã­t operÃ¡tor dereference.</p>
<blockquote>
<p>Pozor na rozdÃ­l mezi <code>*</code> pouÅ¾Ã­vanou pro deklaraci datovÃ©ho typu ukazatel, operÃ¡torem dereference
a operÃ¡torem nÃ¡sobenÃ­. VÅ¡echny tyto vÄ›ci sice pouÅ¾Ã­vajÃ­ hvÄ›zdiÄku, ale jinak spolu nesouvisÃ­.
VÅ¾dy zÃ¡leÅ¾Ã­ na kontextu, kde jsou tyto znaky pouÅ¾ity:</p>
<pre><code class="language-c">// hvÄ›zdiÄka Å™Ã­kÃ¡, Å¾e datovÃ½ typ promÄ›nnÃ© `p` je ukazatel na `int`
int* p;

// hvÄ›zdiÄka provede dereferenci nÃ¡vratovÃ© hodnoty funkce `vrat_ukazatel`
int x = *vrat_ukazatel();

// hvÄ›zdiÄka provede nÃ¡sobenÃ­ dvou ÄÃ­sel
int a = 5 * 6;
</code></pre>
</blockquote>
<h2><a class="header" href="#aritmetika-s-ukazateli" id="aritmetika-s-ukazateli">Aritmetika s ukazateli</a></h2>
<p>Abychom se mohli v pamÄ›ti &quot;posouvat&quot; o urÄitÃ½ kus dopÅ™edu Äi dozadu (relativnÄ› k nÄ›jakÃ© adrese),
mÅ¯Å¾eme k ukazatelÅ¯m pÅ™iÄÃ­tat Äi odÄÃ­tat ÄÃ­sla. Toto se oznaÄuje jako <strong>aritmetika s ukazateli</strong>
(<em>pointer arithmetic</em>). Tato aritmetika mÃ¡ dÅ¯leÅ¾itÃ© pravidlo â€“ pokud k ukazateli na konkrÃ©tnÃ­ datovÃ½
typ pÅ™iÄteme hodnotu <code>n</code>, tak se adresa v ukazateli zvÃ½Å¡Ã­ o <code>n</code>-nÃ¡sobek velikosti datovÃ©ho typu,
na kterÃ½ ukazatel ukazuje. PÅ™i aritmetice s ukazateli se tak neposouvÃ¡me po jednotlivÃ½ch bytech,
ale po celÃ½ch hodnotÃ¡ch danÃ©ho datovÃ©ho typu<sup class='margin-toggle sidenote-number'>4</sup>.</p>
<span class='sidenote'><p><sup class='number'>4</sup>Z toho vyplÃ½vÃ¡, Å¾e aritmetiku nemÅ¯Å¾eme provÃ¡dÄ›t nad ukazateli typu <code>void*</code>, protoÅ¾e ty neukazujÃ­
na Å¾Ã¡dnÃ½ konkrÃ©tnÃ­ datovÃ½ typ.</p>
</span>
<p>NapÅ™Ã­klad, pokud bychom mÄ›li ukazatel <code>int* p</code> s hodnotou <code>16</code> (tj. &quot;ukazuje&quot; na adresu <code>16</code>) a
velikost <code>int</code>u by byla <code>4</code>, tak vÃ½raz <code>p + 1</code> bude ukazatel s hodnotou <code>20</code>, vÃ½raz <code>p + 2</code> bude
ukazatel s adresou <code>24</code> atd.</p>
<p>Je dÅ¯leÅ¾itÃ© <a href="c/prace_s_pameti/../../caste_chyby/caste_chyby.html#%C5%A0patn%C3%A1-pr%C3%A1ce-s-ukazatelem">rozliÅ¡ovat</a>, jestli pÅ™i
pouÅ¾itÃ­ sÄÃ­tÃ¡nÃ­/odÄÃ­tÃ¡nÃ­ pracujeme s hodnotou ukazatele anebo s hodnotou na adrese, kterÃ¡ je v
ukazateli uloÅ¾ena:</p>
<pre><code class="language-c">int x = 1;
int* p = &amp;x;

*p += 1;    // zvÃ½Å¡ili jsme hodnotu na adrese v `p` (tj. promÄ›nnou `x`) o `1`
p += 1;     // zvÃ½Å¡ili jsme adresu v `p` o `4` (tj. p nynÃ­ uÅ¾ neukazuje na `x`)
</code></pre>
<blockquote>
<p>K Äemu je aritmetika s ukazateli uÅ¾iteÄnÃ¡ se dozvÃ­te v sekci o prÃ¡ci s
<a href="c/prace_s_pameti/../pole/staticka_pole.html#p%C5%99%C3%ADstup-k-prvk%C5%AFm-pole">vÃ­ce promÄ›nnÃ½mi zÃ¡roveÅˆ</a>.</p>
</blockquote>
<p>KromÄ› dereference a aritmetiky lze s ukazateli provÃ¡dÄ›t takÃ© porovnÃ¡vÃ¡nÃ­ (klasicky pomocÃ­ operÃ¡toru
<code>==</code>). DÃ­ky tomu mÅ¯Å¾eme zjistit, jestli se dvÄ› adresy rovnajÃ­.</p>
<h2><a class="header" href="#vyuÅ¾itÃ­-ukazatelÅ¯" id="vyuÅ¾itÃ­-ukazatelÅ¯">VyuÅ¾itÃ­ ukazatelÅ¯</a></h2>
<p>Jak se dozvÃ­te v <a href="c/prace_s_pameti/dynamicka_pamet.html">nÃ¡sledujÃ­cÃ­ sekci</a>, ukazatele jsou nezbytnÃ© pro
dynamickou alokaci pamÄ›ti. HodÃ­ se takÃ© pÅ™i prÃ¡ci s <a href="c/prace_s_pameti/../pole/pole.html">vÃ­ce promÄ›nnÃ½mi</a> zÃ¡roveÅˆ. KromÄ›
toho je ale lze pouÅ¾Ã­t takÃ© napÅ™Ã­klad v nÃ¡sledujÃ­cÃ­ch situacÃ­ch, kterÃ© vÅ¡echny souvisÃ­ s pÅ™edÃ¡vÃ¡nÃ­m
adres (ukazatelÅ¯) do funkcÃ­:</p>
<ul>
<li>
<p><strong>ZmÄ›na vnÄ›jÅ¡Ã­ch hodnot zevnitÅ™ funkce</strong> Hodnoty argumentÅ¯ pÅ™edÃ¡vanÃ½ch pÅ™i
<a href="c/prace_s_pameti/../funkce/funkce.html#parametrizace-funkc%C3%AD">volÃ¡nÃ­ funkcÃ­</a> se do funkce kopÃ­rujÃ­, nelze tak jednoduÅ¡e
zevnitÅ™ funkce mÄ›nit hodnoty promÄ›nnÃ½ch, kterÃ© existujÃ­ mimo danou funkci. To je sice samo o sobÄ›
vhodnÃ¡ vlastnost, protoÅ¾e pokud bude funkce mÄ›nit pouze svÃ© lokÃ¡lnÃ­ promÄ›nnÃ©, pÅ™Ã­padnÄ› parametry,
tak bude jednoduÅ¡Å¡Ã­ se v nÃ­ vyznat. NicmÃ©nÄ›, nÄ›kdy opravdu chceme ve funkci zmÄ›nit hodnoty externÃ­ch
promÄ›nnÃ½ch.</p>
<p>Toho mÅ¯Å¾eme dosÃ¡hnout tak, Å¾e si do funkce mÃ­sto hodnoty promÄ›nnÃ© poÅ¡leme jejÃ­ adresu v
ukazateli, a pomocÃ­ tÃ©to adresy pak hodnotu promÄ›nnÃ© zmÄ›nÃ­me. Takto napÅ™Ã­klad mÅ¯Å¾eme vytvoÅ™it funkci,
kterÃ¡ vezme adresy dvou promÄ›nnÃ½ch a prohodÃ­ jejich hodnoty:</p>
<pre><code class="language-c editable">#include &lt;stdio.h&gt;

void vymen(int* a, int* b) {
    int docasna_hodnota = *a;  // naÄti hodnotu na adrese v `a`
    *a = *b;  // naÄti hodnotu na adrese v `b` a uloÅ¾ ji na adresu v `a`
    *b = docasna_hodnota;  // uloÅ¾ uloÅ¾enou hodnotu na adresu v `b`
}
int main() {
    int x = 5;
    int y = 10;
    vymen(&amp;x, &amp;y);
    printf(&quot;Po prehozeni: x=%d, y=%d\n&quot;, x, y);
    return 0;
}
</code></pre>
<details>
  <summary>InteraktivnÃ­ vizualizace kÃ³du</summary>
<iframe width="750" height="500" frameborder="0" src="https://pythontutor.com/iframe-embed.html#code=%23include%20%3Cstdio.h%3E%0Avoid%20vymen%28int*%20a,%20int*%20b%29%20%7B%0A%20%20%20%20int%20docasna_hodnota%20%3D%20*a%3B%0A%20%20%20%20*a%20%3D%20*b%3B%0A%20%20%20%20*b%20%3D%20docasna_hodnota%3B%0A%7D%0Aint%20main%28%29%20%7B%0A%20%20%20%20int%20x%20%3D%205%3B%0A%20%20%20%20int%20y%20%3D%2010%3B%0A%20%20%20%20vymen%28%26x,%20%26y%29%3B%0A%20%20%20%20printf%28%22Po%20prehozeni%3A%20x%3D%25d,%20y%3D%25d%5Cn%22,%20x,%20y%29%3B%0A%20%20%20%20return%200%3B%0A%7D&codeDivHeight=400&codeDivWidth=350&curInstr=12&origin=opt-frontend.js&py=c_gcc9.3.0&rawInputLstJSON=%5B%5D"> </iframe>
</details>
</li>
<li>
<p><strong>VrÃ¡cenÃ­ vÃ­ce nÃ¡vratovÃ½ch hodnot</strong> PosÃ­lÃ¡nÃ­ adres promÄ›nnÃ½ch do funkce mÅ¯Å¾eme vyuÅ¾Ã­t takÃ© k
tomu, abychom z funkce vrÃ¡tili vÃ­ce neÅ¾ jednu nÃ¡vratovou hodnotu (do adres uloÅ¾enÃ½ch v parametrech
totiÅ¾ mÅ¯Å¾eme zapsat &quot;nÃ¡vratovÃ©&quot; hodnoty). Toho bychom vÅ¡ak mÄ›li vyuÅ¾Ã­vat pouze, pokud je to opravdu
nezbytnÃ©. TakovÃ©to funkce je totiÅ¾ sloÅ¾itÄ›jÅ¡Ã­ volat a nejsou
<a href="c/prace_s_pameti/../funkce/funkce.html#pro%C4%8D-n%C3%A1zev-funkce">ÄistÃ©</a>, protoÅ¾e obsahujÃ­ vedlejÅ¡Ã­ efekt - mÄ›nÃ­ externÃ­ stav
programu.</p>
<pre><code class="language-c editable">#include &lt;stdio.h&gt;

void vrat_dve_hodnoty(int* a, int* b) {
    *a = 5;
    *b = 6;
}

int main() {
    int a = 0;
    int b = 0;
    vrat_dve_hodnoty(&amp;a, &amp;b);

    printf(&quot;a=%d, b=%d\n&quot;, a, b);

    return 0;
}
</code></pre>
</li>
<li>
<p><strong>SdÃ­lenÃ­ hodnot bez kopÃ­rovÃ¡nÃ­</strong> Pokud bychom mÄ›li promÄ›nnÃ©, kterÃ© v pamÄ›ti zabÃ­rajÃ­ velkÃ©
mnoÅ¾stvÃ­ bytÅ¯ (napÅ™Ã­klad <a href="c/prace_s_pameti/../struktury/struktury.html">struktury</a>), a pÅ™edÃ¡vali je jako argumenty
funkci, tak mÅ¯Å¾e bÃ½t zbyteÄnÄ› pomalÃ© je pokaÅ¾dÃ© kopÃ­rovat. Pokud do funkce pouze pÅ™edÃ¡me jejich
adresu, tak dojde ke kopii pouze jednoho ÄÃ­sla s adresou, nezÃ¡visle na tom, jak velkÃ¡ je promÄ›nnÃ¡,
kterÃ¡ je na danÃ© adrese uloÅ¾ena. Ukazatele tak mÅ¯Å¾eme pouÅ¾Ã­t ke sdÃ­lenÃ­ hodnot v pamÄ›ti mezi funkcemi
bez toho, abychom je kopÃ­rovali.</p>
</li>
</ul>
<h2><a class="header" href="#konstantnÃ­-ukazatele" id="konstantnÃ­-ukazatele">KonstantnÃ­ ukazatele</a></h2>
<p>Pokud pouÅ¾ijeme klÃ­ÄovÃ© slovo <a href="c/prace_s_pameti/../promenne/konstanty.html"><code>const</code></a> v kombinaci s ukazateli, je
potÅ™eba si dÃ¡vat pozor na to, k Äemu se tohle klÃ­ÄovÃ© slovo vÃ¡Å¾e. To zÃ¡visÃ­ na tom, zda je <code>const</code>
v datovÃ©m typu pÅ™ed nebo za hvÄ›zdiÄkou. Zde jsou moÅ¾nÃ© kombinace, kterÃ© mÅ¯Å¾ou vzniknout u
jednoduchÃ©ho ukazatele:</p>
<ul>
<li><code>int*</code> - ukazatel na celÃ© ÄÃ­slo. Adresu v ukazateli lze mÄ›nit, hodnotu ÄÃ­sla na adrese v ukazateli
takÃ© lze mÄ›nit.</li>
<li><code>const int*</code> - ukazatel na konstantnÃ­ celÃ© ÄÃ­slo. Adresu v ukazateli lze mÄ›nit, hodnotu ÄÃ­sla na
adrese v ukazateli nikoliv.</li>
<li><code>int const *</code> - konstantnÃ­ ukazatel na celÃ© ÄÃ­slo. Adresu v ukazateli nelze mÄ›nit, hodnotu ÄÃ­sla na
adrese v ukazateli lze mÄ›nit.</li>
<li><code>const int const *</code> - konstantnÃ­ ukazatel na konstantnÃ­ celÃ© ÄÃ­slo. Adresu v ukazateli nelze mÄ›nit,
hodnotu ÄÃ­sla na adrese v ukazateli takÃ© nelze mÄ›nit.</li>
</ul>
<h2><a class="header" href="#definice-vÃ­ce-ukazatelÅ¯-najednou" id="definice-vÃ­ce-ukazatelÅ¯-najednou">Definice vÃ­ce ukazatelÅ¯ najednou</a></h2>
<p>Pokud byste chtÄ›li vytvoÅ™it vÃ­ce ukazatelÅ¯
<a href="c/prace_s_pameti/../promenne/promenne.html#definice-v%C3%ADce-prom%C4%9Bnn%C3%BDch-najednou">najednou</a>, musÃ­te si dÃ¡t pozor na to, Å¾e
v tomto pÅ™Ã­padÄ› se hvÄ›zdiÄka vztahuje pouze k jednomu nÃ¡sledujÃ­cÃ­mu nÃ¡zvu promÄ›nnÃ©. Tento kÃ³d tak
vytvoÅ™Ã­ ukazatel s nÃ¡zvem <code>x</code>, a dvÄ› celÃ¡ ÄÃ­sla s nÃ¡zvy <code>y</code> a <code>z</code>:</p>
<pre><code class="language-c">int* x, y, z;
</code></pre>
<p>Pokud byste chtÄ›li vytvoÅ™it tÅ™i ukazatele, musÃ­te dÃ¡t hvÄ›zdiÄku pÅ™ed kaÅ¾dÃ½ nÃ¡zev promÄ›nnÃ©:</p>
<pre><code class="language-c">int* x, *y, *z;
</code></pre>
<hr />
<p><strong>KvÃ­z</strong> ğŸ¤”</p>
<ol>
<li>
<p>Co vypÃ­Å¡e nÃ¡sledujÃ­cÃ­ program?</p>
<pre><code class="language-c editable mainbody">#include &lt;stdio.h&gt;

int main() {
    int a = 2;
    int* p = &amp;a;
    p = 5;

    printf(&quot;%d\n&quot;, a);

    return 0;
}
</code></pre>
<details>
 <summary>OdpovÄ›Ä</summary>
<p>Program vypÃ­Å¡e <code>2</code>. PÅ™iÅ™azenÃ­m <code>p = 5</code> zmÄ›nÃ­me adresu uloÅ¾enou v ukazateli <code>p</code> na <code>5</code>. Touto
operacÃ­ se tedy nijak nezmÄ›nÃ­ hodnota promÄ›nnÃ© <code>a</code>, jejÃ­Å¾ adresu ukazatel pÅ™ed tÃ­mto pÅ™iÅ™azenÃ­m
obsahoval. Aby k tomuto doÅ¡lo, museli bychom napsat <code>*p = 5</code>.</p>
</details>
</li>
<li>
<p>Co vypÃ­Å¡e nÃ¡sledujÃ­cÃ­ program?</p>
<pre><code class="language-c editable mainbody">#include &lt;stdio.h&gt;

int main() {
    int a = 2;
    int b = 3;

    int* p = &amp;a;
    p = &amp;b;

    *p += 1;

    printf(&quot;a = %d, b = %d\n&quot;, a, b);

    return 0;
}
</code></pre>
<details>
 <summary>OdpovÄ›Ä</summary>
<p>Program vypÃ­Å¡e <code>a = 2, b = 4</code>. Nejprve jsme sice nastavili ukazatel <code>p</code> na adresu promÄ›nnÃ© <code>a</code>,
ale potÃ© jsme do <code>p</code> zapsali adresu promÄ›nnÃ© <code>b</code>. Å˜Ã¡dek <code>*p += 1;</code> tak zvedne hodnotu v pamÄ›ti
na adrese, kde leÅ¾Ã­ <code>b</code>, o jedniÄku, jinak Å™eÄeno zvÃ½Å¡Ã­ hodnotu promÄ›nnÃ© <code>b</code> o jedniÄku.</p>
</details>
</li>
<li>
<p>Co vypÃ­Å¡e nÃ¡sledujÃ­cÃ­ program?</p>
<pre><code class="language-c editable mainbody">#include &lt;stdio.h&gt;

void zmen_ukazatel(int* p, int a) {
    p = &amp;a;
}

int main() {
    int a = 2;
    int b = 3;

    int* p = &amp;b;
    zmen_ukazatel(p, a);

    printf(&quot;%d\n&quot;, *p);

    return 0;
}
</code></pre>
<details>
 <summary>OdpovÄ›Ä</summary>
<p>Program vypÃ­Å¡e <code>3</code>. KdyÅ¾ pÅ™edÃ¡me argument typu ukazatele do funkce, tak stejnÄ› jako u jinÃ½ch datovÃ½ch
typÅ¯ dojde k tomu, Å¾e se ve funkci vytvoÅ™Ã­ novÃ¡ promÄ›nnÃ¡ a do nÃ­ se nakopÃ­ruje hodnota argumentu.
ZmÄ›na adresy v ukazateli <code>p</code> uvnitÅ™ funkce <code>zmen_ukazatel</code> tak neovlivnÃ­ adresu v ukazateli <code>p</code>
uvnitÅ™ funkce <code>main</code>. A jelikoÅ¾ <code>p</code> v <code>main</code>u ukazuje na promÄ›nnou <code>b</code>, tak dereference tohoto
ukazatele se vyhodnotÃ­ jako hodnota <code>3</code>.</p>
</details>
</li>
<li>
<p>Co vypÃ­Å¡e nÃ¡sledujÃ­cÃ­ program?</p>
<pre><code class="language-c editable mainbody">#include &lt;stdio.h&gt;

int main() {
    int a = 2;

    int* p = &amp;a;
    *p = 4;

    int b = *p;
    *p = 8;

    printf(&quot;a = %d, b = %d\n&quot;, a, b);

    return 0;
}
</code></pre>
<details>
 <summary>OdpovÄ›Ä</summary>
<p>Program vypÃ­Å¡e <code>a = 8, b = 4</code>. PÅ™i vytvÃ¡Å™enÃ­ promÄ›nnÃ© <code>b</code> se hodnota na adrese uloÅ¾enÃ© v ukazateli
<code>p</code> uloÅ¾Ã­ do <code>b</code>. V danou chvÃ­li je na tÃ©to adrese uloÅ¾ena hodnota <code>4</code>, proto se do promÄ›nnÃ© <code>b</code>
uloÅ¾Ã­ prÃ¡vÄ› hodnota <code>4</code>. DalÅ¡Ã­ zmÄ›ny hodnot na adrese uloÅ¾enÃ© v <code>p</code> uÅ¾ promÄ›nnou <code>b</code> neovlivnÃ­.</p>
</details>
</li>
<li>
<p>Co vypÃ­Å¡e nÃ¡sledujÃ­cÃ­ program?</p>
<pre><code class="language-c editable mainbody">#include &lt;stdio.h&gt;

int main() {
    int a = 2;
    int* p = &amp;a;

    printf(&quot;%d\n&quot;, p);

    return 0;
}
</code></pre>
<details>
 <summary>OdpovÄ›Ä</summary>
<p>Tento program obsahuje <a href="c/prace_s_pameti/../../ruzne/nedefinovane_chovani.html"><strong>nedefinovanÃ© chovÃ¡nÃ­</strong></a> ğŸ’£, protoÅ¾e jsme pouÅ¾ili
<a href="c/prace_s_pameti/../prikazy_vyrazy.html#v%C3%BDpis-v%C3%BDraz%C5%AF">zÃ¡stupnÃ½ znak</a> <code>%d</code>, kterÃ½ slouÅ¾Ã­ k vÃ½pisu celÃ½ch ÄÃ­sel, ale
pÅ™edali jsme funkci <code>printf</code> argument <code>p</code>, kterÃ½ je datovÃ©ho typu ukazatel.</p>
<p>SprÃ¡vnÄ› mÅ¯Å¾eme buÄ pouÅ¾Ã­t zÃ¡stupnÃ½ znak <code>%p</code>, abychom vypsali adresu uloÅ¾enou v ukazateli, nebo
mÅ¯Å¾eme pouÅ¾Ã­t dereferenci a vypsat hodnotu uloÅ¾enou na adrese v ukazateli:</p>
<pre><code class="language-c">printf(&quot;%p\n&quot;, p);
printf(&quot;%d\n&quot;, *p);
</code></pre>
</details>
</li>
<li>
<p>Co vypÃ­Å¡e nÃ¡sledujÃ­cÃ­ program?</p>
<pre><code class="language-c editable mainbody">#include &lt;stdio.h&gt;

int main() {
    int a = 2;
    int b = 3;

    int* p = &amp;a;
    int** px = &amp;p;
    *px = &amp;b;

    *p = 8;

    printf(&quot;a = %d, b = %d\n&quot;, a, b);

    return 0;
}
</code></pre>
<details>
 <summary>OdpovÄ›Ä</summary>
<p>Program vypÃ­Å¡e <code>a = 2, b = 8</code>. PromÄ›nnÃ¡ <code>px</code> je ukazatel na ukazatel na <code>int</code>. Obsahuje adresu,
kde v pamÄ›ti leÅ¾Ã­ promÄ›nnÃ¡ <code>p</code>. PomocÃ­ <code>*px</code> zmÄ›nÃ­me hodnotu na tÃ©to adrese na <code>&amp;b</code>, tj. adresu
promÄ›nnÃ© <code>b</code>. V podstatÄ› je to to stejnÃ©, jako kdybychom napsali <code>p = &amp;b</code>.</p>
<p>Zkuste si na papÃ­r nakreslit, jak tento program bude vypadat v pamÄ›ti, jakÃ© adresy/hodnoty budou
v jednotlivÃ½ch promÄ›nnÃ½ch. VÃ½sledek si mÅ¯Å¾ete ovÄ›Å™it <a href="https://pythontutor.com/render.html#code=%23include%20%3Cstdio.h%3E%0A%0Aint%20main%28%29%20%7B%0A%20%20%20%20int%20a%20%3D%202%3B%0A%20%20%20%20int%20b%20%3D%203%3B%0A%0A%20%20%20%20int*%20p%20%3D%20%26a%3B%0A%20%20%20%20int**%20px%20%3D%20%26p%3B%0A%20%20%20%20*px%20%3D%20%26b%3B%0A%0A%20%20%20%20*p%20%3D%208%3B%0A%0A%20%20%20%20printf%28%22a%20%3D%20%25d,%20b%20%3D%20%25d%5Cn%22,%20a,%20b%29%3B%0A%0A%20%20%20%20return%200%3B%0A%7D&amp;cumulative=false&amp;curInstr=9&amp;heapPrimitives=nevernest&amp;mode=display&amp;origin=opt-frontend.js&amp;py=c_gcc9.3.0&amp;rawInputLstJSON=%5B%5D&amp;textReferences=false">touto</a>
vizualizacÃ­.</p>
</details>
</li>
</ol>
<h1><a class="header" href="#ukazatele-na-funkce" id="ukazatele-na-funkce">Ukazatele na funkce</a></h1>
<blockquote>
<p>ğŸ¤“ Tato sekce obsahuje doplÅˆujÃ­cÃ­ uÄivo. Pokud je toho na vÃ¡s moc, mÅ¯Å¾ete ji prozatÃ­m pÅ™eskoÄit
a vrÃ¡tit se k nÃ­ pozdÄ›ji.</p>
</blockquote>
<p>Ve funkcionÃ¡lnÃ­ch jazycÃ­ch<sup class='margin-toggle sidenote-number'>1</sup> mÅ¯Å¾eme <a href="c/prace_s_pameti/../funkce/funkce.html">funkce</a> pouÅ¾Ã­vat jako kterÃ©koliv jinÃ©
hodnoty a provÃ¡dÄ›t tak s nimi operace jako je uloÅ¾enÃ­ funkce do promÄ›nnÃ©, pÅ™edÃ¡nÃ­ funkce jako
argument jinÃ© funkci, vrÃ¡cenÃ­ funkce jako nÃ¡vratovÃ© hodnoty z jinÃ© funkce atd. V <em>C</em> tyto operace
s funkcemi pÅ™Ã­mo provÃ¡dÄ›t nemÅ¯Å¾eme, nicmÃ©nÄ› toto omezenÃ­ lze alespoÅˆ ÄÃ¡steÄnÄ› obejÃ­t pouÅ¾itÃ­m
<strong>ukazatele na funkci</strong> (<em>function pointer</em>).</p>
<span class='sidenote'><p><sup class='number'>1</sup>Jako je napÅ™. <a href="https://www.haskell.org/">Haskell</a>.</p>
</span>
<p>Ukazatel na funkci je ÄÃ­slo, kterÃ© neinterpretujeme jako adresu nÄ›jakÃ© hodnoty, ale jako
adresu kÃ³du (tedy pÅ™eloÅ¾enÃ½ch instrukcÃ­) funkce v pamÄ›ti bÄ›Å¾Ã­cÃ­ho programu. Tyto ukazatele se od
bÄ›Å¾nÃ½ch ukazatelÅ¯ liÅ¡Ã­ tÃ­m, Å¾e pouÅ¾Ã­vajÃ­ jinou syntaxi a takÃ© umoÅ¾ÅˆujÃ­ zavolat funkci, jejÃ­Å¾ adresa
je v ukazateli uloÅ¾ena.</p>
<h2><a class="header" href="#syntaxe-1" id="syntaxe-1">Syntaxe</a></h2>
<p>Syntaxe datovÃ©ho typu ukazatele na funkci vychÃ¡zÃ­ ze syntaxe <a href="c/prace_s_pameti/../funkce/funkce.html#syntaxe">signatury funkce</a>
a vypadÃ¡ takto:</p>
<pre><code class="language-c">&lt;datovÃ½ typ&gt; (*)(&lt;parametr 1&gt;, &lt;parametr 2&gt;, ...)
</code></pre>
<p>Zde je nÄ›kolik ukÃ¡zek:</p>
<ul>
<li>Ukazatel na funkci, kterÃ¡ vracÃ­ <code>int</code> a bere parametr <code>int</code>: <code>int (*)(int)</code></li>
<li>Ukazatel na funkci, kterÃ¡ vracÃ­ <code>int</code> a bere parametry <code>int</code> a <code>bool</code>: <code>int (*)(int, bool)</code></li>
<li>Ukazatel na funkci, kterÃ¡ nic nevracÃ­ a nemÃ¡ Å¾Ã¡dnÃ© parametry: <code>void (*)()</code></li>
</ul>
<p>Ukazatel na funkci tak v podstatÄ› odpovÃ­dÃ¡ signatuÅ™e funkce, na kterou ukazuje, s tÃ­m rozdÃ­lem,
Å¾e mÃ­sto nÃ¡zvu funkce obsahuje znaky <code>(*)</code>.</p>
<p>JelikoÅ¾ v definici ukazatele na funkci jsou dÅ¯leÅ¾itÃ© hlavnÄ› datovÃ© typy parametrÅ¯, nemusÃ­te jednotlivÃ©
parametry pojmenovÃ¡vat. Pokud ale chcete kÃ³d uÄinit pÅ™ehlednÄ›jÅ¡Ã­, mÅ¯Å¾ete jim dÃ¡t jmÃ©na:</p>
<pre><code class="language-c">int (*)(int mocnina, int mocnitel); 
</code></pre>
<h2><a class="header" href="#pouÅ¾itÃ­-v-promÄ›nnÃ©" id="pouÅ¾itÃ­-v-promÄ›nnÃ©">PouÅ¾itÃ­ v promÄ›nnÃ©</a></h2>
<p>Pokud chcete vytvoÅ™it promÄ›nnou (Äi parametr) datovÃ©ho typu ukazatel na funkce, tak musÃ­te pouÅ¾Ã­t
speciÃ¡lnÃ­ syntaxi. BÄ›Å¾nÄ› pÅ™i vytvÃ¡Å™enÃ­ promÄ›nnÃ© nejprve napÃ­Å¡eme jejÃ­ datovÃ½ typ a potÃ© jejÃ­ nÃ¡zev.
U ukazatele na funkci se vÅ¡ak nÃ¡zev promÄ›nnÃ© nepÃ­Å¡e aÅ¾ za datovÃ½ typ, ale dovnitÅ™ zÃ¡vorek s hvÄ›zdiÄkou.
Takto lze vytvoÅ™it promÄ›nnou s nÃ¡zvem <code>ukazatel1</code>, do kterÃ© pÅ¯jde uloÅ¾it adresu funkcÃ­, kterÃ© vracÃ­ <code>int</code>
a berou dva parametry, oba typu <code>int</code>:</p>
<pre><code class="language-c">int (*ukazatel1)(int, int);
</code></pre>
<h2><a class="header" href="#inicializace-a-volÃ¡nÃ­-funkce" id="inicializace-a-volÃ¡nÃ­-funkce">Inicializace a volÃ¡nÃ­ funkce</a></h2>
<p>Pokud chcete nastavit do ukazatele na funkci nÄ›jakou hodnotu, staÄÃ­ do nÄ›j pÅ™iÅ™adit nÃ¡zev existujÃ­cÃ­
funkce.</p>
<pre><code class="language-c">int funkce(int x) {
    return x + 1;
}

int main() {
    int (*ukazatel)(int) = funkce;

    return 0;
}
</code></pre>
<p>Signatura pÅ™iÅ™azenÃ© funkce musÃ­ odpovÃ­dat datovÃ©mu typu ukazatele, nelze tak napÅ™Ã­klad pÅ™iÅ™adit
funkci, kterÃ¡ nic nevracÃ­, do ukazatele, kterÃ½ mÃ¡ signaturu <code>int (*)()</code>.</p>
<p>Jakmile mÃ¡me v promÄ›nnÃ© ukazatele na funkci uloÅ¾enou adresu nÄ›jakÃ© funkce, mÅ¯Å¾eme pomocÃ­ nÃ¡zvu tÃ©to
promÄ›nnÃ© danou funkci zavolat.</p>
<pre><code class="language-c editable">#include &lt;stdio.h&gt;

int funkce(int x) {
    printf(&quot;Funkce zavolana s parametrem %d\n&quot;, x);
    return x + 1;
}

int main() {
    int (*ukazatel)(int) = funkce;
    
    int ret = ukazatel(1);
    printf(&quot;Funkce vratila %d\n&quot;, ret);

    return 0;
}
</code></pre>
<h2><a class="header" href="#pÅ™Ã­pady-pouÅ¾itÃ­" id="pÅ™Ã­pady-pouÅ¾itÃ­">PÅ™Ã­pady pouÅ¾itÃ­</a></h2>
<p>K Äemu vlastnÄ› ukazatel na funkce mÅ¯Å¾e slouÅ¾it? UÅ¾ vÃ­me, Å¾e pomocÃ­ funkcÃ­ mÅ¯Å¾eme
<a href="c/prace_s_pameti/../funkce/funkce.html#parametrizace-funkc%C3%AD">parametrizovat</a> kÃ³d, coÅ¾ nÃ¡m umoÅ¾Åˆuje pouÅ¾Ã­vat identickÃ½
kÃ³d nad rÅ¯znÃ½mi vstupnÃ­mi hodnotami bez toho, abychom tento kÃ³d museli neustÃ¡le duplikovat.</p>
<p>ProzatÃ­m jsme pro parametrizaci pouÅ¾Ã­vali pouze jednoduchÃ© hodnoty, jako ÄÃ­sla nebo pravdivostnÃ­
hodnoty. PomocÃ­ ukazatelÅ¯ na funkce vÅ¡ak mÅ¯Å¾eme parametrizovat samotnÃ½ kÃ³d, kterÃ½ se mÃ¡ uvnitÅ™
nÄ›jakÃ© funkce provÃ©st.</p>
<p>PÅ™edstavte si napÅ™Ã­klad, Å¾e chcete vytvoÅ™it funkci, kterÃ¡ provede nÄ›jakou operaci (napÅ™. pÅ™iÄtenÃ­
konstanty, vynÃ¡sobenÃ­ konstantou nebo vypsÃ¡nÃ­ na vÃ½stup) s ÄÃ­slem, ale pouze v pÅ™Ã­padÄ›, Å¾e toto ÄÃ­slo
je kladnÃ©. V opaÄnÃ©m pÅ™Ã­padÄ› by mÄ›la funkce toto ÄÃ­slo pouze vrÃ¡tit, bez jakÃ©koliv zmÄ›ny. Jak byste
tuto funkci napsali, bez toho, abyste ji duplikovali pro kaÅ¾dou operaci, kterÃ¡ se mÃ¡ s kladnÃ½m ÄÃ­slem
provÃ©st?</p>
<p>PrvnÃ­ Å™eÅ¡enÃ­ by mohlo vypadat napÅ™Ã­klad takto:</p>
<pre><code class="language-c editable">#include &lt;stdio.h&gt;

int proved_pro_kladne(int cislo, int operace) {
    if (cislo &lt;= 0) return cislo;
    
    if (operace == 0) {
        return cislo * 3;
    } else if (operace == 1) {
        return cislo + 1;
    } else {
        printf(&quot;Cislo: %d\n&quot;, cislo);
        return cislo;
    }
}

int main() {
    printf(&quot;%d\n&quot;, proved_pro_kladne(-1, 0));
    printf(&quot;%d\n&quot;, proved_pro_kladne(1, 0));
    printf(&quot;%d\n&quot;, proved_pro_kladne(1, 1));
    printf(&quot;%d\n&quot;, proved_pro_kladne(1, 2));

    return 0;
}
</code></pre>
<p>Toto Å™eÅ¡enÃ­ jistÄ› bude fungovat, nicmÃ©nÄ› je dost nepraktickÃ©, protoÅ¾e musÃ­me ve funkci
<code>proved_pro_kladne</code> dopÅ™edu vyjmenovat vÅ¡echny moÅ¾nÃ© operace, kterÃ© lze s ÄÃ­slem provÃ©st. Pokud
bychom tak chtÄ›li pÅ™idat novou operaci, budeme muset tuto funkci upravit. ZÃ¡roveÅˆ je takÃ© dost
nepÅ™ehlednÃ© pÅ™edÃ¡vat funkci informaci o tom, jakÃ¡ operace se mÃ¡ provÃ©st, pomocÃ­ promÄ›nnÃ© typu <code>int</code>
(parametr <code>operace</code>).</p>
<p>PomocÃ­ ukazatele na funkci mÅ¯Å¾eme funkci <code>proved_pro_kladne</code> pÅ™edat kÃ³d<sup class='margin-toggle sidenote-number'>2</sup>, kterÃ½ se mÃ¡ provÃ©st,
pokud je pÅ™edanÃ© ÄÃ­slo kladnÃ©. PomocÃ­ toho mÅ¯Å¾eme od sebe oddÄ›lit logiku naÅ¡Ã­ funkce (kontrola,
jestli je ÄÃ­slo kladnÃ© Äi ne) a samotnou operaci, kterÃ¡ se mÃ¡ provÃ©st s kladnÃ½m ÄÃ­slem.
Pokud tak vytvoÅ™Ã­me novou operaci, nemusÃ­me funkci <code>proved_pro_kladne</code> jakkoliv upravovat, staÄÃ­
ji zavolat s jinÃ½m argumentem.</p>
<span class='sidenote'><p><sup class='number'>2</sup>Ve formÄ› adresy funkce.</p>
</span>
<pre><code class="language-c editable">#include &lt;stdio.h&gt;

int proved_pro_kladne(int cislo, int(*operace)(int)) {
    if (cislo &lt;= 0) return cislo;
    return operace(cislo);
}

int vynasob_dvema(int cislo) { return cislo * 2; }
int pricti_jednicku(int cislo) { return cislo + 1; }
int vypis(int cislo) {
    printf(&quot;Cislo: %d\n&quot;, cislo);
    return cislo;
}

int main() {
    printf(&quot;%d\n&quot;, proved_pro_kladne(-1, vynasob_dvema));
    printf(&quot;%d\n&quot;, proved_pro_kladne(1, vynasob_dvema));
    printf(&quot;%d\n&quot;, proved_pro_kladne(1, pricti_jednicku));
    printf(&quot;%d\n&quot;, proved_pro_kladne(1, vypis));

    return 0;
}
</code></pre>
<p>Ukazatele na funkce nÃ¡m umoÅ¾ÅˆujÃ­ vytvÃ¡Å™et kÃ³d, kterÃ½ je vÃ­ce <em>composable</em>, jinak Å™eÄeno lze jej
sklÃ¡dat jako kostky Lega a nenutÃ­ nÃ¡s zadrÃ¡tovat vÅ¡echny moÅ¾nÃ© zpÅ¯soby pouÅ¾itÃ­ dopÅ™edu (jako tomu
bylo v prvnÃ­m Å™eÅ¡enÃ­ s parametrem <code>int operace</code>).</p>
<p>JeÅ¡tÄ› uÅ¾iteÄnÄ›jÅ¡Ã­ jsou ukazatele na funkci v kombinacemi se zpracovÃ¡nÃ­m vÃ­ce hodnot pomocÃ­
<a href="c/prace_s_pameti/../pole/pole.html">polÃ­</a>, kdy mÅ¯Å¾eme napsat obecnou funkci, kterÃ¡ nÄ›jak zpracovÃ¡vÃ¡ pole, a pÅ™edat jÃ­
napÅ™Ã­klad ukazatel na funkci, kterÃ¡ se mÃ¡ zavolat nad kaÅ¾dÃ½m prvkem v poli. HodÃ­ se takÃ© pÅ™i prÃ¡ci
se <a href="c/prace_s_pameti/../struktury/struktury.html">strukturami</a>, kdy mÅ¯Å¾eme do atributu struktury uloÅ¾it ukazatel na
funkci a pÅ™idat tak individuÃ¡lnÃ­ chovÃ¡nÃ­ k rÅ¯znÃ½m hodnotÃ¡m stejnÃ© struktury.</p>
<h1><a class="header" href="#dynamickÃ¡-pamÄ›Å¥" id="dynamickÃ¡-pamÄ›Å¥">DynamickÃ¡ pamÄ›Å¥</a></h1>
<p>UÅ¾ vÃ­me, Å¾e pomocÃ­ <a href="c/prace_s_pameti/automaticka_pamet.html">automatickÃ© pamÄ›ti</a> na zÃ¡sobnÃ­ku nemÅ¯Å¾eme alokovat
velkÃ© mnoÅ¾stvÃ­ pamÄ›ti a nemÅ¯Å¾eme ani alokovat pamÄ›Å¥ s dynamickou velikostÃ­ (zÃ¡vislou na velikosti
vstupu programu). Abychom tohoto dosÃ¡hli, tak musÃ­me pouÅ¾Ã­t jinÃ½ mechanismus alokace pamÄ›ti, ve
kterÃ©m pamÄ›Å¥ alokujeme i uvolÅˆujeme manuÃ¡lnÄ›.</p>
<p>Tento mechanismus se nazÃ½vÃ¡ <strong>dynamickÃ¡ alokace pamÄ›ti</strong> (<em>dynamic memory allocation</em>). PomocÃ­ nÄ›kolika
funkcÃ­ standardnÃ­ knihovny <em>C</em> mÅ¯Å¾eme naalokovat pamÄ›Å¥ s libovolnou velikosti. Tato pamÄ›Å¥ je
alokovÃ¡na v oblasti pamÄ›ti zvanÃ© <strong>halda</strong> (<em>heap</em>). NarozdÃ­l od zÃ¡sobnÃ­ku, prvky na haldÄ› neleÅ¾Ã­
striktnÄ› za sebou, a lze je tak uvolÅˆovat v libovolnÃ©m poÅ™adÃ­. MÅ¯Å¾eme tak naalokovat pamÄ›Å¥ libovolnÃ©
velikosti, kterÃ¡ pÅ™eÅ¾ije i ukonÄenÃ­ vykonÃ¡vÃ¡nÃ­ funkce, dÃ­ky ÄemuÅ¾ tak mÅ¯Å¾eme sdÃ­let (potenciÃ¡lnÄ› velkÃ¡)
data mezi funkcemi. NicmÃ©nÄ› musÃ­me takÃ© tuto pamÄ›Å¥ ruÄnÄ› uvolÅˆovat, protoÅ¾e (narozdÃ­l od zÃ¡sobnÃ­ku)
to za nÃ¡s nikdo neudÄ›lÃ¡.</p>
<h2><a class="header" href="#alokace-pamÄ›ti" id="alokace-pamÄ›ti">Alokace pamÄ›ti</a></h2>
<p>K naalokovÃ¡nÃ­ pamÄ›ti mÅ¯Å¾eme pouÅ¾Ã­t funkci <a href="https://devdocs.io/c/memory/malloc"><code>malloc</code></a> (<em>memory
alloc</em>), kterÃ¡ je dostupnÃ¡ v souboru <code>stdlib.h</code> ze <a href="c/prace_s_pameti/../funkce/stdlib.html">standardnÃ­ knihovny <em>C</em></a>.
Tato funkce mÃ¡ nÃ¡sledujÃ­cÃ­ signaturu<sup class='margin-toggle sidenote-number'>1</sup>:</p>
<span class='sidenote'><p><sup class='number'>1</sup>DatovÃ½ typ <a href="https://devdocs.io/c/types/size_t"><code>size_t</code></a> reprezentuje bezznamÃ©nkovÃ©
celÃ© ÄÃ­slo, do kterÃ©ho by mÄ›la jÃ­t uloÅ¾it velikost nejvÄ›tÅ¡Ã­ moÅ¾nÃ© hodnoty libovolnÃ©ho typu. ÄŒasto
se pouÅ¾Ã­vÃ¡ pro indexaci <a href="c/prace_s_pameti/../pole/pole.html">polÃ­</a> nebo prÃ¡vÄ› urÄovÃ¡nÃ­ velikosti (napÅ™. alokacÃ­).</p>
</span>
<pre><code class="language-c">void* malloc(size_t size);
</code></pre>
<h3><a class="header" href="#velikost-alokovanÃ©-pamÄ›ti" id="velikost-alokovanÃ©-pamÄ›ti">Velikost alokovanÃ© pamÄ›ti</a></h3>
<p>Parametr <code>size</code> udÃ¡vÃ¡, kolik bytÅ¯ pamÄ›ti se mÃ¡ naalokovat. Tuto velikost mÅ¯Å¾eme &quot;tipnout&quot;
manuÃ¡lnÄ›, nicmÃ©nÄ› to nenÃ­ moc dobrÃ½ nÃ¡pad, protoÅ¾e bychom si museli pamatovat velikosti datovÃ½ch
typÅ¯ (pÅ™iÄemÅ¾ jejich velikost se mÅ¯Å¾e liÅ¡it v zÃ¡vislosti na pouÅ¾itÃ©m operaÄnÃ­m systÃ©mu Äi
pÅ™ekladaÄi!). Abychom tomu pÅ™edeÅ¡li, tak mÅ¯Å¾eme pouÅ¾Ã­t operÃ¡tor <code>sizeof</code>, kterÃ©mu mÅ¯Å¾eme pÅ™edat datovÃ½
typ<sup class='margin-toggle sidenote-number'>2</sup>. Tento vÃ½raz se potÃ© vyhodnotÃ­ jako velikost danÃ©ho datovÃ©ho typu:</p>
<span class='sidenote'><p><sup class='number'>2</sup>PÅ™Ã­padnÄ› vÃ½raz, v tom pÅ™Ã­padÄ› si <code>sizeof</code> vezme jeho datovÃ½ typ.</p>
</span>
<pre><code class="language-c editable mainbody">#include &lt;stdio.h&gt;
int main() {
    printf(&quot;Velikost int je: %lu\n&quot;, sizeof(int));
    printf(&quot;Velikost int* je: %lu\n&quot;, sizeof(int*));
    return 0;
}
</code></pre>
<p>NÃ¡vratovÃ½ typ <code>void*</code> reprezentuje ukazatel na libovolnÃ¡ data. Funkce <code>malloc</code> musÃ­ fungovat pro
alokaci libovolnÃ©ho datovÃ©ho typu, proto musÃ­ mÃ­t jako nÃ¡vratovÃ½ typ prÃ¡vÄ› univerzÃ¡lnÃ­ ukazatel
<code>void*</code>. PÅ™i zavolÃ¡nÃ­ funkce <code>malloc</code> bychom mÄ›li tento nÃ¡vratovÃ½ typ
<a href="c/prace_s_pameti/../datove_typy/konverze.html">pÅ™etypovat</a> na ukazatel na datovÃ½ typ, kterÃ½ alokujeme.</p>
<p>PÅ™i zavolÃ¡nÃ­ <code>malloc</code>u dojde k naalokovÃ¡nÃ­ <code>size</code> bytÅ¯ na haldÄ›. Adresa prvnÃ­ho bytu tÃ©to
naalokovanÃ© pamÄ›ti se potÃ© vrÃ¡tÃ­ jako nÃ¡vratovÃ¡ hodnota <code>malloc</code>u. Zde je ukÃ¡zka programu, kterÃ½
naalokuje pamÄ›Å¥ pro jeden <code>int</code> ve funkci, adresu naalokovanÃ© pamÄ›ti potÃ© vrÃ¡tÃ­ jako nÃ¡vratovou
hodnotu a naalokovanÃ¡ pamÄ›Å¥ je potÃ© pÅ™eÄtena ve funkci <code>main</code>:</p>
<pre><code class="language-c editable">#include &lt;stdlib.h&gt;

int* naalokuj_pamet() {
    int* pamet = (int*) malloc(sizeof(int));
    *pamet = 5;
    return pamet; 
}
int main() {
    int* pamet = naalokuj_pamet();
    printf(&quot;%d\n&quot;, *pamet);

    free(pamet); // uvolnÄ›nÃ­ pamÄ›ti, vysvÄ›tleno nÃ­Å¾e

    return 0;
}
</code></pre>
<details>
  <summary>InteraktivnÃ­ vizualizace kÃ³du</summary>
<iframe width="750" height="500" frameborder="0" src="https://pythontutor.com/iframe-embed.html#code=%23include%20%3Cstdlib.h%3E%0A%0Aint*%20naalokuj_pamet%28%29%20%7B%0A%20%20%20%20int*%20pamet%20%3D%20%28int*%29%20malloc%28sizeof%28int%29%29%3B%0A%20%20%20%20*pamet%20%3D%205%3B%0A%20%20%20%20return%20pamet%3B%20%0A%7D%0Aint%20main%28%29%20%7B%0A%20%20%20%20int*%20pamet%20%3D%20naalokuj_pamet%28%29%3B%0A%20%20%20%20printf%28%22%25d%5Cn%22,%20*pamet%29%3B%0A%20%20%20%20return%200%3B%0A%7D%0A&codeDivHeight=400&codeDivWidth=350&curInstr=8&origin=opt-frontend.js&py=c_gcc9.3.0&rawInputLstJSON=%5B%5D"> </iframe>
</details>
<h3><a class="header" href="#iniciÃ¡lnÃ­-hodnota-pamÄ›ti" id="iniciÃ¡lnÃ­-hodnota-pamÄ›ti">IniciÃ¡lnÃ­ hodnota pamÄ›ti</a></h3>
<p>StejnÄ› jako u <a href="c/prace_s_pameti/../promenne/promenne.html#v%C5%BEdy-inicializujte-prom%C4%9Bnn%C3%A9">lokÃ¡lnÃ­ch promÄ›nnÃ½ch</a>, i u
dynamicky naalokovanÃ© pamÄ›ti platÃ­, Å¾e jejÃ­ hodnota je zpoÄÃ¡tku nedefinovanÃ¡. NeÅ¾ se tedy hodnotu
danÃ© pamÄ›ti pokusÃ­te pÅ™eÄÃ­st, musÃ­te jÃ­ nainicializovat zÃ¡pisem nÄ›jakÃ© hodnoty! Jinak bude program
obsahovat <a href="c/prace_s_pameti/../../ruzne/nedefinovane_chovani.html">nedefinovanÃ© chovÃ¡nÃ­</a> ğŸ’£.</p>
<p>Pokud byste chtÄ›li, aby naalokovanÃ¡ pamÄ›Å¥ byla rovnou pÅ™i alokaci vynulovÃ¡na (vÅ¡echny byty
nastavenÃ© na hodnotu <code>0</code>), mÅ¯Å¾ete mÃ­sto funkce <code>malloc</code> pouÅ¾Ã­t funkci
<a href="https://devdocs.io/c/memory/calloc"><code>calloc</code></a><sup class='margin-toggle sidenote-number'>3</sup>. PÅ™Ã­padnÄ› mÅ¯Å¾ete pouÅ¾Ã­t uÅ¾iteÄnou funkci
<a href="https://devdocs.io/c/string/byte/memset"><code>memset</code></a>, kterÃ¡ vÃ¡m vyplnÃ­ blok pamÄ›ti zadanÃ½m bytem.</p>
<span class='sidenote'><p><sup class='number'>3</sup>Pozor vÅ¡ak na to, Å¾e tato funkce mÃ¡ jinÃ© parametry neÅ¾ <code>malloc</code>. OÄekÃ¡vÃ¡ poÄet hodnot, kterÃ©
se majÃ­ naalokovat, a velikost kaÅ¾dÃ© hodnoty.</p>
</span>
<h2><a class="header" href="#uvolnÄ›nÃ­-pamÄ›ti" id="uvolnÄ›nÃ­-pamÄ›ti">UvolnÄ›nÃ­ pamÄ›ti</a></h2>
<p>S velkou mocÃ­ pÅ™ichÃ¡zÃ­ i velkÃ¡ <a href="https://citaty.net/citaty/1957976-stan-lee-s-velkou-moci-prichazi-velka-odpovednost/">zodpovÄ›dnost</a>,
takÅ¾e pÅ™i pouÅ¾itÃ­ dynamickÃ© pamÄ›ti sice mÃ¡me vÃ­ce moÅ¾nostÃ­, neÅ¾ pÅ™i pouÅ¾itÃ­ automatickÃ© pamÄ›ti
(resp. zÃ¡sobnÃ­ku), ale zÃ¡roveÅˆ <strong>MUSÃME</strong> tuto pamÄ›Å¥ korektnÄ› uvolÅˆovat (coÅ¾ se u automatickÃ© pamÄ›ti
provÃ¡dÄ›lo automaticky). Pokud bychom totiÅ¾ pamÄ›Å¥ neustÃ¡le pouze alokovali a neuvolÅˆovali, tak by nÃ¡m
<a href="c/prace_s_pameti/../../caste_chyby/pametove_chyby.html#memory-leak">brzy doÅ¡la</a>.</p>
<p>Abychom pamÄ›Å¥ naalokovanou pomocÃ­ funkcÃ­ <code>malloc</code> Äi <code>calloc</code> uvolnili, tak musÃ­me pouÅ¾Ã­t funkci
<a href="https://devdocs.io/c/memory/free"><code>free</code></a>:</p>
<pre><code class="language-c editable">#include &lt;stdlib.h&gt;

int main() {
    int* p = (int*) malloc(sizeof(int)); // alokace pamÄ›ti
    *p = 0;                              // pouÅ¾itÃ­ pamÄ›ti
    free(p);                             // uvolnÄ›nÃ­ pamÄ›ti

    return 0;
}
</code></pre>
<p>Jako argument tÃ©to funkci musÃ­me pÅ™edat ukazatel navrÃ¡cenÃ½ z volÃ¡nÃ­ <code>malloc</code>/<code>calloc</code>. Nic jinÃ©ho
do tÃ©to funkce nedÃ¡vejte, uvolÅˆovat mÅ¯Å¾eme pouze dynamicky alokovanou pamÄ›Å¥! Nevolejte <code>free</code> s
adresami napÅ™. lokÃ¡lnÃ­ch promÄ›nnÃ½ch<sup class='margin-toggle sidenote-number'>4</sup>.</p>
<span class='sidenote'><p><sup class='number'>4</sup>Je vÅ¡ak bezpeÄnÃ© uvolnit &quot;nulovÃ½ ukazatel&quot;, tj. <code>free(NULL)</code> je validnÃ­ (v tomto pÅ™Ã­padÄ› funkce nic neudÄ›lÃ¡).</p>
</span>
<p>Jakmile se pamÄ›Å¥ uvolnÃ­, tak uÅ¾ k tÃ©to pamÄ›ti nesmÃ­te pÅ™istupovat! Pokud byste se pokusili pÅ™eÄÃ­st
nebo zapsat uvolnÄ›nou pamÄ›Å¥, tak dojde k <a href="c/prace_s_pameti/../../ruzne/nedefinovane_chovani.html">nedefinovanÃ©mu chovÃ¡nÃ­</a> ğŸ’£.
NesmÃ­te ani pamÄ›Å¥ uvolnit vÃ­ce neÅ¾ jednou.</p>
<p>PÅ™i prÃ¡ci s dynamicky alokovanou pamÄ›tÃ­ tak dbejte zvÃ½Å¡enÃ© opatrnosti a ideÃ¡lnÄ› pouÅ¾Ã­vejte pÅ™i
vÃ½voji <a href="c/prace_s_pameti/../../prostredi/ladeni.html#address-sanitizer">Address sanitizer</a>. (NeÃºplnÃ½) seznam vÄ›cÃ­,
kterÃ© se mÅ¯Å¾ou pokazit, pokud kombinaci dynamickÃ© alokace a uvolÅˆovÃ¡nÃ­ pamÄ›ti pokazÃ­te, naleznete
<a href="c/prace_s_pameti/../../caste_chyby/pametove_chyby.html">zde</a>.</p>
<h2><a class="header" href="#alokace-vÃ­ce-hodnot-zÃ¡roveÅˆ" id="alokace-vÃ­ce-hodnot-zÃ¡roveÅˆ">Alokace vÃ­ce hodnot zÃ¡roveÅˆ</a></h2>
<p>Jak jste si mohli vÅ¡imnout ze signatury funkce <code>malloc</code>, mÅ¯Å¾ete jÃ­ dÃ¡t libovolnÃ½ poÄet bytÅ¯.
NemusÃ­te se tak omezovat velikostÃ­ zÃ¡kladnÃ­ch datovÃ½ch typÅ¯, mÅ¯Å¾ete napÅ™Ã­klad naalokovat pamÄ›Å¥ pro
5 <code>int</code>Å¯ zÃ¡roveÅˆ, kterÃ© potÃ© budou leÅ¾et za sebou v pamÄ›ti a bude tak jednoduchÃ© k nim pÅ™istupovat
v cyklu. Jak tento koncept funguje se dozvÃ­te v sekci o
<a href="c/prace_s_pameti/../pole/dynamicka_pole.html">dynamickÃ½ch polÃ­ch</a>.</p>
<h2><a class="header" href="#kdy-pouÅ¾Ã­t-dynamicky-alokovanou-pamÄ›Å¥" id="kdy-pouÅ¾Ã­t-dynamicky-alokovanou-pamÄ›Å¥">Kdy pouÅ¾Ã­t dynamicky alokovanou pamÄ›Å¥?</a></h2>
<p>Å˜iÄte se pravidlem, Å¾e pokud lze pouÅ¾Ã­t <a href="c/prace_s_pameti/automaticka_pamet.html">automatickou pamÄ›Å¥</a> na zÃ¡sobnÃ­ku,
tak ji vyuÅ¾ijte a <code>malloc</code> nepouÅ¾Ã­vejte. AÅ¾ v momentÄ›, kdy z nÄ›jakÃ©ho dÅ¯vodu nebude staÄit naalokovat
pamÄ›Å¥ na zÃ¡sobnÃ­ku, tak se obraÅ¥e na <code>malloc</code>.</p>
<p>Seznam situacÃ­, ve kterÃ½ch se mÅ¯Å¾e dynamickÃ¡ pamÄ›Å¥ hodit, se
<a href="c/prace_s_pameti/automaticka_pamet.html#nev%C3%BDhody-automatick%C3%A9-pam%C4%9Bti">nachÃ¡zÃ­</a> v sekci o automatickÃ© pamÄ›ti.</p>
<hr />
<p><strong>KvÃ­z</strong> ğŸ¤”</p>
<p>PodÃ­vejte se na sekci o <a href="c/prace_s_pameti/../../caste_chyby/pametove_chyby.html">pamÄ›Å¥ovÃ½ch chybÃ¡ch</a> pro pÅ™Ã­klad toho,
co vÅ¡echno se mÅ¯Å¾e pÅ™i prÃ¡ci s dynamickou pamÄ›tÃ­ a ukazateli pokazit.</p>
<h1><a class="header" href="#globÃ¡lnÃ­-pamÄ›Å¥" id="globÃ¡lnÃ­-pamÄ›Å¥">GlobÃ¡lnÃ­ pamÄ›Å¥</a></h1>
<p>PoslednÃ­m zÃ¡kladnÃ­m typem pamÄ›ti je tzv. globÃ¡lnÃ­ (nazÃ½vanÃ¡ takÃ© statickÃ¡) pamÄ›Å¥. Tato pamÄ›Å¥ je
specifickÃ¡ tÃ­m, Å¾e vznikÃ¡ pÅ™i spuÅ¡tÄ›nÃ­ programu a zanikÃ¡ pÅ™i jeho ukonÄenÃ­, lze ji tak pouÅ¾Ã­vat
bÄ›hem celÃ© dÃ©lky bÄ›hu programu.</p>
<p><a href="c/prace_s_pameti/../promenne/globalni_promenne.html">GlobÃ¡lnÃ­ promÄ›nnÃ©</a> jsou umÃ­stÄ›ny v globÃ¡lnÃ­ pamÄ›ti. Je dobrÃ© si
uvÄ›domit, Å¾e tyto promÄ›nnÃ© zÃ¡roveÅˆ zabÃ­rajÃ­ mÃ­sto ve spustitelnÃ©m souboru na disku, protoÅ¾e v nÄ›m
musÃ­ bÃ½t uloÅ¾ena jejich iniciÃ¡lnÃ­ hodnota<sup class='margin-toggle sidenote-number'>1</sup>.</p>
<span class='sidenote'><p><sup class='number'>1</sup>Pokud tedy nejsou
<a href="c/prace_s_pameti/../promenne/globalni_promenne.html#inici%C3%A1ln%C3%AD-hodnota">inicializovanÃ© na nulu</a>).</p>
</span>
<p>V globÃ¡lnÃ­ pamÄ›ti takÃ© leÅ¾Ã­ samotnÃ© instrukce programu, kterÃ½ prÃ¡vÄ› bÄ›Å¾Ã­. Jsou tam umÃ­stÄ›nÃ© funkce,
kterÃ© jste napsali a kterÃ© potÃ© byly pÅ™eloÅ¾eny na strojovÃ© instrukce a uloÅ¾eny ve spustitelnÃ©m souboru.</p>
<h1><a class="header" href="#pole" id="pole">Pole</a></h1>
<p>NynÃ­ uÅ¾ znÃ¡me zÃ¡klady alokovÃ¡nÃ­ pamÄ›ti v jazyce <em>C</em>, zatÃ­m ale stÃ¡le umÃ­me pracovat pouze
s jednotkami promÄ›nnÃ½ch. PoÄÃ­taÄe slouÅ¾Ã­ k (rychlÃ©mu) zpracovÃ¡nÃ­ velkÃ©ho objemu dat, a abychom je
tak naplno vyuÅ¾ili, chtÄ›li bychom zpracovÃ¡vat mnoho promÄ›nnÃ½ch najednou. NapÅ™Ã­klad:</p>
<ul>
<li>V dokumentu otevÅ™enÃ©m ve Wordu mÅ¯Å¾eme mÃ­t uloÅ¾enÃ© tisÃ­ce rÅ¯znÃ½ch znakÅ¯.</li>
<li>Na server v online hÅ™e mÅ¯Å¾e v danou chvÃ­li bÃ½t pÅ™ipojenÃ© velkÃ© mnoÅ¾stvÃ­ hrÃ¡ÄÅ¯ a vÅ¡em musÃ­me
posÃ­lat informace o stavu hry.</li>
<li>ObrÃ¡zky se bÄ›Å¾nÄ› v programech reprezentujÃ­ jako dvourozmÄ›rnÃ¡ mÅ™Ã­Å¾ka pixelÅ¯. NapÅ™Ã­klad obrÃ¡zek
ve stupnÃ­ch Å¡edi s rozmÄ›ry <code>1024x1024</code> vyÅ¾aduje drÅ¾et v pamÄ›ti <code>1048576</code> bytÅ¯ (ÄÃ­sel) reprezentujÃ­cÃ­ch
jednotlivÃ© pixely.</li>
</ul>
<p>Asi si dovedete pÅ™edstavit, Å¾e napÅ™Ã­klad pro reprezentaci obrÃ¡zku bychom si s promÄ›nnÃ½mi, kterÃ© jsme
pouÅ¾Ã­vali doposud, nevystaÄili. Pokud bychom po jednÃ© vytvÃ¡Å™eli promÄ›nnÃ© <code>pixel1</code>, <code>pixel2</code>,
<code>pixel3</code>, tak by jednak byl nÃ¡Å¡ zdrojovÃ½ kÃ³d obrovskÃ½ a nedalo by se v nÄ›m vyznat, a takÃ© bychom
nemohli mÃ­t velikost obrÃ¡zku zÃ¡vislou na vstupu programu, protoÅ¾e poÄet promÄ›nnÃ½ch (pixelÅ¯) by byl
&quot;zadrÃ¡tovanÃ½&quot; ve zdrojovÃ©m kÃ³du programu. ChtÄ›li bychom tak mÃ­t moÅ¾nost napsat kÃ³d, kterÃ½ bude umÄ›t
zpracovat 1, 2, 100 nebo tÅ™eba 1000 hodnot bez toho, abychom tento kÃ³d museli jakkoliv mÄ›nit.</p>
<p>Asi nejbÄ›Å¾nÄ›jÅ¡Ã­m a nejjednoduÅ¡Å¡Ã­m zpÅ¯sobem, jak v pamÄ›ti poÄÃ­taÄe uchovÃ¡vat vÄ›tÅ¡Ã­ mnoÅ¾stvÃ­ hodnot,
je uloÅ¾it vÅ¡echny hodnoty jednu po druhÃ© za sebou v pamÄ›ti. Tento koncept uloÅ¾enÃ­ dat se nazÃ½vÃ¡
<strong>pole</strong> (<em>array</em>)<sup class='margin-toggle sidenote-number'>1</sup> a je tak bÄ›Å¾nÃ½, Å¾e ho programovacÃ­ jazyky obvykle pÅ™Ã­mo podporujÃ­ ve svÃ© syntaxi,
a jazyk <em>C</em> nenÃ­ vÃ½jimkou.</p>
<span class='sidenote'><p><sup class='number'>1</sup>ZpÅ¯soby, jak v pamÄ›ti poÄÃ­taÄe uchovÃ¡vat komplexnÃ­ a rozsÃ¡hlÃ¡ data, se nazÃ½vajÃ­
<a href="https://cs.wikipedia.org/wiki/Datov%C3%A1_struktura">datovÃ© struktury</a>. Pole je jednou z
nejjednoduÅ¡Å¡Ã­ch datovÃ½ch struktur.</p>
</span>
<p>V nÃ¡sledujÃ­cÃ­ch sekcÃ­ch se dozvÃ­te, jak s poli pracovat, jak je vytvoÅ™it v
<a href="c/pole/staticka_pole.html">automatickÃ©</a> a <a href="c/pole/dynamicka_pole.html">dynamickÃ© pamÄ›ti</a> a jak lze v poÄÃ­taÄi
reprezentovat <a href="c/pole/vicerozmerna_pole.html">vÃ­cerozmÄ›rnÃ¡ pole</a>.</p>
<h1><a class="header" href="#statickÃ¡-pole" id="statickÃ¡-pole">StatickÃ¡ pole</a></h1>
<p>Pole v <a href="c/pole/../prace_s_pameti/automaticka_pamet.html">automatickÃ© pamÄ›ti</a><sup class='margin-toggle sidenote-number'>1</sup> (na zÃ¡sobnÃ­ku) se oznaÄujÃ­
jako <strong>statickÃ¡ pole</strong> (<em>static arrays</em>). MÅ¯Å¾eme je vytvoÅ™it tak, Å¾e pÅ™i definici promÄ›nnÃ© za jejÃ­
nÃ¡zev pÅ™idÃ¡me hranatÃ© zÃ¡vorky s ÄÃ­slem udÃ¡vajÃ­cÃ­m poÄet prvkÅ¯ v poli. Takto napÅ™Ã­klad vytvoÅ™Ã­me pole
celÃ½ch ÄÃ­sel s tÅ™emi prvky:</p>
<span class='sidenote'><p><sup class='number'>1</sup>Pole mÅ¯Å¾ete tÃ­mto zpÅ¯sobem vytvoÅ™it takÃ© v
<a href="c/pole/../prace_s_pameti/globalni_pamet.html">globÃ¡lnÃ­ pamÄ›ti</a>, pokud vytvoÅ™Ã­te
<a href="c/pole/../promenne/globalni_promenne.html">globÃ¡lnÃ­ promÄ›nnou</a> datovÃ©ho typu pole.</p>
</span>
<pre><code class="language-c">int pole[3];
</code></pre>
<p>TakovÃ¡to promÄ›nnÃ¡ bude obsahovat pamÄ›Å¥ pro 3 celÃ¡ ÄÃ­sla (tedy nejspÃ­Å¡e na vaÅ¡em poÄÃ­taÄi dohromady
12 bytÅ¯). PoÄet prvkÅ¯ v poli se oznaÄuje jako jeho <strong>velikost</strong> (<em>size</em>).</p>
<blockquote>
<p>Pozor na to, Å¾e hranatÃ© zÃ¡vorky se udÃ¡vajÃ­ za nÃ¡zev promÄ›nnÃ©, a ne za nÃ¡zev datovÃ©ho typu.
<code>int[3] pole;</code> je tedy Å¡patnÄ›.</p>
</blockquote>
<p>ÄŒÃ­sla takovÃ©ho pole budou v pamÄ›ti uloÅ¾ena jedno za druhÃ½m<sup class='margin-toggle sidenote-number'>2</sup>:
<upr-container>
<upr-array array='[0, 0, 0]'></upr-array>
</upr-container></p>
<span class='sidenote'><p><sup class='number'>2</sup>KaÅ¾dÃ½ zelenÃ½ Ätverec na tomto obrÃ¡zku reprezentuje 4 byty v pamÄ›ti (velikost jednoho <code>int</code>u).</p>
</span>
<p>V jistÃ©m smyslu je tak pole pouze zobecnÄ›nÃ­m normÃ¡lnÃ­ promÄ›nnÃ©. Pokud totiÅ¾ vytvoÅ™Ã­te pole o
velikosti jedna (<code>int a[1];</code>), tak v pamÄ›ti bude reprezentovÃ¡no ÃºplnÄ› stejnÄ› jako klasickÃ¡ promÄ›nnÃ¡
(<code>int a;</code>).</p>
<blockquote>
<p>Pole lze vytvoÅ™it takÃ© na haldÄ› pomocÃ­ <a href="c/pole/dynamicka_pole.html">dynamickÃ© alokace pamÄ›ti</a>. VÅ¡echny nÃ­Å¾e
popsanÃ© koncepty jsou platnÃ© i pro dynamickÃ¡ pole, nicmÃ©nÄ› budeme je demonstrovat na statickÃ½ch
polÃ­ch, protoÅ¾e ty je jednoduÅ¡Å¡Ã­ vytvoÅ™it.</p>
</blockquote>
<h3><a class="header" href="#konstantnÃ­-velikost-statickÃ©ho-pole" id="konstantnÃ­-velikost-statickÃ©ho-pole">KonstantnÃ­ velikost statickÃ©ho pole</a></h3>
<p>Hodnota zadanÃ¡ v hranatÃ½ch zÃ¡vorkÃ¡ch by mÄ›la bÃ½t &quot;konstantnÃ­m vÃ½razem&quot;, tj. buÄ pÅ™Ã­mo ÄÃ­selnÃ¡ hodnota anebo
ÄÃ­selnÃ¡ hodnota pochÃ¡zejÃ­cÃ­ z <a href="c/pole/../preprocesor/makra.html">makra</a><sup class='margin-toggle sidenote-number'>3</sup>. Pokud budete potÅ™ebovat pole dynamickÃ© velikosti,
tak byste mÄ›li pouÅ¾Ã­t <a href="c/pole/dynamicka_pole.html">dynamickou alokaci pamÄ›ti</a>.</p>
<span class='sidenote'><p><sup class='number'>3</sup>Dokonce ani <a href="c/pole/../promenne/konstanty.html">konstantnÃ­</a> promÄ›nnÃ¡
<a href="https://stackoverflow.com/questions/62354105/why-is-const-int-x-5-not-a-constant-expression-in-c">nenÃ­</a>
v C &quot;konstantnÃ­m vÃ½razem&quot;.</p>
</span>
<p>Jazyk <em>C</em> od verze <a href="https://en.wikipedia.org/wiki/C99"><em>C99</em></a> jiÅ¾ sice povoluje dÃ¡vat do hranatÃ½ch
zÃ¡vorek i &quot;dynamickÃ©&quot; hodnoty, tj. vÃ½razy, jejichÅ¾ hodnota nemusÃ­ bÃ½t znÃ¡ma v dobÄ› pÅ™ekladu:</p>
<pre><code class="language-c">int velikost = ...; // velikost se naÄte napÅ™. ze souboru
int pole[velikost];
</code></pre>
<p>Tato funkcionalita zvanÃ¡ <a href="https://en.wikipedia.org/wiki/Variable-length_array">VLA</a> (variable-length array)
je nicmÃ©nÄ› urÄenÃ¡ pro velmi specifickÃ© pouÅ¾itÃ­ a nese s sebou rÅ¯znÃ© nevÃ½hody, proto ji v rÃ¡mci pÅ™edmÄ›tu
UPR <strong>nepouÅ¾Ã­vejte</strong>. Pokud si chcete bÃ½t jisti, Å¾e se VLA ve vaÅ¡em kÃ³du nevyskytuje, pÅ™eklÃ¡dejte svÃ© programy s
<a href="c/pole/../../ruzne/parametry_prekladace.html">parametrem pÅ™ekladaÄe</a> <code style="white-space: nowrap;">-Werror=vla</code>.</p>
<details>
<summary>ProÄ ne VLA?</summary>
<p>ZÃ¡sobnÃ­k mÃ¡ znaÄnÄ› <a href="c/pole/../prace_s_pameti/automaticka_pamet.html#nev%C3%BDhody-automatick%C3%A9-pam%C4%9Bti">omezenou velikost</a>
a nenÃ­ urÄen pro alokaci velkÃ©ho mnoÅ¾stvÃ­ pamÄ›ti<sup class='margin-toggle sidenote-number'>4</sup>. Pokud velikost takovÃ©hoto pole mÅ¯Å¾e ovlivnit
uÅ¾ivatel programu (napÅ™. zadÃ¡nÃ­m vstupu), mÅ¯Å¾e vÃ¡Å¡ program jednoduÅ¡e &quot;shodit&quot; (v lepÅ¡Ã­m pÅ™Ã­padÄ›)
nebo zpÅ¯sobit pÅ™epsÃ¡nÃ­ existujÃ­cÃ­ pamÄ›ti (v horÅ¡Ã­m pÅ™Ã­padÄ›), pokud by zadal velkÃ©
ÄÃ­slo a doÅ¡lo by k pokusu o vytvoÅ™enÃ­ moc velkÃ©ho pole na zÃ¡sobnÃ­ku. VLA mÃ¡ takÃ© rÅ¯znÃ© problÃ©my s
kompatibilitou mezi pÅ™ekladaÄi a jeho implementace pÅ™ekladaÄi nenÃ­ zdaleka triviÃ¡lnÃ­.</p>
<span class='sidenote'><p><sup class='number'>4</sup>MÅ¯Å¾ete si napÅ™Ã­klad zkusit pÅ™eloÅ¾it nÃ¡sledujÃ­cÃ­ program:</p>
<pre><code class="language-c">int main() {
    int pole[10000000];
    return 0;
}
</code></pre>
<p>PÅ™i spuÅ¡tÄ›nÃ­ by mÄ›l program selhat na
<a href="c/pole/../../caste_chyby/pametove_chyby.html#segmentation-fault">pamÄ›Å¥ovou chybu</a>, i kdyÅ¾ vÃ¡Å¡ poÄÃ­taÄ mÃ¡
pravdÄ›podobnÄ› vÃ­ce neÅ¾ <code>10000000 * 4</code> (cca <code>38</code> MiB) pamÄ›ti. Pokud chcete alokovat vÃ­ce neÅ¾ nÄ›kolik
stovek bytÅ¯, pouÅ¾ijte radÄ›ji <a href="c/pole/dynamicka_pole.html">dynamickou alokaci</a> na haldÄ›.</p>
</span>
<p>Alokace pamÄ›ti s dynamickou velikostÃ­ na zÃ¡sobnÃ­ku se mÅ¯Å¾e hodit ve velmi specifickÃ½ch pÅ™Ã­padech,
napÅ™. pÅ™i vÃ½voji embedded zaÅ™Ã­zenÃ­ nebo pÅ™i vysoce efektivnÃ­ prÃ¡ci s I/O (vstup/vÃ½stup). NicmÃ©nÄ› pro
ÃºÄely bÄ›Å¾nÃ©ho programovÃ¡nÃ­ v <em>C</em> a pÅ™edmÄ›tu UPR rozhodnÄ› nenÃ­ potÅ™eba, proto se VLA prosÃ­me zkuste
vyhnout.</p>
</details>
<h2><a class="header" href="#poÄÃ­tÃ¡nÃ­-od-nuly" id="poÄÃ­tÃ¡nÃ­-od-nuly">PoÄÃ­tÃ¡nÃ­ od nuly</a></h2>
<p>Pozice jednotlivÃ½ch prvkÅ¯ v poli se oznaÄujÃ­ jako jejich <strong>indexy</strong> (<em>array indices</em>). Tyto pozice
se ÄÃ­slujÃ­ od hodnoty <code>0</code> (tedy ne od jedniÄky, jak mÅ¯Å¾ete bÃ½t jinak zvyklÃ­). PrvnÃ­ prvek pole je
tedy ve skuteÄnosti na nultÃ© pozici (indexu), druhÃ½ na prvnÃ­ pozici atd. (viz obrÃ¡zek nahoÅ™e).
<strong>PoÄÃ­tÃ¡nÃ­ od nuly</strong> (<em>zero-based indexing</em>) je ve svÄ›tÄ› programovÃ¡nÃ­ bÄ›Å¾nÃ© a budete si na nÄ›j
muset zvyknout. Jeden z dÅ¯vodÅ¯, proÄ se prvky poÄÃ­tajÃ­ prÃ¡vÄ› od nuly, se dozvÃ­te
<a href="c/pole/staticka_pole.html#p%C5%99%C3%ADstup-k-prvk%C5%AFm-pole">nÃ­Å¾e</a>.</p>
<p>Z tohoto vyplÃ½vÃ¡ jedna dÅ¯leÅ¾itÃ¡ vlastnost - poslednÃ­ prvek pole je vÅ¾dy na indexu
<code>&lt;velikost pole&gt; - 1</code>! Pokud byste se pokusili pÅ™istoupit k prvku na indexu <code>&lt;velikost pole&gt;</code>,
budete pÅ™istupovat mimo pamÄ›Å¥ pole, coÅ¾ zpÅ¯sobÃ­
<a href="c/pole/../../caste_chyby/pametove_chyby.html">pamÄ›Å¥ovou chybu</a>.</p>
<h2><a class="header" href="#inicializace-pole" id="inicializace-pole">Inicializace pole</a></h2>
<p>StejnÄ› jako u normÃ¡lnÃ­ch lokÃ¡lnÃ­ch promÄ›nnÃ½ch
<a href="c/pole/../promenne/promenne.html#v%C5%BEdy-inicializujte-prom%C4%9Bnn%C3%A9">platÃ­</a>, Å¾e pokud pole nenainicializujete,
tak bude obsahovat nedefinovanÃ© hodnoty. V takovÃ©m pÅ™Ã­padÄ› nesmÃ­te hodnoty v poli jakkoliv ÄÃ­st,
jinak by doÅ¡lo k <a href="c/pole/../../ruzne/nedefinovane_chovani.html">nedefinovanÃ©mu chovÃ¡nÃ­</a> ğŸ’£! K inicializaci pole mÅ¯Å¾ete
pouÅ¾Ã­t sloÅ¾enÃ© zÃ¡vorky se seznamem hodnot oddÄ›lenÃ½ch ÄÃ¡rkou, kterÃ© budou do pole uloÅ¾eny. Pokud
nezadÃ¡te dostatek hodnot pro vyplnÄ›nÃ­ celÃ©ho pole, tak zbytek hodnot bude nastaveno na nulu.</p>
<pre><code class="language-c">int a[3];               // pole bez definovanÃ© hodnoty, nepouÅ¾Ã­vat!
int b[3] = {};          // pole s hodnotami 0, 0, 0
int c[4] = { 1 };       // pole s hodnotami 1, 0, 0, 0
int d[2] = { 2, 3 };    // pole s hodnotami 2, 3
</code></pre>
<p>Hodnot samozÅ™emÄ› nemÅ¯Å¾ete zadat vÃ­ce, neÅ¾ je velikost pole.</p>
<p>Pokud vyuÅ¾ijete inicializaci statickÃ©ho pole, mÅ¯Å¾ete vynechat velikost pole v hranatÃ½ch zÃ¡vorkÃ¡ch.
PÅ™ekladaÄ v tomto pÅ™Ã­padÄ› dopoÄÃ­tÃ¡ velikost za vÃ¡s:</p>
<pre><code class="language-c">int p[] = { 1, 2, 3 }; // p je pole s tÅ™emi ÄÃ­sly, pÅ™ekladaÄ si odvodÃ­ int p[3]
</code></pre>
<h2><a class="header" href="#pÅ™Ã­stup-k-prvkÅ¯m-pole" id="pÅ™Ã­stup-k-prvkÅ¯m-pole">PÅ™Ã­stup k prvkÅ¯m pole</a></h2>
<p>Abychom vyuÅ¾ili toho, Å¾e nÃ¡m pole umoÅ¾ÅˆujÃ­ vytvoÅ™it vÄ›tÅ¡Ã­ mnoÅ¾stvÃ­ pamÄ›ti najednou, musÃ­me mÃ­t
moÅ¾nost pÅ™istupovat k jednotlivÃ½m prvkÅ¯m v poli. K tomu mÅ¯Å¾eme vyuÅ¾Ã­t
<a href="c/pole/../prace_s_pameti/ukazatele.html">ukazatelÅ¯</a>. PromÄ›nnÃ¡ pole se totiÅ¾ chovÃ¡ jako ukazatel na prvnÃ­
prvek (prvek na nultÃ©m indexu!) danÃ©ho pole, pomocÃ­ operÃ¡toru
<a href="c/pole/../prace_s_pameti/ukazatele.html#p%C5%99%C3%ADstup-k-pam%C4%9Bti-pomoc%C3%AD-ukazatele">dereference</a> tak k tomutu prvku
mÅ¯Å¾eme jednoduÅ¡e pÅ™istoupit:</p>
<pre><code class="language-c editable mainbody">#include &lt;stdio.h&gt;

int main() {
    int pole[3] = { 1, 2, 3 };
    printf(&quot;%d\n&quot;, *pole);
    return 0;
}
</code></pre>
<p>Abychom pÅ™istoupili i k dalÅ¡Ã­m prvkÅ¯m v poli, tak mÅ¯Å¾eme vyuÅ¾Ã­t
<a href="c/pole/../prace_s_pameti/ukazatele.html#aritmetika-s-ukazateli">aritmetiky s ukazateli</a>. Pokud chceme
zÃ­skat adresu prvku na <code>i</code>-tÃ©m indexu, staÄÃ­ k ukazateli na prvnÃ­ prvek pÅ™iÄÃ­st <code>i</code><sup class='margin-toggle sidenote-number'>5</sup>:</p>
<span class='sidenote'><p><sup class='number'>5</sup>VÅ¡imnÄ›te si, Å¾e pÅ™i pouÅ¾itÃ­ operÃ¡toru dereference zde pouÅ¾Ã­vÃ¡me zÃ¡vorky. Je to z dÅ¯vodu
<a href="https://en.cppreference.com/w/c/language/operator_precedence">priority operÃ¡torÅ¯</a>. VÃ½raz <code>*pole + 2</code>
by se vyhodnotil jako prvnÃ­ prvek z pole <code>pole</code> plus <code>2</code>, protoÅ¾e <code>*</code> (dereference) mÃ¡ vÄ›tÅ¡Ã­
prioritu neÅ¾ sÄÃ­tÃ¡nÃ­. </p>
</span>
<pre><code class="language-c editable mainbody">#include &lt;stdio.h&gt;

int main() {
    int pole[3] = { 1, 2, 3 };
    printf(&quot;%d\n&quot;, *(pole + 0));   // prvnÃ­ prvek pole
    printf(&quot;%d\n&quot;, *(pole + 1));   // druhÃ½ prvek pole
    printf(&quot;%d\n&quot;, *(pole + 2));   // tÅ™etÃ­ prvek pole
    return 0;
}
</code></pre>
<p>NynÃ­ uÅ¾ moÅ¾nÃ¡ tuÅ¡Ã­te, proÄ se pÅ™i prÃ¡ci s poli vyplatÃ­ poÄÃ­tat od nuly. Prvek na nultÃ©m indexu je
totiÅ¾ vzdÃ¡len nula prvkÅ¯ od zaÄÃ¡tku pole. Prvek na prvnÃ­m indexu je vzdÃ¡len jeden prvek od zaÄÃ¡tku
pole atd. Pokud bychom indexovali od jedniÄky, museli bychom pÅ™i vÃ½poÄtu adresy relativnÄ› k ukazateli
na zaÄÃ¡tek pole vÅ¾dy odeÄÃ­st jedniÄku, coÅ¾ by bylo nepraktickÃ©.</p>
<blockquote>
<p>PÅ™istupovÃ¡nÃ­ k prvkÅ¯m pole se bÄ›Å¾nÄ› oznaÄuje pojmem <strong>indexovÃ¡nÃ­ pole</strong>.</p>
</blockquote>
<h2><a class="header" href="#operÃ¡tor-pÅ™Ã­stupu-k-poli" id="operÃ¡tor-pÅ™Ã­stupu-k-poli">OperÃ¡tor pÅ™Ã­stupu k poli</a></h2>
<p>JelikoÅ¾ je operace pÅ™Ã­stupu k poli (&quot;posunutÃ­&quot; ukazatele a jeho dereference) velmi
bÄ›Å¾nÃ¡ (a zÃ¡roveÅˆ relativnÄ› krkolomnÃ¡), <em>C</em> obsahuje speciÃ¡lnÃ­ operÃ¡tor, kterÃ½ ji zjednoduÅ¡uje.
Tento operÃ¡tor se nazÃ½vÃ¡ <em>array subscription operator</em> a mÃ¡ syntaxi</p>
<pre><code>&lt;vÃ½raz a&gt;[&lt;vÃ½raz b&gt;]
</code></pre>
<p>SlouÅ¾Ã­ jako zkratka<sup class='margin-toggle sidenote-number'>6</sup> za vÃ½raz</p>
<span class='sidenote'><p><sup class='number'>6</sup>TakovÃ©to &quot;zkratky&quot;, kterÃ© v programovacÃ­m jazyku nepÅ™inÃ¡Å¡Ã­ novou funkcionalitu, pouze zkracujÃ­
Äi zjednoduÅ¡Å¡ujÃ­ Äasto pouÅ¾Ã­vanÃ© kombinace pÅ™Ã­kazÅ¯, se oznaÄujÃ­ jako
<a href="https://en.wikipedia.org/wiki/Syntactic_sugar"><strong>syntactic sugar</strong></a>.</p>
</span>
<pre><code>*(&lt;vÃ½raz a&gt; + &lt;vÃ½raz b&gt;)
</code></pre>
<p>PÅ™Ã­klad:</p>
<ul>
<li><code>pole[0]</code> je ekvivalentnÃ­ vÃ½razu <code>*(pole + 0)</code></li>
<li><code>pole[5]</code> je ekvivalentnÃ­ vÃ½razu <code>*(pole + 5)</code></li>
</ul>
<pre><code class="language-c">int pole[3] = { 1, 2, 3 };
pole[0] = 5;       // nastavili jsme prvnÃ­ prvek pole na hodnotu `5`
int c = pole[2];   // nastavili jsme `c` na hodnotu poslednÃ­ho (tÅ™etÃ­ho) prvku pole
</code></pre>
<p>JelikoÅ¾ je pouÅ¾Ã­vÃ¡nÃ­ hranatÃ½ch zÃ¡vorek pÅ™ehlednÄ›jÅ¡Ã­ neÅ¾ pouÅ¾Ã­vÃ¡nÃ­ zÃ¡vorek a hvÄ›zdiÄek, doporuÄujeme
je pouÅ¾Ã­vat pro pÅ™istupovÃ¡nÃ­ k prvkÅ¯m pole, pokud to pÅ¯jde.</p>
<blockquote>
<p>Pozor na rozdÃ­l mezi tÃ­mto operÃ¡torem a definicÃ­ pole. ObojÃ­ sice pouÅ¾Ã­vÃ¡ hranatÃ© zÃ¡vorky, ale
jinak spolu tyto dvÄ› vÄ›ci nesouvisejÃ­. PodobnÄ› jako se <code>*</code> pouÅ¾Ã­vÃ¡ pro definici datovÃ©ho typu
ukazatele a <a href="c/pole/../prace_s_pameti/ukazatele.html#p%C5%99%C3%ADstup-k-pam%C4%9Bti-pomoc%C3%AD-ukazatele">zÃ¡roveÅˆ</a>
jako operÃ¡tor dereference (navÃ­c i jako operÃ¡tor pro nÃ¡sobenÃ­). VÅ¾dy zÃ¡leÅ¾Ã­ na kontextu, kde jsou
tyto znaky pouÅ¾ity.</p>
</blockquote>
<h2><a class="header" href="#pouÅ¾itÃ­-polÃ­-s-cykly" id="pouÅ¾itÃ­-polÃ­-s-cykly">PouÅ¾itÃ­ polÃ­ s cykly</a></h2>
<p>Pokud bychom k polÃ­m pÅ™istupovali po individuÃ¡lnÃ­ch prvcÃ­ch, tak bychom nemohli vyuÅ¾Ã­t jejich plnÃ½
potenciÃ¡l. I kdyÅ¾ umÃ­me jednÃ­m Å™Ã¡dkem kÃ³du vytvoÅ™it napÅ™Ã­klad 100 rÅ¯znÃ½ch hodnot (<code>int pole[100];</code>),
pokud bychom museli psÃ¡t <code>pole[0]</code>, <code>pole[1]</code> atd. pro pÅ™Ã­stup k jednotlivÃ½m prvkÅ¯m, tak bychom
nemohli s polem efektivnÄ› pracovat. Smyslem polÃ­ je umoÅ¾nit zpracovÃ¡nÃ­ velkÃ©ho mnoÅ¾stvÃ­ dat jednotnÃ½m
zpÅ¯sobem pomocÃ­ krÃ¡tkÃ©ho kusu kÃ³du. Jinak Å™eÄeno, chtÄ›li bychom mÃ­t stejnÃ½ kÃ³d, kterÃ½ umÃ­ zpracovat
pole o velikosti <code>2</code> i <code>1000</code>. K tomu mÅ¯Å¾eme efektivnÄ› vyuÅ¾Ã­t <a href="c/pole/../rizeni_toku/cykly.html">cykly</a>.</p>
<p>ÄŒasto je praktickÃ© pouÅ¾Ã­t <a href="c/pole/../rizeni_toku/while.html#%C5%98%C3%ADd%C3%ADc%C3%AD-prom%C4%9Bnn%C3%A1">Å™Ã­dÃ­cÃ­ promÄ›nnou</a> cyklu k tomu,
abychom pomocÃ­ nÃ­ indexovali pole. NapÅ™Ã­klad, pokud bychom mÄ›li pole s velikostÃ­ <code>10</code>, tak ho mÅ¯Å¾eme
&quot;projÃ­t&quot;<sup class='margin-toggle sidenote-number'>7</sup> pomocÃ­ cyklu <code>for</code>:</p>
<span class='sidenote'><p><sup class='number'>7</sup>PouÅ¾Ã­vÃ¡ se takÃ© pojem <em>proiterovat</em>.</p>
</span>
<pre><code class="language-c editable mainbody">#include &lt;stdio.h&gt;

int main() {
    int pole[10] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };
    for (int i = 0; i &lt; 10; i++) {
        printf(&quot;%d &quot;, pole[i]);
    }
    return 0;
}
</code></pre>
<p>Situace, kdy pomocÃ­ cyklu projdeme pole, je velmi ÄastÃ¡ a urÄitÄ› se s nÃ­ mnohokrÃ¡t setkÃ¡te a
vyuÅ¾ijete ji. Zkuste si to procviÄit napÅ™Ã­klad pomocÃ­
<a href="c/pole/../../ulohy/pole.html#minim%C3%A1ln%C3%AD-hodnota-v-poli">tÄ›chto Ãºloh</a>.</p>
<h2><a class="header" href="#pÅ™edÃ¡vÃ¡nÃ­-pole-do-funkcÃ­" id="pÅ™edÃ¡vÃ¡nÃ­-pole-do-funkcÃ­">PÅ™edÃ¡vÃ¡nÃ­ pole do funkcÃ­</a></h2>
<p>Pole mÅ¯Å¾eme (stejnÄ› jako hodnoty jinÃ½ch datovÃ½ch typÅ¯) pÅ™edÃ¡vat jako argumenty do funkcÃ­.
MusÃ­me si pÅ™i tom vÅ¡ak dÃ¡vat pozor zejmÃ©na na dvÄ› vÄ›ci.</p>
<h3><a class="header" href="#pÅ™evod-pole-na-ukazatel" id="pÅ™evod-pole-na-ukazatel">PÅ™evod pole na ukazatel</a></h3>
<p>UÅ¾ vÃ­me, Å¾e kdyÅ¾ pÅ™edÃ¡vÃ¡me <a href="c/pole/../funkce/funkce.html#parametrizace-funkc%C3%AD">argumenty</a> do funkcÃ­, tak se
jejich hodnota zkopÃ­ruje. U statickÃ½ch polÃ­ tomu tak ovÅ¡em nenÃ­, protoÅ¾e pole mÅ¯Å¾ou bÃ½t potenciÃ¡lnÄ›
velmi velkÃ¡ a provÃ¡dÄ›nÃ­ kopiÃ­ polÃ­ by tak potenciÃ¡lnÄ› mohlo brzdit provÃ¡dÄ›nÃ­ programu. KdyÅ¾ tak
pouÅ¾ijeme promÄ›nnou pole jako argument pÅ™i volÃ¡nÃ­ funkce, dojde k tzv. <strong>konverzi pole na ukazatel</strong>
(<em>array to pointer decay</em>). Pole se tak vÅ¾dy pÅ™edÃ¡ jako ukazatel na jeho prvnÃ­ prvek:</p>
<pre><code class="language-c editable">#include &lt;stdio.h&gt;

void vypis_pole(int* pole) {
    printf(&quot;%d\n&quot;, pole[0]);
}

int main() {
    int pole[3] = { 1, 2, 3 };
    vypis_pole(pole);
    return 0;
}
</code></pre>
<p>Pro parametry sice mÅ¯Å¾ete pouÅ¾Ã­t datovÃ½ typ pole:</p>
<pre><code class="language-c">void vypis_pole(int pole[3]) { ... }
</code></pre>
<p>nicmÃ©nÄ› i v tomto pÅ™Ã­padÄ› se bude takovÃ½to parametr chovat stejnÄ› jako ukazatel (v tomto pÅ™Ã­padÄ›
tedy <code>int*</code>). NavÃ­c pÅ™ekladaÄ ani nebude kontrolovat, jestli do takovÃ©ho parametru opravdu dÃ¡vÃ¡me
pole se sprÃ¡vnou velikostÃ­. Pro parametry reprezentujÃ­cÃ­ pole tak radÄ›ji rovnou pouÅ¾Ã­vejte ukazatel,
abychom ÄtenÃ¡Å™e kÃ³du nemÃ¡tli.</p>
<h3><a class="header" href="#pÅ™edÃ¡vÃ¡nÃ­-velikosti-pole" id="pÅ™edÃ¡vÃ¡nÃ­-velikosti-pole">PÅ™edÃ¡vÃ¡nÃ­ velikosti pole</a></h3>
<p>KdyÅ¾ ve funkci pÅ™ijmeme jako parametr ukazatel na pole, tak nevÃ­me, kolik prvkÅ¯ v tomto poli je.
Tato informace je ale stÄ›Å¾ejnÃ­, bez nÃ­ totiÅ¾ nevÃ­me, ke kolika prvkÅ¯m pole si mÅ¯Å¾eme dovolit
pÅ™istupovat. Pokud tedy ukazatel na pole pÅ™edÃ¡vÃ¡me do funkce, je obvykle potÅ™eba zÃ¡roveÅˆ s nÃ­m
pÅ™edat i dÃ©lku danÃ©ho pole:</p>
<pre><code class="language-c">int secti_pole(int* pole, int velikost) {
    int soucet = 0;
    for (int i = 0; i &lt; velikost; i++) {
        soucet += pole[i];
    }
    return soucet;
}
</code></pre>
<h4><a class="header" href="#vÃ½poÄet-velikosti-pole" id="vÃ½poÄet-velikosti-pole">VÃ½poÄet velikosti pole</a></h4>
<p>Abyste pÅ™i zmÄ›nÄ› velikosti statickÃ©ho pole nemuseli ruÄnÄ› jeho velikost upravovat na vÃ­ce mÃ­stech v
kÃ³du, tak mÅ¯Å¾ete ve funkci, kde definujete statickÃ© pole, vypoÄÃ­tat jeho velikost pomocÃ­ operÃ¡toru
<code>sizeof</code>:</p>
<pre><code class="language-c">int pole[3] = { 1, 2, 3 };
printf(&quot;Velikost pole v bytech: %lu\n&quot;, sizeof(pole));
</code></pre>
<p>Abyste zjistili poÄet prvkÅ¯ ve statickÃ©m poli, mÅ¯Å¾ete velikost v bytech vydÄ›lit velikostÃ­ kaÅ¾dÃ©ho
prvku v poli:</p>
<pre><code class="language-c">int pole[3] = { 1, 2, 3 };
printf(&quot;Pocet prvku v poli: %lu\n&quot;, sizeof(pole) / sizeof(pole[0]));
</code></pre>
<blockquote>
<p>OperÃ¡tor <code>sizeof</code> bude pro toto pouÅ¾itÃ­ fungovat pouze pro statickÃ© pole a pouze ve funkci, ve kterÃ©
statickÃ© pole vytvÃ¡Å™Ã­te! Pokud pole poÅ¡lete do jinÃ© funkce, uÅ¾ z nÄ›j bude pouze ukazatel, pro kterÃ½
<code>sizeof</code> vrÃ¡tÃ­ velikost ukazatele (coÅ¾ bude na vaÅ¡em PC nejspÃ­Å¡e <code>8</code> bytÅ¯). VÃ­ce v kvÃ­zech nÃ­Å¾e.</p>
</blockquote>
<hr />
<p><strong>KvÃ­z</strong> ğŸ¤”</p>
<ol>
<li>
<p>Co vypÃ­Å¡e nÃ¡sledujÃ­cÃ­ program?</p>
<pre><code class="language-c editable mainbody">#include &lt;stdio.h&gt;

int main() {
    int pole[3] = { 1, 4, 7 };
    int a = *pole + 1;
    int b = *(pole + 1);

    printf(&quot;a = %d, b = %d\n&quot;, a, b);

    return 0;
}
</code></pre>
<details>
 <summary>OdpovÄ›Ä</summary>
<p>Program vypÃ­Å¡e <code>a = 2, b = 4</code>. JelikoÅ¾ mÃ¡ operÃ¡tor dereference (<code>*</code>) vÄ›tÅ¡Ã­
<a href="https://en.cppreference.com/w/c/language/operator_precedence">prioritu</a> neÅ¾ operÃ¡tor seÄtenÃ­
(<code>+</code>), tak se do promÄ›nnÃ© <code>a</code> uloÅ¾Ã­ hodnota (<code>2</code>). Nejprve se totiÅ¾ provede vÃ½raz <code>*pole</code>, kde
dojde k dereferenci ukazatele na prvnÃ­ prvek pole, ÄÃ­mÅ¾ vznikne hodnota <code>1</code>, a k nÃ­ se potÃ© pÅ™iÄte
jedniÄka.</p>
<p>V pÅ™Ã­padÄ› promÄ›nnÃ© <code>b</code> se nejprve ukazatel na prvnÃ­ prvek pole posune o jeden prvek dopÅ™edu, tj.
na adresu druhÃ©ho prvku pole, kterÃ½ mÃ¡ hodnotu <code>4</code>. PotÃ© dojde k dereferenci adresy tohoto prvku,
do promÄ›nnÃ© <code>b</code> se tak uloÅ¾Ã­ hodnota <code>4</code>.</p>
</details>
</li>
<li>
<p>Co vypÃ­Å¡e nÃ¡sledujÃ­cÃ­ program?</p>
<pre><code class="language-c editable mainbody">#include &lt;stdio.h&gt;

void prijmi_pole(int p[3]) {
    p[2] += 1;
}

int main() {
    int pole[3] = { 1, 2, 3 };

    prijmi_pole(pole); 

    printf(&quot;{ %d, %d, %d }\n&quot;, pole[0], pole[1], pole[2]);

    return 0;
}
</code></pre>
<details>
 <summary>OdpovÄ›Ä</summary>
<p>Program vypÃ­Å¡e <code>{ 1, 2, 4 }</code>. PÅ™i pÅ™edÃ¡vÃ¡nÃ­ statickÃ©ho pole do funkce dojde pouze k pÅ™edÃ¡nÃ­
ukazatele na jeho prvnÃ­ prvek (i kdyÅ¾ mÃ¡ parametr typ <code>int p[3]</code>). Pokud tedy pomocÃ­ ukazatele
<code>p</code> zmÄ›nÃ­me hodnotu tÅ™etÃ­ho prvku pole, tato zmÄ›na se nÃ¡m projevÃ­ i ve funkci <code>main</code>, protoÅ¾e
stÃ¡le pracujeme s tou stejnou pamÄ›tÃ­.</p>
</details>
</li>
<li>
<p>Co vypÃ­Å¡e nÃ¡sledujÃ­cÃ­ program?</p>
<pre><code class="language-c editable mainbody">#include &lt;stdio.h&gt;

int main() {
    int pole[3] = { 1, 2, 3 };
    int *p = pole;

    p[1] = 5;
    pole[0] = 8;

    printf(&quot;%d, %d\n&quot;, *p, pole[1]);

    return 0;
}
</code></pre>
<details>
 <summary>OdpovÄ›Ä</summary>
<p>Program vypÃ­Å¡e <code>8, 5</code>. Do ukazatele <code>p</code> jsme si uloÅ¾ili adresu prvnÃ­ho prvku v poli. PomocÃ­
<code>p[1]</code> posuneme ukazatel o jeden prvek v pamÄ›ti &quot;dopÅ™edu&quot; (bude tedy ukazovat na druhÃ½ prvek pole)
a rovnou na tuto adresu v pamÄ›ti zapÃ­Å¡eme hodnotu <code>5</code>. PotÃ© zmÄ›nÃ­me hodnotu prvnÃ­ho prvku pole
na <code>8</code>. JelikoÅ¾ <code>p</code> ukazuje na prvnÃ­ prvek v poli, tak pÅ™i jeho dereferenci zÃ­skÃ¡me prÃ¡vÄ› hodnotu
<code>8</code>. A jelikoÅ¾ jsme pÅ™edtÃ­m pomocÃ­ ukazatele <code>p</code> zmÄ›nili druhÃ½ prvek pole na <code>5</code>, tak <code>pole[1]</code>
takÃ© vrÃ¡tÃ­ hodnotu <code>5</code>.</p>
</details>
</li>
<li>
<p>Co vypÃ­Å¡e nÃ¡sledujÃ­cÃ­ program?</p>
<pre><code class="language-c editable mainbody">#include &lt;stdio.h&gt;

int main() {
    int pole[3] = { 1, 2, 3 };
    printf(&quot;%d\n&quot;, pole);

    return 0;
}
</code></pre>
<details>
 <summary>OdpovÄ›Ä</summary>
<p>Tento program obsahuje <a href="c/pole/../../ruzne/nedefinovane_chovani.html"><strong>nedefinovanÃ© chovÃ¡nÃ­</strong></a> ğŸ’£, protoÅ¾e jsme pouÅ¾ili
<a href="c/pole/../prikazy_vyrazy.html#v%C3%BDpis-v%C3%BDraz%C5%AF">zÃ¡stupnÃ½ znak</a> <code>%d</code>, kterÃ½ slouÅ¾Ã­ k vÃ½pisu celÃ½ch ÄÃ­sel, ale
pÅ™edali jsme funkci <code>printf</code> argument <code>pole</code>, kterÃ½ je datovÃ©ho typu pole (resp. ukazatel na prvnÃ­
prvek tohoto pole).</p>
</details>
</li>
<li>
<p>Co vypÃ­Å¡e nÃ¡sledujÃ­cÃ­ program?</p>
<pre><code class="language-c editable mainbody">#include &lt;stdio.h&gt;

int main() {
    int p[3] = { 1, 2, 3 };
    for (int i = 0; i &lt;= 3; i++) {
        printf(&quot;%d\n&quot;, p[i]);
    }

    return 0;
}
</code></pre>
<details>
 <summary>OdpovÄ›Ä</summary>
<p>Tento program obsahuje <a href="c/pole/../../ruzne/nedefinovane_chovani.html"><strong>nedefinovanÃ© chovÃ¡nÃ­</strong></a> ğŸ’£, protoÅ¾e jsme pÅ™istoupili (dereferencovali)
pamÄ›Å¥ mimo rozsah pole! Pole <code>p</code> mÃ¡ pouze tÅ™i prvky, nesmÃ­me tedy pÅ™istoupit k indexu <code>3</code> Äi vyÅ¡Å¡Ã­mu,
coÅ¾ se vÅ¡ak v tomto programu stane, protoÅ¾e promÄ›nnÃ¡ <code>i</code> nabÃ½vÃ¡ hodnot <code>0</code>, <code>1</code>, <code>2</code> a <code>3</code>.</p>
<p>AÅ¥ uÅ¾ tento program pÅ™i konkrÃ©tnÃ­m spuÅ¡tÄ›nÃ­ vypÃ­Å¡e cokoliv, nemÃ¡ cenu se tÃ­m zaobÃ­rat. Tento program
obsahuje pamÄ›Å¥ovou chybu, kterÃ¡ mÅ¯Å¾e zpÅ¯sobit pÃ¡d programu, libovolnou zmÄ›nu hodnot v pamÄ›ti nebo
cokoliv jinÃ©ho. Chybu musÃ­te nejprve odstranit, jinak program nebude sprÃ¡vnÄ› fungovat.</p>
</details>
</li>
<li>
<p>Co vypÃ­Å¡e nÃ¡sledujÃ­cÃ­ program?</p>
<pre><code class="language-c editable mainbody">#include &lt;stdio.h&gt;

int main() {
    int pole[3] = { 1, 2, 3 };
    2[pole] = 5;

    printf(&quot;%d\n&quot;, pole[2]);

    return 0;
}
</code></pre>
<details>
 <summary>OdpovÄ›Ä</summary>
<p>Program vypÃ­Å¡e <code>5</code>. I kdyÅ¾ to vypadÃ¡ zvlÃ¡Å¡tnÄ›, tak jelikoÅ¾ je sÄÃ­tÃ¡nÃ­ komutativnÃ­, a operÃ¡tor
<code>a[b]</code> je definovÃ¡n jako <code>*(a + b)</code>, tak je jedno, jestli napÃ­Å¡ete <code>a[b]</code> nebo <code>b[a]</code>. TakovÃ½to
zÃ¡pis je nicmÃ©nÄ› nestandardnÃ­ a nepouÅ¾Ã­vÃ¡ se, tato Ãºloha pouze mÄ›la demonstrovat, Å¾e jej takto
teoreticky pouÅ¾Ã­t lze, a Å¾e <code>a[b]</code> opravdu nenÃ­ nic jinÃ©ho, neÅ¾ zkratka za <code>*(a + b)</code>.</p>
</details>
</li>
<li>
<p>Co vypÃ­Å¡e nÃ¡sledujÃ­cÃ­ program?</p>
<pre><code class="language-c editable mainbody">#include &lt;stdio.h&gt;

int main() {
    char pole[3];
    char* ptr = pole;

    printf(&quot;%d\n&quot;, (int) sizeof(pole));
    printf(&quot;%d\n&quot;, (int) sizeof(ptr));

    return 0;
}
</code></pre>
<details>
 <summary>OdpovÄ›Ä</summary>
 Program vypÃ­Å¡e toto (na 32-bitovÃ©m systÃ©mu by druhÃ© ÄÃ­slo bylo pravdÄ›podobnÄ› 4):
<pre><code>3
8
</code></pre>
<p>OperÃ¡tor <code>sizeof</code> vrÃ¡tÃ­ velikost celÃ©ho statickÃ©ho pole, pokud jej do nÄ›j pÅ™edÃ¡me. Pokud vÅ¡ak
do nÄ›j dÃ¡me pouze ukazatel, tak <code>sizeof</code> nevÃ­, jak velkÃ¡ pamÄ›Å¥ leÅ¾Ã­ na adrese uloÅ¾enÃ© v tomto
ukazateli, proto nÃ¡m mÃ­sto toho vrÃ¡tÃ­ pouze velikost danÃ©ho ukazatele, coÅ¾ bude na 64-bitovÃ©m
systÃ©mu pravdÄ›podobnÄ› <code>8</code> bytÅ¯.</p>
</details>
</li>
<li>
<p>Co vypÃ­Å¡e nÃ¡sledujÃ­cÃ­ program?</p>
<pre><code class="language-c editable">#include &lt;stdio.h&gt;

void print_size(char pole[3]) {
    printf(&quot;%d\n&quot;, (int) sizeof(pole));
}

int main() {
    char pole[3];
    print_size(pole);

    return 0;
}
</code></pre>
<details>
 <summary>OdpovÄ›Ä</summary>
 Program pravdÄ›podobnÄ› vypÃ­Å¡e Å™Ã¡dek s hodnotou 8 (na 64-bitovÃ©m systÃ©mu) Äi 4 (na 32-bitovÃ©m
 systÃ©mu). Pokud pouÅ¾ijeme datovÃ½ typ pole jako parametr funkce, tak se k nÄ›mu pÅ™ekladaÄ bude
 vÃ­cemÃ©nÄ› chovat jako k bÄ›Å¾nÃ©mu ukazateli. Je to z toho dÅ¯vodu, Å¾e pÅ™ekladaÄ nevÃ­, jak velkou pamÄ›Å¥
 do funkce pÅ™edÃ¡vÃ¡me (mÅ¯Å¾eme tuto funkci zavolat
 s ukazatelem na rÅ¯znÄ› velkÃ¡ pole!). Z toho dÅ¯vodu je tak lepÅ¡Ã­ pro parametry funkcÃ­ vÅ¾dy pouÅ¾Ã­vat
 rovnou ukazatel a ne pole, abychom zamezili nejasnostem.
<p>Tyto nÃ¡sledujÃ­cÃ­ tÅ™i signatury funkce jsou tedy v podstatÄ› totoÅ¾nÃ©:</p>
<pre><code class="language-c">void print_size(char pole[3]);
void print_size(char pole[]);
void print_size(char* pole);
</code></pre>
</details>
</li>
</ol>
<h1><a class="header" href="#dynamickÃ¡-pole" id="dynamickÃ¡-pole">DynamickÃ¡ pole</a></h1>
<p>Pole alokovanÃ¡ na zÃ¡sobnÃ­ku by mÄ›ly mÃ­t velikost danou pÅ™i pÅ™ekladu programu, Äasto ale potÅ™ebujeme
vytvÃ¡Å™et pole v zÃ¡vislosti na vstupu programu. NapÅ™Ã­klad, pokud bychom chtÄ›li vytvoÅ™it pole, kterÃ©
by obsahovalo vÅ¡echny Å™Ã¡dky souboru, tak dopÅ™edu nevÃ­me, kolik tÄ›ch Å™Ã¡dkÅ¯ bude nÄ›jakÃ½ konkrÃ©tnÃ­
soubor mÃ­t.</p>
<p>Ze sekce o <a href="c/pole/../prace_s_pameti/dynamicka_pamet.html">dynamickÃ© pamÄ›ti</a> jiÅ¾ vÃ­me,
jak alokovat libovolnÃ© mnoÅ¾stvÃ­ pamÄ›ti na haldÄ› pomocÃ­ funkce <code>malloc</code>. Pro vytvoÅ™enÃ­
<strong>dynamickÃ©ho pole</strong> (<em>dynamic array</em>) tak staÄÃ­ pouÅ¾Ã­t funkci <code>malloc</code>. NapÅ™Ã­klad pro vytvoÅ™enÃ­
dynamickÃ©ho pole pro <code>5</code> celÃ½ch ÄÃ­sel potÅ™ebujeme naalokovat <code>5 * sizeof(int)</code> bytÅ¯:</p>
<pre><code class="language-c">int* pole = (int*) malloc(5 * sizeof(int));
</code></pre>
<p>S takovouto pamÄ›tÃ­ pak mÅ¯Å¾eme pracovat jako s polem <code>int</code>Å¯ o velikosti <code>5</code>. Jakmile jiÅ¾ takovÃ©to
pole nepotÅ™ebujeme, nesmÃ­me jej samozÅ™ejmÄ› zapomenout
<a href="c/pole/../prace_s_pameti/dynamicka_pamet.html#uvoln%C4%9Bn%C3%AD-pam%C4%9Bti">uvolnit</a>.</p>
<h2><a class="header" href="#zmÄ›na-velikosti-pole" id="zmÄ›na-velikosti-pole">ZmÄ›na velikosti pole</a></h2>
<p>ObÄas potÅ™ebujeme velikost dynamickÃ©ho pole zmÄ›nit (obvykle zvÄ›tÅ¡it). NapÅ™Ã­klad pokud vÃ¡m
uÅ¾ivatel zadÃ¡vÃ¡ na vstupu seznam ÄÃ­sel, na zaÄÃ¡tku mÅ¯Å¾ete vytvoÅ™it pamÄ›Å¥ pro 10 ÄÃ­sel, ale pÅ™i
zadÃ¡nÃ­ 11. ÄÃ­sla musÃ­te tuto pamÄ›Å¥ zvÄ›tÅ¡it, jinak byste nemÄ›li novÃ© ÄÃ­slo kam zapsat. Tento proces
se nazÃ½vÃ¡ <strong>realokace</strong> (<em>reallocation</em>) a lze jej provÃ©st napÅ™Ã­klad nÃ¡sledujÃ­cÃ­m zpÅ¯sobem:</p>
<ol>
<li>Naalokujeme novÃ© dynamickÃ© pole o poÅ¾adovanÃ© velikosti</li>
<li>ZkopÃ­rujeme obsah pÅ¯vodnÃ­ho pole do novÃ©ho pole </li>
<li>UvolnÃ­me pamÄ›Å¥ pÅ¯vodnÃ­ho pole</li>
<li>UpravÃ­me odpovÃ­dajÃ­cÃ­ ukazatel(e) v programu, aby ukazoval(y) na novÄ› naalokovanÃ© pole</li>
</ol>
<p>Pokud se vÃ¡m toto nechce programovat ruÄnÄ›, tak mÅ¯Å¾ete takÃ© pouÅ¾Ã­t funkci
<a href="https://devdocs.io/c/memory/realloc"><code>realloc</code></a> ze standardnÃ­ knihovny <em>C</em>, kterÃ¡ to udÄ›lÃ¡ za vÃ¡s.
Tato funkce oÄekÃ¡vÃ¡ pÅ¯vodnÃ­ adresu alokace z <code>malloc</code>/<code>calloc</code> a poÄet bytÅ¯ novÃ© alokace.</p>
<hr />
<p><strong>CviÄenÃ­</strong> ğŸ‹</p>
<p>Zkuste naprogramovat funkci <code>realokace</code>, kterÃ¡ obdrÅ¾Ã­ dynamicky naalokovanÃ© pole
(tedy ukazatel), jeho pÅ¯vodnÃ­ velikost a novou velikost. Funkce realokuje pole na novou velikost a
vrÃ¡tÃ­ ukazatel na novÄ› naalokovanÃ© pole.</p>
<hr />
<h1><a class="header" href="#vÃ­cerozmÄ›rnÃ¡-pole" id="vÃ­cerozmÄ›rnÃ¡-pole">VÃ­cerozmÄ›rnÃ¡ pole</a></h1>
<p>NÄ›kdy potÅ™ebujeme v programech reprezentovat vÄ›ci, kterÃ© jsou pÅ™irozenÄ› vÃ­cerozmÄ›rnÃ©. TypickÃ½m
pÅ™Ã­kladem jsou obrÃ¡zky, kterÃ© lze reprezentovat jako dvourozmÄ›rnou mÅ™Ã­Å¾ku pixelÅ¯ (jeden rozmÄ›r udÃ¡vÃ¡
Å™Ã¡dky a druhÃ½ sloupce).</p>
<p><a href="c/pole/../../uvod/pamet.html">PamÄ›Å¥ovÃ© adresy</a> vÅ¡ak majÃ­ pouze jeden rozmÄ›r, jelikoÅ¾ jsou reprezentovÃ¡ny
jednÃ­m ÄÃ­slem. Jak tedy mÅ¯Å¾eme do jednorozmÄ›rnÃ© pamÄ›ti uloÅ¾it vÃ­cerozmÄ›rnou hodnotu? ZpÅ¯sobÅ¯ je vÃ­ce,
nicmÃ©nÄ› asi nejjednoduÅ¡Å¡Ã­ je prostÄ› &quot;vysklÃ¡dat&quot; jednotlivÃ© rozmÄ›ry (dimenze) v pamÄ›ti za sebou,
jeden rozmÄ›r za druhÃ½m. Pokud bychom napÅ™Ã­klad mÄ›li dvojrozmÄ›rnou mÅ™Ã­Å¾ku<sup class='margin-toggle sidenote-number'>1</sup> s rozmÄ›ry <code>5x5</code>,
mÅ¯Å¾eme ji reprezentovat tak, Å¾e nejprve do pamÄ›ti uloÅ¾Ã­me prvnÃ­ Å™Ã¡dek, potÃ© druhÃ½ Å™Ã¡dek atd.: </p>
<span class='sidenote'><p><sup class='number'>1</sup>ReprezentujÃ­cÃ­ napÅ™Ã­klad obrÃ¡zek Äi <a href="https://matematika.cz/matice">matici</a>.</p>
</span>
<p><img src="c/pole/../../static/img/2d_array.svg" alt="2D pole" /></p>
<p>Tento koncept se oznaÄuje jako <strong>vÃ­cerozmÄ›rnÃ© pole</strong> (<em>multidimensional array</em>).</p>
<h2><a class="header" href="#zpÅ¯sob-vysklÃ¡dÃ¡nÃ­-dimenzÃ­" id="zpÅ¯sob-vysklÃ¡dÃ¡nÃ­-dimenzÃ­">ZpÅ¯sob vysklÃ¡dÃ¡nÃ­ dimenzÃ­</a></h2>
<p>Je na nÃ¡s, v jakÃ©m poÅ™adÃ­ jednotlivÃ© dimenze do pamÄ›ti uloÅ¾Ã­me. Pokud bychom se bavili o 2D poli,
tak mÅ¯Å¾eme do pamÄ›ti uloÅ¾it Å™Ã¡dek po Å™Ã¡dku (viz obrÃ¡zek vÃ½Å¡e), coÅ¾ se oznaÄuje jako
<strong>row major ordering</strong>. MÅ¯Å¾eme ale takÃ© do pamÄ›ti vysklÃ¡dat sloupec po sloupci, coÅ¾ se nazÃ½vÃ¡
<strong>column major ordering</strong>. Je vÃ­cemÃ©nÄ› jedno, kterÃ½ zpÅ¯sob pouÅ¾ijeme, je ale dÅ¯leÅ¾itÃ© se drÅ¾et
jednoho pÅ™Ã­stupu, jinak mÅ¯Å¾e dojÃ­t k zÃ¡mÄ›nÄ› indexÅ¯. IndexovÃ¡nÃ­ totiÅ¾ zÃ¡leÅ¾Ã­ na tom, jakÃ½ zpÅ¯sob
vysklÃ¡dÃ¡nÃ­ pouÅ¾ijeme. NÃ­Å¾e pÅ™edpoklÃ¡dÃ¡me poÅ™adÃ­ <em>row major</em>.</p>
<h2><a class="header" href="#indexovÃ¡nÃ­" id="indexovÃ¡nÃ­">IndexovÃ¡nÃ­</a></h2>
<p>PÅ™i prÃ¡ci s dvourozmÄ›rnÃ½m polem bychom chtÄ›li pracovat s dvourozmÄ›rnÃ½m indexem (Å™Ã¡dek <code>i</code>, sloupec
<code>j</code>), nicmÃ©nÄ› pÅ™i samotnÃ©m pÅ™Ã­stupu do pamÄ›ti pak musÃ­me tento vÃ­cerozmÄ›rnÃ½ index pÅ™evÃ©st na 1D
index. A naopak, z 1D indexu bychom chtÄ›li mÃ­t moÅ¾nost zÃ­skat zpÄ›t 2D index. Pro vÃ½poÄet indexÅ¯ 2D
pole s <code>vyska</code> Å™Ã¡dky a <code>sirka</code> sloupci mÅ¯Å¾eme pouÅ¾Ã­t tyto jednoduchÃ© vzorce:</p>
<ul>
<li><strong>PÅ™evod z 2D do 1D</strong> - abychom se dostali na cÃ­lovou pozici, musÃ­me pÅ™eskoÄit <code>radek</code> Å™Ã¡dkÅ¯, kde
kaÅ¾dÃ½ Å™Ã¡dek mÃ¡ <code>sirka</code> prvkÅ¯, a potÃ© jeÅ¡tÄ› musÃ­me pÅ™iÄÃ­st pozici sloupce (<code>sloupec</code>).
<pre><code class="language-c">int index_2d_na_1d(int radek, int sloupec, int sirka) {
    return radek * sirka + sloupec;
}
</code></pre>
</li>
<li><strong>PÅ™evod z 1D do 2D</strong> - pro pÅ™evod z 1D indexu zpÄ›t na 2D index staÄÃ­ aplikovat opaÄnÃ½ postup.
Nejprve vydÄ›lÃ­me 1D index poÄtem sloupcÅ¯, abychom zjistili, na jakÃ©m jsme Å™Ã¡dku, a potÃ© pouÅ¾ijeme
zbytek po dÄ›lenÃ­, abychom zjistili, na jakÃ©m jsme sloupci.
<pre><code class="language-c">void index_1d_na_2d(int index, int sirka, int* radek, int* sloupec) {
    *radek = index / sirka;
    *sloupec = index % sirka;
}
</code></pre>
</li>
</ul>
<p>Tento koncept lze zobecnit na libovolnÄ› rozmÄ›rnÃ© pole (3D, 4D, â€¦).</p>
<h2><a class="header" href="#vÃ­cerozmÄ›rnÃ©-pole-na-zÃ¡sobnÃ­ku" id="vÃ­cerozmÄ›rnÃ©-pole-na-zÃ¡sobnÃ­ku">VÃ­cerozmÄ›rnÃ© pole na zÃ¡sobnÃ­ku</a></h2>
<p>Pokud znÃ¡me v dobÄ› pÅ™ekladu velikost a rozmÄ›ry vÃ­cerozmÄ›rnÃ©ho pole, tak mÅ¯Å¾eme vyuÅ¾Ã­t vÃ­cerozmÄ›rnÃ½ch <a href="c/pole/staticka_pole.html">statickÃ½ch polÃ­</a>. PÅ™i
vytvÃ¡Å™enÃ­ pole staÄÃ­ pouÅ¾Ã­t hranatÃ© zÃ¡vorky pro kaÅ¾dou dimenzi pole. NapÅ™Ã­klad takto lze vytvoÅ™it
2D pole s rozmÄ›ry <code>3x3</code> na zÃ¡sobnÃ­ku:</p>
<pre><code class="language-c">int pole[3][3];
</code></pre>
<p>VÃ½hoda takovÃ½chto polÃ­ je, Å¾e pÅ™ekladaÄ provede pÅ™evod z 2D indexu na 1D index za vÃ¡s, a mÅ¯Å¾ete tak
toto pole pÅ™Ã­mo indexovat vÃ­cerozmÄ›rnÃ½m indexem. NapÅ™Ã­klad prvnÃ­ prvek pole z kÃ³du vÃ½Å¡e lze nalÃ©zt
na pozici <code>pole[0][0]</code>, poslednÃ­ na pozici <code>pole[2][2]</code>.</p>
<p>TakovÃ¡to pole jsou v pamÄ›ti vysklÃ¡dÃ¡na postupnÄ› dle jednotlivÃ½ch dimenzÃ­ zleva. Nejprve tedy v
pamÄ›ti leÅ¾Ã­ prvek <code>pole[0][0]</code>, potÃ© <code>pole[0][1]</code>, â€¦, <code>pole[1][1]</code>, <code>pole[1][2]</code> atd. Pokud
bychom mÄ›li 2D pole a prvnÃ­ index bychom poklÃ¡dali za index Å™Ã¡dku, tak toto vysklÃ¡dÃ¡nÃ­ odpovÃ­dÃ¡
<em>row major</em> poÅ™adÃ­.</p>
<p>VÃ­cerozmÄ›rnÃ¡ pole v <em>C</em> lze zobecnit do vyÅ¡Å¡Ã­ch dimenzÃ­ (mÅ¯Å¾ete tak pouÅ¾Ã­t napÅ™Ã­klad
<code>int pole[3][3][3]</code> atd.), nicmÃ©nÄ› je dobrÃ© to nepÅ™ehÃ¡nÄ›t, aby kÃ³d zÅ¯stal pÅ™ehlednÃ½.</p>
<h3><a class="header" href="#inicializace-vÃ­cerozmÄ›rnÃ½ch-polÃ­" id="inicializace-vÃ­cerozmÄ›rnÃ½ch-polÃ­">Inicializace vÃ­cerozmÄ›rnÃ½ch polÃ­</a></h3>
<p>VÃ­cerozmÄ›rnÃ© pole mÅ¯Å¾ete nainicializovat <a href="c/pole/staticka_pole.html#inicializace-pole">stejnÄ›</a> jako klasickÃ©
pole. Pro zpÅ™ehlednÄ›nÃ­ kÃ³du vÅ¡ak takÃ© mÅ¯Å¾ete pouÅ¾Ã­t sloÅ¾enÃ© zÃ¡vorky pro oddÄ›lenÃ­ jednotlivÃ½ch
dimenzÃ­:</p>
<pre><code class="language-c">int pole_2d[3][4] = {  
   {0, 1, 2, 3},    // hodnoty pro prvnÃ­ Å™Ã¡dek
   {4, 5, 6, 7},    // hodnoty pro druhÃ½ Å™Ã¡dek
   {8, 9, 10, 11}   // hodnoty pro tÅ™etÃ­ Å™Ã¡dek
};
</code></pre>
<h2><a class="header" href="#vÃ­cerozmÄ›rnÃ©-pole-na-haldÄ›" id="vÃ­cerozmÄ›rnÃ©-pole-na-haldÄ›">VÃ­cerozmÄ›rnÃ© pole na haldÄ›</a></h2>
<p>Pokud potÅ™ebujeme vÃ­cerozmÄ›rnÃ© pole s <a href="c/pole/dynamicka_pole.html">dynamickou velikostÃ­</a>, staÄÃ­ pÅ™i volÃ¡nÃ­
funkce <code>malloc</code> vytvoÅ™it dostatek pamÄ›ti pro vÅ¡echny rozmÄ›ry. Pokud bychom napÅ™Ã­klad chtÄ›li
naalokovat pamÄ›Å¥ pro 2D obrÃ¡zek s <code>vyska</code> Å™Ã¡dky a <code>sirka</code> sloupci, mÅ¯Å¾eme pouÅ¾Ã­t nÃ¡sledujÃ­cÃ­ volÃ¡nÃ­
funkce <code>malloc</code>:</p>
<pre><code class="language-c">int* pamet_obrazku = (int*) malloc(vyska * sirka * sizeof(int));
</code></pre>
<p>NezapomeÅˆte, Å¾e pro indexovÃ¡nÃ­ takovÃ©ho pole budeme muset pouÅ¾Ã­vat <a href="c/pole/vicerozmerna_pole.html#indexov%C3%A1n%C3%AD">pÅ™epoÄet 1D/2D indexÅ¯</a>!</p>
<h1><a class="header" href="#zubatÃ¡-pole" id="zubatÃ¡-pole">ZubatÃ¡ pole</a></h1>
<blockquote>
<p>ğŸ¤“ Tato sekce obsahuje doplÅˆujÃ­cÃ­ uÄivo. Pokud je toho na vÃ¡s moc, mÅ¯Å¾ete ji prozatÃ­m pÅ™eskoÄit
a vrÃ¡tit se k nÃ­ pozdÄ›ji.</p>
</blockquote>
<p>ObÄas mÅ¯Å¾ete narazit na situaci, kdy potÅ™ebujete vytvoÅ™it vÃ­cerozmÄ›rnÃ© pole, kde nÄ›kterÃ¡ z dimenzÃ­
nemÃ¡ fixnÃ­ velikost. NapÅ™Ã­klad prvnÃ­ Å™Ã¡dek mÅ¯Å¾e mÃ­t dva sloupce, druhÃ½ Å™Ã¡dek tÅ™i sloupce, tÅ™etÃ­ Å™Ã¡dek
Å¾Ã¡dnÃ½ sloupec atd.</p>
<p>V takovÃ©m pÅ™Ã­padÄ› mÅ¯Å¾ete vytvoÅ™it tzv. <strong>zubatÃ© pole</strong> (<em>jagged array</em> nebo takÃ© <em>ragged array</em>).
ZubatÃ© pole je v podstatÄ› &quot;pole polÃ­&quot; - vytvoÅ™Ã­te (dynamickÃ©)<sup class='margin-toggle sidenote-number'>1</sup> pole Å™Ã¡dkÅ¯, a kaÅ¾dÃ½ Å™Ã¡dek bude opÄ›t
dynamickÃ© pole sloupcÅ¯. KvÅ¯li tomuto vnoÅ™enÃ­ polÃ­ je nutnÃ© jako datovÃ½ typ pouÅ¾Ã­t ukazatel na ukazatel.
NÃ¡sledujÃ­cÃ­ kÃ³d vytvoÅ™Ã­ pole pÄ›ti studentÅ¯, a kaÅ¾dÃ©mu studentovi vytvoÅ™Ã­ pole s rÅ¯znÃ½m poÄtem ID pÅ™edmÄ›tÅ¯,
kterÃ© studuje:</p>
<span class='sidenote'><p><sup class='number'>1</sup>VnÄ›jÅ¡Ã­ pole Å™Ã¡dkÅ¯ teoreticky nemusÃ­ bÃ½t dynamickÃ©, ale pokud uÅ¾ potÅ™ebujete dynamickÃ©
poÄty sloupcÅ¯, obvykle budete chtÃ­t i dynamickÃ½ poÄet Å™Ã¡dkÅ¯. </p>
</span>
<pre><code class="language-c editable mainbody">#include &lt;stdlib.h&gt;

int main() {
    // VytvoÅ™enÃ­ pole studentÅ¯
    int** studenti = (int**) malloc(5 * sizeof(int*));

    for (int i = 0; i &lt; 5; i++) {
        // VytvoÅ™enÃ­ pole pÅ™edmÄ›tÅ¯ pro konkrÃ©tnÃ­ho studenta
        studenti[i] = (int*) malloc((i + 1) * sizeof(int));
    }

    // DruhÃ½ pÅ™edmÄ›t tÅ™etÃ­ho studenta bude mÃ­t ID 5
    studenti[2][1] = 5;

    for (int i = 0; i &lt; 5; i++) {
        // UvolnÄ›nÃ­ pole pÅ™edmÄ›tÅ¯ pro konkrÃ©tnÃ­ho studenta
        free(studenti[i]);
    }

    // UvolnÄ›nÃ­ pole studentÅ¯
    free(studenti);
    return 0;
}
</code></pre>
<p>PÅ™i pÅ™Ã­stupu k prvkÅ¯m pole mÅ¯Å¾eme klasicky vyuÅ¾Ã­t hranatÃ½ch zÃ¡vorek. <code>studenti[2]</code> vrÃ¡tÃ­ adresu
pole pÅ™edmÄ›tÅ¯ tÅ™etÃ­ho studenta, a nad tÃ­mto polem (resp. ukazatelem) mÅ¯Å¾eme opÄ›t pouÅ¾Ã­t hranatÃ©
zÃ¡vorky pro pÅ™Ã­stup k druhÃ©mu pÅ™edmÄ›tu. Zde se tak neprovÃ¡dÃ­ Å¾Ã¡dnÃ½ pÅ™evod 2D na 1D indexy ani naopak,
protoÅ¾e jednotlivÃ¡ pole v pamÄ›ti nejsou uloÅ¾ena za sebou.</p>
<p>VÅ¡imnÄ›te si, Å¾e jednotlivÃ© pole pÅ™edmÄ›tÅ¯ (&quot;Å™Ã¡dky&quot; naÅ¡eho vÃ­cerozmÄ›rnÃ©ho pole) musÃ­me uvolÅˆovat
zvlÃ¡Å¡Å¥, a musÃ­me je uvolnit dÅ™Ã­ve, neÅ¾ uvolnÃ­me samotnÃ© pole studentÅ¯ (Å™Ã¡dkÅ¯), jinak bychom uÅ¾ k
adresÃ¡m polÃ­ pÅ™edmÄ›tÅ¯ nesmÄ›li pÅ™istupovat.</p>
<blockquote>
<p>Pokud by zubatÃ© pole mÄ›lo tÅ™i dimenze, typ &quot;vnÄ›jÅ¡Ã­ho&quot; pole by byl <code>int***</code>, pokud ÄtyÅ™i dimenze,
tak <code>int****</code> atd.</p>
</blockquote>
<p>VytvÃ¡Å™enÃ­ a uvolÅˆovÃ¡nÃ­ zubatÃ©ho pole je o dost nÃ¡roÄnÄ›jÅ¡Ã­ neÅ¾ u klasickÃ©ho vÃ­cerozmÄ›rnÃ©ho pole. To
je totiÅ¾ v pamÄ›ti uloÅ¾eno jako klasickÃ© 1D pole, kterÃ© akorÃ¡t indexujeme vÃ­cerozmÄ›rnÃ½m indexem, kdeÅ¾to
zubatÃ© pole je opravdu pole polÃ­ (polÃ­ polÃ­...). NÄ›kdy je ovÅ¡em nutnÃ© mÃ­t rÅ¯znou velikost jednotlivÃ½ch
Å™Ã¡dkÅ¯, a tehdy zubatÃ¡ pole pÅ™ijdou vhod.</p>
<h1><a class="header" href="#text" id="text">Text</a></h1>
<p>Doposud jsme pracovali zejmÃ©na s ÄÃ­sly, nynÃ­ se podÃ­vÃ¡me na to, jak mÅ¯Å¾eme v poÄÃ­taÄi reprezentovat
znaky a jak obecnÄ› pracovat s textem. ZpracovÃ¡nÃ­ textu je obsaÅ¾eno tÃ©mÄ›Å™ v kaÅ¾dÃ©m programu â€“
naÄÃ­tÃ¡nÃ­ konfiguraÄnÃ­ch souborÅ¯, zadÃ¡vÃ¡nÃ­ pÅ™Ã­kazÅ¯ z terminÃ¡lu, prÃ¡ce s dokumenty Äi tabulkami,
komunikace po sÃ­ti a mnoho dalÅ¡Ã­ch ÄinnostÃ­ vyÅ¾aduje prÃ¡ci s textem.</p>
<p>Nejprve si ukÃ¡Å¾eme, jak v poÄÃ­taÄi reprezentovat jednotlivÃ© <a href="c/text/znaky.html">znaky</a>, dÃ¡le jak z nich
vytvoÅ™it delÅ¡Ã­ <a href="c/text/retezce.html">sekvence textu</a> a potÃ© jak text <a href="c/text/vstupavystup.html">naÄÃ­tat a vypisovat</a>.</p>
<h1><a class="header" href="#znaky" id="znaky">Znaky</a></h1>
<p>UÅ¾ vÃ­me, Å¾e v pamÄ›ti poÄÃ­taÄe je nakonec vÅ¡e reprezentovÃ¡no ÄÃ­slem, a ani textovÃ© znaky
nejsou vÃ½jimkou. PÅ™irozenÃ½m zpÅ¯sobem, jak od sebe znaky odliÅ¡it, je pÅ™iÅ™adit kaÅ¾dÃ©mu znaku jinÃ© ÄÃ­slo,
napÅ™Ã­klad znak <code>A</code> mÅ¯Å¾eme reprezentovat ÄÃ­slem <code>0</code>, znak <code>B</code> ÄÃ­slem <code>1</code> atd. Kdyby si vÅ¡ak kaÅ¾dÃ½
program(Ã¡tor) definoval vlastnÃ­ zpÅ¯sob, jak pÅ™evÃ¡dÄ›t znaky na ÄÃ­sla, tak by mezi sebou programy
nemohly rozumnÄ› komunikovat, protoÅ¾e by si nerozumÄ›ly.</p>
<p>Z toho dÅ¯vodu vzniklo za poslednÃ­ desÃ­tky let mnoho <strong>textovÃ½ch kÃ³dovÃ¡nÃ­</strong>
(<em>character encoding</em>), kterÃ© definujÃ­, jakÃ¡ ÄÃ­sla pÅ™iÅ™adit jednotlivÃ½m znakÅ¯m. DneÅ¡nÃ­m de-facto
standardem je kÃ³dovÃ¡nÃ­ <a href="https://en.wikipedia.org/wiki/Unicode">Unicode</a>, kterÃ© obsahuje pÅ™es sto tisÃ­c
rÅ¯znÃ½ch znakÅ¯, od dÃ¡vnÃ½ch hieroglyfÅ¯, pÅ™es Äeskou Äi anglickou abecedu, aÅ¾ po vÅ¡elijakÃ© emoji.
PrÃ¡ce s kÃ³dovÃ¡nÃ­m Unicode vÅ¡ak nenÃ­ v jazyce <em>C</em> pÅ™Ã­moÄarÃ¡, navÃ­c pro naÅ¡e potÅ™eby vÅ¯bec nenÃ­ potÅ™eba<sup class='margin-toggle sidenote-number'>1</sup>.</p>
<span class='sidenote'><p><sup class='number'>1</sup>Pokud byste se o kÃ³dovÃ¡nÃ­ znakÅ¯ a Unicode chtÄ›li dozvÄ›dÄ›t vÃ­ce, pÅ™eÄtÄ›te si tento
<a href="https://kunststube.net/encoding/">ÄlÃ¡nek</a>. </p>
</span>
<p>V rÃ¡mci pÅ™edmÄ›tu UPR si tak vystaÄÃ­me s kÃ³dovÃ¡nÃ­m <a href="https://en.wikipedia.org/wiki/ASCII">ASCII</a>
(American Standard Code for Information Interchange). Toto kÃ³dovÃ¡nÃ­ sice obsahuje pouze 128 znakÅ¯
(ÄÃ­slice, malÃ¡ a velkÃ¡ pÃ­smena anglickÃ© abecedy, interpunkce apod.), nicmÃ©nÄ› prÃ¡ce s nÃ­m je dÃ­ky tomu
velmi jednoduchÃ¡. Je navÃ­c podmnoÅ¾inou Unicode, takÅ¾e programy, kterÃ© podporujÃ­ Unicode kÃ³dovÃ¡nÃ­, si
s ASCII hravÄ› poradÃ­. Tabulku, kterÃ¡ uvÃ¡dÃ­, jak ASCII mapuje jednotlivÃ© znaky na ÄÃ­sla, naleznete napÅ™.
<a href="https://www.asciitable.com/">zde</a><sup class='margin-toggle sidenote-number'>2</sup>.</p>
<span class='sidenote'><p><sup class='number'>2</sup>V tabulce si mÅ¯Å¾ete vÅ¡imnout, Å¾e ÄÃ­sla nejsou znakÅ¯m pÅ™iÅ™azena
zcela nÃ¡hodnÄ›, napÅ™Ã­klad znaky reprezentujÃ­cÃ­ ÄÃ­slice <code>0</code> aÅ¾ <code>9</code> majÃ­ pÅ™iÅ™azena ÄÃ­sla leÅ¾Ã­cÃ­ za sebou
(<code>48</code> - <code>57</code>), a stejnÄ› je tomu i u pÃ­smen anglickÃ© abecedy. TÃ©to vlastnosti mÅ¯Å¾eme vyuÅ¾Ã­t pro
usnadnÄ›nÃ­ nÄ›kterÃ½ch textovÃ½ch <a href="c/text/../../ulohy/text.html#p%C5%99evod-textu-na-%C4%8D%C3%ADslo">operacÃ­</a>.</p>
</span>
<h2><a class="header" href="#ascii-znaky-v-c" id="ascii-znaky-v-c">ASCII znaky v <em>C</em></a></h2>
<p>JelikoÅ¾ ASCII &quot;kÃ³duje&quot; pouze 128 znakÅ¯, tak pro reprezentaci ASCII znaku by nÃ¡m staÄilo 7 bitÅ¯.
NicmÃ©nÄ› pracovat se sedmibitovÃ½mi hodnotami by bylo ponÄ›kud nepraktickÃ©, proto se bÄ›Å¾nÄ› ASCII znak
uklÃ¡dÃ¡ do jednobytovÃ©ho (osmibitovÃ©ho) ÄÃ­sla. V <em>C</em> se pro reprezentaci jednoho ASCII znaku pouÅ¾Ã­vÃ¡
datovÃ½ typ <code>char</code><sup class='margin-toggle sidenote-number'>3</sup>, s kterÃ½m jsme se
<a href="c/text/../datove_typy/celociselne_typy.html">jiÅ¾ setkali</a>.</p>
<span class='sidenote'><p><sup class='number'>3</sup><em>C</em> neobsahuje specializovanÃ½ typ pro jednobytovÃ© celÃ© ÄÃ­slo, <code>char</code> tak reprezentuje jak
ASCII znak, tak i celÃ© ÄÃ­slo s jednÃ­m bytem. ZÃ¡leÅ¾Ã­ pak na nÃ¡s, jak budeme hodnotu v <code>char</code>u
interpretovat - jestli jako celÃ© ÄÃ­slo nebo jako ASCII znak.</p>
</span>
<p>Pokud bychom chtÄ›li do promÄ›nnÃ© s typem <code>char</code> nÄ›jakÃ½ znak uloÅ¾it, tak bychom mohli pouÅ¾Ã­t pÅ™Ã­mo
jeho ÄÃ­slo z ASCII <a href="https://www.asciitable.com/">tabulky</a>:</p>
<pre><code class="language-c">char znak = 65; // tento znak bude reprezentovat pÃ­smeno A
</code></pre>
<p>NicmÃ©nÄ› takto by si kaÅ¾dÃ½ programÃ¡tor musel nazpamÄ›Å¥ pamatovat ASCII tabulku, coÅ¾ je dost nepraktickÃ©.
<em>C</em> tak nabÃ­zÃ­ zkratku v podobÄ› <strong>znakovÃ©ho literÃ¡lu</strong> (<em>char literal</em>). Pokud napÃ­Å¡ete jeden ASCII
znak do apostrofÅ¯ (<code>'</code>), tento vÃ½raz se vyhodnotÃ­ jako ASCII ÄÃ­selnÃ¡ hodnota danÃ©ho znaku s datovÃ½m
typem <code>char</code>. Obvykle tak znaky v programech zadÃ¡vÃ¡me v apostrofech pro zjednoduÅ¡enÃ­:</p>
<pre><code class="language-c">char znak = 'A'; // tento znak bude reprezentovat pÃ­smeno A
</code></pre>
<p>Pokud bychom si chtÄ›li ovÄ›Å™it, Å¾e hodnota tohoto znaku je opravdu <code>65</code>, jak udÃ¡vÃ¡ ASCII, mÅ¯Å¾eme
si ho vypsat na vÃ½stup programu jako ÄÃ­slo:</p>
<pre><code class="language-c editable mainbody">#include &lt;stdio.h&gt;

int main() {
    char znak = 'A';
    printf(&quot;%d\n&quot;, (int) znak);
    return 0;
}
</code></pre>
<p>Do apostrofÅ¯ nikdy nedÃ¡vejte vÃ­ce neÅ¾ jeden znak! PÅ™ekladaÄ by se snaÅ¾il takovÃ½to zÃ¡pis interpretovat
jako vÃ­cebytovÃ½ znak, coÅ¾ tÃ©mÄ›Å™ jistÄ› nenÃ­ to, Äeho chcete dosÃ¡hnout. Pro prÃ¡ci s textem (vÃ­ce znaky
najednou) slouÅ¾Ã­ <a href="c/text/retezce.html">Å™etÄ›zce</a>. Jedinou vÃ½jimkou jsou speciÃ¡lnÃ­ znaky, kterÃ© se zapisujÃ­
pomocÃ­ zpÄ›tnÃ©ho lomÃ­tka, napÅ™Ã­klad:</p>
<ul>
<li><code>'\n'</code> reprezentuje znak <code>LF</code>, kterÃ½ udÃ¡vÃ¡, Å¾e mÃ¡ dojÃ­t k pÅ™echodu kurzoru na novÃ½ Å™Ã¡dek.<sup class='margin-toggle sidenote-number'>4</sup><span class='sidenote'><p><sup class='number'>4</sup>NepleÅ¥te si ho se znakem <code>'n'</code>, kterÃ½ reprezentuje klasickÃ© pÃ­smeno <code>n</code> z abecedy.</p>
</span></li>
<li><code>'\t'</code> reprezentuje znak <code>TAB</code>, kterÃ½ udÃ¡vÃ¡, Å¾e mÃ¡ dojÃ­t k vÃ½pisu delÅ¡Ã­ mezery.</li>
<li><code>'\0'</code> reprezentuje znak <code>NUL</code> s ÄÃ­selnou hodnotou <code>0</code>.</li>
</ul>
<h3><a class="header" href="#ÄŒÃ­sla-vs-znaky" id="ÄŒÃ­sla-vs-znaky">ÄŒÃ­sla vs znaky</a></h3>
<p>PÅ™i pouÅ¾Ã­vÃ¡nÃ­ apostrofÅ¯ je mimo jinÃ© tÅ™eba si dÃ¡vat pozor na to, jestli pracujeme s ÄÃ­selnou
hodnotou nebo se znakem, kterÃ½ reprezentuje nÄ›jakou ÄÃ­slici. NapÅ™Ã­klad zde:</p>
<pre><code class="language-c">char znak = 9;
</code></pre>
<p>Nedojde k uloÅ¾enÃ­ znaku <code>9</code> do promÄ›nnÃ©. Bude do nÃ­ uloÅ¾en znak <code>TAB</code>, kterÃ½ mÃ¡ v ASCII hodnotu <code>9</code>
a pomocÃ­ apostrofÅ¯ ho lze zapsat jako <code>'\t'</code>. Pokud bychom do znaku chtÄ›li zapsat znak reprezentujÃ­cÃ­
ÄÃ­slici <code>9</code>, musÃ­me pouÅ¾Ã­t buÄ literÃ¡l <code>'9'</code> nebo ÄÃ­selnou hodnotu <code>57</code>, kterÃ¡ devÃ­tku v ASCII
reprezentuje.</p>
<p>Pokud byste chtÄ›li pÅ™evÃ©st ASCII znak ÄÃ­slice na jejÃ­ ÄÃ­selnou hodnotu, staÄÃ­ od nÄ›j odeÄÃ­st hodnotu
<code>48</code>, neboli znak <code>'0'</code>. <code>'0' - '0'</code> je <code>0</code>, <code>'5' - '0'</code> je <code>5</code> atd. To je zpÅ¯sobeno tÃ­m, Å¾e ÄÃ­slice
majÃ­ v ASCII kÃ³dovÃ¡nÃ­ pÅ™iÅ™azeny sekvenÄnÃ­ ÄÃ­selnÃ© hodnoty.</p>
<h1><a class="header" href="#Å˜etÄ›zce" id="Å˜etÄ›zce">Å˜etÄ›zce</a></h1>
<p>NynÃ­ uÅ¾ vÃ­me, jak mÅ¯Å¾eme v <em>C</em> pracovat s jednotlivÃ½mi (ASCII) znaky. Obvykle vÅ¡ak chceme pracovat
s delÅ¡Ã­mi sekvencemi textu - Å™Ã¡dky, vÄ›tami, odstavci atd. Sekvence textu se v programovacÃ­ch jazycÃ­ch
obvykle oznaÄujÃ­ jako <strong>Å™etÄ›zce</strong> (<em>strings</em>).</p>
<p>DobrÃ¡ zprÃ¡va je, Å¾e pro pouÅ¾itÃ­ Å™etÄ›zcÅ¯ v <em>C</em> uÅ¾
znÃ¡me vÅ¡e potÅ™ebnÃ© â€“ Å™etÄ›zce nejsou nic jinÃ©ho neÅ¾ <a href="c/text/../pole/pole.html">pole</a> <a href="c/text/znaky.html">znakÅ¯</a>!</p>
<h2><a class="header" href="#Å˜etÄ›zce-v-c" id="Å˜etÄ›zce-v-c">Å˜etÄ›zce v <em>C</em></a></h2>
<p>Teoreticky bychom si mohli navrhnout vlastnÃ­ zpÅ¯sob, jak Å™etÄ›zce v pamÄ›ti reprezentovat a jak s nimi
pracovat. NicmÃ©nÄ› zabÄ›hlÃ½m zpÅ¯sobem, jak s ASCII textem v <em>C</em> pracovat, a pro kterÃ½ <em>C</em> nabÃ­zÃ­ rÅ¯znÃ©
funkce a zÃ¡kladnÃ­ syntaktickou podporu, je pouÅ¾itÃ­ takzvanÃ½ch <strong>Å™etÄ›zcÅ¯ zakonÄenÃ½ch nulou</strong>
(<em>null-terminated strings</em>). Takto reprezentovanÃ½ Å™etÄ›zec nenÃ­ nic jinÃ©ho neÅ¾ <a href="c/text/../pole/pole.html">pole</a>
<a href="c/text/znaky.html">znakÅ¯</a>, kterÃ© obsahuje na svÃ©m poslednÃ­m indexu znak <code>'\0'</code> (s ÄÃ­selnou hodnotou <code>0</code>),
kterÃ½ znaÄÃ­ konec Å™etÄ›zce. NapÅ™Ã­klad Å™etÄ›zec <code>UPR</code> by tedy v pamÄ›ti poÄÃ­taÄe byl reprezentovanÃ½ takto:
<upr-array array='["U", "P", "R", "\\0"]'></upr-array></p>
<h3><a class="header" href="#vytvoÅ™enÃ­-Å™etÄ›zce" id="vytvoÅ™enÃ­-Å™etÄ›zce">VytvoÅ™enÃ­ Å™etÄ›zce</a></h3>
<p>Pokud bychom chtÄ›li vytvoÅ™it Å™etÄ›zec na zÃ¡sobnÃ­ku, mÅ¯Å¾eme vytvoÅ™it statickÃ© pole, umÃ­stit do nÄ›j
jednotlivÃ© znaky Å™etÄ›zce a za nÄ› pÅ™idat znak <code>'\0</code><sup class='margin-toggle sidenote-number'>1</sup>:</p>
<span class='sidenote'><p><sup class='number'>1</sup>Pro <a href="c/text/vystup.html">vÃ½pis</a> Å™etÄ›zce pomocÃ­ funkce <code>printf</code> mÅ¯Å¾eme pouÅ¾Ã­t zÃ¡stupnÃ½ znak <code>%s</code>.</p>
</span>
<pre><code class="language-c editable mainbody">#include &lt;stdio.h&gt;

int main() {
    char text[4] = {'U', 'P', 'R', '\0'};
    printf(&quot;%s\n&quot;, text);
    return 0;
}
</code></pre>
<p>Pokud bychom potÅ™ebovali Å™etÄ›zec s dynamickou nebo velkou dÃ©lkou, mÅ¯Å¾eme pro vytvoÅ™enÃ­ Å™etÄ›zce
samozÅ™ejmÄ› pouÅ¾Ã­t takÃ© <a href="c/text/../pole/dynamicka_pole.html">dynamickou pamÄ›Å¥</a>.</p>
<h3><a class="header" href="#Å˜etÄ›zcovÃ½-literÃ¡l" id="Å˜etÄ›zcovÃ½-literÃ¡l">Å˜etÄ›zcovÃ½ literÃ¡l</a></h3>
<p>VytvÃ¡Å™enÃ­ Å™etÄ›zcÅ¯ tÃ­mto zpÅ¯sobem je nicmÃ©nÄ› celkem zdlouhavÃ© a nepÅ™ehlednÃ©. ÄŒasto chceme v programu
jednoduÅ¡e a rychle zapsat krÃ¡tkÃ½ textovÃ½ Å™etÄ›zec tak, aby Å¡el pÅ™ehlednÄ› pÅ™eÄÃ­st. K tomu mÅ¯Å¾eme vyuÅ¾Ã­t
tzv. <strong>Å™etÄ›zcovÃ½ literÃ¡l</strong> (<em>string literal</em>), kterÃ½ lze vytvoÅ™it tak, Å¾e napÃ­Å¡eme text do dvojitÃ½ch
uvozovek (<code>&quot;</code>). Pokud tedy v naÅ¡em programu vytvoÅ™Ã­me napÅ™Ã­klad literÃ¡l <code>&quot;UPR&quot;</code>, tak se stane nÃ¡sledujÃ­cÃ­:</p>
<ol>
<li>PÅ™ekladaÄ pÅ™i pÅ™ekladu uloÅ¾Ã­ do vÃ½slednÃ©ho spustitelnÃ©ho souboru pole reprezentujÃ­cÃ­ danÃ½ Å™etÄ›zec.
V tomto pÅ™Ã­padÄ› pÅ¯jde o pole velikosti 4 s hodnotami <code>'U'</code>, <code>'P'</code>, <code>'R'</code> a <code>'\0'</code>. PÅ™i spuÅ¡tÄ›nÃ­
programu se toto pole naÄte do <a href="c/text/../prace_s_pameti/globalni_pamet.html">globÃ¡lnÃ­ pamÄ›ti</a> v sekci
adresnÃ­ho prostoru, kterÃ¡ je urÄena pouze pro ÄtenÃ­. Do takto vytvoÅ™enÃ©ho Å™etÄ›zce tak nelze
zapisovat, lze jej pouze ÄÃ­st<sup class='margin-toggle sidenote-number'>2</sup>.<span class='sidenote'><p><sup class='number'>2</sup>Tyto Å™etÄ›zce jsou pouze pro ÄtenÃ­ zejmÃ©na z toho dÅ¯vodu, aby je Å¡lo sdÃ­let. Pokud napÅ™Ã­klad
v programu pouÅ¾ijete tÅ™ikrÃ¡t stejnÃ½ Å™etÄ›zcovÃ½ literÃ¡l, pÅ™ekladaÄ mÅ¯Å¾e v pamÄ›ti pole pro tento
literÃ¡l vytvoÅ™it pouze jednou, aby uÅ¡etÅ™il pamÄ›Å¥. KvÅ¯li toho ale musÃ­ bÃ½t Å™etÄ›zce pouze pro ÄtenÃ­,
pokud bychom totiÅ¾ takto sdÃ­lenÃ½ Å™etÄ›zec zmÄ›nili, zmÄ›nilo by to i hodnotu vÅ¡ech ostatnÃ­ch literÃ¡lÅ¯,
kterÃ© se vyhodnotÃ­ na jeho adresu, coÅ¾ by bylo dost neintuitivnÃ­.</p>
</span></li>
<li>SamotnÃ½ vÃ½raz literÃ¡lu se pÅ™i bÄ›hu programu vyhodnotÃ­ jako adresa prvnÃ­ho znaku Å™etÄ›zce
uloÅ¾enÃ©ho v globÃ¡lnÃ­ pamÄ›ti.</li>
<li>DatovÃ½ typ literÃ¡lu bude
<a href="c/text/../prace_s_pameti/ukazatele.html#konstantn%C3%AD-ukazatele">ukazatel na konstantnÃ­ znak</a>, tedy
<code>const char*</code>. Tento datovÃ½ typ Å™Ã­kÃ¡, Å¾e hodnotu znaku na danÃ© adrese nelze mÄ›nit.</li>
</ol>
<p>PomocÃ­ Å™etÄ›zcovÃ©ho literÃ¡lu si tak mÅ¯Å¾eme znaÄne usnadnit zÃ¡pis Å™etÄ›zcÅ¯ v programech, jelikoÅ¾
nemusÃ­me pÅ™emÃ½Å¡let nad dÃ©lkou pole, nemusÃ­me pamatovat na umÃ­stÄ›nÃ­ znaku <code>'\0'</code> na konec Å™etÄ›zce
a ani nemusÃ­me obalovat jednotlivÃ© znaky do apostrofÅ¯:</p>
<pre><code class="language-c editable mainbody">#include &lt;stdio.h&gt;

int main() {
    const char* text = &quot;UPR&quot;;
    printf(&quot;%s\n&quot;, text);
    return 0;
}
</code></pre>
<p>Je vÅ¡ak tÅ™eba pamatovat na to, Å¾e takto vytvoÅ™enÃ© Å™etÄ›zce jsou opravdu pouze pro ÄtenÃ­, a nesmÃ­me
tak do nich zapisovat. Pokud je budete uklÃ¡dat do promÄ›nnÃ©, tak pouÅ¾ijte datovÃ½ typ <code>const char*</code>,
dÃ­ky kterÃ©mu vÃ¡s pÅ™ekladaÄ bude hlÃ­dat, abyste se do takovÃ©hoto Å™etÄ›zce omylem nesnaÅ¾ili nÄ›co zapsat.</p>
<p>Pokud byste chtÄ›li pouÅ¾Ã­t Å™etÄ›zcovÃ½ literÃ¡l pro vytvoÅ™enÃ­ Å™etÄ›zce, kterÃ½ lze mÄ›nit, mÅ¯Å¾ete ho uloÅ¾it
do promÄ›nnÃ© typu <code>char[]</code> (tj. pole znakÅ¯):</p>
<pre><code class="language-c editable mainbody">#include &lt;stdio.h&gt;

int main() {
    char text[] = &quot;UPR&quot;;
    text[0] = 'A';
    printf(&quot;%s\n&quot;, text);
    return 0;
}
</code></pre>
<p>V takovÃ©mto pÅ™Ã­padÄ› se hodnota z literÃ¡lu pÅ™ekopÃ­ruje do promÄ›nnÃ© pole znakÅ¯ na zÃ¡sobnÃ­ku, kterÃ½ jiÅ¾
lze mÄ›nit.</p>
<blockquote>
<p>Pokud jsou vÃ¡m Å™etÄ›zcovÃ© literÃ¡ly povÄ›domÃ©, je to kvÅ¯li toho, Å¾e jsme je jiÅ¾ mnohokrÃ¡t
vyuÅ¾ili pÅ™i volÃ¡nÃ­ funkce <code>printf</code>.</p>
</blockquote>
<h4><a class="header" href="#vÃ­ceÅ™Ã¡dkovÃ©-Å™etÄ›zcovÃ©-literÃ¡ly" id="vÃ­ceÅ™Ã¡dkovÃ©-Å™etÄ›zcovÃ©-literÃ¡ly">VÃ­ceÅ™Ã¡dkovÃ© Å™etÄ›zcovÃ© literÃ¡ly</a></h4>
<p>Pokud budete chtÃ­t zapsat Å™etÄ›zcovÃ½ literÃ¡l na vÃ­ce Å™Ã¡dkÅ¯ kÃ³du, mÅ¯Å¾ete buÄ na konci kaÅ¾dÃ©ho
neukonÄenÃ©ho Å™Ã¡dku pouÅ¾Ã­t znak <code>\</code>:</p>
<pre><code class="language-c">const char* veta = &quot;Ahoj \
jmenuji \
se \
Karel&quot;;
</code></pre>
<p>nebo kaÅ¾dÃ½ Å™Ã¡dek samostatnÄ› obalit uvozovkami:</p>
<pre><code class="language-c">const char* veta = &quot;Ahoj&quot;
&quot;jmenuji&quot;
&quot;se&quot;
&quot;Karel&quot;;
</code></pre>
<p>Pozor vÅ¡ak na to, Å¾e v ani jednom ze zmÃ­nÄ›nÃ½ch pÅ™Ã­padÅ¯ nebude souÄÃ¡stÃ­ Å™etÄ›zce znak odÅ™Ã¡dkovÃ¡nÃ­.
Ten musÃ­te vÅ¾dy pÅ™idat explicitnÄ›:</p>
<pre><code class="language-c">const char* radky = &quot;radek1\n\
radek2\n\
radek3\n&quot;;

// nebo
const char* radky = &quot;radek1\n&quot;
&quot;radek2\n&quot;
&quot;radek3\n&quot;;
</code></pre>
<h3><a class="header" href="#k-Äemu-slouÅ¾Ã­-nulovÃ½-znak-na-konci" id="k-Äemu-slouÅ¾Ã­-nulovÃ½-znak-na-konci">K Äemu slouÅ¾Ã­ nulovÃ½ znak na konci?</a></h3>
<p>U polÃ­ je trochu nepraktickÃ© to, Å¾e pokud je chceme poslat do nÄ›jakÃ© funkce, musÃ­me spolu s
ukazatelem na prvnÃ­ prvek pole pÅ™edat takÃ© jeho
<a href="c/text/../pole/staticka_pole.html#p%C5%99ed%C3%A1v%C3%A1n%C3%AD-velikosti-pole">velikost</a>, aby funkce vÄ›dÄ›la, ke kolika prvkÅ¯m
si mÅ¯Å¾e dovolit pÅ™istoupit. JinÃ½m zpÅ¯sobem, jak urÄit velikost pole, je zvolit si speciÃ¡lnÃ­ hodnotu,
kterÃ¡ bude znaÄit konec pole. KdyÅ¾ kÃ³d, kterÃ½ s takovÃ½mto polem bude pracovat, na tuto speciÃ¡lnÃ­
hodnotu narazÃ­, tak bude vÄ›dÄ›t, Å¾e dÃ¡le v pamÄ›ti jiÅ¾ pole nepokraÄuje.</p>
<p>Tento mechanismus je vyuÅ¾it prÃ¡vÄ› u Å™etÄ›zcÅ¯ zakonÄenÃ½ch nulou, kde onou speciÃ¡lnÃ­ hodnotou je prÃ¡vÄ›
tzv. <code>NUL</code> znak, kterÃ½ mÃ¡ ÄÃ­selnou hodnotu <code>0</code>. NapÅ™Ã­klad pÅ™i prochÃ¡zenÃ­ Å™etÄ›zce v cyklu tak nemusÃ­me
dopÅ™edu znÃ¡t jeho dÃ©lku, staÄÃ­ cyklus ukonÄit, jakmile narazÃ­me na znak <code>'\0'</code>. NapÅ™Ã­klad funkce
pro spoÄtenÃ­ dÃ©lky Å™etÄ›zce by mohla vypadat takto<sup class='margin-toggle sidenote-number'>3</sup>:</p>
<span class='sidenote'><p><sup class='number'>3</sup>VÅ¡imnÄ›te si, Å¾e tato funkce bere ukazatel na konstantnÃ­ pole znakÅ¯.
Pokud ve funkci nepotÅ™ebujete mÄ›nit hodnoty pole, je obvykle dobrÃ½ nÃ¡pad pouÅ¾Ã­t klÃ­ÄovÃ© slovo
<code>const</code> pÅ™ed datovÃ½m typem obsaÅ¾enÃ½m v poli, aby vÃ¡s pÅ™ekladaÄ ohlÃ­dal, Å¾e se pole nesnaÅ¾Ã­te mÄ›nit.
Do takovÃ©to funkce pak klidnÄ› mÅ¯Å¾ete poslat i pole, kterÃ© ve skuteÄnosti mÄ›nit lze, jinak Å™eÄeno
napÅ™. <code>char*</code> lze bez problÃ©mu pÅ™evÃ©st na <code>const char*</code>. V opaÄnÃ©m smÄ›ru konverze nenÃ­ korektnÃ­.</p>
</span>
<pre><code class="language-c">int delka_retezce(const char* retezec) {
    int delka = 0;

    // dokud nenÃ­ znak na adrese v ukazateli roven znaku NUL
    while (*retezec != '\0') {
        delka = delka + 1;
        retezec = retezec + 1;  // posuÅˆ ukazatel o jeden znak dÃ¡le
    }
    return delka;
}
</code></pre>
<p>Tato funkce postupnÄ› projde vÅ¡echny znaky Å™etÄ›zce a poÄÃ­tÃ¡, kolik jich je, dokud nenarazÃ­ na
znak <code>'\0</code>. Pro prochÃ¡zenÃ­ Å™etÄ›zce je zde pouÅ¾ita
<a href="c/text/../prace_s_pameti/ukazatele.html#aritmetika-s-ukazateli">aritmetika s ukazateli</a>.</p>
<p>Z toho vyplÃ½vÃ¡ mimo jinÃ© to, Å¾e znak <code>NUL</code> nemÅ¯Å¾e bÃ½t pouÅ¾it &quot;uprostÅ™ed&quot; Å™etÄ›zce. Pokud by tomu tak
bylo, tak funkce, kterÃ© by s takovÃ½mto Å™etÄ›zcem pracovaly, by pÅ™i nalezenÃ­ tohoto znaku pÅ™estaly
Å™etÄ›zec zpracovÃ¡vat, a jakÃ©koliv dalÅ¡Ã­ znaky za <code>NUL</code> by byly ignorovÃ¡ny. Uhodnete tak, co vypÃ­Å¡e
nÃ¡sledujÃ­cÃ­ program?</p>
<pre><code class="language-c editable mainbody">#include &lt;stdio.h&gt;

int main() {
    char text[] = {'U', '\0', 'P', 'R', '\0'};
    printf(&quot;%s\n&quot;, text);
    return 0;
}
</code></pre>
<h3><a class="header" href="#Å˜etÄ›zce-jako-pole" id="Å˜etÄ›zce-jako-pole">Å˜etÄ›zce jako pole</a></h3>
<p>S Å™etÄ›zci pracujeme jako s klasickÃ½mi poli znakÅ¯. NapÅ™Ã­klad pro zÃ­skÃ¡nÃ­ prvnÃ­ho znaku Å™etÄ›zce mÅ¯Å¾eme
pouÅ¾Ã­t operÃ¡tor hranatÃ½ch zÃ¡vorek:</p>
<pre><code class="language-c">char vrat_prvni_znak(const char* retezec) {
    return retezec[0];
}
</code></pre>
<h2><a class="header" href="#funkce-pro-prÃ¡ci-s-Å™etÄ›zci" id="funkce-pro-prÃ¡ci-s-Å™etÄ›zci">Funkce pro prÃ¡ci s Å™etÄ›zci</a></h2>
<p>StandardnÃ­ knihovna <em>C</em> obsahuje <a href="https://devdocs.io/c/string/byte">Å™adu funkcÃ­</a>, kterÃ© umÃ­ s
Å™etÄ›zci zakonÄenÃ½mi nulou pracovat. Zde je seznam nÄ›kolika vybranÃ½ch funkcÃ­, kterÃ© pro vÃ¡s mÅ¯Å¾ou
bÃ½t uÅ¾iteÄnÃ©:</p>
<ul>
<li>
<p><strong>ZjiÅ¡tÄ›nÃ­ dÃ©lky Å™etÄ›zce</strong>: funkce <a href="https://devdocs.io/c/string/byte/strlen"><code>strlen</code></a> bere jako
parametr Å™etÄ›zec a vracÃ­ jeho dÃ©lku. JednÃ¡ se o jednu z nejÄastÄ›ji pouÅ¾Ã­vanÃ½ch funkcÃ­ pÅ™i prÃ¡ci s
Å™etÄ›zci a vyplatÃ­ se ji tak znÃ¡t.</p>
<p>PÅ™i jejÃ­m pouÅ¾itÃ­ je ovÅ¡em nutnÃ© si dÃ¡t pozor na to, Å¾e dÃ©lka provÃ¡dÄ›nÃ­ tÃ©to funkce zÃ¡visÃ­ na tom, jak je
Å™etÄ›zec dlouhÃ½. Pokud bude mÃ­t Å™etÄ›zec milion znakÅ¯, tak bude tato funkce muset projÃ­t vÅ¡ech milion
znakÅ¯, dokud nenarazÃ­ na znak <code>NUL</code>. DÃ¡vejte si tak pozor, abyste tuto funkci nevolali zbyteÄnÄ› Äasto.
NapÅ™Ã­klad pokud pouÅ¾ijete funkci <code>strlen</code> v podmÃ­nce cyklu <code>for</code>:</p>
<pre><code class="language-c">for (int i = 0; i &lt; strlen(retezec); i++) {
    ...
}
</code></pre>
<p>Tak se dÃ©lka Å™etÄ›zce vypoÄte pÅ™i kaÅ¾dÃ© iteraci cyklu. Pokud by tak Å™etÄ›zec mÄ›l milion znakÅ¯,
musel by program provÃ©st bilion<sup class='margin-toggle sidenote-number'>4</sup> (!) operacÃ­ pouze pro zjiÅ¡tÄ›nÃ­ dÃ©lky Å™etÄ›zce.
LepÅ¡Ã­ volbou (pokud se tedy dÃ©lka Å™etÄ›zce nemÄ›nÃ­) je tak pÅ™edpoÄÃ­tat si jeho dÃ©lku dopÅ™edu a
uloÅ¾it si ji do promÄ›nnÃ©:</p>
<span class='sidenote'><p><sup class='number'>4</sup>1 000 000 000 000</p>
</span>
<pre><code class="language-c">int delka = strlen(retezec);
for (int i = 0; i &lt; delka; i++) {
    ...
}
</code></pre>
</li>
</ul>
<ul>
<li>
<p><strong>PorovnÃ¡nÃ­ dvou Å™etÄ›zcÅ¯</strong>: bÄ›Å¾nou operacÃ­, kterou bychom s Å™etÄ›zci chtÄ›li udÄ›lat, je porovnat,
zdali jsou dva Å™etÄ›zce stejnÃ©, popÅ™Ã­padÄ› kterÃ½ z nich je menÅ¡Ã­<sup class='margin-toggle sidenote-number'>5</sup>. Funkce
<a href="https://devdocs.io/c/string/byte/strcmp"><code>strcmp</code></a> bere dva Å™etÄ›zce a vracÃ­ nulu, pokud se Å™etÄ›zce
rovnajÃ­, zÃ¡pornou hodnotu, pokud je prvnÃ­ Å™etÄ›zec menÅ¡Ã­ neÅ¾ ten druhÃ½, a kladnou hodnotu, pokud je
druhÃ½ Å™etÄ›zec menÅ¡Ã­ neÅ¾ prvnÃ­.</p>
<span class='sidenote'><p><sup class='number'>5</sup>Pro porovnÃ¡vÃ¡nÃ­ Å™etÄ›zcÅ¯ se pouÅ¾Ã­vÃ¡ <a href="https://cs.wikipedia.org/wiki/Lexikografick%C3%A9_uspo%C5%99%C3%A1d%C3%A1n%C3%AD">lexikografickÃ© uspoÅ™Ã¡dÃ¡nÃ­</a>.
Nalezne se prvnÃ­ dvojice znakÅ¯ (zleva), ve kterÃ©m se Å™etÄ›zce liÅ¡Ã­, a tyto dva znaky se porovnajÃ­
pomocÃ­ jejich ÄÃ­selnÃ© (ASCII) hodnoty.</p>
</span>
<blockquote>
<p>Pro porovnÃ¡vÃ¡nÃ­ dvou Å™etÄ›zcÅ¯ nikdy nepouÅ¾Ã­vejte operÃ¡tor <code>==</code>! Nebude to
<a href="c/text/../../caste_chyby/caste_chyby.html#porovn%C3%A1v%C3%A1n%C3%AD-%C5%99et%C4%9Bzc%C5%AF-pomoc%C3%AD-">fungovat</a>.</p>
</blockquote>
</li>
</ul>
<ul>
<li>
<p><strong>VyhledÃ¡nÃ­ Å™etÄ›zce v Å™etÄ›zci</strong>: pokud chcete zjistit, jestli se v nÄ›jakÃ©m Å™etÄ›zci vyskytuje jinÃ½
Å™etÄ›zec, mÅ¯Å¾ete pouÅ¾Ã­t funkci <a href="https://devdocs.io/c/string/byte/strstr"><code>strstr</code></a>.</p>
</li>
<li>
<p><strong>PÅ™evod textu na ÄÃ­slo</strong>: Äasto mÅ¯Å¾ete potÅ™ebovat pÅ™evÃ©st textovÃ½ zÃ¡pis ÄÃ­sla na jeho ÄÃ­selnou
hodnotu. K tomu mÅ¯Å¾ete pouÅ¾Ã­t napÅ™Ã­klad funkci <a href="https://devdocs.io/c/string/byte/strtol"><code>strtol</code></a>
(<em>string to long</em>). PrvnÃ­ parametr funkce je Å™etÄ›zec, kterÃ½ chcete pÅ™evÃ©st, do druhÃ©ho parametru
mÅ¯Å¾ete pÅ™edat ukazatel na ukazatel na znak, do kterÃ©ho se uloÅ¾Ã­ pozice ve vstupnÃ­m Å™etÄ›zci tÄ›snÄ› za
naÄtenÃ½m ÄÃ­slem. PoslednÃ­m parametrem je soustava, ve kterÃ© se mÃ¡ ÄÃ­slo naÄÃ­st (obvykle to bude
desÃ­tkovÃ¡ soustava, tedy hodnota <code>10</code>). NÃ¡vratovou hodnotou funkce je pak naÄtenÃ© ÄÃ­slo.</p>
<p>MÅ¯Å¾ete pouÅ¾Ã­t takÃ© funkci <a href="https://devdocs.io/c/string/byte/atoi"><code>atoi</code></a>, kterÃ¡ je trochu
jednoduÅ¡Å¡Ã­ na pouÅ¾itÃ­, ale pÅ™i jejÃ­m pouÅ¾itÃ­ nelze zjistit, zdali pÅ™i konverzi nedoÅ¡lo k chybÄ›
(napÅ™Ã­klad pokud vstupnÃ­ Å™etÄ›zec nereprezentoval ÄÃ­slo).</p>
</li>
</ul>
<hr />
<p><strong>CviÄenÃ­</strong> ğŸ‹</p>
<p>Pro procviÄenÃ­ prÃ¡ce s Å™etÄ›zci si mÅ¯Å¾ete zkusit nÄ›kterÃ© z tÄ›chto funkcÃ­ sami
naprogramovat. DalÅ¡Ã­ Ãºlohy pro prÃ¡ci s Å™etÄ›zci mÅ¯Å¾ete nalÃ©zt <a href="c/text/../../ulohy/text.html">zde</a>.</p>
<hr />
<p><strong>KvÃ­z</strong> ğŸ¤”</p>
<ol>
<li>
<p>Co vypÃ­Å¡e nÃ¡sledujÃ­cÃ­ program?</p>
<pre><code class="language-c editable mainbody">#include &lt;stdio.h&gt;

int main() {
    const char* str = &quot;hello&quot;;

    printf(&quot;%c\n&quot;, str[3]);
    printf(&quot;%c\n&quot;, str[2]);
    printf(&quot;%c\n&quot;, str[1]);

    return 0;
}
</code></pre>
<details>
 <summary>OdpovÄ›Ä</summary>
<p>Program vypÃ­Å¡e:</p>
<pre><code>l
l
e
</code></pre>
<p>JelikoÅ¾ jsou Å™etÄ›zce poli znakÅ¯, tak pÅ™i pÅ™istoupenÃ­ na nÄ›jakÃ½ index Å™etÄ›zce zÃ­skÃ¡me hodnotu
datovÃ©ho typu znak.</p>
</details>
</li>
<li>
<p>Co vypÃ­Å¡e nÃ¡sledujÃ­cÃ­ program?</p>
<pre><code class="language-c editable mainbody">#include &lt;stdio.h&gt;

int main() {
    const char* str = &quot;hello&quot;;
    
    for (int i = 0; i &lt; 5; i++) {
        printf(&quot;%c&quot;, str[i] - 32);
    }
    printf(&quot;\n&quot;);

    return 0;
}
</code></pre>
<details>
 <summary>OdpovÄ›Ä</summary>
<p>Program vypÃ­Å¡e <code>HELLO</code>. KdyÅ¾ se podÃ­vÃ¡te na <a href="https://www.asciitable.com/">ASCII tabulku</a>, tak
zjistÃ­te, Å¾e rozdÃ­l mezi ÄÃ­sly reprezentujÃ­cÃ­mi jednotlivÃ© znaky malÃ© a velkÃ© anglickÃ© abecedy
je <code>32</code>, a Å¾e znaky malÃ© abecedy jsou reprezentovÃ¡ny vyÅ¡Å¡Ã­mi ÄÃ­sly. KdyÅ¾ tak napÅ™. od <code>'h'</code>
odeÄteme hodnotu <code>32</code>, zÃ­skÃ¡me znak <code>'H'</code>. PÅ™ehlednÄ›jÅ¡Ã­ by bylo napsat tuto konverzi jako
<code>str[i] - ('a' - 'A')</code> nebo pouÅ¾Ã­t funkci <a href="https://devdocs.io/c/string/byte/tolower"><code>tolower</code></a>
ze standardnÃ­ knihovny jazyka <em>C</em>.</p>
</details>
</li>
</ol>
<h1><a class="header" href="#vstup-a-vÃ½stup" id="vstup-a-vÃ½stup">Vstup a vÃ½stup</a></h1>
<p>UÅ¾ vÃ­me, jak v pamÄ›ti poÄÃ­taÄe pracovat s (ASCII) znaky a Å™etÄ›zci. NynÃ­ si ukÃ¡Å¾eme, jak mÅ¯Å¾ou naÅ¡e
programy komunikovat s okolnÃ­m svÄ›tem â€“ se <a href="c/text/../soubory/soubory.html">soubory</a> na disku, s terminÃ¡lem, s
ostatnÃ­mi programy bÄ›Å¾Ã­cÃ­mi na vaÅ¡em poÄÃ­taÄi Äi s ÃºplnÄ› jinÃ½m poÄÃ­taÄem pÅ™es sÃ­Å¥. Komunikace programÅ¯
se obecnÄ› oznaÄuje jako <strong>I/O</strong> (<em>input/output</em>).</p>
<p>Komunikace s terminÃ¡lem, souborem, tiskÃ¡rnou Äi pÅ™es sÃ­Å¥ mÃ¡ samozÅ™ejmÄ› rozliÅ¡nÃ¡ pravidla. Abychom v
kaÅ¾dÃ©m programu nemuseli programovat podporu pro kaÅ¾dÃ½ vstupnÃ­/vÃ½stupnÃ­ kanÃ¡l od nuly, z velkÃ© ÄÃ¡sti
se o toto starÃ¡ operaÄnÃ­ systÃ©m. Ten nÃ¡m umoÅ¾Åˆuje komunikovat s okolnÃ­m svÄ›tem pomocÃ­ tzv.
<strong>souborovÃ½ch deskriptorÅ¯</strong> (<em>file descriptors</em>). PÅ™i vytvoÅ™enÃ­ novÃ©ho komunikaÄnÃ­ho kanÃ¡lu
(napÅ™Ã­klad pÅ™i otevÅ™enÃ­ souboru) naÅ¡emu programu operaÄnÃ­ systÃ©m pÅ™edÃ¡ novÃ½ souborovÃ½ deskriptor
identifikovanÃ½ ÄÃ­slem. KdyÅ¾ potÃ© nÃ¡Å¡ program chce vypsat nebo naÄÃ­st data, tak musÃ­ pÅ™edat operaÄnÃ­mu
systÃ©mu ÄÃ­slo deskriptoru, se kterÃ½m chceme komunikovat. MÅ¯Å¾eme napÅ™Ã­klad Å™Ã­ct <code>VypiÅ¡ text &quot;ahoj&quot; do souborovÃ©ho deskriptoru s ÄÃ­slem 5</code>. AÅ¥ uÅ¾ je na tento deskriptor pÅ™ipojen soubor, terminÃ¡l Äi nÄ›co
jinÃ©ho, operaÄnÃ­ systÃ©m se postarÃ¡ o to, aby k nÄ›mu data z naÅ¡eho programu korektnÄ› dorazila.</p>
<h2><a class="header" href="#standardnÃ­-souborovÃ©-deskriptory" id="standardnÃ­-souborovÃ©-deskriptory">StandardnÃ­ souborovÃ© deskriptory</a></h2>
<p>KaÅ¾dÃ©mu programu pÅ™i spuÅ¡tÄ›nÃ­ pÅ™iÅ™adÃ­ operaÄnÃ­ systÃ©m tÅ™i zÃ¡kladnÃ­ souborovÃ© deskriptory:</p>
<ul>
<li>
<p><strong>StandardnÃ­ vstup</strong> (<code>stdin</code>): tento deskriptor mÃ¡ ÄÃ­slo <code>0</code> a pouÅ¾Ã­vÃ¡ se pro ÄtenÃ­ vstupu.
Pokud vÃ¡Å¡ program spustÃ­te z terminÃ¡lu, tak do <code>stdin</code>u bude pÅ™esmÄ›rovÃ¡n text, kterÃ½ napÃ­Å¡ete v
terminÃ¡lu. NemusÃ­ tomu tak vÅ¡ak bÃ½t vÅ¾dy. VÃ¡Å¡ program mÅ¯Å¾ete napÅ™Ã­klad spustit z jinÃ©ho programu, a
pÅ™edat mu vstup pÅ™Ã­mo z pamÄ›ti. Nebo mÅ¯Å¾ete napÅ™Ã­klad na vstup vaÅ¡eho programu pÅ™esmÄ›rovat soubor z
disku:</p>
<pre><code class="language-bash">$ ./program &lt; soubor.txt
</code></pre>
</li>
<li>
<p><strong>StandardnÃ­ vÃ½stup</strong> (<code>stdout</code>): tento deskriptor mÃ¡ ÄÃ­slo <code>1</code> a pouÅ¾Ã­vÃ¡ se pro vÃ½pis dat. Pokud
vÃ¡Å¡ program spustÃ­te z terminÃ¡lu, tak data odeslanÃ¡ do <code>stdout</code>u se objevÃ­ na obrazovce terminÃ¡lu.
OpÄ›t to ale nenÃ­ jedinÃ¡ moÅ¾nost, <code>stdout</code> mÅ¯Å¾e bÃ½t napÅ™Ã­klad pÅ™esmÄ›rovanÃ½ do souboru na disku:</p>
<pre><code class="language-bash">$ ./program &gt; soubor.txt
</code></pre>
<p>Funkce <code>printf</code> posÃ­lÃ¡ svÅ¯j vÃ½stup prÃ¡vÄ› do deskriptoru <code>stdout</code>.</p>
<p>Pokud to <a href="https://devdocs.io/c/io/setvbuf">nezmÄ›nÃ­te</a>, tak <code>stdout</code> implicitnÄ› pouÅ¾Ã­vÃ¡ 
tzv. <strong>bufferovÃ¡nÃ­ po Å™Ã¡dcÃ­ch</strong> (<em>line buffering</em>). To znamenÃ¡, Å¾e pokud zapÃ­Å¡ete do <code>stdout</code>
pomocÃ­ nÄ›kterÃ© z funkcÃ­ standardnÃ­ knihovny <em>C</em> nÄ›jakÃ½ text, tak tento text se nejprve zapÃ­Å¡e
do doÄasnÃ©ho pole (tzv. <em>bufferu</em>) v pamÄ›ti. AÅ¾ jakmile na vÃ½stup zapÃ­Å¡ete znak odÅ™Ã¡dkovÃ¡nÃ­ <code>'\n'</code><sup class='margin-toggle sidenote-number'>1</sup>,
tak dojde k vyprÃ¡zdnÄ›nÃ­ (<em>flush</em>) bufferu, kdy je jeho obsah odeslÃ¡n na vÃ½stup. Jinak Å™eÄeno,
dokud nevypÃ­Å¡ete znak odÅ™Ã¡dkovÃ¡nÃ­, vÃ¡Å¡ vÃ½stup se neobjevÃ­ napÅ™. v terminÃ¡lu. BufferovÃ¡nÃ­ po
Å™Ã¡dcÃ­ch se provÃ¡dÃ­ jako optimalizace, vÃ½stup (i vstup) totiÅ¾ dost Äasto brzdÃ­ vykonÃ¡vÃ¡nÃ­ programÅ¯.</p>
<span class='sidenote'><p><sup class='number'>1</sup>Nebo jakmile v bufferu dojde pamÄ›Å¥.</p>
</span></li>
<li>
<p><strong>StandardnÃ­ chybovÃ½ vÃ½stup</strong> (<code>stderr</code>): tento deskriptor mÃ¡ ÄÃ­slo <code>2</code> a pouÅ¾Ã­vÃ¡ se pro vÃ½pis
chyb a logovacÃ­ch zÃ¡znamÅ¯. NarozdÃ­l od <code>stdout</code> nepouÅ¾Ã­vÃ¡ <code>stderr</code> implicitnÄ› line buffering, takÅ¾e
cokoliv, co do nÄ›j zapÃ­Å¡ete, se okamÅ¾ite odeÅ¡le na vÃ½stup deskriptoru.</p>
</li>
</ul>
<p>Mimo tÄ›chto standardnÃ­ch deskriptorÅ¯ mÅ¯Å¾ete ve svÃ½ch programech vytvÃ¡Å™et i dalÅ¡Ã­ deskriptory,
napÅ™Ã­klad pomocÃ­ otevÃ­rÃ¡nÃ­ <a href="c/text/../soubory/soubory.html">souborÅ¯</a>. VÃ­ce o tom, jak fungujÃ­ souborovÃ© deskriptory
a vstup a vÃ½stup programu se dozvÃ­te v pÅ™edmÄ›tu
<a href="http://poli.cs.vsb.cz/edu/osy/osnova.html">OperaÄnÃ­ systÃ©my</a>.</p>
<h3><a class="header" href="#interpretace-vstupnÃ­ch-a-vÃ½stupnÃ­ch-dat" id="interpretace-vstupnÃ­ch-a-vÃ½stupnÃ­ch-dat">Interpretace vstupnÃ­ch a vÃ½stupnÃ­ch dat</a></h3>
<p>Je dobrÃ© si uvÄ›domit, Å¾e stejnÄ› jako v <a href="c/text/../../uvod/pamet.html">operaÄnÃ­ pamÄ›ti</a>, i pÅ™i komunikaci vÅ¾dy
pracujeme pouze s ÄÃ­sly (byty), jejichÅ¾ vÃ½znam je dÃ¡n ÄistÄ› tÃ­m, jak je jejich pÅ™Ã­jemce bude interpretovat.
Pokud nÃ¡Å¡ program do souboru zapÃ­Å¡e byty <code>85</code>, <code>80</code>, <code>82</code>, a my tento soubor otevÅ™eme v textovÃ©m
editoru, kterÃ½ jej bude poklÃ¡dat za ASCII soubor, zobrazÃ­ se nÃ¡m text <code>UPR</code>. Pokud jej vÅ¡ak otevÅ™eme
v binÃ¡rnÃ­m editoru, budou to pro nÄ›j pouze tÅ™i celÃ¡ ÄÃ­sla. Pro prohlÃ­Å¾eÄ obrÃ¡zkÅ¯ by tato ÄÃ­sla zase
mohla reprezentovat barevnÃ© sloÅ¾ky RGB pixelu.</p>
<p>Aby tak komunikace dvou stran dÃ¡vala smysl, musÃ­ se obÄ› strany dohodnout na tom, jak budou
interpretovat pÅ™enÃ¡Å¡enÃ¡ data. NapÅ™Ã­klad u souborÅ¯ se zpÅ¯sob interpretace obvykle udÃ¡vÃ¡ tÃ­m, jakou
dÃ¡me souboru pÅ™Ã­ponu (<code>.txt</code> je poklÃ¡dÃ¡n za textovÃ½ soubor, <code>.jpg</code> za JPEG obrÃ¡zek atd.).</p>
<h2><a class="header" href="#oÅ¡etÅ™enÃ­-chyb" id="oÅ¡etÅ™enÃ­-chyb">OÅ¡etÅ™enÃ­ chyb</a></h2>
<p>ZatÃ­m jsme pÅ™edpoklÃ¡dali, Å¾e operace, kterÃ© provÃ¡dÃ­me v programu, vÅ¾dy uspÄ›jÃ­. NapÅ™Ã­klad pÅ™i zÃ¡pisu
hodnoty do promÄ›nnÃ© jsme pÅ™edpoklÃ¡dali, Å¾e se hodnota v pamÄ›ti na adrese danÃ© promÄ›nnÃ© opravdu objevÃ­
a kdyÅ¾ ji pak zpÃ¡tky naÄteme, tak se pÅ™i pÅ™enosu nijak neznehodnotÃ­.</p>
<p>PÅ™i naÄÃ­tÃ¡nÃ­ vstupu Äi vypisovÃ¡nÃ­ dat ovÅ¡em mÅ¯Å¾e velmi Äasto dojÃ­t k rÅ¯znÃ½m chybovÃ½m situacÃ­m.
BÄ›hem zÃ¡pisu souboru na USB &quot;flashku&quot; ji mÅ¯Å¾eme omylem vytÃ¡hnout, pÅ™i posÃ­lÃ¡nÃ­ dat pÅ™es sÃ­Å¥ nÃ¡m mÅ¯Å¾e
vypadnout pÅ™ipojenÃ­ k internetu nebo pÅ™i naÄÃ­tÃ¡nÃ­ ÄÃ­sla z terminÃ¡lu nÃ¡m mÅ¯Å¾e zÃ¡keÅ™nÃ½ uÅ¾ivatel zadat
nÄ›co, co ÄÃ­slo ani zdaleka nepÅ™ipomÃ­nÃ¡.</p>
<p>Pokud tedy chceme psÃ¡t robustnÃ­ programy, kterÃ© zvlÃ¡dnou korektnÄ› reagovat i na nevalidnÃ­ vstup a
na rÅ¯znÃ© chybovÃ© situace, kterÃ© mohou nastat, musÃ­me do naÅ¡ich programÅ¯ pÅ™idat tzv.
<strong>oÅ¡etÅ™enÃ­ chyb</strong> (<em>error handling</em>). JednÃ¡ se o obsluÅ¾nÃ½ kÃ³d, kterÃ½ reaguje na moÅ¾nÃ© problÃ©movÃ©
situace a snaÅ¾Ã­ se je vyÅ™eÅ¡it. Jak oÅ¡etÅ™ovat chyby pÅ™i komunikaci si ukÃ¡Å¾eme v jednotlivÃ½ch sekcÃ­ch
o <a href="c/text/vstup.html">vstupu</a> a <a href="c/text/vystup.html">vÃ½stupu</a>.</p>
<h1><a class="header" href="#vstup" id="vstup">Vstup</a></h1>
<p>Abychom mohli naÅ¡im programÅ¯m dÃ¡vat pÅ™Ã­kazy nebo parametrizovat jejich chovÃ¡nÃ­, tÃ©mÄ›Å™ vÅ¾dy v nich
potÅ™ebujeme pÅ™eÄÃ­st nÄ›jakÃ© informace ze vstupu programu. V tÃ©to sekci si ukÃ¡Å¾eme nÄ›kolik uÅ¾iteÄnÃ½ch
funkcÃ­ ze <a href="c/text/../funkce/stdlib.html">standardnÃ­ knihovny <em>C</em></a>, kterÃ© nÃ¡m to umoÅ¾ÅˆujÃ­. Pro pouÅ¾itÃ­ tÄ›chto
funkcÃ­ musÃ­te ve svÃ©m programu <a href="c/text/../preprocesor/vkladani_souboru.html">vloÅ¾it</a> soubor <code>&lt;stdio.h&gt;</code>.</p>
<h2><a class="header" href="#naÄtenÃ­-jednoho-znaku" id="naÄtenÃ­-jednoho-znaku">NaÄtenÃ­ jednoho znaku</a></h2>
<p>Pro naÄtenÃ­ jednoho znaku ze standardnÃ­ho vstupu (<code>stdin</code>) mÅ¯Å¾eme pouÅ¾Ã­t funkci
<a href="https://devdocs.io/c/io/getchar"><code>getchar</code></a>. Ta nÃ¡m vrÃ¡tÃ­ jeden znak ze vstupu, popÅ™Ã­padÄ› hodnotu
makra <code>EOF</code><sup class='margin-toggle sidenote-number'>1</sup>, pokud jiÅ¾ je vstup uzavÅ™enÃ½ a nelze z nÄ›j nic dalÅ¡Ã­ho naÄÃ­st nebo pokud doÅ¡lo pÅ™i
naÄÃ­tÃ¡nÃ­ k nÄ›jakÃ© chybÄ›.</p>
<span class='sidenote'><p><sup class='number'>1</sup><em>End-of-file</em></p>
</span>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int main() {
    char x = getchar();
    printf(&quot;ZadanÃ½ znak: %c\n&quot;, x);

    return 0;
}
</code></pre>
<h2><a class="header" href="#naÄtenÃ­-Å™Ã¡dku" id="naÄtenÃ­-Å™Ã¡dku">NaÄtenÃ­ Å™Ã¡dku</a></h2>
<p>NaÄÃ­tat vstup po jednotlivÃ½ch znacÃ­ch je pomÄ›rnÄ› zdlouhavÃ©. Velmi Äasto chceme ze vstupu naÄÃ­st
delÅ¡Ã­ Ãºsek textu najednou, napÅ™Ã­klad celÃ½ Å™Ã¡dek. Toho mÅ¯Å¾eme dosÃ¡hnout napÅ™Ã­klad pouÅ¾itÃ­m funkce
<a href="https://devdocs.io/c/io/fgets"><code>fgets</code></a>. Ta jako parametry pÅ™ijÃ­mÃ¡ ukazatel na Å™etÄ›zec, do kterÃ©ho
zapÃ­Å¡e naÄÃ­tanÃ½ Å™Ã¡dek a maximÃ¡lnÃ­ poÄet znakÅ¯, kterÃ½ lze naÄÃ­st<sup class='margin-toggle sidenote-number'>2</sup>. TÅ™etÃ­ parametr je
<a href="c/text/../soubory/soubory.html">soubor</a>, ze kterÃ©ho se mÃ¡ vstup naÄÃ­st. O souborech se dozvÃ­te vÃ­ce pozdÄ›ji,
pokud chcete naÄÃ­tat data ze standardnÃ­ho vstupu, tak pouÅ¾ijte jako tÅ™etÃ­ parametr globÃ¡lnÃ­ promÄ›nnou
<code>stdin</code>, kterÃ¡ je nadefinovÃ¡na v souboru <code>&lt;stdio.h&gt;</code>. Pro jednoduchÃ© zjiÅ¡tÄ›nÃ­ dÃ©lky Å™etÄ›zce, do
kterÃ©ho zapisujete, mÅ¯Å¾ete pouÅ¾Ã­t operÃ¡tor <code>sizeof</code>:</p>
<span class='sidenote'><p><sup class='number'>2</sup>Tato velikost je vÄetnÄ› znaku <code>'\0'</code>, kterÃ½ je vÅ¾dy zapsÃ¡n na konec vstupnÃ­ho Å™etÄ›zce. Pokud
tak mÃ¡te Å™etÄ›zec (pole) o dÃ©lce <code>10</code>, pÅ™edejte do <code>fgets</code> hodnotu <code>10</code>. Funkce naÄte maximÃ¡lnÄ› <code>9</code>
znakÅ¯ a na konec Å™etÄ›zce umÃ­stÃ­ znak <code>'\0'</code>.</p>
</span>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int main() {
    char buf[80];
    // naÄti Å™Ã¡dek textu ze vstupu do Å™etÄ›zce `buf`
    fgets(buf, sizeof(buf), stdin);

    return 0;
}
</code></pre>
<p>Pokud tato funkce vrÃ¡tÃ­ nÃ¡vratovou hodnotu <code>NULL</code>, tak pÅ™i naÄÃ­tÃ¡nÃ­ doÅ¡lo k chybÄ›. Tuto chybu byste
tak ideÃ¡lnÄ› mÄ›li nÄ›jak oÅ¡etÅ™it:</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int main() {
    char buf[80];
    if (fgets(buf, sizeof(buf), stdin) == NULL) {
        printf(&quot;Nacteni dat nevyslo. Ukoncuji program\n&quot;);
        return 1;
    }

    return 0;
}
</code></pre>
<blockquote>
<p>Pokud byl na vstupu Å™Ã¡dek ukonÄenÃ½ odÅ™Ã¡dkovÃ¡nÃ­m (<code>\n</code>), tak se toto odÅ™Ã¡dkovÃ¡nÃ­ bude nachÃ¡zet i v
naÄtenÃ©m Å™etÄ›zci po zavolÃ¡nÃ­ <code>fgets</code>! Pokud tedy takto naÄtenÃ½ Å™etÄ›zec chcete napÅ™Ã­klad porovnat s
jinÃ½m Å™etÄ›zcem, mÄ›li byste nejprve znak odÅ™Ã¡dkovÃ¡nÃ­ odstranit. VÃ­ce se mÅ¯Å¾ete dozvÄ›dÄ›t
<a href="c/text/../../caste_chyby/caste_chyby.html#porovn%C3%A1v%C3%A1n%C3%AD-%C5%99et%C4%9Bzce-na%C4%8Dten%C3%A9ho-funkc%C3%AD-fgets">zde</a>.</p>
</blockquote>
<h2><a class="header" href="#naÄtenÃ­-formÃ¡tovanÃ©ho-textu" id="naÄtenÃ­-formÃ¡tovanÃ©ho-textu">NaÄtenÃ­ formÃ¡tovanÃ©ho textu</a></h2>
<p>Pokud chceme naÄÃ­tat text, u kterÃ©ho oÄekÃ¡vÃ¡me, Å¾e bude mÃ­t nÄ›jakÃ½ specifickÃ½ formÃ¡t, popÅ™Ã­padÄ› chceme
text rovnou nÄ›jak zpracovat, napÅ™Ã­klad jej pÅ™evÃ©st na ÄÃ­slo, mÅ¯Å¾eme pouÅ¾Ã­t formÃ¡tovanÃ© naÄÃ­tÃ¡nÃ­ vstupu
pomocÃ­ funkce <a href="https://devdocs.io/c/io/fscanf"><code>scanf</code></a>. TÃ©to funkci pÅ™edÃ¡me tzv.
<strong>formÃ¡tovacÃ­ Å™etÄ›zec</strong> (<em>format string</em>), kterÃ½ udÃ¡vÃ¡, jak mÃ¡ vypadat vstupnÃ­ text. V tomto Å™etÄ›zci
mÅ¯Å¾eme pouÅ¾Ã­vat rÅ¯znÃ© zÃ¡stupnÃ© znaky. Za kaÅ¾dÃ½ zÃ¡stupnÃ½ znak ve formÃ¡tovacÃ­m Å™etÄ›zci <code>scanf</code> oÄekÃ¡vÃ¡
jeden argument s adresou, do kterÃ© se mÃ¡ uloÅ¾it naÄtenÃ¡ hodnota popsanÃ¡ zÃ¡stupnÃ½m znakem ze vstupu.
NapÅ™Ã­klad tento kÃ³d naÄte ze vstupu dvÄ› celÃ¡ ÄÃ­sla:</p>
<pre><code class="language-c">int x, y;
scanf(&quot;%d%d&quot;, &amp;x, &amp;y);
</code></pre>
<p>PomocÃ­ formÃ¡tovacÃ­ho Å™etÄ›zce mÅ¯Å¾eme takÃ© vyÅ¾adovat, co musÃ­ v textu bÃ½t. NapÅ™Ã­klad <code>scanf(&quot;x%d&quot;, â€¦)</code>
naÄte vstup pouze, pokud v nÄ›m nalezne znak <code>'x'</code> nÃ¡sledovanÃ½ ÄÃ­slem.</p>
<p>Seznam vÅ¡ech tÄ›chto zÃ¡stupnÃ½ch znakÅ¯ naleznete v <a href="https://devdocs.io/c/io/fscanf">dokumentaci</a>.
NaÄÃ­tat mÅ¯Å¾eme napÅ™Ã­klad celÃ¡ ÄÃ­sla (<code>%d</code>), desetinnÃ¡ ÄÃ­sla (<code>%f</code>) Äi znaky (<code>%c</code>).</p>
<blockquote>
<p>Funkce <code>scanf</code> naÄÃ­tÃ¡ data ze standardnÃ­ho vstupu programu (<code>stdin</code>). Obsahuje ovÅ¡em nÄ›kolik dalÅ¡Ã­ch
variant, pomocÃ­ kterÃ½ch mÅ¯Å¾e naÄÃ­tat formÃ¡tovanÃ¡ data z libovolnÃ©ho souboru (<code>fscanf</code>) nebo tÅ™eba i
z Å™etÄ›zce v pamÄ›ti (<code>sscanf</code>).</p>
</blockquote>
<p>Funkce <code>scanf</code> je jistÄ› uÅ¾iteÄnÃ¡, zejmÃ©na u krÃ¡tkÃ½ch a jednoduchÃ½ch programÅ¯, nicmÃ©nÄ› mÃ¡ takÃ© urÄitÃ©
problÃ©my, kterÃ© jsou popsÃ¡ny nÃ­Å¾e. Pokud to je tedy moÅ¾nÃ©, pro naÄÃ­tÃ¡nÃ­ vstupu radÄ›ji pouÅ¾Ã­vejte
funkci <code>fgets</code>.</p>
<h3><a class="header" href="#naÄÃ­tÃ¡nÃ­-Å™etÄ›zcÅ¯-pomocÃ­-scanf" id="naÄÃ­tÃ¡nÃ­-Å™etÄ›zcÅ¯-pomocÃ­-scanf">NaÄÃ­tÃ¡nÃ­ Å™etÄ›zcÅ¯ pomocÃ­ <code>scanf</code></a></h3>
<p>PomocÃ­ <code>scanf</code> mÅ¯Å¾eme naÄÃ­tat takÃ© celÃ© Å™etÄ›zce pomocÃ­ zÃ¡stupnÃ©ho znaku <code>%s</code>. Zde si ovÅ¡em musÃ­me
dÃ¡vat pozor, abychom u nÄ›j uvedli i maximÃ¡lnÃ­ dÃ©lku Å™etÄ›zce, do kterÃ©ho chceme text naÄÃ­st<sup class='margin-toggle sidenote-number'>3</sup>:</p>
<span class='sidenote'><p><sup class='number'>3</sup>NarozdÃ­l od funkce <code>fgets</code> se zde musÃ­ uvÃ©st dÃ©lka o jedna menÅ¡Ã­, neÅ¾ je dÃ©lka cÃ­lovÃ©ho Å™etÄ›zce,
do kterÃ©ho znaky zapisujeme.</p>
</span>
<pre><code class="language-c">char buf[21];
scanf(&quot;%20s&quot;, buf);
</code></pre>
<p>Pokud bychom pouÅ¾ili zÃ¡stupnÃ½ znak <code>%s</code> bez uvedenÃ© velikosti cÃ­lovÃ©ho Å™etÄ›zce, snadno by se mohlo
stÃ¡t, Å¾e nÃ¡m uÅ¾ivatel zadÃ¡ moc dat, kterÃ© by funkce <code>scanf</code> zaÄala vesele zapisovat i za pamÄ›Å¥ pÅ™edanÃ©ho
Å™etÄ›zce, coÅ¾ mÅ¯Å¾e vÃ©st buÄ k pÃ¡du programu (v tom lepÅ¡Ã­m pÅ™Ã­padÄ›) nebo ke vzniku bezpeÄnostnÃ­
zranitelnosti, pomocÃ­ kterÃ© by uÅ¾ivatel naÅ¡eho programu mohl napÅ™Ã­klad zÃ­skat pÅ™Ã­stup k poÄÃ­taÄi,
na kterÃ©m program bÄ›Å¾Ã­ (v tom horÅ¡Ã­m pÅ™Ã­padÄ›):</p>
<pre><code class="language-c">char buf[21];
// pokud uÅ¾ivatel zadÃ¡ vÃ­ce neÅ¾ 20 znakÅ¯, mÅ¯Å¾e svÃ½m vstupem zaÄÃ­t pÅ™episovat pamÄ›Å¥
// bÄ›Å¾Ã­cÃ­ho programu
scanf(&quot;%s&quot;, buf);
</code></pre>
<h3><a class="header" href="#zpracovÃ¡nÃ­-bÃ­lÃ½ch-znakÅ¯" id="zpracovÃ¡nÃ­-bÃ­lÃ½ch-znakÅ¯">ZpracovÃ¡nÃ­ bÃ­lÃ½ch znakÅ¯</a></h3>
<p>Funkce <code>scanf</code> ignoruje bÃ­lÃ© znaky (mezery, odÅ™Ã¡dkovÃ¡nÃ­, tabulÃ¡tory atd.) mezi jednotlivÃ½mi
zÃ¡stupnÃ½mi znaky ve formÃ¡tovacÃ­m Å™etÄ›zci. NapÅ™Ã­klad v nÃ¡sledujÃ­cÃ­m kÃ³du je validnÃ­m vstupem <code>x8</code>,
<code>x 8</code> i <code>x â€ƒ 8</code>:</p>
<pre><code class="language-c">int a;
scanf(&quot;x%d&quot;, &amp;a);
</code></pre>
<p>I kdyÅ¾ mÅ¯Å¾e toto chovÃ¡nÃ­ bÃ½t uÅ¾iteÄnÃ©, nÄ›kdy je takÃ© celkem neintuitivnÃ­. ProblÃ©m mÅ¯Å¾e zpÅ¯sobovat
zejmÃ©na, pokud se pro naÄÃ­tÃ¡nÃ­ vstupu kombinuje formÃ¡tovanÃ© naÄÃ­tÃ¡nÃ­ (<code>scanf</code>) s neformÃ¡tovanÃ½m
naÄÃ­tÃ¡nÃ­m (napÅ™. <code>fgets</code>). Funkce <code>scanf</code> totiÅ¾ bÃ­lÃ© znaky nechÃ¡ ve vstupu leÅ¾et, pokud je
nepotÅ™ebuje zpracovat.</p>
<p>NÃ¡sledujÃ­cÃ­ program naÄÃ­tÃ¡ ÄÃ­slo pomocÃ­ funkce <code>scanf</code> a potÃ© se snaÅ¾Ã­ naÄÃ­st nÃ¡sledujÃ­cÃ­
Å™Ã¡dek textu pomocÃ­ funkce <code>fgets</code>:</p>
<pre><code class="language-c">int cislo;
scanf(&quot;%d&quot;, &amp;cislo);

char radek[80];
fgets(radek, sizeof(radek), stdin);
</code></pre>
<p>Pokud tomuto programu pÅ™edÃ¡me text <code>5\nahoj</code>, oÄekÃ¡vali bychom, Å¾e se v Å™etÄ›zci <code>radek</code> objevÃ­
<code>ahoj</code>. NicmÃ©nÄ› funkce <code>scanf</code> naÄte ÄÃ­slo <code>5</code> a nechÃ¡ ve vstupu leÅ¾et znak odÅ™Ã¡dkovÃ¡nÃ­, protoÅ¾e
nic dalÅ¡Ã­ho naÄÃ­st nepotÅ™ebuje. Funkce <code>fgets</code> potÃ© uvidÃ­ znak odÅ™Ã¡dkovÃ¡nÃ­, naÄte jej a skonÄÃ­
svÃ© provÃ¡dÄ›nÃ­ (naÄte prÃ¡zdnÃ½ Å™Ã¡dek), coÅ¾ zÅ™ejmÄ› nenÃ­ chovÃ¡nÃ­, kterÃ© bychom od programu Äekali.</p>
<h3><a class="header" href="#oÅ¡etÅ™enÃ­-chyb-1" id="oÅ¡etÅ™enÃ­-chyb-1">OÅ¡etÅ™enÃ­ chyb</a></h3>
<p>Funkce <code>scanf</code> je problematickÃ¡ i co se tÃ½Äe oÅ¡etÅ™enÃ­ chyb. JejÃ­ nÃ¡vratovÃ¡ hodnota sice udÃ¡vÃ¡, kolik
zÃ¡stupnÃ½ch znakÅ¯ ze vstupu se jÃ­ podaÅ™ilo naÄÃ­st, problÃ©mem vÅ¡ak je, Å¾e pokud funkce naÄte tÅ™eba
pouze polovinu vstupu, tak ji uÅ¾ nemÅ¯Å¾eme zavolat znovu se stejnÃ½m formÃ¡tovacÃ­m Å™etÄ›zcem, jinak by se
snaÅ¾ila naÄÃ­st data, kterÃ¡ jiÅ¾ naÄetla. NapÅ™Ã­klad pokud bychom tomuto programu:</p>
<pre><code class="language-c">int x, y;
scanf(&quot;%d%d&quot;, &amp;x, &amp;y);
</code></pre>
<p>pÅ™edali text <code>5 asd</code>, tak funkce vrÃ¡tÃ­ hodnotu <code>1</code>, tj. naÄetla ze vstupu jedno ÄÃ­slo. NynÃ­ ovÅ¡em uÅ¾
funkci nemÅ¯Å¾eme zavolat znovu se stejnÃ½mi parametry (jakmile bychom napÅ™. ve vstupu pÅ™eskoÄili nevalidnÃ­
text), protoÅ¾e v tuto chvÃ­li uÅ¾ bychom chtÄ›li naÄÃ­st pouze jedno ÄÃ­slo. </p>
<h2><a class="header" href="#parametry-pÅ™Ã­kazovÃ©ho-Å™Ã¡dku" id="parametry-pÅ™Ã­kazovÃ©ho-Å™Ã¡dku">Parametry pÅ™Ã­kazovÃ©ho Å™Ã¡dku</a></h2>
<p>DalÅ¡Ã­ moÅ¾nostÃ­, jak pÅ™edat nÄ›jakÃ½ vstup vaÅ¡emu programu, je pÅ™edat mu parametry pÅ™i spuÅ¡tÄ›nÃ­ v
terminÃ¡lu:</p>
<pre><code class="language-bash">$ ./program arg1 arg2 arg3
</code></pre>
<p>K tÄ›mto pÅ™edanÃ½m Å™etÄ›zcÅ¯m potÃ© lze pÅ™istoupit ve funkci
<a href="c/text/../../ruzne/funkce_main.html#vstupn%C3%AD-parametry-funkce-main"><code>main</code></a>.</p>
<hr />
<p><strong>KvÃ­z</strong> ğŸ¤”</p>
<ol>
<li>
<p>Co vypÃ­Å¡e nÃ¡sledujÃ­cÃ­ program, pokud na vstup zadÃ¡me <code>5</code>?</p>
<pre><code class="language-c editable mainbody">#include &lt;stdio.h&gt;

int main() {
    int a;
    scanf(&quot;%d&quot;, a);

    printf(&quot;Hodnota: %d\n&quot;, a);

    return 0;
}
</code></pre>
<details>
 <summary>OdpovÄ›Ä</summary>
<p>Tento program obsahuje <a href="c/text/../../ruzne/nedefinovane_chovani.html"><strong>nedefinovanÃ© chovÃ¡nÃ­</strong></a> ğŸ’£. Funkce <code>scanf</code>
oÄekÃ¡vÃ¡ pro kaÅ¾dÃ½ zÃ¡stupnÃ½ znak ve svÃ©m formÃ¡tovacÃ­m Å™etÄ›zci dalÅ¡Ã­ argument, kterÃ½ musÃ­ obsahovat <strong>adresu</strong>,
do kterÃ© se danÃ¡ hodnota ze vstupu uloÅ¾Ã­. Zde mÃ­sto adresy pÅ™edÃ¡vÃ¡me do <code>scanf</code> hodnotu ÄÃ­selnÃ© promÄ›nnÃ©,
kterÃ¡ navÃ­c ani nenÃ­ inicializovanÃ¡, takÅ¾e jejÃ­ pÅ™edÃ¡nÃ­ do funkce je samo o sobÄ› takÃ© nedefinovanÃ½m
chovÃ¡nÃ­m.</p>
</details>
</li>
<li>
<p>Co vypÃ­Å¡e nÃ¡sledujÃ­cÃ­ program, pokud na vstup zadÃ¡me <code>5</code>?</p>
<pre><code class="language-c editable mainbody">#include &lt;stdio.h&gt;

int main() {
    int* p;
    scanf(&quot;%d&quot;, p);

    printf(&quot;Hodnota: %d\n&quot;, a);

    return 0;
}
</code></pre>
<details>
 <summary>OdpovÄ›Ä</summary>
<p>Tento program obsahuje <a href="c/text/../../ruzne/nedefinovane_chovani.html"><strong>nedefinovanÃ© chovÃ¡nÃ­</strong></a> ğŸ’£. Sice sprÃ¡vnÄ› do
funkce <code>scanf</code> pÅ™edÃ¡vÃ¡ adresu celÃ©ho ÄÃ­sla, ale tato adresa je neinicializovanÃ¡! Adresy pÅ™edanÃ© funkci
<code>scanf</code> po formÃ¡tovacÃ­m Å™etÄ›zci jsou vÃ½stupnÃ­mu argumenty, jinak Å™eÄeno do pÅ™edanÃ½ch adres budou zapsÃ¡ny
hodnoty naÄtenÃ© ze vstupu. MusÃ­me tak do funkce pÅ™edat validnÃ­ adresu na kus pamÄ›ti, kde je opravdu uloÅ¾eno celÃ©
ÄÃ­slo, coÅ¾ v tomto pÅ™Ã­padÄ› neplatÃ­.</p>
</details>
</li>
<li>
<p>Co vypÃ­Å¡e nÃ¡sledujÃ­cÃ­ program, pokud na vstup zadÃ¡me <code>5</code>?</p>
<pre><code class="language-c editable mainbody">#include &lt;stdio.h&gt;

int main() {
    int a;
    scanf(&quot;%s&quot;, &amp;a);

    printf(&quot;Hodnota: %d\n&quot;, a);

    return 0;
}
</code></pre>
<details>
 <summary>OdpovÄ›Ä</summary>
<p>Tento program obsahuje <a href="c/text/../../ruzne/nedefinovane_chovani.html"><strong>nedefinovanÃ© chovÃ¡nÃ­</strong></a> ğŸ’£. Sice sprÃ¡vnÄ› do
funkce <code>scanf</code> pÅ™edÃ¡vÃ¡ adresu promÄ›nnÃ©, ale Å¡patnÃ©ho typu. ZÃ¡stupnÃ½ znak <code>%s</code> vyÅ¾aduje adresu (pole) znakÅ¯,
zatÃ­mco zde pÅ™edÃ¡vÃ¡me adresu celÃ©ho ÄÃ­sla.</p>
</details>
</li>
<li>
<p>Co vypÃ­Å¡e nÃ¡sledujÃ­cÃ­ program, pokud na vstup zadÃ¡me <code>Martin\nNovak</code>?</p>
<pre><code class="language-c editable mainbody">#include &lt;stdio.h&gt;

int main() {
    char radek[100];
    fgets(radek, sizeof(radek), stdin);

    const char* jmeno = radek;

    fgets(radek, sizeof(radek), stdin);

    const char* prijmeni = radek;

    printf(&quot;%s&quot;, jmeno);
    printf(&quot;%s&quot;, prijmeni);

    return 0;
}
</code></pre>
<details>
 <summary>OdpovÄ›Ä</summary>
<p>VypÃ­Å¡e se tohle:</p>
<pre><code>Novak
Novak
</code></pre>
<p>Je dÅ¯leÅ¾itÃ© si uvÄ›domit, co znamenÃ¡ <code>const char* jmeno = radek;</code>. <code>char*</code> je ukazatel, tedy ÄÃ­slo
obsahujÃ­cÃ­ adresu. TÃ­mto Å™Ã¡dkem pouze Å™Ã­kÃ¡me, Å¾e do ukazatele s nÃ¡zvem <code>jmeno</code> uklÃ¡dÃ¡me adresu
pole znakÅ¯ <code>radek</code>. Å˜Ã¡dkem <code>const char* prijmeni = radek;</code> Å™Ã­kÃ¡me, Å¾e tuto adresu uklÃ¡dÃ¡me do
promÄ›nnÃ© s nÃ¡zvem <code>prijmeni</code>. ObÄ› dvÄ› promÄ›nnÃ© (<code>jmeno</code> a <code>prijmeni</code>) tedy obsahujÃ­ stejnou adresu.
No a jelikoÅ¾ si druhÃ½m volÃ¡nÃ­m funkce <code>fgets</code> pÅ™epÃ­Å¡eme pÅ¯vodnÃ­ obsah pole <code>radek</code>, a obÄ› promÄ›nnÃ©
ukazujÃ­ na pole <code>radek</code>, tak se vypÃ­Å¡e dvakrÃ¡t poslednÃ­ naÄtenÃ½ Å™Ã¡dek.</p>
<p>PoznÃ¡mka: ve formÃ¡tovacÃ­m Å™etÄ›zci funkce <code>printf</code> jsme zde nepouÅ¾ili znak odÅ™Ã¡dkovÃ¡nÃ­ (<code>\n</code>),
protoÅ¾e funkce <code>fgets</code> jej uloÅ¾Ã­ do pole <code>radek</code> a nÃ¡Å¡ kÃ³d ho zde neodstranil. TakÅ¾e pokud bychom
ho mÄ›li i v <code>printf</code>, tak by se vypsaly dva znaky odÅ™Ã¡dkovÃ¡nÃ­ za sebou.</p>
</details>
</li>
</ol>
<h1><a class="header" href="#vÃ½stup" id="vÃ½stup">VÃ½stup</a></h1>
<p>StejnÄ› jako pro naÄÃ­tÃ¡nÃ­ vstupu, i pro vÃ½pis textu na vÃ½stup nabÃ­zÃ­ standardnÃ­ knihovna <em>C</em> sadu
uÅ¾iteÄnÃ½ch funkcÃ­, opÄ›t umÃ­stÄ›nÃ½ch v souboru <code>&lt;stdio.h&gt;</code>. StejnÄ› jako u naÄÃ­tÃ¡nÃ­ <a href="c/text/vstup.html">vstupu</a>
bychom i u vÃ½stupu mÄ›li Å™eÅ¡it <a href="c/text/vstupavystup.html#o%C5%A1et%C5%99en%C3%AD-chyb">oÅ¡etÅ™enÃ­ chyb</a>. NicmÃ©nÄ›, u zÃ¡pisu to
(alespoÅˆ u malÃ½ch programÅ¯) nenÃ­ aÅ¾ tak nezbytnÃ©, protoÅ¾e chyby zÃ¡pisu jsou vzÃ¡cnÄ›jÅ¡Ã­ neÅ¾ chyby pÅ™i
vstupu. Zdrojem dat je totiÅ¾ nÃ¡Å¡ program, a nemusÃ­me tedy tak striktnÄ› kontrolovat, jestli jsou
vypsanÃ¡ data validnÃ­. Tato povinnost v jistÃ©m smyslu pÅ™echÃ¡zÃ­ na druhou stranu, s kterou nÃ¡Å¡ program
komunikuje, protoÅ¾e ta bude nÃ¡mi vypsanÃ¡ data ÄÃ­st.</p>
<h2><a class="header" href="#vypsÃ¡nÃ­-znaku" id="vypsÃ¡nÃ­-znaku">VypsÃ¡nÃ­ znaku</a></h2>
<p>Pro vypsÃ¡nÃ­ jednoho znaku na standardnÃ­ vÃ½stup (<code>stdout</code>) mÅ¯Å¾eme pouÅ¾Ã­t funkci
<a href="https://devdocs.io/c/io/putchar"><code>putchar</code></a>.</p>
<pre><code class="language-c editable mainbody">#include &lt;stdio.h&gt;

int main() {
    putchar('x');
    return 0;
}
</code></pre>
<h2><a class="header" href="#vypsÃ¡nÃ­-Å™etÄ›zce" id="vypsÃ¡nÃ­-Å™etÄ›zce">VypsÃ¡nÃ­ Å™etÄ›zce</a></h2>
<p>Pro vypsÃ¡nÃ­ celÃ©ho Å™etÄ›zce na <code>stdout</code> mÅ¯Å¾ete pouÅ¾Ã­t funkci <a href="https://devdocs.io/c/io/puts"><code>puts</code></a>,
kterÃ¡ zÃ¡roveÅˆ za Å™etÄ›zcem vypÃ­Å¡e znak odÅ™Ã¡dkovÃ¡nÃ­ <code>\n</code>:</p>
<pre><code class="language-c editable mainbody">#include &lt;stdio.h&gt;

int main() {
    puts(&quot;Ahoj&quot;);
    puts(&quot;UPR&quot;);
    return 0;
}
</code></pre>
<p>DÃ¡vejte si pozor na to, Å¾e v pÅ™edanÃ©m Å™etÄ›zci musÃ­ bÃ½t obsaÅ¾en ukonÄovacÃ­ <code>NUL</code> znak! Funkce <code>puts</code>
se bude snaÅ¾it ÄÃ­st a vypisovat znaky ze zadanÃ© adresy, aÅ¾ dokud na takovÃ½to znak nenarazÃ­. Pokud
by tento znak v pÅ™edanÃ©m Å™etÄ›zci nebyl, tak se bude funkce pokouÅ¡et ÄÃ­st nevalidnÃ­ pamÄ›Å¥ za koncem
Å™etÄ›zce, dokud na <code>NUL</code> nenarazÃ­, coÅ¾ by vedlo k
<a href="c/text/../../caste_chyby/pametove_chyby.html">pamÄ›Å¥ovÃ© chybÄ›</a> ğŸ’£.</p>
<h2><a class="header" href="#vypsÃ¡nÃ­-formÃ¡tovanÃ©ho-textu" id="vypsÃ¡nÃ­-formÃ¡tovanÃ©ho-textu">VypsÃ¡nÃ­ formÃ¡tovanÃ©ho textu</a></h2>
<p>K vÃ½pisu formÃ¡tovanÃ©ho textu na <code>stdout</code> mÅ¯Å¾eme pouÅ¾Ã­t funkci <code>printf</code>, s kterou jsme se jiÅ¾
mnohokrÃ¡t setkali. PrvnÃ­m parametrem funkce je formÃ¡tovacÃ­ Å™etÄ›zec, do kterÃ©ho mÅ¯Å¾ete dÃ¡vat
zÃ¡stupnÃ© znaky zaÄÃ­najÃ­cÃ­ procentem (napÅ™. <code>%d</code> nebo <code>%s</code>). Pro kaÅ¾dÃ½ takovÃ½to zÃ¡stupnÃ½ znak funkce bude oÄekÃ¡vat jednu
hodnotu (argument) za formÃ¡tovacÃ­m Å™etÄ›zcem, kterÃ¡ bude zformÃ¡tovÃ¡na na vÃ½stup. NapÅ™Ã­klad takto mÅ¯Å¾eme vytisknout ÄÃ­slo
a po nÄ›m Å™etÄ›zec:</p>
<pre><code class="language-c">const char* text = &quot;Cislo&quot;;
int cislo = 5;
printf(&quot;Cislo %d, retezec %s: \n&quot;, cislo, text);
</code></pre>
<p>JelikoÅ¾ jsme ve formÃ¡tovacÃ­m Å™etÄ›zci pÅ™edali dva zÃ¡stupnÃ© znaky (<code>%d</code> - ÄÃ­slo a <code>%s</code> - Å™etÄ›zec), tak po Å™etÄ›zci musÃ­me
do funkce <code>printf</code> pÅ™edat jeden argument ÄÃ­selnÃ©ho typu, a potÃ© jeden Å™etÄ›zec.</p>
<p>ZÃ¡stupnÃ© znaky funkcÃ­ <code>printf</code> i <code>scanf</code> jsou obdobnÃ©, jejich seznam a rÅ¯znÃ© moÅ¾nosti nastavenÃ­
mÅ¯Å¾ete najÃ­t v <a href="https://devdocs.io/c/io/fprintf">dokumentaci</a>. NejÄastÄ›ji budeme pouÅ¾Ã­vat tyto zÃ¡stupnÃ© znaky:</p>
<ul>
<li><code>%d</code> - vÃ½pis celÃ©ho ÄÃ­sla se znamÃ©nkem, nejÄastÄ›ji datovÃ½ typ <code>int</code></li>
<li><code>%f</code> - vÃ½pis desetinnÃ©ho ÄÃ­sla, datovÃ½ typ <code>float</code></li>
<li><code>%s</code> - vÃ½pis Å™etÄ›zce, datovÃ½ typ <code>char*</code> (ukazatel na znak)
<ul>
<li>Na pÅ™edanÃ© adrese musÃ­ leÅ¾et Å™etÄ›zec, tj. pole znakÅ¯ <strong>ukonÄenÃ© znakem <code>'\0'</code></strong>!</li>
</ul>
</li>
</ul>
<blockquote>
<p>StejnÄ› jako <code>scanf</code> mÃ¡ i funkce <code>printf</code> rÅ¯znÃ© varianty pro formÃ¡tovanÃ½ vÃ½pis do souborÅ¯
(<code>fprintf</code>) Äi do Å™etÄ›zce v pamÄ›ti (<code>sprintf</code>).</p>
</blockquote>
<hr />
<p><strong>KvÃ­z</strong> ğŸ¤”</p>
<ol>
<li>
<p>Co vypÃ­Å¡e nÃ¡sledujÃ­cÃ­ program?</p>
<pre><code class="language-c editable mainbody">#include &lt;stdio.h&gt;

int main() {
    int a = 1;

    printf(&quot;Hodnota: %f&quot;, a);

    return 0;
}
</code></pre>
<details>
 <summary>OdpovÄ›Ä</summary>
<p>Tento program obsahuje <a href="c/text/../../ruzne/nedefinovane_chovani.html"><strong>nedefinovanÃ© chovÃ¡nÃ­</strong></a> ğŸ’£. Å˜Ã­kÃ¡me funkci <code>printf</code>,
Å¾e chceme vypsat desetinnÃ© ÄÃ­slo (zÃ¡stupnÃ½ znak <code>%f</code>), ale jako argument pÅ™edÃ¡vÃ¡me vÃ½raz typu celÃ© ÄÃ­slo (<code>int</code>).
Tento program tedy nenÃ­ validnÃ­.</p>
</details>
</li>
<li>
<p>Co vypÃ­Å¡e nÃ¡sledujÃ­cÃ­ program?</p>
<pre><code class="language-c editable mainbody">#include &lt;stdio.h&gt;

int main() {
    int a = 1;

    printf(&quot;Hodnota: %d (a=%d)&quot;, a);

    return 0;
}
</code></pre>
<details>
<summary>OdpovÄ›Ä</summary>
<p>Tento program obsahuje <a href="c/text/../../ruzne/nedefinovane_chovani.html"><strong>nedefinovanÃ© chovÃ¡nÃ­</strong></a> ğŸ’£. Å˜Ã­kÃ¡me funkci <code>printf</code>, Å¾e
jÃ­ pÅ™edÃ¡me dvÄ› hodnoty (dva vÃ½razy) typu celÃ©ho ÄÃ­sla (zÃ¡stupnÃ½ znak <code>%d</code>), ale pÅ™edÃ¡vÃ¡me pouze jednu hodnotu (<code>a</code>).
Tento program tedy nenÃ­ validnÃ­.</p>
</details>
</li>
<li>
<p>Co vypÃ­Å¡e nÃ¡sledujÃ­cÃ­ program?</p>
<pre><code class="language-c editable mainbody">#include &lt;stdio.h&gt;

int main() {
    int a = 1;

    printf(&quot;Hodnota: %s&quot;, a);

    return 0;
}
</code></pre>
<details>
<summary>OdpovÄ›Ä</summary>
<p>Tento program obsahuje <a href="c/text/../../ruzne/nedefinovane_chovani.html"><strong>nedefinovanÃ© chovÃ¡nÃ­</strong></a> ğŸ’£. Å˜Ã­kÃ¡me funkci <code>printf</code>, Å¾e
jÃ­ pÅ™edÃ¡me hodnotu typu Å™etÄ›zec (zÃ¡stupnÃ½ znak <code>%s</code>), ale pÅ™edÃ¡vÃ¡me pouze hodnotu typu celÃ© ÄÃ­slo (<code>int</code>). Tento
program tedy nenÃ­ validnÃ­.</p>
</details>
</li>
</ol>
<h1><a class="header" href="#vlastnÃ­-datovÃ©-typy" id="vlastnÃ­-datovÃ©-typy">VlastnÃ­ datovÃ© typy</a></h1>
<p>NynÃ­ uÅ¾ umÃ­me pracovat se zÃ¡kladnÃ­mi datovÃ½mi typy v <em>C</em>
(<a href="c/struktury/../datove_typy/celociselne_typy.html">celÃ¡ ÄÃ­sla</a>, <a href="c/struktury/../datove_typy/desetinne_typy.html">desetinnÃ¡ ÄÃ­sla</a>,
<a href="c/struktury/../datove_typy/pravdivostni_typy.html">pravdivostnÃ­ hodnoty</a>, <a href="c/struktury/../text/znaky.html">znaky</a>) a takÃ©
umÃ­me pracovat s jejich <a href="c/struktury/../prace_s_pameti/ukazatele.html">adresami</a> a vytvÃ¡Å™et jich
<a href="c/struktury/../pole/pole.html">vÃ­ce najednou</a>. Doposud jsme vÅ¡ak vÅ¾dy pracovali s kaÅ¾dÃ½m datovÃ½m typem zvlÃ¡Å¡Å¥.</p>
<p>PÅ™edstavte si, Å¾e byste chtÄ›li naprogramovat hru, ve kterÃ© budete mÃ­t nÄ›jakÃ© poÄÃ­taÄem ovlÃ¡danÃ©
pÅ™Ã­Å¡ery<sup class='margin-toggle sidenote-number'>1</sup>. KaÅ¾dÃ¡ pÅ™Ã­Å¡era mÅ¯Å¾e mÃ­t spoustu vlastnostÃ­ â€“ jmÃ©no, poÄet Å¾ivotÅ¯, zranÄ›nÃ­, kterÃ© udÄ›luje,
umÃ­stÄ›nÃ­ na mapÄ›, koÅ™ist atd. ZÃ¡roveÅˆ bude takovÃ½ch pÅ™Ã­Å¡er v naÅ¡Ã­ hÅ™e urÄitÄ› vÃ­ce. Mohli bychom tak
pÅ™Ã­Å¡ery reprezentovat pomocÃ­ pole pro kaÅ¾dou jeho vlastnost:</p>
<span class='sidenote'><p><sup class='number'>1</sup><em>Non-player character</em> (NPC)</p>
</span>
<pre><code class="language-c">const char* prisera_jmeno[100];
int prisera_zivot[100];
int prisera_zraneni[100];
float prisera_poloha_x[100];
float prisera_poloha_y[100];
...
</code></pre>
<p>I kdyÅ¾ by jistÄ› Å¡lo programy tvoÅ™it tÃ­mto zpÅ¯sobem, asi sami uznÃ¡te, Å¾e to nenÃ­ ideÃ¡lnÃ­, protoÅ¾e to
mÃ¡ spoustu nevÃ½hod:</p>
<ul>
<li>Pokud bychom napÅ™Ã­klad zmÄ›nili (maximÃ¡lnÃ­) poÄet pÅ™Ã­Å¡er, museli bychom synchronizovat tuto velikost
mezi vÅ¡emi poli, kterÃ¡ reprezentujÃ­ jednotlivÃ© vlastnosti pÅ™Ã­Å¡er.</li>
<li>K nÃ¡zvÅ¯m promÄ›nnÃ½ch musÃ­me pÅ™idÃ¡vat nÄ›jakou pÅ™edponu (napÅ™. <code>prisera</code>), abychom dali najevo, Å¾e
tyto promÄ›nnÃ© vlastnÄ› patÅ™Ã­ k jednomu logickÃ©mu prvku (pÅ™Ã­Å¡eÅ™e).</li>
<li>Pokud bychom chtÄ›li jednu takovou pÅ™Ã­Å¡eru poslat do funkce, tak by to vyÅ¾adovalo spoustu parametrÅ¯:
<pre><code class="language-c">int vypocti_pocet_zkusenosti(
    const char* prisera_jmeno,
    int prisera_zivot,
    int prisera_zraneni,
    float prisera_poloha_x,
    float prisera_poloha_y,
    ...
) { }
</code></pre>
Celou pÅ™Ã­Å¡eru bychom ani nemohli z funkce pÅ™Ã­moÄaÅ™e vrÃ¡tit, protoÅ¾e funkce mohou vracet pouze
jednu hodnotu.</li>
<li>Pokud bychom chtÄ›li pÅ™Ã­Å¡eÅ™e pÅ™idat novou vlastnost, museli bychom pÅ™idat novou promÄ›nnou nebo pole
na vÅ¡echna mÃ­sta, kde s pÅ™Ã­Å¡erami pracujeme. NapÅ™Ã­klad by se musely zmÄ›nit parametry kaÅ¾dÃ© funkce,
kterÃ¡ by pÅ™ijÃ­mala pÅ™Ã­Å¡eru.</li>
</ul>
<p>Co bychom ve skuteÄnosti chtÄ›li pÅ™ekladaÄi Å™Ã­ct, je nÄ›co ve smyslu <code>PÅ™Ã­Å¡era je nÄ›co, co mÃ¡ jmÃ©no, poÄet Å¾ivotÅ¯, zranÄ›nÃ­, pozici a koÅ™ist</code>, a potÃ© bychom chtÄ›li ve funkci napÅ™Ã­klad Å™Ã­ct <code>VytvoÅ™ pole 100 pÅ™Ã­Å¡er</code>:</p>
<pre><code class="language-c">Prisera prisery[100];
</code></pre>
<p>Takto bychom zlepÅ¡ili ÃºroveÅˆ abstrakce naÅ¡eho kÃ³du â€“ v tomto konkrÃ©tnÃ­m pÅ™Ã­padÄ› bychom se mohli zaÄÃ­t
v kÃ³du bavit o <code>pÅ™Ã­Å¡eÅ™e</code> mÃ­sto pouze o sadÄ› atributÅ¯ <code>jmÃ©no, poÄet Å¾ivotÅ¯, zranÄ›nÃ­, â€¦</code>.</p>
<p>Jinak Å™eÄeno, chtÄ›li bychom si vytvoÅ™it nÃ¡Å¡ vlastnÃ­ datovÃ½ typ. A prÃ¡vÄ› to mÅ¯Å¾eme v <em>C</em> udÄ›lat pomocÃ­
<a href="c/struktury/struktury.html">struktur</a>.</p>
<blockquote>
<p>Struktury jsou poslednÃ­m syntaktickÃ½m prvkem <em>C</em>, o kterÃ©m se budeme v pÅ™edmÄ›tu UPR bavit. Jazyk
<em>C</em> sice obsahuje i nÄ›kolik dalÅ¡Ã­ch <a href="c/struktury/../co_dal.html">syntaktickÃ½ch prvkÅ¯</a>, kterÃ© jsme si neukÃ¡zali,
ty vÅ¡ak nejsou nutnÃ© pro tvorbu jednoduchÃ½ch programÅ¯. DÃ¡le se uÅ¾ pouze budeme bavit o konkrÃ©tnÃ­ch
aplikacÃ­ch toho, co jsme se nauÄili, pro tvorbu rÅ¯znÃ½ch typÅ¯ programÅ¯.</p>
</blockquote>
<h1><a class="header" href="#struktury" id="struktury">Struktury</a></h1>
<p><strong>Struktury</strong> (<em>structures</em>) nÃ¡m umoÅ¾ÅˆujÃ­ popsat novÃ½ datovÃ½ typ, kterÃ½ se bude sklÃ¡dat z
jednoho Äi vÃ­ce tzv. <strong>ÄlenÅ¯</strong> (<em>members</em>)<sup class='margin-toggle sidenote-number'>1</sup>. KaÅ¾dÃ©mu Älenu musÃ­me urÄit jeho jmÃ©no a datovÃ½ typ.
Novou strukturu mÅ¯Å¾eme popsat pomocÃ­ tzv. <em>deklarace struktury</em>:</p>
<span class='sidenote'><p><sup class='number'>1</sup>MÅ¯Å¾ete se setkat takÃ© s nÃ¡zvy <strong>atribut</strong> (<em>attribute</em>), <strong>vlastnost</strong> (<em>property</em>) nebo
<em>field</em>. V kontextu struktur <em>C</em> oznaÄujÃ­ vÅ¡echny tyto nÃ¡zvy jedno a to samÃ© - Älena struktury.</p>
</span>
<pre><code class="language-c">struct &lt;nÃ¡zev struktury&gt; {
    &lt;datovÃ½ typ prvnÃ­ho Älenu&gt; &lt;nÃ¡zev prvnÃ­ho Älenu&gt;;
    &lt;datovÃ½ typ druhÃ©ho Älenu&gt; &lt;nÃ¡zev druhÃ©ho Älenu&gt;;
    &lt;datovÃ½ typ tÅ™etÃ­ho Älenu&gt; &lt;nÃ¡zev tÅ™etÃ­ho Älenu&gt;;
    ...
};
</code></pre>
<blockquote>
<p>PÅ™i deklaraci struktury nezapomÃ­nejte na finÃ¡lnÃ­ stÅ™ednÃ­k za sloÅ¾enÃ½mi zÃ¡vorkami, je povinnÃ½.</p>
</blockquote>
<p>NapÅ™Ã­klad, pokud bychom chtÄ›li vytvoÅ™it datovÃ½ typ reprezentujÃ­cÃ­ <code>pÅ™Ã­Å¡eru</code>, kterÃ¡ mÃ¡ svÃ© jmÃ©no
a poÄet Å¾ivotÅ¯, mÅ¯Å¾eme deklarovat nÃ¡sledujÃ­cÃ­ strukturu:</p>
<pre><code class="language-c">struct Prisera {
    const char* jmeno;
    int pocet_zivotu;
};
</code></pre>
<p>Tento kÃ³d sÃ¡m o sobÄ› <strong>nic neprovÃ¡dÃ­</strong>! Pouze pomocÃ­ nÄ›j Å™Ã­kÃ¡me pÅ™ekladaÄi, Å¾e vytvÃ¡Å™Ã­me novÃ½ datovÃ½
typ s nÃ¡zvem <code>struct Prisera</code>. PotÃ© nÃ¡m pÅ™ekladaÄ umoÅ¾nÃ­ dÃ¡le v programu vytvoÅ™it napÅ™Ã­klad lokÃ¡lnÃ­
promÄ›nnou tohoto datovÃ©ho typu:</p>
<pre><code class="language-c">// lokÃ¡lnÃ­ promÄ›nnÃ¡ s nÃ¡zvem `karel` a datovÃ½m typem `struct Prisera`
struct Prisera karel;
</code></pre>
<p>Pro pojmenovÃ¡vÃ¡nÃ­ struktur pouÅ¾Ã­vejte v rÃ¡mci pÅ™edmÄ›tu UPR jmennou konvenci
<a href="c/struktury/../promenne/pojmenovavani.html#v%C3%ADceslovn%C3%A9-n%C3%A1zvy"><code>PascalCase</code></a>.</p>
<blockquote>
<p>Struktury jsou plnohodnotnÃ½mi datovÃ½mi typy. MÅ¯Å¾ete tak vytvÃ¡Å™et ukazatele na struktury, pole
struktur, mÅ¯Å¾ete pouÅ¾Ã­t struktury jako <a href="c/struktury/struktury.html#pou%C5%BEit%C3%AD-struktur-ve-struktur%C3%A1ch">Äleny jinÃ© struktury</a>
atd.</p>
</blockquote>
<h2><a class="header" href="#reprezentace-struktury-v-pamÄ›ti" id="reprezentace-struktury-v-pamÄ›ti">Reprezentace struktury v pamÄ›ti</a></h2>
<p>Pokud vytvoÅ™Ã­me promÄ›nnou datovÃ©ho typu struktury, tak pÅ™ekladaÄ naalokuje pamÄ›Å¥ pro vÅ¡echny
Äleny tÃ©to struktury. V pÅ™Ã­padÄ› vÃ½Å¡e by promÄ›nnÃ¡ <code>karel</code> obsahovala nejprve byty pro ukazatel
<code>const char*</code> a potÃ© byty pro <code>int</code>. ÄŒlenovÃ© struktury budou v pamÄ›ti uloÅ¾eni ve stejnÃ©m poÅ™adÃ­,
v jakÃ©m byli popsÃ¡ni pÅ™i deklaraci struktury. NeznamenÃ¡ to ovÅ¡em, Å¾e musÃ­ leÅ¾et hned za sebou!
PÅ™ekladaÄ se mÅ¯Å¾e rozhodnout mezi Äleny struktury v pamÄ›ti vloÅ¾it mezery (tzv. <em>padding</em>) kvÅ¯li
urychlenÃ­ provÃ¡dÄ›nÃ­ programu. VÃ­ce detailÅ¯ se mÅ¯Å¾ete dozvÄ›dÄ›t v podkapitole
<a href="c/struktury/pametova_reprezentace.html">Reprezentace struktur v pamÄ›ti</a>.</p>
<p>ProzatÃ­m si zapamatujte, Å¾e pro zjiÅ¡tÄ›nÃ­ velikosti struktury v bytech (napÅ™Ã­klad pÅ™i dynamickÃ©
alokaci pamÄ›ti) vÅ¾dy pouÅ¾Ã­vejte operÃ¡tor
<a href="c/struktury/../prace_s_pameti/dynamicka_pamet.html#velikost-alokovan%C3%A9-pam%C4%9Bti"><code>sizeof</code></a> a nesnaÅ¾te se velikost
&quot;tipovat&quot; ruÄnÄ›.</p>
<h3><a class="header" href="#umÃ­stÄ›nÃ­-a-platnost-struktur" id="umÃ­stÄ›nÃ­-a-platnost-struktur">UmÃ­stÄ›nÃ­ a platnost struktur</a></h3>
<p>StejnÄ› jako u <a href="c/struktury/../promenne/promenne.html#platnost">promÄ›nnÃ½ch</a> platÃ­, Å¾e strukturu lze
pouÅ¾Ã­vat pouze v oblasti, ve kterÃ© je platnÃ¡ (v jejÃ­m tzv. <em>scopu</em>). NarozdÃ­l od
<a href="c/struktury/../funkce/funkce.html#um%C3%ADst%C4%9Bn%C3%AD-funkc%C3%AD">funkcÃ­</a> lze struktury deklarovat i uvnitÅ™ funkcÃ­, nicmÃ©nÄ›
nejÄastÄ›ji se struktury deklarujÃ­ na nejvyÅ¡Å¡Ã­ Ãºrovni souboru (tzv. <em>global scope</em>), stejnÄ› jako
funkce.</p>
<h2><a class="header" href="#inicializace-struktury" id="inicializace-struktury">Inicializace struktury</a></h2>
<p>StejnÄ› jako u <a href="c/struktury/../promenne/promenne.html#v%C5%BEdy-inicializujte-prom%C4%9Bnn%C3%A9">zÃ¡kladnÃ­ch datovÃ½ch typÅ¯</a> a
<a href="c/struktury/../pole/staticka_pole.html#inicializace-pole">polÃ­</a> platÃ­, Å¾e pokud lokÃ¡lnÃ­ promÄ›nnÃ© s datovÃ½m typem
nÄ›jakÃ© struktury nedÃ¡te poÄÃ¡teÄnÃ­ hodnotu, tak bude jejÃ­ hodnota nedefinovanÃ¡ ğŸ’£. Strukturu mÅ¯Å¾ete
nainicializovat pomocÃ­ sloÅ¾enÃ½ch zÃ¡vorek se seznamem hodnot pro jednotlivÃ© Äleny struktury:</p>
<pre><code class="language-c">struct Prisera karel = { &quot;Karel&quot;, 100 };
</code></pre>
<p>StejnÄ› jako u polÃ­ platÃ­, Å¾e hodnoty, kterÃ© nezadÃ¡te, se nainicializujÃ­ na nulu:</p>
<pre><code class="language-c">struct Prisera karel = {}; // `jmeno` i `pocet_zivotu` bude `0`
struct Prisera karel = { &quot;Karel&quot; }; // `jmeno` bude &quot;Karel&quot;, `pocet_zivotu` bude `0`
</code></pre>
<p>Abyste si nemuseli pamatovat poÅ™adÃ­ ÄlenÅ¯ struktury pÅ™i jejÃ­ inicializaci, mÅ¯Å¾ete jednotlivÃ© Äleny
nainicializovat explicitnÄ› pomocÃ­ teÄky a nÃ¡zvu danÃ©ho Älenu:</p>
<pre><code class="language-c">struct Prisera karel = { .pocet_zivotu = 100, .jmeno = &quot;Karel&quot; };
</code></pre>
<p>JednotlivÃ© hodnoty ÄlenÅ¯m se pÅ™iÅ™azujÃ­ zleva doprava, takÅ¾e pokud pouÅ¾ijete nÃ¡zev nÄ›jakÃ©ho Älenu
vÃ­ce neÅ¾ jednou, &quot;zvÃ­tÄ›zÃ­&quot; poslednÃ­ zadanÃ¡ hodnota. Tomuto se vÅ¡ak vyhnÄ›te, a ani nekombinujte
inicializaci pomocÃ­ poÅ™adÃ­ a pomocÃ­ nÃ¡zvÅ¯ ÄlenÅ¯. TakovÃ½to kÃ³d by totiÅ¾ byl znaÄnÄ› nepÅ™ehlednÃ½.</p>
<h2><a class="header" href="#pÅ™Ã­stup-ke-ÄlenÅ¯m-struktur" id="pÅ™Ã­stup-ke-ÄlenÅ¯m-struktur">PÅ™Ã­stup ke ÄlenÅ¯m struktur</a></h2>
<p>Abychom mohli ÄÃ­st a zapisovat jednotlivÃ© Äleny struktur, mÅ¯Å¾eme pouÅ¾Ã­t operÃ¡tor
<strong>pÅ™Ã­stupu ke Älenu</strong> (<em>member access operator</em>), kterÃ½ mÃ¡ syntaxi <code>&lt;vÃ½raz typu struktura&gt;.&lt;nÃ¡zev Älenu&gt;</code>:</p>
<pre><code class="language-c editable">#include &lt;stdio.h&gt;

struct Osoba {
    int vek;
    int pocet_pratel;
};

int main() {
    struct Osoba martina = { .vek = 18, .pocet_pratel = 10 };
    martina.vek += 1;           // pÅ™Ã­stup k Älenu `vek`
    martina.pocet_pratel += 20; // pÅ™Ã­stup k Älenu `pocet_pratel`
    printf(&quot;Martina ma %d let a ma %d pratel\n&quot;, martina.vek, martina.pocet_pratel);

    return 0;
}
</code></pre>
<p>Pokud mÃ¡me k dispozici pouze ukazatel na strukturu, tak je pÅ™Ã­stup k jejÃ­m ÄlenÅ¯m trochu nepraktickÃ½
kvÅ¯li <a href="https://en.cppreference.com/w/c/language/operator_precedence">prioritÄ› operÃ¡torÅ¯</a>. OperÃ¡tor
dereference (<code>*</code>) mÃ¡ totiÅ¾ menÅ¡Ã­ prioritu neÅ¾ operÃ¡tor pÅ™Ã­stupu ke Älenu (<code>.</code>). Abychom tak nejprve
z ukazatele na strukturu naÄetli jejÃ­ hodnotu a aÅ¾ potÃ© pÅ™istoupili k jejÃ­mu Älenu, museli bychom
pouÅ¾Ã­t zÃ¡vorky:</p>
<pre><code class="language-c">void pridej_pratele(struct Osoba* osoba) {
    (*osoba).pocet_pratel++;
}
</code></pre>
<p>JelikoÅ¾ ukazatele na struktury jsou vyuÅ¾Ã­vÃ¡ny velmi Äasto, <em>C</em> nabÃ­zÃ­ pro tuto situaci zkratku v
podobÄ› operÃ¡toru <strong>pÅ™Ã­stupu k Älenu pÅ™es ukazatel</strong> (<em>member access through pointer</em>), kterÃ½ mÃ¡
syntaxi <code>&lt;ukazatel na strukturu&gt;-&gt;&lt;nÃ¡zev Älenu&gt;</code>:</p>
<pre><code class="language-c">void pridej_pratele(struct Osoba* osoba) {
   osoba-&gt;pocet_pratel++;
}
</code></pre>
<p>OperÃ¡tor <code>-&gt;</code> je ÄistÄ› syntaktickou zkratkou, tj. platÃ­ <code>*(ukazatel).clen == ukazatel-&gt;clen</code>.</p>
<h2><a class="header" href="#vytvÃ¡Å™enÃ­-novÃ½ch-jmen-pro-datovÃ©-typy" id="vytvÃ¡Å™enÃ­-novÃ½ch-jmen-pro-datovÃ©-typy">VytvÃ¡Å™enÃ­ novÃ½ch jmen pro datovÃ© typy</a></h2>
<p>MoÅ¾nÃ¡ vÃ¡s napadlo, Å¾e psÃ¡t pÅ™i kaÅ¾dÃ©m pouÅ¾itÃ­ struktury klÃ­ÄovÃ© slovo <code>struct</code> pÅ™ed jejÃ­m nÃ¡zvem je
zdlouhavÃ©. <em>C</em> umoÅ¾Åˆuje dÃ¡vat datovÃ½m typÅ¯m novÃ© nÃ¡zvy, aby se nÃ¡m s nimi lÃ©pe pracovalo. Lze toho
dosÃ¡hnout pomocÃ­ syntaxe <code>typedef &lt;datovÃ½ typ&gt; &lt;jmÃ©no&gt;;</code>:</p>
<pre><code class="language-c">typedef int teplota;

int main() {
    teplota venkovni = 24;
    return 0;
}
</code></pre>
<p>PomocÃ­ <code>typedef</code> vytvoÅ™Ã­me novÃ© jmÃ©no pro datovÃ½ typ, pomocÃ­ kterÃ©ho se pak na tento typ mÅ¯Å¾eme
odkazovat (pÅ¯vodnÃ­ nÃ¡zev datovÃ©ho typu to vÅ¡ak nijak neovlivnÃ­ a mÅ¯Å¾eme ho stÃ¡le pouÅ¾Ã­vat). OpÄ›t
platÃ­, Å¾e takto vytvoÅ™enÃ© jmÃ©no lze pouÅ¾Ã­t pouze v oblasti (<em>scopu</em>), kde byl <code>typedef</code> pouÅ¾it.
Obvykle se pouÅ¾Ã­vÃ¡ na nejvyÅ¡Å¡Ã­ Ãºrovni souboru. </p>
<p>U struktur si pomocÃ­ <code>typedef</code> mÅ¯Å¾eme zkrÃ¡tit jejich nÃ¡zev, typicky ze <code>struct &lt;nazev&gt;</code> na <code>&lt;nazev&gt;</code>:</p>
<pre><code class="language-c">struct Osoba {
    int vek;
};

typedef struct Osoba Osoba;

int main() {
    Osoba jiri;
    return 0;
}
</code></pre>
<p>Toto lze jeÅ¡tÄ› vÃ­ce zkrÃ¡tit, pokud deklaraci struktury pouÅ¾ijeme pÅ™Ã­mo na mÃ­stÄ› datovÃ©ho typu v
<code>typedef</code>:</p>
<pre><code class="language-c">typedef struct Osoba {
    int vek;
} Osoba;
</code></pre>
<p>A koneÄnÄ›, abychom nemuseli jmÃ©no struktury opakovat dvakrÃ¡t, mÅ¯Å¾eme vytvoÅ™it tzv. <strong>anonymnÃ­
strukturu</strong> (<em>anonymous structure</em>) bez nÃ¡zvu, a jmÃ©no jÃ­ pÅ™iÅ™adit aÅ¾ pomocÃ­ <code>typedef</code>.</p>
<pre><code class="language-c">typedef struct {
    int vek;
} Osoba;
</code></pre>
<p>PrÃ¡vÄ› takto se obvykle deklarujÃ­ struktury v <em>C</em>.</p>
<h2><a class="header" href="#pouÅ¾itÃ­-struktur-ve-strukturÃ¡ch" id="pouÅ¾itÃ­-struktur-ve-strukturÃ¡ch">PouÅ¾itÃ­ struktur ve strukturÃ¡ch</a></h2>
<p>JelikoÅ¾ deklarace struktury vytvoÅ™Ã­ novÃ½ datovÃ½ typ, nic vÃ¡m nebrÃ¡nÃ­ v tom pouÅ¾Ã­vat struktury jako
Äleny jinÃ½ch struktur<sup class='margin-toggle sidenote-number'>3</sup>:</p>
<span class='sidenote'><p><sup class='number'>3</sup>Lze si mÅ¯Å¾ete vÅ¡imnout, Å¾e vnoÅ™enÃ© struktury lze inicializovat stejnÄ› jako promÄ›nnÃ© struktur,
tj. pomocÃ­ sloÅ¾enÃ½ch zÃ¡vorek <code>{}</code>.</p>
</span>
<pre><code class="language-c">typedef struct {
    float x;
    float y;
} Poloha;

typedef struct {
    const char* jmeno;
    int cena;
} Vec;

typedef struct {
    int pocet_zivotu;
    Poloha poloha;
    Vec korist[10];
} Prisera;

int main() {
    Prisera prisera = { .pocet_zivotu = 100, .poloha = { .x = 0, .y = 0 } };

    return 0;
}
</code></pre>
<p>DÃ­ky tomu mÅ¯Å¾eme vytvÃ¡Å™et celÃ© hierarchie datovÃ½ch typÅ¯, coÅ¾ mÅ¯Å¾e znaÄnÄ› zpÅ™ehlednit nÃ¡Å¡ program,
protoÅ¾e mÅ¯Å¾eme pracovat s kÃ³dem na vyÅ¡Å¡Ã­ Ãºrovni abstrakce.</p>
<h3><a class="header" href="#rekurzivnÃ­-struktury" id="rekurzivnÃ­-struktury">RekurzivnÃ­ struktury</a></h3>
<p>Pokud bychom chtÄ›li pouÅ¾Ã­t jako Älena struktury tu stejnou strukturu (napÅ™Ã­klad struktura
<code>Osoba</code> mÅ¯Å¾e mÃ­t Älen <code>matka</code> opÄ›t s datovÃ½m typem <code>Osoba</code>), nemÅ¯Å¾eme takovÃ½to Älen uloÅ¾it ve
struktuÅ™e pÅ™Ã­mo, mÅ¯Å¾eme tam uloÅ¾it pouze jeho adresu<sup class='margin-toggle sidenote-number'>4</sup>:</p>
<span class='sidenote'><p><sup class='number'>4</sup>Zde si mÅ¯Å¾ete vÅ¡imnout, Å¾e musÃ­me pouÅ¾Ã­t <code>struct Osoba</code> pro datovÃ½ typ Älenu <code>matka</code>. Je to z
toho dÅ¯vodu, Å¾e v momentÄ›, kdy tento Älen definujeme, tak jeÅ¡tÄ› nenÃ­ platnÃ½ <code>typedef</code>, ve kterÃ©m se
struktura nachÃ¡zÃ­, takÅ¾e datovÃ½ typ <code>Osoba</code> zatÃ­m neexistuje. NovÃ© jmÃ©no pro datovÃ½ typ lze pouÅ¾Ã­vat
aÅ¾ za stÅ™ednÃ­kem danÃ©ho <code>typedef</code>u. V tomto pÅ™Ã­padÄ› takÃ© nemÅ¯Å¾eme vytvoÅ™it strukturu jako anonymnÃ­,
ale musÃ­me ji rovnou pojmenovat (<code>typedef struct Osoba ...</code>).</p>
</span>
<pre><code class="language-c">typedef struct Osoba {
    int vek;
    struct Osoba* matka;
} Osoba;
</code></pre>
<p>Je to proto, Å¾e pokud by <code>Osoba</code> byla definovÃ¡na pomocÃ­ <code>Osoby</code>, tak by doÅ¡lo k rekurzivnÃ­ definici,
kterou nelze vyÅ™eÅ¡it. NeÅ¡lo by totiÅ¾ urÄit velikost <code>Osoby</code> - jejÃ­ velikost by zÃ¡visela na velikosti
jejÃ­ho Älenu <code>matka</code>, jehoÅ¾ velikost by zÃ¡visela na velikosti jeho Älenu <code>matka</code> atd. Proto tedy musÃ­me
v tomto pÅ™Ã­padÄ› pouÅ¾Ã­t ukazatel, kterÃ½ mÃ¡ fixnÃ­ velikost, aÅ¥ uÅ¾ ukazuje na jakÃ½koliv typ.</p>
<h1><a class="header" href="#pamÄ›Å¥ovÃ¡-reprezentace-struktur" id="pamÄ›Å¥ovÃ¡-reprezentace-struktur">PamÄ›Å¥ovÃ¡ reprezentace struktur</a></h1>
<blockquote>
<p>ğŸ¤“ Tato sekce obsahuje doplÅˆujÃ­cÃ­ uÄivo. Pokud je toho na vÃ¡s moc, mÅ¯Å¾ete ji prozatÃ­m pÅ™eskoÄit
a vrÃ¡tit se k nÃ­ pozdÄ›ji.</p>
</blockquote>
<p>V tÃ©to kapitole si popÃ­Å¡eme, jak se pÅ™ekladaÄ rozhoduje o tom, kolik bytÅ¯ budou v pamÄ›ti zabÃ­rat
promÄ›nnÃ© struktur, kterÃ© vytvÃ¡Å™Ã­me v naÅ¡ich programech.</p>
<p>KdyÅ¾ vytvoÅ™Ã­me promÄ›nnou struktury v pamÄ›ti, tak bychom si intuitivnÄ› mohli myslet, Å¾e pÅ™ekladaÄ
jednotlivÃ© Äleny struktury &quot;vysÃ¡zÃ­&quot; v pamÄ›ti jeden za druhÃ½m. NicmÃ©nÄ› nenÃ­ tomu tak vÅ¾dy. Z dÅ¯vodu
dodrÅ¾enÃ­ tzv. <strong>zarovnÃ¡nÃ­</strong> (<em>alignment</em>) jednotlivÃ½ch datovÃ½ch typÅ¯ ÄlenÅ¯ struktury se totiÅ¾
pÅ™ekladaÄ mÅ¯Å¾e rozhodnout mezi tyto Äleny vloÅ¾it nÄ›jakÃ© byty navÃ­c.</p>
<h2><a class="header" href="#zarovnÃ¡nÃ­" id="zarovnÃ¡nÃ­">ZarovnÃ¡nÃ­</a></h2>
<p>KaÅ¾dÃ½ datovÃ½ typ v jazyce <em>C</em> mÃ¡ kromÄ› svÃ© velikosti (poÄet bytÅ¯, kterÃ© zabÃ­rÃ¡ v pamÄ›ti) takÃ© tzv.
<strong>zarovnÃ¡nÃ­</strong>. JednÃ¡ se o ÄÃ­slo, kterÃ© Å™Ã­kÃ¡, na jakÃ½ch adresÃ¡ch v pamÄ›ti by ideÃ¡lnÄ› mÄ›ly bÃ½t umÃ­stÄ›ny
hodnoty tohoto datovÃ©ho typu. ZarovnÃ¡nÃ­ <code>n</code> Å™Ã­kÃ¡, Å¾e danÃ½ datovÃ½ typ mÅ¯Å¾e leÅ¾et na adresÃ¡ch, kterÃ©
jsou dÄ›litelnÃ© ÄÃ­slem <code>n</code>. TakÅ¾e napÅ™. datovÃ½ typ se zarovnÃ¡nÃ­m <code>4</code> mÅ¯Å¾e leÅ¾et na adresÃ¡ch <code>4</code>, <code>8</code>,
<code>12</code>, <code>200</code> nebo <code>512</code>, nemÄ›l by vÅ¡ak leÅ¾et napÅ™. na adresÃ¡ch <code>1</code>, <code>3</code> nebo <code>134</code>, protoÅ¾e ty nejsou
dÄ›litelnÃ© ÄtyÅ™kou. Mohli bychom Å™Ã­ct, Å¾e pro zarovnÃ¡nÃ­ <code>4</code> jsou adresy <code>4</code> nebo <code>8</code> <strong>zarovnanÃ©</strong>
(<em>aligned</em>), zatÃ­mco adresy <code>3</code> nebo <code>134</code> jsou <strong>nezarovnanÃ©</strong> (<em>unaligned</em>).</p>
<p>ZarovnÃ¡nÃ­ existuje z toho dÅ¯vodu, Å¾e nÄ›kterÃ© typy procesorÅ¯ jsou navrÅ¾eny tak, Å¾e jednoduÅ¡e
nezvlÃ¡dnou naÄÃ­tat hodnoty z adres, kterÃ© nesplÅˆujÃ­ zarovnÃ¡nÃ­ danÃ©ho datovÃ©ho typu. NÄ›kterÃ© jinÃ©
procesory to zase sice zvlÃ¡dnou, ale mnohem mÃ©nÄ› efektivnÄ›ji, neÅ¾ kdybychom naÄÃ­tali hodnoty ze
zarovnanÃ½ch adres.</p>
<p>Pokud to v naÅ¡em programu neupravÃ­me, tak primitivnÃ­ datovÃ© typy majÃ­ zarovnÃ¡nÃ­ stejnÃ©, jako je
jejich velikost, a struktury majÃ­ zarovnÃ¡nÃ­ nastavenÃ© na nejvyÅ¡Å¡Ã­ zarovnÃ¡nÃ­ ze vÅ¡ech datovÃ½ch ÄlenÅ¯
typÅ¯ danÃ© struktury.</p>
<p>Zde jsou ukÃ¡zky zarovnÃ¡nÃ­ pro nÄ›kolik zÃ¡kladnÃ­ch datovÃ½ch typÅ¯:</p>
<ul>
<li><code>char</code>: zarovnÃ¡nÃ­ <code>1</code></li>
<li><code>int</code>: zarovnÃ¡nÃ­ je stejnÃ© velikost (tedy typicky <code>4</code>)</li>
<li><code>float</code>: zarovnÃ¡nÃ­ <code>4</code></li>
<li><code>char*</code>: zarovnÃ¡nÃ­ je stejnÃ© velikost (tedy typicky <code>8</code>)</li>
</ul>
<h2><a class="header" href="#struktury-a-zarovnÃ¡nÃ­" id="struktury-a-zarovnÃ¡nÃ­">Struktury a zarovnÃ¡nÃ­</a></h2>
<p>ZarovnÃ¡nÃ­ jednotlivÃ½ch datovÃ½ch typÅ¯ ovlivÅˆuje to, jak pÅ™ekladaÄ rozmÃ­stÃ­ jednotlivÃ© Äleny struktur
v pamÄ›ti. Bude se totiÅ¾ snaÅ¾it o to, aby kaÅ¾dÃ½ Älen struktury leÅ¾el na adrese, kterÃ¡ bude zarovnanÃ¡
vzhledem k datovÃ©mu typu danÃ©ho Älenu. VezmÄ›me si napÅ™Ã­klad nÃ¡sledujÃ­cÃ­ strukturu:</p>
<blockquote>
<p>PoznÃ¡mka: ve vÅ¡ech pÅ™Ã­padech nÃ­Å¾e budeme pÅ™edpoklÃ¡dat, Å¾e <code>short</code> zabÃ­rÃ¡ <code>2</code> byty,
<code>int</code> zabÃ­rÃ¡ <code>4</code> byty, a ukazatel zabÃ­rÃ¡ <code>8</code> bytÅ¯.</p>
</blockquote>
<pre><code class="language-c">typedef struct {
    char a;
    int b;
} Str1;
</code></pre>
<p>JelikoÅ¾ <code>char</code> zabÃ­rÃ¡ <code>1</code> byte a <code>int</code> zabÃ­rÃ¡ <code>4</code> byty, mohli bychom si myslet, Å¾e <code>sizeof(Str1)</code>
bude <code>5</code>. NicmÃ©nÄ› pÅ™ekladaÄ musÃ­ zajistit, Å¾e Älen <code>b</code> bude leÅ¾et na adrese, kterÃ¡ bude zarovnanÃ¡
na <code>4</code> byty, protoÅ¾e zarovnÃ¡nÃ­ datovÃ©ho typu <code>int</code> je <code>4</code>. Dejme tomu, Å¾e by promÄ›nnÃ¡ typu <code>Str1</code>
leÅ¾ela tÅ™eba na adrese <code>16</code>, tj. i Älen <code>a</code> by leÅ¾el na adrese <code>16</code>. Pokud by pÅ™ekladaÄ umÃ­stil Älen
<code>b</code> na adresu <code>17</code>, tak by tento Älen leÅ¾el na nezarovnanÃ© adrese<sup class='margin-toggle sidenote-number'>1</sup>:</p>
<span class='sidenote'><p><sup class='number'>1</sup>KaÅ¾dÃ¡ ÄtvercovÃ¡ buÅˆka reprezentuje jeden byte. V pravÃ©m hornÃ­m rohu buÅˆky je znÃ¡zornÄ›na adresa buÅˆky. Å edÃ© buÅˆky oznaÄujÃ­ byty <em>paddingu</em>. ÄŒerchovanÃ© buÅˆky obsahujÃ­ nezarovnanÃ¡ data.</p>
</span>
<p><img src="c/struktury/../../static/img/padding/padding1-packed.png" alt="str1-packed" /></p>
<p>Z tohoto dÅ¯vodu pÅ™ekladaÄ vloÅ¾Ã­ za <code>a</code> tÅ™i byty tzv. <strong>vÃ½plnÄ›</strong> (<em>padding</em>). Tyto byty nebudou k
niÄemu vyuÅ¾Ã­vÃ¡ny, budou slouÅ¾it pouze k tomu, aby byl Älen <code>b</code> sprÃ¡vnÄ› zarovnanÃ½. Struktura tedy bude
v pamÄ›ti uloÅ¾ena takto, jejÃ­ velikost bude <code>8</code> bytÅ¯ a jejÃ­ zarovnÃ¡nÃ­ budou <code>4</code> byty:</p>
<p><img src="c/struktury/../../static/img/padding/padding1-unpacked.png" alt="str1-unpacked" /></p>
<p>PÅ™ekladaÄ ovÅ¡em nevklÃ¡dÃ¡ vÃ½plÅˆ pouze mezi jednotlivÃ© Äleny struktur. NÄ›kdy musÃ­ vloÅ¾it vÃ½plÅˆ i na
samotnÃ½ konec struktury. PodÃ­vejme se na nÃ¡sledujÃ­cÃ­ strukturu <code>Str2</code>:</p>
<pre><code class="language-c">typedef struct {
    int b;
    char a;
} Str2;
</code></pre>
<p>Mohlo by se zdÃ¡t, Å¾e zde bÃ½t vÃ½plÅˆ bÃ½t nemusÃ­, protoÅ¾e <code>int</code> mÅ¯Å¾e leÅ¾et &quot;na zaÄÃ¡tku&quot; struktury,
a <code>char</code> mÃ¡ zarovnÃ¡nÃ­ <code>1</code>, takÅ¾e mÅ¯Å¾e leÅ¾et kdekoliv. Co by se ovÅ¡em stalo, kdybychom tyto struktury
uloÅ¾ili za sebe do pamÄ›ti v poli?</p>
<p><img src="c/struktury/../../static/img/padding/padding2-packed.png" alt="str2-packed" /></p>
<p>PrvnÃ­ struktura v poli by byla zarovnanÃ¡ sprÃ¡vnÄ›, ale druhÃ¡ (pÅ™Ã­padnÄ› ty dalÅ¡Ã­) uÅ¾ ne! Z toho dÅ¯vodu
musÃ­ pÅ™ekladaÄ zajistit, Å¾e budou sprÃ¡vnÄ› zarovnanÃ­ nejenom vÅ¡ichni ÄlenovÃ© struktury, ale i struktura
samotnÃ¡. ZarovnÃ¡nÃ­ struktury se rovnÃ¡ nejvyÅ¡Å¡Ã­mu zarovnÃ¡nÃ­ ze vÅ¡ech ÄlenÅ¯ struktury, v tomto pÅ™Ã­padÄ›
to bude <code>4</code>. PÅ™ekladaÄ tak musÃ­ zajistit, aby vÅ¡echny struktury <code>Str2</code> (i kdyÅ¾ budou leÅ¾et v poli za
sebou) leÅ¾ely na adresÃ¡ch, kterÃ© budou nÃ¡sobky <code>4</code>. Z tohoto dÅ¯vodu zde pÅ™ekladaÄ vloÅ¾Ã­ <code>3</code> byty vÃ½plnÄ›
i na konec struktury, aby byly promÄ›nnÃ© tÃ©to struktury sprÃ¡vnÄ› zarovnanÃ©:</p>
<p><img src="c/struktury/../../static/img/padding/padding2-unpacked.png" alt="str2-unpacked" /></p>
<h2><a class="header" href="#minimalizace-velikosti-struktury" id="minimalizace-velikosti-struktury">Minimalizace velikosti struktury</a></h2>
<p>ObecnÄ› bychom se mÄ›li snaÅ¾it velikosti struktur minimalizovat, abychom v naÅ¡ich programech neplÃ½tvali
pamÄ›tÃ­. ExistujÃ­ rÅ¯znÃ© <a href="https://stackoverflow.com/a/8568441/1107768">atributy</a>, kterÃ½mi mÅ¯Å¾eme napÅ™.
pÅ™ekladaÄi Å™Ã­ct, aby zarovnÃ¡nÃ­ ignoroval, to ovÅ¡em nemusÃ­ bÃ½t dobrÃ½ nÃ¡pad, protoÅ¾e potÃ© nÃ¡Å¡ program
na urÄitÃ½ch procesorech nemusÃ­ vÅ¯bec fungovat.</p>
<p>UniverzÃ¡lnÄ›jÅ¡Ã­m a bezpeÄnÄ›jÅ¡Ã­m Å™eÅ¡enÃ­m je seÅ™adit Äleny struktury tak, abychom minimalizovali
vÃ½plÅˆ. ObecnÃ¡ pouÄka znÃ­ Å™adit Äleny podle jejich velikosti, od nejvÄ›tÅ¡Ã­ho po nejmenÅ¡Ã­. Porovnejte
napÅ™Ã­klad nÃ¡sledujÃ­cÃ­ dvÄ› struktury:</p>
<ul>
<li>
<p>NeseÅ™azenÃ© Äleny, velikost <code>24</code> bytÅ¯, <code>10</code> bytÅ¯ vÃ½plnÄ›:</p>
<pre><code class="language-c">typedef struct {
    char a;
    int b;
    char c;
    const char* d;
} Str3;
</code></pre>
<p><img src="c/struktury/../../static/img/padding/padding3.png" alt="str3" /></p>
</li>
<li>
<p>SeÅ™azenÃ© Äleny, velikost <code>16</code> bytÅ¯, <code>2</code> byty vÃ½plnÄ›:</p>
<pre><code class="language-c">typedef struct {
    const char* a;
    int b;
    char c;
    char d;
} Str4;
</code></pre>
<p><img src="c/struktury/../../static/img/padding/padding4.png" alt="str4" /></p>
</li>
</ul>
<h2><a class="header" href="#kvÃ­z-" id="kvÃ­z-">KvÃ­z ğŸ¤”</a></h2>
<p>Zde je nÄ›kolik ukÃ¡zek struktur, na kterÃ½ch si mÅ¯Å¾ete otestovat svÃ© znalosti zarovnÃ¡nÃ­ a vÃ½plnÄ›.</p>
<ul>
<li>
<p><code>S1</code></p>
<pre><code class="language-c">typedef struct {
    int a;
    const char* b;
} S1;
</code></pre>
<details>
  <summary>Velikost a zarovnÃ¡nÃ­</summary>
<p>Velikost <code>16</code> bytÅ¯, zarovnÃ¡nÃ­ <code>8</code> bytÅ¯, vÃ½plÅˆ <code>4</code> byty.</p>
<p><img src="c/struktury/../../static/img/padding/padding5.png" alt="str5" /></p>
</details>
</li>
<li>
<p><code>S2</code></p>
<pre><code class="language-c">typedef struct {
    char a[4];
    char b;
} S2;
</code></pre>
<details>
  <summary>Velikost a zarovnÃ¡nÃ­</summary>
<p>Velikost <code>5</code> bytÅ¯, zarovnÃ¡nÃ­ <code>1</code> byte, vÃ½plÅˆ <code>0</code> bytÅ¯. ÄŒlen <code>a</code> mÃ¡ sice takÃ© <code>4</code> byty, jako <code>int</code>,
nicmÃ©nÄ› jelikoÅ¾ je zarovnÃ¡nÃ­ datovÃ©ho typu <code>char</code> pouze <code>1</code>, tak i zarovnÃ¡nÃ­ tohoto pole je <code>1</code>.
A jelikoÅ¾ Älen <code>b</code> mÅ¯Å¾e taktÃ©Å¾ leÅ¾et na libovolnÃ© adrese, tak zde nenÃ­ pÅ™idÃ¡na Å¾Ã¡dnÃ¡ vÃ½plÅˆ. </p>
<p><img src="c/struktury/../../static/img/padding/padding6.png" alt="str6" /></p>
</details>
</li>
<li>
<p><code>S3</code></p>
<pre><code class="language-c">typedef struct {
    short a;
    char b;
    char c;
    int d;
} S3;
</code></pre>
<details>
  <summary>Velikost a zarovnÃ¡nÃ­</summary>
<p>Velikost <code>8</code> bytÅ¯, zarovnÃ¡nÃ­ <code>4</code> byty, vÃ½plÅˆ <code>0</code> bytÅ¯.</p>
<p><img src="c/struktury/../../static/img/padding/padding7.png" alt="str7" /></p>
</details>
</li>
</ul>
<h1><a class="header" href="#struktury-a-funkce" id="struktury-a-funkce">Struktury a funkce</a></h1>
<p>PomocÃ­ struktur si mÅ¯Å¾eme vytvoÅ™it novÃ½ datovÃ½ typ, coÅ¾ pomÃ¡hÃ¡ pÅ™ehlednosti programÅ¯, protoÅ¾e se
dÃ­ky tomu mÅ¯Å¾eme v programech vyjadÅ™ovat pomocÃ­ pojmÅ¯ z oblasti (tzv. domÃ©ny), kterou se nÃ¡Å¡ program
zabÃ½vÃ¡ (<code>Student</code>, <code>PÅ™Ã­Å¡era</code>, <code>Munice</code>, <code>Letadlo</code>, <code>Volant</code> atd.) a ne pouze pomocÃ­ pojmÅ¯, kterÃ½m
rozumÃ­ poÄÃ­taÄ (ÄÃ­slo, znak, pravdivostnÃ­ hodnota).</p>
<p>Abychom pracovali s jeÅ¡tÄ› vyÅ¡Å¡Ã­ ÃºrovnÃ­ abstrakce, bylo by uÅ¾iteÄnÃ©, pokud bychom mohli k
vlastnÃ­m datovÃ½m typÅ¯m nadefinovat takÃ© vlastnÃ­ operace, kterÃ© by s nimi umÄ›ly pracovat. NÄ›kterÃ©
programovacÃ­ jazyky umoÅ¾ÅˆujÃ­ provÃ¡dÄ›t tzv.
<a href="https://en.wikipedia.org/wiki/Operator_overloading">pÅ™etÄ›Å¾ovÃ¡nÃ­ operÃ¡torÅ¯</a> (<em>operator overloading</em>),
pomocÃ­ kterÃ©ho mÅ¯Å¾eme napÅ™Ã­klad umoÅ¾nit pouÅ¾Ã­vÃ¡nÃ­ operÃ¡torÅ¯ jako je <code>+</code> s vlastnÃ­mi datovÃ½mi typy.
<em>C</em> toto sice neumoÅ¾Åˆuje, nicmÃ©nÄ› chovÃ¡nÃ­ mÅ¯Å¾eme k nÃ¡mi vytvoÅ™enÃ½m strukturÃ¡m pÅ™idat pomocÃ­ funkcÃ­.</p>
<p>ÄŒasto tak k naÅ¡Ã­ struktuÅ™e chceme vytvoÅ™it sadu funkcÃ­, kterÃ© s nÃ­ budou pracovat. V <em>C</em> pro tento
koncept neexistuje Å¾Ã¡dnÃ¡ syntaktickÃ¡ podpora. Obvykle se tak prostÄ› takovÃ©to funkce pojmenujÃ­ tak,
aby zaÄÃ­naly nÃ¡zvem struktury, ke kterÃ© jsou pÅ™idruÅ¾enÃ©, a pÅ™ebÃ­rajÃ­ ukazatel na tuto strukturu jako
svÅ¯j prvnÃ­ parametr<sup class='margin-toggle sidenote-number'>1</sup>:</p>
<span class='sidenote'><p><sup class='number'>1</sup>Ukazatel se pouÅ¾Ã­vÃ¡, abychom nemuseli struktury pÅ™i pÅ™edÃ¡vÃ¡nÃ­ do funkcÃ­ kopÃ­rovat (mohou bÃ½t
relativnÄ› velkÃ©) a abychom je mohli pÅ™Ã­padnÄ› zevnitÅ™ funkcÃ­ modifikovat.</p>
</span>
<pre><code class="language-c editable">#include &lt;stdbool.h&gt;
#include &lt;stdio.h&gt;

typedef struct {
    float x;
    float y;
} Poloha;

typedef struct {
    const char* jmeno;
    int skore;
    Poloha poloha;
} Hrac;

void hrac_posun(Hrac* hrac, int x, int y) {
    hrac-&gt;poloha.x += x;
    hrac-&gt;poloha.y += y;
}
void hrac_pridej_skore(Hrac* hrac, int skore) {
    hrac-&gt;skore += skore;
    if (hrac-&gt;skore &gt; 100) {
        hrac-&gt;skore = 100;
    }
}
bool hrac_vyhral(Hrac* hrac) {
    return hrac-&gt;skore == 100;
}

int main() {
    Hrac hrac = { .jmeno = &quot;Jindrich&quot;, .skore = 40, .poloha = { .x = 10, .y = 20 } };
    hrac_posun(&amp;hrac, 5, -8);
    hrac_pridej_skore(&amp;hrac, 70);

    printf(&quot;Hrac vyhral: %d\n&quot;, hrac_vyhral(&amp;hrac));

    return 0;
}
</code></pre>
<p>Pokud vytvoÅ™Ã­me vhodnÃ© datovÃ© typy (struktury) a budeme s nimi pracovat pomocÃ­ funkcÃ­, tak by se naÅ¡e
programy mÄ›ly pÅ™ibliÅ¾ovat k tomu, aby je Å¡lo ÄÃ­st jako plynulÃ½ a pÅ™ehlednÃ½ text. </p>
<blockquote>
<p>VytvÃ¡Å™enÃ­ vlastnÃ­ch datovÃ½ch typÅ¯, kterÃ© majÃ­ pÅ™idruÅ¾enÃ© chovÃ¡nÃ­, je jednÃ­m z rysÅ¯ tzv.
<a href="https://edison.sso.vsb.cz/cz.vsb.edison.edu.study.prepare.web/SubjectVersion.faces?version=460-2055/01&amp;subjectBlockAssignmentId=375759&amp;studyFormId=2&amp;studyPlanId=22001&amp;locale=cs&amp;back=true">ObjektovÄ› orientovanÃ©ho programovÃ¡nÃ­</a>.</p>
</blockquote>
<h2><a class="header" href="#struktury-jako-nÃ¡vratovÃ½-typ-funkce" id="struktury-jako-nÃ¡vratovÃ½-typ-funkce">Struktury jako nÃ¡vratovÃ½ typ funkce</a></h2>
<p>JelikoÅ¾ struktury mohou obsahovat vÃ­ce datovÃ½ch typÅ¯, mÅ¯Å¾ete pomocÃ­ nich takÃ© obejÃ­t fakt, Å¾e
funkce mohou vracet pouze jednu hodnotu:</p>
<pre><code class="language-c">typedef struct {
    float x;
    float y;
} Poloha;

Poloha vrat_pocatecni_polohu() { ... }
</code></pre>
<hr />
<p><strong>CviÄenÃ­</strong> ğŸ‹</p>
<p>VyzkouÅ¡ejte si prÃ¡ci se strukturami a funkcemi <a href="c/struktury/../../ulohy/struktury.html">zde</a>.</p>
<hr />
<p><strong>KvÃ­z</strong> ğŸ¤”</p>
<ol>
<li>
<p>Co vypÃ­Å¡e nÃ¡sledujÃ­cÃ­ program?</p>
<pre><code class="language-c editable mainbody">#include &lt;stdio.h&gt;

typedef struct {
    int vek;
} Osoba;

void oslav_narozeniny(Osoba osoba) {
    osoba.vek += 1;
}

int main() {
    Osoba milan = { .vek = 17 };
    oslav_narozeniny(milan);
    printf(&quot;Vek Milana: %d\n&quot;, milan.vek);

    return 0;
}
</code></pre>
<details>
 <summary>OdpovÄ›Ä</summary>
<p>Program vypÃ­Å¡e <code>Vek Milana: 17</code>. StejnÄ› jako u ostatnÃ­ch datovÃ½ch typÅ¯, tak i u struktur platÃ­,
Å¾e pÅ™i pÅ™edÃ¡vÃ¡nÃ­ hodnot struktur do funkcÃ­ dojde ke kopii pÅ™edÃ¡vanÃ© hodnoty. KdyÅ¾ tedy zmÄ›nÃ­me
hodnotu Älenu <code>vek</code> uvntÅ™ funkce <code>oslav_narozeniny</code>, nijak se to neprojevÃ­ v promÄ›nnÃ© <code>milan</code>
ve funkci <code>main</code>. Abychom strukturu mohli upravit, museli bychom do funkce pÅ™edat jejÃ­ adresu
a zmÄ›nit typ parametru na <code>Osoba* osoba</code>.</p>
</details>
</li>
<li>
<p>Co vypÃ­Å¡e nÃ¡sledujÃ­cÃ­ program?</p>
<pre><code class="language-c editable mainbody">#include &lt;stdio.h&gt;

typedef struct {
    char* jmeno;
} Osoba;

void uprav_jmeno(Osoba osoba) {
    osoba.jmeno[0] = 'k';
}

int main() {
    char jmeno[] = &quot;Karel&quot;;

    Osoba karel = { .jmeno = jmeno };
    uprav_jmeno(karel);
    printf(&quot;Jmeno Karla: %s\n&quot;, karel.jmeno);

    return 0;
}
</code></pre>
<details>
 <summary>OdpovÄ›Ä</summary>
<p>Program vypÃ­Å¡e <code>Jmeno Karla: karel</code>. Do funkce <code>uprav_jmeno</code> se sice pÅ™edÃ¡ struktura pomocÃ­ kopie,
nicmÃ©nÄ› uvnitÅ™ funkce pÅ™istoupÃ­me na adresu uloÅ¾enou v Älenu <code>jmeno</code> a zmÄ›nÃ­me hodnotu v pamÄ›ti
na tÃ©to adrese. JelikoÅ¾ na tÃ©to adrese leÅ¾Ã­ pole <code>jmeno</code> uvnitÅ™ funkce <code>main</code>, a promÄ›nnÃ¡ <code>karel</code>
obsahuje ukazatel na tu stejnou adresu v pamÄ›ti, tak se tato zmÄ›na projevÃ­ pÅ™i vÃ½pisu jmÃ©na promÄ›nnÃ©
<code>karel</code>.</p>
</details>
</li>
</ol>
<h1><a class="header" href="#soubory" id="soubory">Soubory</a></h1>
<p>V sekci o <a href="c/soubory/../text/vstupavystup.html">vstupu a vÃ½stupu</a> jsme si ukÃ¡zali, jak pracovat se souborovÃ½mi
deskriptory <code>stdin</code> a <code>stdout</code> pro zÃ¡kladnÃ­ komunikaci s okolnÃ­m svÄ›tem (obvykle s terminÃ¡lem).
NynÃ­ si ukÃ¡Å¾eme, jak si vytvoÅ™it vlastnÃ­ souborovÃ© deskriptory pomocÃ­ otevÃ­rÃ¡nÃ­ souborÅ¯ na disku.
PouÅ¾ijeme k tomu funkce ze standardnÃ­ knihovny <em>C</em>, kterÃ© se opÄ›t nachÃ¡zÃ­ v souboru <code>&lt;stdio.h&gt;</code>.</p>
<p>StejnÄ› jako u obecnÃ©ho vstupu a vÃ½stupu platÃ­, Å¾e soubor na disku je pouze seznamem ÄÃ­sel (bytÅ¯).
Jejich vÃ½znam je dÃ¡n ÄistÄ› tÃ­m, jak je budeme interpretovat. StejnÃ½ soubor mÅ¯Å¾e bÃ½t napÅ™Ã­klad:</p>
<ul>
<li>TextovÃ½m editorem poklÃ¡dÃ¡n za textovÃ½ dokument</li>
<li>ProhlÃ­Å¾eÄem obrÃ¡zkÅ¯ poklÃ¡dÃ¡n za obrÃ¡zek</li>
<li>HudebnÃ­m pÅ™ehrÃ¡vaÄem poklÃ¡dan za zvukovou nahrÃ¡vku</li>
</ul>
<p>Obvykle souborÅ¯m dÃ¡vÃ¡me pÅ™Ã­pony (<code>.txt</code>, <code>.jpg</code>, <code>.mp3</code> atd.), abychom dali najevo, jak by se
danÃ½ soubor mÄ›l interpretovat. SamotnÃ¡ pÅ™Ã­pona vÅ¡ak sama o sobÄ› nic neznamenÃ¡. ZmÄ›nou pÅ™Ã­pony z
<code>.txt</code> na <code>.jpg</code> sice mÅ¯Å¾eme zmÄ›nit zpÅ¯sob interpretace souboru, samotnÃ¡ data v nÄ›m vÅ¡ak zÅ¯stanou
stÃ¡le stejnÃ¡ â€“ pokud v souboru pÅ™edtÃ­m nebyla data ve formÃ¡tu <a href="https://en.wikipedia.org/wiki/JPEG">JPEG</a>,
zmÄ›na pÅ™Ã­pony tento stav nijak nezmÄ›nÃ­ a soubor se nÃ¡m tak nejspÃ­Å¡e jako obrÃ¡zek nepodaÅ™Ã­ otevÅ™Ã­t.</p>
<p>Nejprve si ukÃ¡Å¾eme, jak mÅ¯Å¾eme <a href="c/soubory/otevirani_souboru.html">otevÃ­rat</a> soubory na disku, a potÃ© jak do
otevÅ™enÃ½ch souborÅ¯ <a href="c/soubory/prace_se_soubory.html">zapisovat nebo z nich ÄÃ­st</a> data.</p>
<h1><a class="header" href="#otevÃ­rÃ¡nÃ­-souborÅ¯" id="otevÃ­rÃ¡nÃ­-souborÅ¯">OtevÃ­rÃ¡nÃ­ souborÅ¯</a></h1>
<p>Abychom mohli s nÄ›jakÃ½m souborem zaÄÃ­t pracovat, musÃ­me ho nejprve v naÅ¡em programu otevÅ™Ã­t, aby
byl vytvoÅ™en souborovÃ½ deskriptor, do kterÃ©ho pak mÅ¯Å¾eme zapisovat Äi z nÄ›j ÄÃ­st data. K tomu slouÅ¾Ã­
funkce <a href="https://devdocs.io/c/io/fopen"><code>fopen</code></a>, kterÃ¡ mÃ¡ nÃ¡sledujÃ­cÃ­
<a href="c/soubory/../funkce/funkce.html#syntaxe">signaturu</a>:</p>
<pre><code class="language-c">FILE* fopen(const char* filename, const char* mode);
</code></pre>
<h2><a class="header" href="#cesta-k-souboru" id="cesta-k-souboru">Cesta k souboru</a></h2>
<p>Jako svÅ¯j prvnÃ­ parametr funkce <code>fopen</code> oÄekÃ¡vÃ¡ Å™etÄ›zec s cestou k souboru, kterÃ½ mÃ¡ bÃ½t otevÅ™en.
Cestu mÅ¯Å¾ete zadat dvÄ›ma zpÅ¯soby:</p>
<ul>
<li><strong>AbsolutnÃ­ cesta</strong> (<em>absolute path</em>) je cesta, kterÃ¡ zaÄÃ­nÃ¡ koÅ™enovÃ½m adresÃ¡Å™em souborovÃ©ho
systÃ©mu, napÅ™Ã­klad <code>/home/student/upr/soubor.txt</code><sup class='margin-toggle sidenote-number'>1</sup>. Aby byla cesta absolutnÃ­, musÃ­ na Linuxu
zaÄÃ­nat dopÅ™ednÃ½m lomÃ­tkem.<span class='sidenote'><p><sup class='number'>1</sup>Na Windows by podobnÃ¡ cesta mohla vypadat napÅ™Ã­klad takto: <code>C:\Users\student\upr\soubor.txt</code>.</p>
</span></li>
<li><strong>RelativnÃ­ cesta</strong> (<em>relative path</em>) se vyhodnotÃ­ relativnÄ› k tzv. <strong>pracovnÃ­mu adresÃ¡Å™i</strong>
(<em>working directory</em>) bÄ›Å¾Ã­cÃ­ho programu. Pokud spustÃ­te vÃ¡Å¡ program z terminÃ¡lu, tak se pracovnÃ­
adresÃ¡Å™ implicitnÄ› nastavÃ­ na adresÃ¡Å™, ze kterÃ©ho jste program spustili. Pokud tedy napÅ™Ã­klad spustÃ­te
vÃ¡Å¡ program z adresÃ¡Å™e <code>/home/student/upr</code> a funkci <code>fopen</code> pÅ™edÃ¡te cestu <code>soubor.txt</code>, tak se funkce
pokusÃ­ otevÅ™Ã­t soubor na cestÄ› <code>/home/student/upr/soubor.txt</code>.</li>
</ul>
<p>PÅ™i zadÃ¡vÃ¡nÃ­ cesty mÅ¯Å¾ete vyuÅ¾Ã­t speciÃ¡lnÃ­ odkazy <code>.</code> a <code>..</code>, kterÃ© jsou uÅ¾iteÄnÃ© zejmÃ©na u relativnÃ­ch
cest:</p>
<ul>
<li>Odkaz <code>.</code> se odkazuje na souÄasnÃ½ adresÃ¡Å™, <code>./soubor.txt</code> je tedy to samÃ© jako <code>soubor.txt</code>.</li>
<li>Odkaz <code>..</code> se odkazuje na rodiÄovskÃ½ adresÃ¡Å™, <code>../data/abc.txt</code> tedy Å™Ã­kÃ¡:
<code>PodÃ­vej se do rodiÄovskÃ©ho adresÃ¡Å™e, tam vyhledej adresÃ¡Å™ data a v nÄ›m soubor abc.txt</code>.</li>
</ul>
<p>NepokouÅ¡ejte se vÅ¡ak zadÃ¡vat cesty k neexistujÃ­cÃ­m adresÃ¡Å™Å¯m. <code>fopen</code> sice umÃ­ vytvoÅ™it novÃ½ soubor
(pokud pouÅ¾ijete odpovÃ­dajÃ­cÃ­ <a href="c/soubory/otevirani_souboru.html#m%C3%B3d-otev%C5%99en%C3%AD">mÃ³d</a>), neexistujÃ­cÃ­ adresÃ¡Å™ za vÃ¡s nicmÃ©nÄ› nevytvoÅ™Ã­.</p>
<blockquote>
<p>Doposud jsme pouÅ¾Ã­vali prvky <em>C</em>, kterÃ© byly vesmÄ›s nezÃ¡vislÃ© na pouÅ¾itÃ©m operaÄnÃ­m systÃ©mu. Jakmile
ale naÅ¡e programy zaÄnou interagovat se <strong>souborovÃ½m systÃ©mem</strong> (<em>file system</em>), budeme muset zaÄÃ­t
respektovat zÃ¡konitosti operaÄnÃ­ho systÃ©mu, na kterÃ©m nÃ¡Å¡ program pobÄ›Å¾Ã­. Proto napÅ™Ã­klad u cesty
k souborÅ¯m vÅ¾dy pouÅ¾Ã­vejte dopÅ™ednÃ¡ lomÃ­tka (<code>/</code>) pro oddÄ›lovÃ¡nÃ­ adresÃ¡Å™Å¯, pokud program budete
spouÅ¡tÄ›t na Linuxu. </p>
</blockquote>
<h2><a class="header" href="#mÃ³d-otevÅ™enÃ­" id="mÃ³d-otevÅ™enÃ­">MÃ³d otevÅ™enÃ­</a></h2>
<p>DruhÃ½m parametrem funkce <code>fopen</code> je Å™etÄ›zec, jehoÅ¾ obsah urÄuje, v jakÃ©m <strong>mÃ³du</strong> (<em>mode</em>) se mÃ¡
soubor otevÅ™Ã­t. KompletnÃ­ seznam vÅ¡ech kombinacÃ­ mÃ³dÅ¯ naleznete v
<a href="https://devdocs.io/c/io/fopen">dokumentaci</a>, zde je seznam bÄ›Å¾nÃ½ch variant:</p>
<table><thead><tr><th align="center">MÃ³d</th><th align="center">MoÅ¾nÃ© operace</th><th align="center">Co se stane, kdyÅ¾ uÅ¾ soubor existuje?</th><th align="center">Co se stane, kdyÅ¾ soubor neexistuje?</th></tr></thead><tbody>
<tr><td align="center"><code>&quot;r&quot;</code></td><td align="center">ÄŒtenÃ­</td><td align="center"></td><td align="center">chyba</td></tr>
<tr><td align="center"><code>&quot;w&quot;</code></td><td align="center">ZÃ¡pis</td><td align="center">obsah souboru je smazÃ¡n</td><td align="center">soubor je vytvoÅ™en</td></tr>
<tr><td align="center"><code>&quot;a&quot;</code></td><td align="center">ZÃ¡pis na konci</td><td align="center"></td><td align="center">soubor je vytvoÅ™en</td></tr>
<tr><td align="center"><code>&quot;r+&quot;</code></td><td align="center">ÄŒtenÃ­, zÃ¡pis</td><td align="center"></td><td align="center">chyba</td></tr>
<tr><td align="center"><code>&quot;w+&quot;</code></td><td align="center">ÄŒtenÃ­, zÃ¡pis</td><td align="center">obsah souboru je smazÃ¡n</td><td align="center">soubor je vytvoÅ™en</td></tr>
<tr><td align="center"><code>&quot;a+&quot;</code></td><td align="center">ÄŒtenÃ­, zÃ¡pis na konci</td><td align="center"></td><td align="center">soubor je vytvoÅ™en</td></tr>
</tbody></table>
<p>PÅ™i otevÃ­rÃ¡nÃ­ souboru si musÃ­te rozmyslet, jestli z nÄ›j chcete ÄÃ­st, zapisovat do nÄ›j nebo provÃ¡dÄ›t
obojÃ­. ZÃ¡roveÅˆ si musÃ­te urÄit, jestli chcete soubor vytvoÅ™it v pÅ™Ã­padÄ›, Å¾e neexistuje, popÅ™Ã­padÄ›
jestli mÃ¡ bÃ½t jeho obsah smazÃ¡n, pokud uÅ¾ existuje. Podle tÄ›chto vlastnostÃ­ si pak zvolte odpovÃ­dajÃ­cÃ­
mÃ³d otevÅ™enÃ­ souboru. NejbÄ›Å¾nÄ›ji pouÅ¾Ã­vanÃ½mi mÃ³dy jsou <code>&quot;r&quot;</code> pro ÄtenÃ­ ze souboru a <code>&quot;w&quot;</code> pro zÃ¡pis
do souboru.</p>
<h3><a class="header" href="#textovÃ½-vs-binÃ¡rnÃ­-reÅ¾im" id="textovÃ½-vs-binÃ¡rnÃ­-reÅ¾im">TextovÃ½ vs binÃ¡rnÃ­ reÅ¾im</a></h3>
<p>Pokud pouÅ¾ijete jeden ze zÃ¡kladnÃ­ch mÃ³dÅ¯, soubor se otevÅ™e v tzv. <strong>textovÃ©m reÅ¾imu</strong>. V tomto reÅ¾imu
dochÃ¡zÃ­ ke konverzi urÄitÃ½ch bytÅ¯ pÅ™i ÄtenÃ­ a zÃ¡pisu ze souboru. Asi nejdÅ¯leÅ¾itÄ›jÅ¡Ã­m znakem, kterÃ½
je takto konvertovÃ¡n, je <code>'\n'</code>, neboli <strong>odÅ™Ã¡dkovÃ¡nÃ­</strong> (<em>newline</em>). RÅ¯znÃ© operaÄnÃ­ systÃ©my totiÅ¾
pÅ™i interpretaci souborÅ¯ pouÅ¾Ã­vajÃ­ rÅ¯znÃ© znaky pro odliÅ¡enÃ­ situace, kdy mÃ¡ dojÃ­t k pÅ™esunu kurzoru
na novÃ½ Å™Ã¡dek:</p>
<ul>
<li><code>LF</code>: Linux a macOS<sup class='margin-toggle sidenote-number'>2</sup> pouÅ¾Ã­vajÃ­ pro konec Å™Ã¡dku pÅ™Ã­mo ASCII znak <code>LF (line feed)</code>, kterÃ½ lze v
<em>C</em> zapsat jako <code>'\n'</code>.<span class='sidenote'><p><sup class='number'>2</sup>V <a href="https://en.wikipedia.org/wiki/Classic_Mac_OS">dÃ¡vnÃ½ch dobÃ¡ch</a> pouÅ¾Ã­val Mac OS pro odÅ™Ã¡dkovÃ¡nÃ­
pouze znak <code>CR</code>.</p>
</span></li>
<li><code>CRLF</code>: Windows pouÅ¾Ã­vÃ¡ pro konec Å™Ã¡dku dvojici ASCII znakÅ¯ <code>CR (carriage return)</code> a <code>LF</code>
(v tomto poÅ™adÃ­). <code>CR</code> lze v <em>C</em> zapsat jako <code>'\r'</code>.</li>
</ul>
<p>Na Windows tak pÅ™i zÃ¡pisu do souborÅ¯ otevÅ™enÃ½ch v textovÃ©m mÃ³du dojde ke konverzi znaku odÅ™Ã¡dkovÃ¡nÃ­
<code>\n</code> na dvojici znakÅ¯ <code>\r\n</code>. StejnÄ› tak pÅ™i naÄÃ­tÃ¡nÃ­ dat ze souboru se dvojice znakÅ¯ <code>\r\n</code> pÅ™evedou
na <code>\n</code>. Na Linuxu textovÃ½ mÃ³d v podstatÄ› nic nedÄ›lÃ¡, protoÅ¾e se zde pro odÅ™Ã¡dkovÃ¡nÃ­ pouÅ¾Ã­vÃ¡ pÅ™Ã­mo
znak <code>\n</code>.</p>
<p>Pokud byste vÅ¡ak chtÄ›li mÃ­t jistotu, Å¾e opravdu k Å¾Ã¡dnÃ© konverzi nedojde, a budete zapisovat data,
kterÃ¡ nemajÃ­ bÃ½t interpretovÃ¡na jako text, mÅ¯Å¾ete na konec mÃ³du pÅ™idat znak <code>b</code>. PotÃ© se soubor
otevÅ™e v tzv. <strong>binÃ¡rnÃ­ reÅ¾imu</strong>, kde k Å¾Ã¡dnÃ© konverzi nedochÃ¡zÃ­. MÃ³d <code>&quot;rb&quot;</code> tak napÅ™Ã­klad Å™Ã­kÃ¡
<code>OtevÅ™i soubor pro ÄtenÃ­ v binÃ¡rnÃ­m reÅ¾imu</code>.</p>
<blockquote>
<p>Pokud byste chtÄ›li explicitnÄ› Å™Ã­ct, Å¾e se mÃ¡ pouÅ¾Ã­t textovÃ½ reÅ¾im, mÅ¯Å¾ete na konec mÃ³du pÅ™idat
znak <code>t</code>. NapÅ™Ã­klad mÃ³d <code>&quot;rt&quot;</code> je ekvivalentnÃ­ s mÃ³dem <code>&quot;r&quot;</code> a oznaÄuje otevÅ™enÃ­ souboru pro
textovÃ© ÄtenÃ­.</p>
</blockquote>
<h3><a class="header" href="#oÅ¡etÅ™enÃ­-chyb-2" id="oÅ¡etÅ™enÃ­-chyb-2">OÅ¡etÅ™enÃ­ chyb</a></h3>
<p>Jakmile Å™eknete funkci <code>fopen</code> jakÃ½ soubor (a v jakÃ©m mÃ³du) mÃ¡ otevÅ™Ã­t, funkce jej otevÅ™e a vrÃ¡tÃ­
vÃ¡m ukazatel na strukturu <code>FILE</code>, pomocÃ­ kterÃ© mÅ¯Å¾ete se souborem dÃ¡le pracovat<sup class='margin-toggle sidenote-number'>3</sup>. StejnÄ› jako
u jakÃ©koliv prÃ¡ce se vstupem a vÃ½stupem i pÅ™i prÃ¡ci se soubory vÅ¡ak mÅ¯Å¾e Äasto dochÃ¡zet k rÅ¯znÃ½m
chybÃ¡m.</p>
<span class='sidenote'><p><sup class='number'>3</sup><code>FILE</code> je tzv. <strong>neprÅ¯hlednÃ¡</strong> (<em>opaque</em>) struktura deklarovanÃ¡ ve standardnÃ­ knihovnÄ› <em>C</em>.
Nebudete pÅ™istupovat k Å¾Ã¡dnÃ½m jejÃ­m ÄlenÅ¯m, pouze budete ukazatel na ni posÃ­lat do rÅ¯znÃ½ch funkcÃ­
pro prÃ¡ci se soubory, abyste urÄili, s jakÃ½m (otevÅ™enÃ½m) souborem chcete pracovat.</p>
</span>
<p>Pokud byste se napÅ™Ã­klad pokouÅ¡eli otevÅ™Ã­t neexistujÃ­cÃ­ soubor v mÃ³du pro ÄtenÃ­ <code>&quot;r&quot;</code>, dojde k chybÄ›.
V takovÃ©m pÅ™Ã­padÄ› vÃ¡m funkce <code>fopen</code> vrÃ¡tÃ­ adresu nula (tzv. <code>NULL</code> ukazatel). Po kaÅ¾dÃ©m pokusu o
otevÅ™enÃ­ souboru byste tak mÄ›li ovÄ›Å™it, zdali se otevÅ™enÃ­ opravdu podaÅ™ilo nebo ne. Pokud pÅ™i otevÅ™enÃ­
doÅ¡lo k chybÄ›, tak se do <a href="c/soubory/../promenne/globalni_promenne.html">globÃ¡lnÃ­ promÄ›nnÃ©</a>
<a href="https://devdocs.io/c/error/errno"><code>errno</code></a> uloÅ¾Ã­ ÄÃ­slo, kterÃ© identifikuje, o jakÃ½ typ chyby Å¡lo<sup class='margin-toggle sidenote-number'>4</sup>.
K promÄ›nnÃ© budete mÃ­t pÅ™Ã­stup, pokud do svÃ©ho programu <a href="c/soubory/../preprocesor/vkladani_souboru.html">vloÅ¾Ã­te</a>
soubor <code>&lt;errno.h&gt;</code>. PomocÃ­ funkce <a href="https://devdocs.io/c/string/byte/strerror"><code>strerror</code></a> ze souboru
<code>&lt;string.h&gt;</code> pak mÅ¯Å¾ete zÃ­skat Å™etÄ›zec, kterÃ½ danou chybu popisuje:</p>
<span class='sidenote'><p><sup class='number'>4</sup>Seznam rÅ¯znÃ½ch chybovÃ½ch hodnot, kterÃ© se mÅ¯Å¾ou v <code>errno</code> objevit na operaÄnÃ­m systÃ©mu Linux,
mÅ¯Å¾ete naleznout napÅ™Ã­klad <a href="https://www.thegeekstuff.com/2010/10/linux-error-codes/#optiontable">zde</a>.</p>
</span>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;errno.h&gt;
#include &lt;string.h&gt;

int main() {
    FILE* soubor = fopen(&quot;soubor.txt&quot;, &quot;r&quot;);
    if (soubor == NULL) {
        printf(&quot;Doslo k chybe pri otevirani souboru: %s\n&quot;, strerror(errno));
        return 1; // doÅ¡lo k chybÄ›, vrÃ¡tÃ­me 1 jako chybovÃ½ stav programu
    }

    return 0;
}
</code></pre>
<h3><a class="header" href="#pouÅ¾itÃ­-assert" id="pouÅ¾itÃ­-assert">PouÅ¾itÃ­ <code>assert</code></a></h3>
<p>Pokud pÃ­Å¡ete malÃ½ program a nechce se vÃ¡m ruÄnÄ› kaÅ¾dou chybu oÅ¡etÅ™ovat, mÅ¯Å¾ete vyuÅ¾Ã­t
<a href="c/soubory/../preprocesor/makra.html">makro</a> <a href="https://devdocs.io/c/error/assert"><code>assert</code></a> ze souboru <code>&lt;assert.h&gt;</code>.
Toto makro oÄekÃ¡vÃ¡ pravdivostnÃ­ hodnotu a kontroluje, zdali platÃ­ (<code>assert</code> znamenÃ¡
<code>ujisti se, Å¾e platÃ­ â€¦</code>). Pokud hodnota neplatÃ­, tj. vyhodnotÃ­ se na <code>0</code> Äi <code>false</code>, tak dojde k
okamÅ¾itÃ©mu ukonÄenÃ­ vaÅ¡eho programu. Nebudete tak sice moct ovlivnit vypsanou chybovou hlÃ¡Å¡ku, ale
oÅ¡etÅ™enÃ­ chyby se znaÄnÄ› zjednoduÅ¡Å¡Ã­:</p>
<pre><code class="language-c">FILE* soubor = fopen(&quot;soubor.txt&quot;, &quot;r&quot;);
assert(soubor); // pokud je `soubor` roven `NULL`, program se zde ukonÄÃ­
</code></pre>
<p>OÅ¡etÅ™enÃ­ chyb je dobrÃ© nepodceÅˆovat. Pokud chybu oÅ¡etÅ™Ã­te okamÅ¾itÄ› po jejÃ­m moÅ¾nÃ©m vzniku (i kdyby
to mÄ›lo bÃ½t okamÅ¾itÃ½m vypnutÃ­m programu), tak bude mnohem jednoduÅ¡Å¡Ã­ zjistit, kde v kÃ³du a proÄ vznikla.
Jinak se mÅ¯Å¾e jednoduÅ¡e stÃ¡t, Å¾e k chybÄ› sice dojde, ale program bude pokraÄovat vesele dÃ¡l. Tato
chyba pak mÅ¯Å¾e v prÅ¯bÄ›hu programu zpÅ¯sobit kaskÃ¡du dalÅ¡Ã­ch chyb, kterÃ© nakonec dÅ™Ã­ve Äi pozdÄ›ji povedou
k &quot;spadnutÃ­&quot; nebo Å¡patnÃ©mu fungovÃ¡nÃ­ programu. V takovÃ© situaci bude mnohem nÃ¡roÄnÄ›jÅ¡Ã­ zjistit, kde
vznikla pÅ¯vodnÃ­ chyba, kterÃ¡ vÅ¡e zpÅ¯sobila, protoÅ¾e program mÅ¯Å¾e spadnout na ÃºplnÄ› jinÃ©m mÃ­stÄ› v kÃ³du. </p>
<h2><a class="header" href="#zavÅ™enÃ­-souboru" id="zavÅ™enÃ­-souboru">ZavÅ™enÃ­ souboru</a></h2>
<p>Jakmile se souborem pÅ™estanete pracovat, je <strong>nutnÃ©</strong> ho zavÅ™Ã­t. K tomu slouÅ¾Ã­ funkce
<a href="https://devdocs.io/c/io/fclose"><code>fclose</code></a>:</p>
<pre><code class="language-c">FILE* soubor = fopen(&quot;soubor.txt&quot;, &quot;w&quot;);
// zÃ¡pis/ÄtenÃ­ ze souboruâ€¦
fclose(soubor);
</code></pre>
<p>Funkce <code>fclose</code> vracÃ­ ÄÃ­selnou hodnotu, kterÃ¡ oznamuje, zdali funkce probÄ›hla v poÅ™Ã¡dku nebo ne.
Pokud funkce vrÃ¡tÃ­ <code>0</code>, tak se soubor ÃºspÄ›Å¡nÄ› uzavÅ™el. I u zavÃ­rÃ¡nÃ­ souborÅ¯ bychom tedy mÄ›li mÃ­t
alespoÅˆ zÃ¡kladnÃ­ oÅ¡etÅ™enÃ­ chyb<sup class='margin-toggle sidenote-number'>5</sup>:</p>
<span class='sidenote'><p><sup class='number'>5</sup>OperÃ¡tor <code>!</code> provede logickou negaci. Pokud jej pouÅ¾ijeme s hodnotou <code>0</code>, vrÃ¡tÃ­ hodnotu <code>1</code>.
Pokud jej pouÅ¾ijeme s jakoukoliv jinou hodnotou, vrÃ¡tÃ­ hodnotu <code>0</code>. Pokud tedy funkce <code>fclose</code> vrÃ¡tÃ­
cokoliv jinÃ©ho neÅ¾ <code>0</code>, <code>assert</code> ukonÄÃ­ program.</p>
</span>
<pre><code class="language-c">assert(!fclose(soubor));
</code></pre>
<p>Pokud bychom soubor nezavÅ™eli, tak se napÅ™Ã­klad mÅ¯Å¾e stÃ¡t, Å¾e kvÅ¯li pouÅ¾itÃ©mu
<a href="c/soubory/../text/vstupavystup.html#standardn%C3%AD-souborov%C3%A9-deskriptory"><em>bufferovÃ¡nÃ­</em></a> by se data, kterÃ¡ jsme do
souboru zapsali, nemusela objevit na souborovÃ©m systÃ©mu.</p>
<h1><a class="header" href="#prÃ¡ce-se-soubory" id="prÃ¡ce-se-soubory">PrÃ¡ce se soubory</a></h1>
<p>Jakmile jsme se pokusili o otevÅ™enÃ­ souboru, ujistili jsme se, Å¾e se to opravdu povedlo a zÃ­skali
jsme ukazatel <code>FILE*</code>, mÅ¯Å¾eme zaÄÃ­t do programu zapisovat nebo z nÄ›j ÄÃ­st data (podle toho, v jakÃ©m
mÃ³du jsme ho otevÅ™eli).</p>
<h2><a class="header" href="#pozice-v-souboru" id="pozice-v-souboru">Pozice v souboru</a></h2>
<p>Struktura <code>FILE</code> mÃ¡ vnitÅ™nÄ› uloÅ¾enou <strong>pozici</strong> v souboru, na kterÃ© probÃ­hajÃ­ veÅ¡kerÃ© operace ÄtenÃ­
a zÃ¡pisu. Pro zjednoduÅ¡enÃ­ prÃ¡ce se soubory se pozice automaticky posouvÃ¡ dopÅ™edu o odpovÃ­dajÃ­cÃ­
poÄet bytÅ¯ po kaÅ¾dÃ©m ÄtenÃ­ Äi zÃ¡pisu. Jakmile tedy pÅ™eÄtete ze souboru <code>n</code> bytÅ¯, tak se pozice posune
o <code>n</code> pozic dopÅ™edu. Pokud byste tedy dvakrÃ¡t po sobÄ› pÅ™eÄetli jeden byte ze souboru obsahujÃ­cÃ­ text
<code>ABC</code>, nejprve zÃ­skÃ¡te znak <code>A</code>, a podruhÃ© uÅ¾ znak <code>B</code>, protoÅ¾e po prvnÃ­m ÄtenÃ­ se pozice posunula
dopÅ™edu o jeden byte.</p>
<blockquote>
<p>TÃ­m, Å¾e je pozice sdÃ­lenÃ¡ pro ÄtenÃ­ a zÃ¡pis, tak se radÄ›ji vyvarujte souÄasnÃ©mu ÄtenÃ­ i zÃ¡pisu
nad stejnÃ½m otevÅ™enÃ½m souborem. V opaÄnÃ©m pÅ™Ã­padÄ› budete muset bÃ½t opatrnÃ­, abyste si omylem
nepÅ™epsali data nebo neÄetli data ze Å¡patnÃ© pozice.</p>
</blockquote>
<p>SouÄasnou pozici v souboru mÅ¯Å¾ete zjistit pomocÃ­ funkce <a href="https://devdocs.io/c/io/ftell"><code>ftell</code></a>.
Pokud byste chtÄ›li pozici ruÄnÄ› zmÄ›nit, mÅ¯Å¾ete pouÅ¾Ã­t funkci <a href="https://devdocs.io/c/io/fseek"><code>fseek</code></a>,
pomocÃ­ kterÃ© se takÃ© napÅ™Ã­klad mÅ¯Å¾ete v souboru pÅ™esunout na zaÄÃ¡tek (napÅ™. abyste ho pÅ™eÄetli
podruhÃ©) nebo na konec (napÅ™. abyste zjistili, kolik soubor celkovÄ› obsahuje bytÅ¯)<sup class='margin-toggle sidenote-number'>1</sup>.</p>
<span class='sidenote'><p><sup class='number'>1</sup>Toho mÅ¯Å¾ete dosÃ¡hnout tak, Å¾e pomocÃ­ <code>fseek(file, 0, SEEK_END)</code> pÅ™esunete pozici na konec
souboru, a dÃ¡le pomocÃ­ <code>ftell(file)</code> zjistÃ­te, na jakÃ© pozici jste. To vÃ¡m Å™ekne, kolik mÃ¡ soubor
celkovÄ› bytÅ¯.</p>
</span>
<blockquote>
<p>PÅ™i pouÅ¾itÃ­ mÃ³du <code>&quot;a&quot;</code> budou veÅ¡kerÃ© zÃ¡pisy probÃ­hat vÅ¾dy na konci souboru. Tento mÃ³d se hodÃ­
napÅ™Ã­klad pÅ™i zÃ¡pisu do tzv. <strong>logovacÃ­ch souborÅ¯</strong>, kterÃ© chronologicky zaznamenÃ¡vajÃ­ udÃ¡losti v
programu (udÃ¡losti tak vÅ¾dy pouze pÅ™ibÃ½vajÃ­). ZÃ¡roveÅˆ se vÅ¡ak po kaÅ¾dÃ©m zÃ¡pisu v tomto mÃ³du
pozice posune na jeho konec. RadÄ›ji tak nepouÅ¾Ã­vejte mÃ³d <code>&quot;a+&quot;</code>, kterÃ½ umoÅ¾Åˆuje zÃ¡pis na konec i
ÄtenÃ­. PrÃ¡ce s pozicÃ­ pÅ™i souÄasnÃ©m zapisovÃ¡nÃ­ i ÄtenÃ­ je v takovÃ©mto mÃ³du totiÅ¾ ponÄ›kud nÃ¡roÄnÃ¡.</p>
</blockquote>
<p>VÅ¡imnÄ›te si, Å¾e pÅ™i prÃ¡ci se <code>stdout</code> a <code>stdin</code> jsme s pozicÃ­ manipulovat nemohli. Je to proto, Å¾e
tyto dva deskriptory jsou z jistÃ©ho pohledu &quot;obecnÄ›jÅ¡Ã­&quot; neÅ¾ soubory. MÅ¯Å¾ou bÃ½t pÅ™esmÄ›rovanÃ© na
terminÃ¡l, do souboru, ale klidnÄ› takÃ© i do jinÃ©ho poÄÃ­taÄe pÅ™es sÃ­Å¥. TÃ­m, Å¾e nevÃ­me, &quot;co jsou zaÄ&quot;,
tak si s nimi nemÅ¯Å¾eme dovolit provÃ¡dÄ›t nÄ›kterÃ© operace, jako je prÃ¡vÄ› manipulace s pozicÃ­. Pokud
napÅ™Ã­klad odeÅ¡leme data pÅ™es sÃ­Å¥, uÅ¾ je nemÅ¯Å¾eme &quot;vrÃ¡tit zpÃ¡tky&quot; zmÄ›nou pozice. U souborÅ¯ vÅ¡ak
vÃ­me, Å¾e opravdu pracujeme se souborem, takÅ¾e pozici pro zÃ¡pis a ÄtenÃ­ mÄ›nit mÅ¯Å¾eme.</p>
<h2><a class="header" href="#zÃ¡pis-a-ÄtenÃ­-souborÅ¯" id="zÃ¡pis-a-ÄtenÃ­-souborÅ¯">ZÃ¡pis a ÄtenÃ­ souborÅ¯</a></h2>
<p>V nÃ¡sledujÃ­cÃ­ch sekcÃ­ch se dozvÃ­te, jak <a href="c/soubory/zapis_do_souboru.html">zapisovat</a> a <a href="c/soubory/cteni_ze_souboru.html">ÄÃ­st</a>
ze souborÅ¯.</p>
<h1><a class="header" href="#zÃ¡pis-do-souboru" id="zÃ¡pis-do-souboru">ZÃ¡pis do souboru</a></h1>
<p>Pokud chceme do otevÅ™enÃ©ho souboru zapsat nÄ›jakÃ© byty, mÅ¯Å¾eme pouÅ¾Ã­t funkci
<a href="https://devdocs.io/c/io/fwrite"><code>fwrite</code></a>:</p>
<pre><code class="language-c">size_t fwrite(
    const void* buffer, // adresa, ze kterÃ© naÄteme data do souboru
    size_t size,        // velikost prvku, kterÃ½ zapisujeme
    size_t count,       // poÄet prvkÅ¯, kterÃ© zapisujeme
    FILE* stream        // soubor, do kterÃ©ho zapisujeme
);
</code></pre>
<p>Funkce <code>fwrite</code> pÅ™edpoklÃ¡dÃ¡, Å¾e budeme do souboru zapisovat vÃ­ce hodnot stejnÃ©ho datovÃ©ho typu.
Parametr <code>size</code> udÃ¡vÃ¡ velikost tohoto datovÃ©ho typu a parametr <code>count</code> poÄet hodnot, kterÃ© chceme
zapsat. Pokud tuto funkci zavolÃ¡me, tak dojde k zÃ¡pisu <code>size * count</code> bytÅ¯ z adresy <code>buffer</code> do
souboru <code>stream</code>. NÃ¡vratovÃ¡ hodnota <code>fwrite</code> znaÄÃ­, kolik prvkÅ¯ bylo do souboru ÃºspÄ›Å¡nÄ› zapsÃ¡no.
Pokud je tato hodnota menÅ¡Ã­ neÅ¾ <code>count</code>, tak doÅ¡lo k nÄ›jakÃ© chybÄ›. NapÅ™Ã­klad zÃ¡pis pÄ›ti celÃ½ch
ÄÃ­sel do souboru by mohl vypadat nÃ¡sledovnÄ›:</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;assert.h&gt;

int main() {
    int pole[5] = { 1, 2, 3, 4, 5 };

    // otevÅ™enÃ­ souboru
    FILE* soubor = fopen(&quot;soubor&quot;, &quot;wb&quot;);
    assert(soubor);

    // binÃ¡rnÃ­ zÃ¡pis do souboru
    int zapsano = fwrite(pole, sizeof(int), 5, soubor);
    assert(zapsano == 5);

    // zavÅ™enÃ­ souboru
    fclose(soubor);    

    return 0;
}
</code></pre>
<blockquote>
<p>PÅ™i takovÃ©mto pouÅ¾itÃ­ <code>fwrite</code> mÅ¯Å¾e dojÃ­t k zapsÃ¡nÃ­ napÅ™Ã­klad pouze <code>3</code> ÄÃ­sel, pokud bÄ›hem zÃ¡pisu
dojde k chybÄ›<sup class='margin-toggle sidenote-number'>1</sup>. Pokud bychom chtÄ›li zapsat buÄ vÅ¡e nebo nic, mÅ¯Å¾eme Å™Ã­ct, Å¾e zapisujeme pouze
jeden prvek a parameter <code>count</code> nastavit na celkovou velikost vÅ¡ech dat, kterÃ© chceme zapsat:</p>
<span class='sidenote'><p><sup class='number'>1</sup>V takovÃ©mto pÅ™Ã­padÄ› by funkce <code>fwrite</code> vrÃ¡tila hodnotu <code>3</code>.</p>
</span>
<pre><code class="language-c">int pole[5] = { 1, 2, 3, 4, 5 };
fwrite(pole, sizeof(pole), 1, soubor);
</code></pre>
</blockquote>
<p>Pokud bychom zapsali <code>pole</code> do souboru takto, uloÅ¾Ã­ se do nÄ›j celkem <code>20</code> (<code>5</code> * <code>4</code>) bytÅ¯ (ÄÃ­sel),
kterÃ© pozdÄ›ji mÅ¯Å¾eme v programu zase <a href="c/soubory/cteni_ze_souboru.html">naÄÃ­st zpÃ¡tky</a>. Pokud bychom se podÃ­vali,
co v souboru je, nalezli bychom seznam ÄÃ­sel <code>1 0 0 0 2 0 0 0 3 0 0 0 4 0 0 0 5 0 0 0</code>, coÅ¾ odpovÃ­dÃ¡
pamÄ›Å¥ovÃ© reprezentaci pole pÄ›ti <code>int</code>Å¯, kterÃ© bylo vytvoÅ™eno vÃ½Å¡e.</p>
<h2><a class="header" href="#textovÃ½-zÃ¡pis" id="textovÃ½-zÃ¡pis">TextovÃ½ zÃ¡pis</a></h2>
<p>Pokud bychom chtÄ›li tato data zapsat do souboru v textovÃ© podobÄ› (a ne pouze jako jejich binÃ¡rnÃ­
reprezentaci), mÅ¯Å¾eme ÄÃ­sla z vÃ½Å¡e zmÃ­nÄ›nÃ©ho pole zapsat pomocÃ­ nÄ›jakÃ©ho textovÃ©ho kÃ³dovÃ¡nÃ­,
napÅ™Ã­klad <a href="c/soubory/../text/znaky.html">ASCII</a>. K tomu mÅ¯Å¾eme vyuÅ¾Ã­t funkci
<a href="https://devdocs.io/c/io/fprintf"><code>fprintf</code></a>, kterÃ¡ funguje stejnÄ› jako <code>printf</code>, s tÃ­m rozdÃ­lem,
Å¾e text nevypisuje na <code>stdout</code>, ale do pÅ™edanÃ©ho souboru<sup class='margin-toggle sidenote-number'>2</sup>:</p>
<span class='sidenote'><p><sup class='number'>2</sup>VÅ¡imnÄ›te si, Å¾e zde jsme pouÅ¾ili <a href="c/soubory/otevirani_souboru.html#M%C3%B3d-otev%C5%99en%C3%AD">mÃ³d otevÅ™enÃ­</a> pro textovÃ½
zÃ¡pis (<code>&quot;wt&quot;</code>), namÃ­sto binÃ¡rnÃ­ho zÃ¡pisu <code>&quot;wb&quot;</code> pouÅ¾itÃ©ho vÃ½Å¡e.</p>
</span>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;assert.h&gt;

int main() {
    int pole[5] = { 1, 2, 3, 4, 5 };

    // otevÅ™enÃ­ souboru
    FILE* soubor = fopen(&quot;soubor.txt&quot;, &quot;wt&quot;);
    assert(soubor);

    // textovÃ½ zÃ¡pis do souboru
    for (int i = 0; i &lt; 5; i++) {
        fprintf(soubor, &quot;%d &quot;, pole[i]);
    }

    // zavÅ™enÃ­ souboru
    fclose(soubor);    

    return 0;
}
</code></pre>
<p>V tomto pÅ™Ã­padÄ› by se do souboru zapsalo deset bytÅ¯ (ÄÃ­sel) <code>49 32 50 32 51 32 52 32 53 32</code>, protoÅ¾e
ÄÃ­slice jsou v <a href="https://www.asciitable.com/">ASCII</a> reprezentovÃ¡ny ÄÃ­sly <code>48</code> aÅ¾ <code>57</code> a mezera je
reprezentovÃ¡na ÄÃ­slem <code>32</code>. Pokud bychom tento soubor otevÅ™eli v textovÃ©m editoru, tak by se nÃ¡m
zobrazil text <code>1 2 3 4 5 </code>.</p>
<h2><a class="header" href="#bufferovÃ¡nÃ­" id="bufferovÃ¡nÃ­">BufferovÃ¡nÃ­</a></h2>
<p>StejnÄ› jako pÅ™i zÃ¡pisu do <code>stdout</code> se i pÅ™i zÃ¡pisu do souborÅ¯ uplatÅˆuje
<a href="c/soubory/../text/vstupavystup.html#standardn%C3%AD-souborov%C3%A9-deskriptory"><em>bufferovÃ¡nÃ­</em></a>. Data, kterÃ¡ do souboru
zapÃ­Å¡eme, se tak v nÄ›m neobjevÃ­ hned. Pokud bychom chtÄ›li donutit nÃ¡Å¡ program, aby data uloÅ¾enÃ¡
v bufferu opravdu vypsal do souboru, mÅ¯Å¾eme pouÅ¾Ã­t funkci <a href="https://devdocs.io/c/io/fflush"><code>fflush</code></a>
<sup class='margin-toggle sidenote-number'>3</sup>.</p>
<span class='sidenote'><p><sup class='number'>3</sup>Ani zavolÃ¡nÃ­ funkce <code>fflush</code> vÅ¡ak nezajistÃ­, Å¾e se data opravdu zapÃ­Å¡ou na fyzickÃ© mÃ©dium
(napÅ™Ã­klad harddisk). To je ve skuteÄnosti velmi obtÃ­Å¾nÃ½ <a href="https://lwn.net/Articles/457667/">problÃ©m</a>.</p>
</span><h1><a class="header" href="#ÄŒtenÃ­-ze-souboru" id="ÄŒtenÃ­-ze-souboru">ÄŒtenÃ­ ze souboru</a></h1>
<p>Pro ÄtenÃ­ ze souboru mÅ¯Å¾eme pouÅ¾Ã­t funkci <a href="https://devdocs.io/c/io/fread"><code>fread</code></a>, kterÃ¡ je
protikladem funkce <code>fwrite</code>:</p>
<pre><code class="language-c">size_t fread(
    void* buffer,   // adresa, na kterou zapÃ­Å¡eme data ze souboru
    size_t size,    // velikost prvku, kterÃ½ naÄÃ­tÃ¡me
    size_t count,   // poÄet prvkÅ¯, kterÃ© naÄÃ­tÃ¡me
    FILE* stream    // soubor, ze kterÃ©ho Äteme
);
</code></pre>
<p>Tato funkce opÄ›t pÅ™edpoklÃ¡dÃ¡, Å¾e budeme ze souboru naÄÃ­tat nÄ›kolik hodnot stejnÃ©ho datovÃ©ho typu.
NapÅ™Ã­klad naÄtenÃ­ pÄ›ti celÃ½ch ÄÃ­sel, kterÃ© jsme zapsali v kÃ³du <a href="c/soubory/zapis_do_souboru.html">zde</a>, by mohlo
vypadat nÃ¡sledovnÄ›:</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;assert.h&gt;

int main() {
    int pole[5] = { 1, 2, 3, 4, 5 };

    // otevÅ™enÃ­ souboru
    FILE* soubor = fopen(&quot;soubor&quot;, &quot;rb&quot;);
    assert(soubor);

    // ÄtenÃ­ ze souboru
    int precteno = fread(pole, sizeof(int), 5, soubor);
    assert(precteno == 5);

    // zavÅ™enÃ­ souboru
    fclose(soubor);    

    return 0;
}
</code></pre>
<p>Funkce <code>fread</code> vracÃ­ poÄet prvkÅ¯, kterÃ© ÃºspÄ›Å¡nÄ› naÄetla ze souboru.</p>
<h2><a class="header" href="#textovÃ©-ÄtenÃ­" id="textovÃ©-ÄtenÃ­">TextovÃ© ÄtenÃ­</a></h2>
<p>Pokud bychom chtÄ›li naÄÃ­tat ze souboru ASCII text, mÅ¯Å¾eme pouÅ¾Ã­t jiÅ¾ znÃ¡mÃ© funkce pro naÄÃ­tÃ¡nÃ­ textu,
napÅ™Ã­klad <a href="https://devdocs.io/c/io/fgets"><code>fgets</code></a><sup class='margin-toggle sidenote-number'>1</sup> nebo <a href="https://devdocs.io/c/io/fscanf"><code>fscanf</code></a>,
coÅ¾ je varianta funkce <code>scanf</code> urÄenÃ¡ pro formÃ¡tovanÃ© ÄtenÃ­ ze souborÅ¯.</p>
<span class='sidenote'><p><sup class='number'>1</sup>S funkcÃ­ <code>fgets</code> jsme se setkali jiÅ¾ <a href="c/soubory/../text/vstup.html#na%C4%8Dten%C3%AD-%C5%99%C3%A1dku">dÅ™Ã­ve</a>, kdy jsme jÃ­
jako poslednÃ­ parametr globÃ¡lnÃ­ promÄ›nnou <code>stdin</code>. DatovÃ½ typ promÄ›nnÃ© <code>stdin</code> je prÃ¡vÄ› <code>FILE*</code> â€“
pÅ™i spuÅ¡tÄ›nÃ­ programu standardnÃ­ knihovna <em>C</em> vytvoÅ™Ã­ promÄ›nnÃ© <code>stdin</code>, <code>stdout</code> a <code>stderr</code> a uloÅ¾Ã­
do nich standardnÃ­ vstup, vÃ½stup a chybovÃ½ vÃ½stup.</p>
</span>
<blockquote>
<p>U naÄÃ­tÃ¡nÃ­ dat si vÅ¾dy dejte pozor na to, abyste na adrese, kterou pÅ™edÃ¡vÃ¡te do <code>fread</code> nebo
<code>fgets</code>, mÄ›li dostatek naalokovanÃ© validnÃ­ pamÄ›ti. Jinak by se mohlo stÃ¡t, Å¾e data ze souboru
pÅ™epÃ­Å¡ou adresy v pamÄ›ti, kde leÅ¾Ã­ nÄ›jakÃ© nesouvisejÃ­cÃ­ hodnoty, coÅ¾ by vedlo k
<a href="c/soubory/../../caste_chyby/pametove_chyby.html#segmentation-fault">pamÄ›Å¥ovÃ© chybÄ›</a> ğŸ’£.</p>
</blockquote>
<h3><a class="header" href="#rozpoznÃ¡nÃ­-konce-souboru" id="rozpoznÃ¡nÃ­-konce-souboru">RozpoznÃ¡nÃ­ konce souboru</a></h3>
<p>PÅ™i ÄtenÃ­ ze souboru je tÅ™eba vyÅ™eÅ¡it jednu dodateÄnou vÄ›c â€“ jak rozpoznÃ¡me, Å¾e uÅ¾ jsme soubor
pÅ™eÄetli celÃ½ a uÅ¾ v nÄ›m nic dalÅ¡Ã­ho nezbÃ½vÃ¡? Pokud naÄÃ­tÃ¡me data ze souboru &quot;binÃ¡rnÄ›&quot;, tj.
interpretujeme je jako byty a ne jako (ASCII) text, obvykle staÄÃ­ si velikost souboru
<a href="c/soubory/prace_se_soubory.html#pozice-v-souboru">pÅ™edpoÄÃ­tat</a> po jeho otevÅ™enÃ­ pomocÃ­ funkcÃ­
<a href="https://devdocs.io/c/io/ftell"><code>ftell</code></a> a <a href="https://devdocs.io/c/io/fseek"><code>fseek</code></a> nebo si ji
pÅ™eÄÃ­st pÅ™Ã­mo ze samotnÃ©ho souboru<sup class='margin-toggle sidenote-number'>2</sup>.</p>
<span class='sidenote'><p><sup class='number'>2</sup>Spousta binÃ¡rnÃ­ch formÃ¡tÅ¯ (napÅ™. <code>JPEG</code>) jsou tzv. <strong>samo-popisnÃ©</strong> (<em>self-describing</em>), coÅ¾
znamenÃ¡, Å¾e typicky na zaÄÃ¡tku souboru je v pevnÄ› stanovenÃ©m formÃ¡tu (tzv. <em>hlaviÄce</em>) uvedeno,
jak je danÃ½ soubor velkÃ½. VyuÅ¾ijeme toho napÅ™Ã­klad pÅ™i prÃ¡ci s obrÃ¡zkovÃ½m formÃ¡tem
<a href="c/soubory/../aplikovane_ulohy/tga.html"><code>TGA</code></a>.</p>
</span>
<p>Co ale dÄ›lat, kdyÅ¾ naÄÃ­tÃ¡me textovÃ© soubory, jejichÅ¾ formÃ¡t obvykle nenÃ­ ani zdaleka pevnÄ› danÃ½?
PÅ™edpoÄÃ­tat si velikost souboru a pak muset po kaÅ¾dÃ©m naÄtenÃ­ napÅ™. Å™Ã¡dku poÄÃ­tat, kolik znakÅ¯ jsme
vlastnÄ› naÄetli, by bylo relativnÄ› komplikovanÃ©. PÅ™i ÄtenÃ­ textovÃ½ch souborÅ¯ se tak obvykle vyuÅ¾Ã­vÃ¡
jinÃ¡ strategie â€“ Äteme ze souboru tak dlouho, dokud nedojde k chybÄ›. ZpÅ¯sob detekce chyby zÃ¡leÅ¾Ã­ na
pouÅ¾itÃ© funkci:</p>
<ul>
<li><a href="https://devdocs.io/c/io/fscanf"><code>fscanf</code></a> vrÃ¡tÃ­ ÄÃ­slo <code>&lt;= 0</code>, pokud se jÃ­ nepodaÅ™Ã­ naÄÃ­st Å¾Ã¡dnÃ½
zÃ¡stupnÃ½ znak ze vstupu.</li>
<li><a href="https://devdocs.io/c/io/fgets"><code>fgets</code></a> vrÃ¡tÃ­ ukazatel s hodnotou <code>0</code>, pokud dojde k chybÄ› pÅ™i
ÄtenÃ­.</li>
</ul>
<p>Jakmile dojde k chybÄ›, tak bychom jeÅ¡tÄ› mÄ›li ovÄ›Å™it, jestli jsme opravdu na konci souboru, anebo
byla chyba zpÅ¯sobena nÄ›ÄÃ­m jinÃ½m<sup class='margin-toggle sidenote-number'>3</sup>. To mÅ¯Å¾eme zjistit pomocÃ­ funkcÃ­
<a href="https://devdocs.io/c/io/feof"><code>feof</code></a>, kterÃ¡ vrÃ¡tÃ­ nenulovou hodnotu, pokud jsme se <strong>pÅ™ed jejÃ­m
zavolÃ¡nÃ­m</strong> pokusili o ÄtenÃ­ a <a href="c/soubory/prace_se_soubory.html#pozice-v-souboru">pozice</a> jiÅ¾ byla na konci souboru,
a <a href="https://devdocs.io/c/io/ferror"><code>ferror</code></a>, kterÃ¡ vrÃ¡tÃ­ nenulovou hodnotu, pokud doÅ¡lo k nÄ›jakÃ©
jinÃ© chybÄ› pÅ™i prÃ¡ci se souborem. </p>
<span class='sidenote'><p><sup class='number'>3</sup>NapÅ™Ã­klad pokud Äteme soubor z USB flashky, kterÃ½ je bÄ›hem ÄtenÃ­ odpojen od poÄÃ­taÄe.</p>
</span>
<p>Program, kterÃ½ by naÄÃ­tal a rovnou vypisoval Å™Ã¡dky textu ze vstupnÃ­ho souboru, dokud nedojde na
jeho konec, by tedy mohl vypadat napÅ™Ã­klad takto:</p>
<pre><code class="language-c">#include &lt;assert.h&gt;
#include &lt;errno.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

int main() {
    FILE* soubor = fopen(&quot;soubor.txt&quot;, &quot;rt&quot;);
    assert(soubor);

    char radek[80];
    while (1) {
        if (fgets(radek, sizeof(radek), soubor)) {
            // radek byl uspesne nacten
            printf(&quot;Nacteny radek: %s&quot;, radek);
        }
        else {
            if (feof(soubor)) {
                printf(&quot;Dosli jsme na konec souboru\n&quot;);
            } else if (ferror(soubor)) {
                printf(&quot;Pri cteni ze souboru doslo k chybe: %s\n&quot;, strerror(errno));
            }

            break;
        }
    }

    fclose(soubor);

    return 0;
}
</code></pre>
<hr />
<p><strong>KvÃ­z</strong> ğŸ¤”</p>
<ol>
<li>
<p>Co vypÃ­Å¡e nÃ¡sledujÃ­cÃ­ program za pÅ™edpokladu, Å¾e v souboru <code>soubor.txt</code> je tento obsah?</p>
<pre><code>radek1
radek2
radek3
</code></pre>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;assert.h&gt;

int main() {
    FILE* soubor = fopen(&quot;soubor.txt&quot;, &quot;r&quot;);
    assert(soubor);

    char radek[80];
    while (feof(soubor) == false) {
        fgets(radek, sizeof(radek), soubor);
        printf(&quot;Nacteny radek: %s&quot;, radek);
    }

    fclose(soubor);
    return 0;
}
</code></pre>
<details>
 <summary>OdpovÄ›Ä</summary>
<p>Program vypÃ­Å¡e:</p>
<pre><code>radek1
radek2
radek3
radek3
</code></pre>
<p>Funkce <code>feof</code> vrÃ¡tÃ­ pravdivou hodnotu pouze tehdy, kdy pÅ™ed jejÃ­m zavolÃ¡nÃ­m na danÃ©m souborovÃ©m
deskriptoru doÅ¡lo k pokusu o ÄtenÃ­, kterÃ½ selhal z dÅ¯vodu konce vstupnÃ­ho souboru. Po naÄtenÃ­
prvnÃ­ch tÅ™Ã­ Å™Ã¡dkÅ¯ tedy <code>feof</code> vrÃ¡tÃ­ <code>false</code>, protoÅ¾e poslednÃ­ pokus o ÄtenÃ­ uspÄ›l. AÅ¾ v momentÄ›,
kdy se pokusÃ­me naÄÃ­st ÄtvrtÃ½ Å™Ã¡dek, tak funkce <code>fgets</code> selÅ¾e a potÃ© <code>feof</code> vrÃ¡tÃ­ <code>true</code>. JelikoÅ¾
ale tento kÃ³d nekontroluje nÃ¡vratovou hodnotu funkce <code>fgets</code> a vÅ¾dy po pokusu o naÄtenÃ­ Å™Ã¡dku vypÃ­Å¡e
promÄ›nnou <code>radek</code>, tak se poslednÃ­ Å™Ã¡dek souboru vypÃ­Å¡e dvakrÃ¡t.</p>
</details>
</li>
</ol>
<h1><a class="header" href="#modularizace" id="modularizace">Modularizace</a></h1>
<p>ProzatÃ­m byly naÅ¡e programy tvoÅ™eny pouze jednÃ­m zdrojovÃ½m souborem. Pro krÃ¡tkÃ© programy do pÃ¡r
stovek Å™Ã¡dkÅ¯ to staÄÃ­, nicmÃ©nÄ› asi si dovedete pÅ™edstavit, Å¾e programy s tisÃ­ce Äi miliony Å™Ã¡dkÅ¯ kÃ³du
uÅ¾ se do jednoho souboru rozumnÄ› &quot;nevlezou&quot;. V tÃ©to sekci si tak ukÃ¡Å¾eme, jak programy v <em>C</em> rozdÄ›lit
do vÃ­ce zdrojovÃ½ch souborÅ¯.</p>
<p>RozdÄ›lenÃ­ programu do vÃ­ce souborÅ¯ mÃ¡ spoustu vÃ½hod:</p>
<ul>
<li>
<p><strong>VÄ›tÅ¡Ã­ pÅ™ehlednost</strong> Pokud by byl veÅ¡kerÃ½ kÃ³d v jednom zdrojovÃ©m souboru, tak by se v takovÃ©m souboru
dalo u vÄ›tÅ¡Ã­ch programÅ¯ jen tÄ›Å¾ko vyznat. Pokud budou jednotlivÃ© logickÃ© ÄÃ¡sti programu umÃ­stÄ›ny
v samostatnÃ½ch souborech Äi adresÃ¡Å™Ã­ch, bude napÅ™. mnohem jednoduÅ¡Å¡Ã­ najÃ­t ÄÃ¡st programu, kterou
chceme upravit.</p>
<p>NapÅ™Ã­klad u hry bychom mohli rozdÄ›lit program do souborÅ¯ <code>zvuk.c</code>, <code>grafika.c</code>, <code>ovladani_priser.c</code>,
<code>zbrane.c</code>, <code>klavesnice.c</code>, <code>mys.c</code> atd. Pokud by nÄ›kterÃ½ z tÄ›chto souborÅ¯ byl opÄ›t moc velkÃ½
nebo sloÅ¾itÃ½, mÅ¯Å¾eme jeho funkcionalitu dÃ¡le rozdÄ›lit do vÃ­ce souborÅ¯.</p>
</li>
<li>
<p><strong>MenÅ¡Ã­ provÃ¡zanost</strong> Pokud je vÅ¡e v jednom souboru, znamenÃ¡ to, Å¾e z libovolnÃ© funkce lze volat
vÅ¡echny ostatnÃ­ funkce (popÅ™. pouÅ¾Ã­vat vÅ¡echny ostatnÃ­ struktury atd.). Toto vede k situaci, kdy jsou
jednotlivÃ© ÄÃ¡sti programu na sobÄ› vzÃ¡jemnÄ› zÃ¡vislÃ© a propojenÃ©. To moÅ¾nÃ¡ znÃ­ nevinnÄ›, nicmÃ©nÄ› ve
skuteÄnosti to tÃ©mÄ›Å™ nevyhnutelnÄ› vede k programu, kterÃ½ je velmi obtÃ­Å¾nÃ© upravit. Pokud totiÅ¾
zmÄ›nÃ­te jednu vÄ›c, Äasto se musÃ­ zmÄ›nit i vÅ¡echny dalÅ¡Ã­ vÄ›ci (funkce, struktury), kterÃ© na danÃ© vÄ›ci
zÃ¡visÃ­. Pokud zÃ¡visÃ­ vÅ¡e na vÅ¡em, tak i malÃ¡ zmÄ›na v jednÃ© ÄÃ¡sti kÃ³du mÅ¯Å¾e kaskÃ¡dovÄ› vyvolat nutnost
upravit celÃ½ zbytek programu, coÅ¾ je nÃ¡roÄnÃ©.</p>
<p>Abychom tomu pÅ™edeÅ¡li, je vhodnÃ© uÄinit jednotlivÃ© ÄÃ¡sti programu samostatnÃ©, sdÃ­let z nich se
zbytkem kÃ³du pouze to, co je opravdu potÅ™eba, a zbytek funkcionality uÄinit &quot;soukromou&quot; pro danÃ½
soubor. ZmÄ›ny v tÄ›chto soukromÃ½ch ÄÃ¡stech pak nemohou ovlivnit zbytek kÃ³du, protoÅ¾e ten na nich
nebude zÃ¡viset.</p>
</li>
<li>
<p><strong>EfektivnÄ›jÅ¡Ã­ spoluprÃ¡ce v tÃ½mu</strong> RozdÄ›lenÃ­ na vÃ­ce souborÅ¯ takÃ© usnadnÃ­ tÃ½movou spoluprÃ¡ci.
Pokud budou jednotlivÃ­ programÃ¡toÅ™i upravovat jinÃ© soubory, bude mnohem menÅ¡Ã­ riziko tzv. &quot;soubÄ›hu&quot;,
kdy by jejich zmÄ›ny ve stejnÃ©m souboru mohly kolidovat. Tyto problÃ©my pak dÃ¡le Å™eÅ¡Ã­ tzv.
<a href="https://cs.wikipedia.org/wiki/Verzov%C3%A1n%C3%AD">verzovÃ¡nÃ­</a>, o kterÃ©m se dozvÃ­te v navazujÃ­cÃ­ch
pÅ™edmÄ›tech.</p>
</li>
<li>
<p><strong>ZnovuvyuÅ¾itÃ­ kÃ³du</strong> Pokud by kaÅ¾dÃ½ program musel implementovat veÅ¡kerou funkcionalitu od nuly,
tak by bylo programovÃ¡nÃ­ i jednoduchÃ©ho programu nesmÃ­rnÄ› nÃ¡roÄnÃ©.<sup class='margin-toggle sidenote-number'>1</sup> V rÃ¡mci jednoho programu si
mÅ¯Å¾eme nÄ›jakou ucelenou funkcionalitu (napÅ™. sadu funkcÃ­ spolu se strukturami) vyÄlenit do
samostatnÃ©ho souboru, coÅ¾ nÃ¡m umoÅ¾nÃ­ ji opakovanÄ› pouÅ¾Ã­vat z ostatnÃ­ch souborÅ¯ v naÅ¡em programu.
NapÅ™Ã­Ä programy pak mÅ¯Å¾eme sdÃ­let kÃ³d pomocÃ­ tzv. <strong>knihoven</strong> (<em>libraries</em>). Pro obojÃ­ musÃ­me umÄ›t
pouÅ¾Ã­vat kÃ³d, kterÃ½ se nenachÃ¡zÃ­ ve zdrojovÃ©m souboru, ze kterÃ©ho ho chceme vyuÅ¾Ã­t.</p>
<span class='sidenote'><p><sup class='number'>1</sup>OstatnÄ› napÅ™Ã­klad bez <a href="c/modularizace/../funkce/stdlib.html">standardnÃ­ knihovny <em>C</em></a> bychom v naÅ¡em programu
ani nebyli schopni nÄ›co vypsat do terminÃ¡lu.</p>
</span></li>
</ul>
<p>V programovacÃ­ch jazycÃ­ch se obecnÄ› rÅ¯znÃ© samostatnÃ© ÄÃ¡sti kÃ³du, kterÃ© jsou typicky umÃ­stÄ›ny v
adresÃ¡Å™Ã­ch Äi souborech, a starajÃ­ se o konkrÃ©tnÃ­ funkcionalitu v programu, nazÃ½vajÃ­ <em>moduly</em>.
Proto je tato sekce nazvÃ¡na <em>modularizace</em>. JednÃ¡ se vÅ¡ak spÃ­Å¡e o obecnÃ½ pojem, v jazyce <em>C</em> se pÅ™Ã­mo
s pojmem modul zase tak bÄ›Å¾nÄ› nesetkÃ¡te.</p>
<p>PostupnÄ› si ukÃ¡Å¾eme:</p>
<ul>
<li>Jak funguje pÅ™eklad programÅ¯ <a href="c/modularizace/linker.html">s vÃ­ce zdrojovÃ½mi soubory</a></li>
<li>Jak pouÅ¾Ã­vat funkce a promÄ›nnÃ© <a href="c/modularizace/pouzivani_kodu_z_jinych_souboru.html">z jinÃ½ch souborÅ¯</a></li>
<li>JakÃ© jsou konvence pro pouÅ¾Ã­vÃ¡nÃ­ <a href="c/modularizace/hlavickove_soubory.html">vÃ­ce zdrojovÃ½ch souborÅ¯ v C</a></li>
<li>Jak pouÅ¾Ã­vat kÃ³d, kterÃ½ napsal nÄ›kdo jinÃ½, a nasdÃ­lel ho v podobÄ› <a href="c/modularizace/knihovny.html">knihovny</a></li>
</ul>
<h1><a class="header" href="#linker" id="linker">Linker</a></h1>
<p>V tÃ©to sekci si vysvÄ›tlÃ­me detailnÄ›ji, jak probÃ­hÃ¡ pÅ™eklad <em>C</em> programÅ¯, jehoÅ¾ zÃ¡kladnÃ­ fungovÃ¡nÃ­
jiÅ¾ bylo struÄnÄ› popsÃ¡no v sekci o <a href="c/modularizace/../../prostredi/preklad_programu.html">pÅ™ekladu</a>. DÃ­ky tomu pak
budeme schopni vytvÃ¡Å™et programy sklÃ¡dajÃ­cÃ­ se z vÃ­ce neÅ¾ jednoho zdrojovÃ©ho souboru.</p>
<p>ProzatÃ­m jsme naÅ¡e programy (sklÃ¡dajÃ­cÃ­ se z jedinÃ©ho zdrojovÃ©ho souboru) pÅ™eklÃ¡dali pomocÃ­
pÅ™Ã­kazu podobnÃ©mu tomuto:</p>
<pre><code class="language-bash">$ gcc soubor.c -o program
</code></pre>
<p>TÃ­mto pÅ™Ã­kazem jsme ve skuteÄnosti provÃ¡dÄ›li dvÄ› vÄ›ci najednou: <strong>pÅ™eklad</strong> (<em>translation</em>) a
<strong>linkovÃ¡nÃ­</strong> (<em>linking</em>). NÃ­Å¾e si vysvÄ›tlÃ­me obÄ› dvÄ› tyto ÄÃ¡sti detailnÄ›ji.</p>
<blockquote>
<p>PÅ™eklad a linkovÃ¡nÃ­ se dohromady nazÃ½vÃ¡ <strong>kompilace</strong> programu.</p>
</blockquote>
<h2><a class="header" href="#pÅ™eklad-programu-1" id="pÅ™eklad-programu-1">PÅ™eklad programu</a></h2>
<p>Programy v <em>C</em> se sklÃ¡dajÃ­ z jednÃ© Äi vÃ­ce tzv. <strong>jednotek pÅ™ekladu</strong> (<em>translation unit</em>). JednÃ¡ se
o nezÃ¡vislÃ© komponenty, ze kterÃ½ch je nakonec vytvoÅ™en cÃ­lovÃ½ program. KaÅ¾dÃ¡ jednotka je obvykle
tvoÅ™ena jednÃ­m zdrojovÃ½m souborem (obvykle s pÅ™Ã­ponou <code>.c</code>). PÅ™i pÅ™ekladu <strong>pÅ™ekladaÄ</strong> pÅ™evede
jednotku ze zdrojovÃ©ho kÃ³du v <em>C</em> do instrukcÃ­ procesoru, tzv. <strong>objektovÃ©ho kÃ³du</strong> (<em>object code</em>).</p>
<p>Pokud chceme pÅ™ekladaÄem <code>gcc</code> (pouze) pÅ™eloÅ¾it zdrojovÃ½ soubor do objektovÃ©ho kÃ³du (resp.
objektovÃ©ho souboru), mÅ¯Å¾eme pouÅ¾Ã­t pÅ™epÃ­naÄ <code>-c</code>:</p>
<pre><code class="language-bash">$ gcc -c soubor.c
</code></pre>
<p>Pokud nezadÃ¡me nÃ¡zev vÃ½stupu pomocÃ­ pÅ™epÃ­naÄe <code>-o</code>, tak <code>gcc</code> implicitnÄ› vytvoÅ™Ã­ objektovÃ½ soubor
<code>&lt;nazev-vstupu&gt;.o</code> (tj. zde <code>soubor.o</code>).</p>
<p>Jednotky pÅ™ekladu jsou na sobÄ› nezÃ¡vislÃ©, mÅ¯Å¾eme tedy kaÅ¾dou jednotku (zdrojovÃ½ soubor) pÅ™eloÅ¾it
zvlÃ¡Å¡Å¥:</p>
<pre><code class="language-bash">$ gcc -c a.c
$ gcc -c b.c
...
</code></pre>
<p>Jak ale nynÃ­ jednotlivÃ© soubory propojÃ­me? Aby vÅ¯bec mÄ›lo rozdÄ›lenÃ­ do vÃ­ce jednotek (souborÅ¯) smysl,
tak musÃ­me mÃ­t moÅ¾nost v jednom souboru pouÅ¾Ã­vat kÃ³d (napÅ™. funkce nebo globÃ¡lnÃ­ promÄ›nnÃ©), kterÃ½ je
nadefinovanÃ½ v jinÃ©m souboru. V <em>C</em> toto propojenÃ­ jednotek neprobÃ­hÃ¡ pÅ™i pÅ™ekladu, ale aÅ¾ v nÃ¡slednÃ©
fÃ¡zi nazÃ½vanÃ© linkovÃ¡nÃ­.</p>
<h2><a class="header" href="#linkovÃ¡nÃ­-programu" id="linkovÃ¡nÃ­-programu">LinkovÃ¡nÃ­ programu</a></h2>
<p>Jakmile pÅ™eloÅ¾Ã­me vÅ¡echny naÅ¡e zdrojovÃ© soubory postupnÄ› do objektovÃ½ch souborÅ¯, potÅ™ebujeme z nich
vytvoÅ™it finÃ¡lnÃ­ spustitelnÃ½ soubor, coÅ¾ je prÃ¡ce programu nazÃ½vanÃ©ho <strong>linker</strong>. Linker obdrÅ¾Ã­
seznam vÅ¡ech (jiÅ¾ pÅ™eloÅ¾enÃ½ch) objektovÃ½ch souborÅ¯, ze kterÃ½ch se mÃ¡ program sklÃ¡dat, propojÃ­ je
dohromady a vytvoÅ™Ã­ z nich spustitelnÃ½ soubor.</p>
<p>Jak propojenÃ­ jednotlivÃ½ch souborÅ¯ probÃ­hÃ¡? PÅ™edstavme si napÅ™Ã­klad, Å¾e v souboru <code>a.c</code> volÃ¡me
funkci <code>foo</code>, kterÃ¡ v tomto souboru neexistuje. PÅ™i pÅ™ekladu tohoto souboru pÅ™ekladaÄ vytvoÅ™Ã­
objektovÃ½ soubor <code>a.o</code>, ve kterÃ©m bude uloÅ¾ena informace, Å¾e volÃ¡me funkci <code>foo</code>. Dejme tomu, Å¾e
tato funkce existuje v souboru <code>b.c</code>, kterÃ½ je pÅ™eloÅ¾en do objektovÃ©ho souboru <code>b.o</code>. PÅ™i linkovÃ¡nÃ­
linker obdrÅ¾Ã­ seznam vÅ¡ech objektovÃ½ch souborÅ¯, tedy <code>a.o</code> i <code>b.o</code>. KdyÅ¾ narazÃ­ na informaci, Å¾e z
<code>a.o</code> chceme volat funkci <code>foo</code>, pokusÃ­ se tuto funkci naleznout v nÄ›kterÃ©m z pÅ™edanÃ½ch objektovÃ½ch
souborÅ¯:</p>
<ul>
<li>Pokud jej nenalezne, tak vypÃ­Å¡e chybu a program se nepÅ™eloÅ¾Ã­<sup class='margin-toggle sidenote-number'>1</sup>.<span class='sidenote'><p><sup class='number'>1</sup>V takovÃ©m pÅ™Ã­padÄ› byste se setkali s chybou <code>undefined reference to 'foo'</code>.</p>
</span></li>
<li>Pokud jej nalezne (v tomto pÅ™Ã­padÄ› v <code>b.o</code>), tak volÃ¡nÃ­ funkce &quot;propojÃ­&quot; tak, aby se volala sprÃ¡vnÃ¡
funkce pÅ¯vodnÄ› vytvoÅ™enÃ¡ v <code>b.c</code>.</li>
</ul>
<p>ManuÃ¡lnÃ­ pouÅ¾itÃ­ linkeru<sup class='margin-toggle sidenote-number'>2</sup> je relativnÄ› sloÅ¾itÃ©, proto i linker budeme pouÅ¾Ã­vat pÅ™es <code>gcc</code>. Tomu
mÅ¯Å¾eme pÅ™edat sadu objektovÃ½ch souborÅ¯ a on se postarÃ¡ o sprÃ¡vnÃ© zavolÃ¡nÃ­ linkeru, kterÃ½ je spojÃ­
a vytvoÅ™Ã­ finÃ¡lnÃ­ spustitelnÃ½ soubor:</p>
<span class='sidenote'><p><sup class='number'>2</sup>Na Linuxu lze pouÅ¾Ã­t napÅ™Ã­klad linker <code>ld</code>.</p>
</span>
<pre><code class="language-bash">$ gcc a.o b.o -o program
</code></pre>
<p>PÅ™i finÃ¡lnÃ­m linkovÃ¡nÃ­ programu takÃ© dochÃ¡zÃ­ ke kontrole toho, jestli je v nÄ›kterÃ©m z objektovÃ½ch
souborÅ¯ obsaÅ¾ena funkce <code>main</code>, aby program vÄ›dÄ›l, kde mÃ¡ zaÄÃ­t svÃ© vykonÃ¡vÃ¡nÃ­.</p>
<h4><a class="header" href="#proÄ-takto-sloÅ¾itÄ›" id="proÄ-takto-sloÅ¾itÄ›">ProÄ takto sloÅ¾itÄ›?</a></h4>
<p>MoÅ¾nÃ¡ vÃ¡s napadlo, proÄ kompilace <em>C</em> programÅ¯ probÃ­hÃ¡ takto komplikovanÄ› a nestaÄÃ­ prostÄ› pÅ™ekladaÄi
dÃ¡t vÅ¡echny zdrojovÃ© soubory naÅ¡eho programu tak, jak jsme to dÄ›lali doposud:</p>
<pre><code class="language-bash">$ gcc soubor1.c soubor2.c soubor3.c ...
</code></pre>
<p>Ve skuteÄnosti i to lze provÃ©st (tento postup se nazÃ½vÃ¡ tzv. <strong>unity build</strong>). NicmÃ©nÄ› mÃ¡ velkou
nevÃ½hodu. Pokud bychom pÅ™eklÃ¡dali celÃ½ nÃ¡Å¡ program najednou, pÅ™i sebemenÅ¡Ã­ zmÄ›nÄ› kÃ³du bychom museli
pÅ™eloÅ¾it vÅ¡echny soubory znovu. Pokud bychom tak mÄ›li obrovskÃ½ program s tisÃ­cem zdrojovÃ½ch souborÅ¯
a zmÄ›nili jeden znak v jednom souboru, muselo by se vÅ¡ech tisÃ­c souborÅ¯ pÅ™eloÅ¾it znovu, coÅ¾ mÅ¯Å¾e bÃ½t
dost pomalÃ©<sup class='margin-toggle sidenote-number'>3</sup>.</p>
<span class='sidenote'><p><sup class='number'>3</sup>VelkÃ© programy v <em>C</em> mÅ¯Å¾e trvat pÅ™eloÅ¾it klidnÄ› i nÄ›kolik hodin!</p>
</span>
<p>Pokud pÅ™eklÃ¡dÃ¡me kaÅ¾dÃ½ soubor zvlÃ¡Å¡Å¥, tak po zmÄ›nÄ› v jednom souboru staÄÃ­ pÅ™eloÅ¾it danÃ½ soubor a znovu
slinkovat vÅ¡echny objektovÃ© soubory (ty pÅ¯vodnÃ­ mÅ¯Å¾eme znovuvyuÅ¾Ã­t, protoÅ¾e se nezmÄ›nily). To je u
velkÃ½ch programÅ¯ mnohem rychlejÅ¡Ã­ neÅ¾ pÅ™eklÃ¡dat vÅ¡e od nuly.</p>
<p>NavÃ­c pokud bychom se nenauÄili pouÅ¾Ã­vat zvlÃ¡Å¡Å¥ pÅ™ekladaÄ a linker, nemohli bychom pouÅ¾Ã­vat
<a href="c/modularizace/knihovny.html">knihovny</a>, u kterÃ½ch obvykle nemÃ¡me pÅ™Ã­stup k samotnÃ©mu zdrojovÃ©mu kÃ³du, ale pouze k
jiÅ¾ pÅ™eloÅ¾enÃ©mu objektovÃ©mu kÃ³du<sup class='margin-toggle sidenote-number'>4</sup>.</p>
<span class='sidenote'><p><sup class='number'>4</sup>NapÅ™Ã­klad proto, aby autor knihovny &quot;zatajil&quot; pÅ¯vodnÃ­ zdrojovÃ½ kÃ³d, kterÃ½ je jeho duÅ¡evnÃ­m
vlastnictvÃ­m.</p>
</span><h1><a class="header" href="#pouÅ¾Ã­vÃ¡nÃ­-kÃ³du-z-jinÃ½ch-souborÅ¯" id="pouÅ¾Ã­vÃ¡nÃ­-kÃ³du-z-jinÃ½ch-souborÅ¯">PouÅ¾Ã­vÃ¡nÃ­ kÃ³du z jinÃ½ch souborÅ¯</a></h1>
<p>NynÃ­ uÅ¾ vÃ­me, jak pÅ™eloÅ¾it program sklÃ¡dajÃ­cÃ­ se z vÃ­ce jednotek pÅ™ekladu (zdrojovÃ½ch souborÅ¯) a
nÃ¡slednÄ› tyto jednotky spojit dohromady pomocÃ­ linkeru. V tÃ©to sekci si ukÃ¡Å¾eme, jak mÅ¯Å¾eme pouÅ¾Ã­t
kÃ³d, kterÃ½ existuje v jinÃ©m zdrojovÃ©m souboru.</p>
<p>Pokud chceme zavolat funkci, kterou jsme napsali v jinÃ©m souboru, mÅ¯Å¾eme ji prostÄ› zavolat a linker
se postarÃ¡ o zbytek:</p>
<pre><code class="language-c">// soubor1.c
int main() {
    moje_funkce();
    return 0;
}

// soubor2.c
void moje_funkce() {}
</code></pre>
<p>Pokud tyto dva soubory pÅ™eloÅ¾Ã­me a potÃ© slinkujeme, tak se zavolÃ¡ sprÃ¡vnÃ¡ funkce:</p>
<pre><code class="language-bash">$ gcc -c soubor1.c
$ gcc -c soubor2.c
$ gcc soubor1.o soubor2.o -o program
</code></pre>
<p>NicmÃ©nÄ›, pokud bychom pouÅ¾Ã­vali kÃ³d z jinÃ½ch souborÅ¯ takto &quot;naslepo&quot;, narazili bychom na nÄ›kolik
problÃ©mÅ¯. TÃ­m, Å¾e pÅ™ekladaÄ v souboru <code>soubor1.c</code> nemÃ¡ pÅ™Ã­stup k <a href="c/modularizace/../funkce/funkce.html#syntaxe">signatuÅ™e</a>
funkce <code>moje_funkce</code>, tak nemÅ¯Å¾e ovÄ›Å™it, jestli jsme jÃ­ pÅ™edali sprÃ¡vnÃ½ poÄet argumentÅ¯ se sprÃ¡vnÃ½mi
datovÃ½mi typy, a ani nevÃ­, jakÃ½ je datovÃ½ typ nÃ¡vratovÃ© hodnoty tÃ©to funkce.</p>
<p>KÃ³d &quot;naslepo&quot; navÃ­c nebude vÅ¯bec fungovat pro pouÅ¾itÃ­ (globÃ¡lnÃ­ch) promÄ›nnÃ½ch. PÅ™i pokusu o
pouÅ¾itÃ­ neexistujÃ­cÃ­ promÄ›nnÃ© by pÅ™ekladaÄ totiÅ¾ rovnou ohlÃ¡sil chybu.</p>
<h2><a class="header" href="#deklarace-vs-definice" id="deklarace-vs-definice">Deklarace vs definice</a></h2>
<p>IdeÃ¡lnÄ› bychom potÅ™ebovali pÅ™ekladaÄi Å™Ã­ct, jak bude kÃ³d, kterÃ½ chceme pouÅ¾Ã­t, vypadat â€“ jakÃ½ bude
datovÃ½ typ a nÃ¡zev globÃ¡lnÃ­ promÄ›nnÃ©, popÅ™. jakÃ© budou parametry, nÃ¡vratovÃ½ typ a nÃ¡zev funkce.
Toho mÅ¯Å¾eme dosÃ¡hnout pomocÃ­ tzv. <strong>deklarace</strong> (<em>declaration</em>).</p>
<p>Deklarace &quot;slibuje&quot;, Å¾e bude v programu existovat nÄ›jakÃ¡ promÄ›nnÃ¡ Äi funkce s konkrÃ©tnÃ­m nÃ¡zvem a
typem, ale neÅ™Ã­kÃ¡, kde bude tato promÄ›nnÃ¡ Äi funkce vytvoÅ™ena (mÅ¯Å¾e to bÃ½t napÅ™Ã­klad v jinÃ©m
zdrojovÃ©m souboru). SamotnÃ© vytvoÅ™enÃ­ funkce Äi promÄ›nnÃ© se nazÃ½vÃ¡ <strong>definice</strong> (<em>definition</em>).
ZatÃ­m jsme tedy provÃ¡dÄ›li vÅ¾dy definice funkcÃ­ i promÄ›nnÃ½ch, nynÃ­ si ukÃ¡Å¾eme, jak vytvoÅ™it pouze
deklaraci.</p>
<p>Deklaraci funkce provedeme tak, Å¾e zadÃ¡me jejÃ­ <a href="c/modularizace/../funkce/funkce.html#syntaxe">signaturu</a>, ale ne jejÃ­
tÄ›lo:</p>
<pre><code class="language-c">int funkce(int a, int b);           // deklarace funkce
int funkce(int a, int b) { ... }    // definice funkce
</code></pre>
<p>Deklaraci globÃ¡lnÃ­ promÄ›nnÃ© lze provÃ©st tak, Å¾e pÅ™ed nÃ­ dÃ¡me klÃ­ÄovÃ© slovo <code>extern</code><sup class='margin-toggle sidenote-number'>1</sup>:</p>
<span class='sidenote'><p><sup class='number'>1</sup>Toto klÃ­ÄovÃ© slovo mÅ¯Å¾eme pouÅ¾Ã­t i pÅ™ed deklaracÃ­ funkce, nicmÃ©nÄ› nenÃ­ to potÅ™eba, <code>extern</code> je
na tomto mÃ­stÄ› pÅ™edpoklÃ¡dÃ¡no implicitnÄ›.</p>
</span>
<pre><code class="language-c">extern int promenna;    // deklarace promÄ›nnÃ©
int promenna;           // definice promÄ›nnÃ©
</code></pre>
<blockquote>
<p>PÅ™i sdÃ­lenÃ­ kÃ³du napÅ™Ã­Ä soubory mÃ¡ smysl se bavit pouze o
<a href="c/modularizace/../promenne/globalni_promenne.html">globÃ¡lnÃ­ch promÄ›nnÃ½ch</a>. LokÃ¡lnÃ­ promÄ›nnÃ© lze totiÅ¾ pouÅ¾Ã­vat vÅ¾dy
pouze v rÃ¡mci jednÃ© funkce.</p>
</blockquote>
<p>DÃ­ky deklaracÃ­m tak mÅ¯Å¾eme v jednom zdrojovÃ©m souboru urÄit, jak majÃ­ vypadat funkce a promÄ›nnÃ©, kterÃ©
chceme pouÅ¾Ã­vat, aby pÅ™ekladaÄ mohl provÃ¡dÄ›t kontrolu datovÃ½ch typÅ¯. Linker pak bÄ›hem linkovÃ¡nÃ­ pouÅ¾ije
sprÃ¡vnÃ© promÄ›nnÃ©/funkce z odpovÃ­dajÃ­cÃ­ch zdrojovÃ½ch souborÅ¯. VÃ­ce o tom, kde a jak deklarace vytvÃ¡Å™et,
se dozvÃ­me v pÅ™Ã­Å¡tÃ­ sekci o <a href="c/modularizace/hlavickove_soubory.html">hlaviÄkovÃ½ch souborech</a>.</p>
<h2><a class="header" href="#jednoprÅ¯chodovÃ½-pÅ™eklad" id="jednoprÅ¯chodovÃ½-pÅ™eklad">JednoprÅ¯chodovÃ½ pÅ™eklad</a></h2>
<p>Z historickÃ½ch dÅ¯vodÅ¯ pÅ™ekladaÄe <em>C</em> fungujÃ­ v tzv. jednoprÅ¯chodovÃ©m reÅ¾imu (<em>one-pass compilation</em>).
ZnamenÃ¡ to, Å¾e pÅ™ekladaÄ &quot;Äte&quot; nÃ¡Å¡ zdrojovÃ½ kÃ³d shora dolÅ¯, a v momentÄ›, kdy chceme napÅ™Ã­klad pouÅ¾Ã­t
nÄ›jakou funkci nebo promÄ›nnou, tak jiÅ¾ pÅ™ekladaÄ dÅ™Ã­ve musel vidÄ›t (alespoÅˆ) jejÃ­ deklaraci, popÅ™.
rovnou i definici.</p>
<p>NapÅ™Ã­klad v nÃ¡sledujÃ­cÃ­m programu:</p>
<pre><code class="language-c">void funkce1() {
    funkce2();
}
void funkce2() {}
</code></pre>
<p>si pÅ™ekladaÄ bude stÄ›Å¾ovat na to, Å¾e na Å™Ã¡dku 2 neznÃ¡ funkci <code>funkce2</code>, protoÅ¾e tato funkce je v
souboru nadefinovanÃ¡ aÅ¾ po funkci <code>funkce1</code>, kterÃ¡ ji pouÅ¾Ã­vÃ¡:</p>
<pre><code>test.c: In function â€˜funkceâ€™:
test.c:2:5: warning: implicit declaration of function â€˜funkce2â€™;
    2 |     funkce2();
</code></pre>
<p>Pokud tedy potÅ™ebujeme nadefinovat funkci na pozdÄ›jÅ¡Ã­m mÃ­stÄ›, neÅ¾ je jejÃ­ prvnÃ­ pouÅ¾itÃ­, mÅ¯Å¾eme
nejprve vytvoÅ™it jejÃ­ deklaraci a aÅ¾ pozdÄ›ji (popÅ™. v ÃºplnÄ› jinÃ©m souboru) vytvoÅ™it jejÃ­ definici:</p>
<pre><code class="language-c">void funkce2();     // deklarace

void funkce1() {
    funkce2();      // pouÅ¾itÃ­
}
void funkce2() {}   // definice
</code></pre>
<p>TakovÃ½to program uÅ¾ se pÅ™eloÅ¾Ã­ bez varovÃ¡nÃ­. Koncept deklarovÃ¡nÃ­ funkcÃ­ Äi promÄ›nnÃ½ch v
jednoprÅ¯chodovÃ½ch pÅ™ekladaÄÃ­ch se nazÃ½vÃ¡ <strong>dopÅ™ednÃ¡ deklarace</strong> (<em>forward declaration</em>).</p>
<h2><a class="header" href="#pravidlo-jednÃ©-definice" id="pravidlo-jednÃ©-definice">Pravidlo jednÃ© definice</a></h2>
<p>V <em>C</em> platÃ­ tzv. <strong>pravidlo jednÃ© definice</strong> (<em>one definition rule</em>). KaÅ¾dÃ¡ promÄ›nnÃ¡ i funkce musÃ­
bÃ½t v programu <em>nadefinovÃ¡na</em> prÃ¡vÄ› jednou (deklarovÃ¡na mÅ¯Å¾e bÃ½t vÃ­cekrÃ¡t). To platÃ­ jak v rÃ¡mci
jednoho souboru, tak v rÃ¡mci celÃ©ho programu (tj. napÅ™Ã­Ä vÅ¡emi zdrojovÃ½mi soubory).</p>
<ul>
<li>Pokud bychom promÄ›nnou Äi funkci pouze nadeklarovali a/nebo pouÅ¾ili bez definice:
<pre><code class="language-c">// soubor.c
void funkce();

int main() {
    funkce();
    return 0;
}
</code></pre>
Tak by kompilace selhala v dobÄ› linkovÃ¡nÃ­, protoÅ¾e by nenaÅ¡el Å¾Ã¡dnou funkci/promÄ›nnou, kterou
by mohl pouÅ¾Ã­t:
<pre><code class="language-bash">$ gcc -c soubor.c
$ gcc soubor.o
/usr/bin/ld: test.o: in function `main':
test.c:(.text+0xe): undefined reference to `funkce'
collect2: error: ld returned 1 exit status
</code></pre>
</li>
<li>Pokud bychom naopak nadefinovali promÄ›nnou Äi funkci vÃ­ce neÅ¾ jednou:
<pre><code class="language-c">// soubor1.c
void funkce() {}

int main() {
    funkce();
    return 0;
}
// soubor2.c
void funkce() {}
</code></pre>
Tak by linkovÃ¡nÃ­ opÄ›t selhalo, protoÅ¾e by linker nevÄ›dÄ›l, kterou definici pouÅ¾Ã­t:
<pre><code class="language-bash">$ gcc -c soubor1.c
$ gcc -c soubor2.c
$ gcc soubor1.o soubor2.o
/usr/bin/ld: soubor2.o: in function `funkce':
soubor2.c:(.text+0x0): multiple definition of `funkce'; test.o:test.c:(.text+0x0): first defined here
collect2: error: ld returned 1 exit status
</code></pre>
</li>
</ul>
<h2><a class="header" href="#viditelnost-funkcÃ­-a-promÄ›nnÃ½ch" id="viditelnost-funkcÃ­-a-promÄ›nnÃ½ch">Viditelnost funkcÃ­ a promÄ›nnÃ½ch</a></h2>
<p>Z jinÃ½ch souborÅ¯ lze pouÅ¾Ã­vat pouze funkce a promÄ›nnÃ©, kterÃ© jsou <em>veÅ™ejnÃ©</em>. ImplicitnÄ› jsou
vÅ¡echny funkce i vÅ¡echny globÃ¡lnÃ­ promÄ›nnÃ© veÅ™ejnÃ©. Pokud byste chtÄ›li zamezit tomu, aby mohly
ostatnÃ­ soubory pouÅ¾Ã­vat nÄ›jakou funkci nebo globÃ¡lnÃ­ promÄ›nnou, mÅ¯Å¾ete ji oznaÄit klÃ­ÄovÃ½m slovem
<code>static</code>, abyste z nich udÄ›lali <em>soukromÃ©</em> funkce Äi promÄ›nnÃ©:</p>
<pre><code class="language-c">static void soukroma_funkce() {}
static int soukroma_promenna;
</code></pre>
<p>TakovÃ©to funkce a promÄ›nnÃ© pÅ¯jde pouÅ¾Ã­vat pouze v souboru, ve kterÃ©m byly nadefinovÃ¡ny. DoporuÄujeme
<code>static</code> pouÅ¾Ã­vat pro oznaÄenÃ­ promÄ›nnÃ½ch a funkcÃ­, kterÃ© nechcete sdÃ­let se zbytkem programu. PÅ¯jde
tak na prvnÃ­ pohled poznat, kterÃ© funkce jsou urÄeny k pouÅ¾itÃ­ z jinÃ½ch souborÅ¯ a kterÃ© ne<sup class='margin-toggle sidenote-number'>2</sup>.</p>
<span class='sidenote'><p><sup class='number'>2</sup>PouÅ¾itÃ­ <code>static</code> takÃ© mÅ¯Å¾e v urÄitÃ½ch pÅ™Ã­padech vÃ©st k vygenerovÃ¡nÃ­ efektivnÄ›jÅ¡Ã­ho kÃ³du a
menÅ¡Ã­ velikosti vÃ½slednÃ©ho spustitelnÃ©ho souboru.</p>
</span>
<blockquote>
<p>KlÃ­ÄovÃ© slovo <code>static</code> lze takÃ© pouÅ¾Ã­t u lokÃ¡lnÃ­ch promÄ›nnÃ½ch, zde mÃ¡ ovÅ¡em ÃºplnÄ› jinÃ½ vÃ½znam neÅ¾
u globÃ¡lnÃ­ch promÄ›nnÃ½ch! PouÅ¾itÃ­ <code>static</code> u lokÃ¡lnÃ­ promÄ›nnÃ© z nÃ­ udÄ›lÃ¡ promÄ›nnou uloÅ¾enou v
<a href="c/modularizace/../prace_s_pameti/globalni_pamet.html">globÃ¡lnÃ­ pamÄ›ti</a>. TakovÃ¡to promÄ›nnÃ¡ se nainicializuje, kdyÅ¾
se program poprvÃ© dostane k Å™Ã¡dku s jejÃ­ definicÃ­. PromÄ›nnÃ¡ bude existovat po celou dobu bÄ›hu
programu a udrÅ¾Ã­ si svou hodnotu i po skonÄenÃ­ volÃ¡nÃ­ funkce:</p>
<pre><code class="language-c editable">#include &lt;stdio.h&gt;

void test() {
  static int x = 0;
  x += 1;
  printf(&quot;%d\n&quot;, x);
}

int main() {
  test();
  test();
  return 0;
}
</code></pre>
</blockquote>
<h1><a class="header" href="#hlaviÄkovÃ©-soubory" id="hlaviÄkovÃ©-soubory">HlaviÄkovÃ© soubory</a></h1>
<p>NynÃ­ uÅ¾ vÃ­me, Å¾e pro pouÅ¾itÃ­ kÃ³du z jinÃ½ch souborÅ¯ bychom nejprve mÄ›li danÃ© funkce a promÄ›nnÃ©
<a href="c/modularizace/pouzivani_kodu_z_jinych_souboru.html#deklarace-vs-definice">deklarovat</a>. Pokud bychom vÅ¡ak museli
v kaÅ¾dÃ©m souboru, ve kterÃ©m chceme pouÅ¾Ã­t kÃ³d z jinÃ©ho souboru, museli vytvÃ¡Å™et deklarace pro
kaÅ¾dou funkci Äi promÄ›nnou, kterou chceme pouÅ¾Ã­t, bylo by to docela zdlouhavÃ©. Pokud by navÃ­c doÅ¡lo
ke zmÄ›nÄ› datovÃ©ho typu Äi nÃ¡zvu takovÃ©to sdÃ­lenÃ© funkce Äi promÄ›nnÃ©, museli bychom deklarace upravit
ve vÅ¡ech souborech, kde funkci Äi promÄ›nnou pouÅ¾Ã­vÃ¡me.</p>
<p>Pro vyÅ™eÅ¡enÃ­ tohoto problÃ©mu se v <em>C</em> Äasto vyuÅ¾Ã­vÃ¡ koncept tzv. <strong>hlaviÄkovÃ½ch souborÅ¯</strong>
(<em>header files</em>). Pro kaÅ¾dÃ½ zdrojovÃ½ soubor, jehoÅ¾ kÃ³d chceme sdÃ­let, vytvoÅ™Ã­me hlaviÄkovÃ½ soubor,
kterÃ½ bude obsahovat deklarace vÅ¡ech sdÃ­lenÃ½ch veÅ™ejnÃ½ch funkcÃ­ a globÃ¡lnÃ­ch promÄ›nnÃ½ch z danÃ©ho
zdrojovÃ©ho souboru. Ve zdrojovÃ©m souboru pak budou jejich definice. Dle jmennÃ© konvence se hlaviÄkovÃ½
soubor pojmenovÃ¡vÃ¡ jako <code>&lt;nÃ¡zev zdrojovÃ©ho souboru&gt;.h</code>:</p>
<pre><code class="language-c">// soubor.h (deklarace)
int moje_funkce();
extern int moje_promenna;

// soubor.c (definice)
int moje_funkce() {}
int moje_promenna;
</code></pre>
<p>HlaviÄkovÃ½ soubor tak udÃ¡vÃ¡ tzv. <strong>rozhranÃ­</strong> (<em>interface</em>) odpovÃ­dajÃ­cÃ­ho zdrojovÃ©ho souboru â€“
obsahuje seznam funkcÃ­ a promÄ›nnÃ½ch, kterÃ© jsou sdÃ­lenÃ© a zbytek programu je mÅ¯Å¾e pouÅ¾Ã­vat.</p>
<p>OstatnÃ­ soubory, kterÃ© chtÄ›jÃ­ funkce z nÄ›jakÃ©ho zdrojovÃ©ho souboru pouÅ¾Ã­t, pak
<a href="c/modularizace/../preprocesor/vkladani_souboru.html">vloÅ¾Ã­</a> jeho hlaviÄkovÃ½ soubor pomocÃ­ preprocesoru, aby mohly
pouÅ¾Ã­vat sdÃ­lenÃ© funkce a globÃ¡lnÃ­ promÄ›nnÃ© s korektnÃ­ kontrolou datovÃ½ch typÅ¯:</p>
<pre><code class="language-c">// main.c
#include &quot;soubor.h&quot;

int main() {
    moje_funkce();
    int x = moje_promenna;

    return 0;
}
</code></pre>
<p>Pokud dojde ke zmÄ›nÄ› signatury funkce Äi typu/nÃ¡zvu promÄ›nnÃ©, tak staÄÃ­ zmÄ›nu udÄ›lat v hlaviÄkovÃ©m
(a odpovÃ­dajÃ­cÃ­m zdrojovÃ©m) souboru. VÅ¡echny ostatnÃ­ soubory, kterÃ© danou funkci nebo promÄ›nnou
pouÅ¾Ã­vajÃ­, pak budou okamÅ¾itÄ› vyuÅ¾Ã­vat upravenou deklaraci dÃ­ky pouÅ¾itÃ­ <code>#include</code>.</p>
<p>S hlaviÄkovÃ½mi soubory jsme jiÅ¾ setkali pÅ™i pouÅ¾itÃ­ <a href="c/modularizace/../funkce/stdlib.html">standardnÃ­ knihovny</a>. V
souborech jako je <code>stdio.h</code> se nachÃ¡zejÃ­ deklarace funkcÃ­ jako je napÅ™Ã­klad <code>printf</code>, jejichÅ¾ definice
je potÃ© obsaÅ¾ena v objektovÃ½ch souborech standardnÃ­ knihovny.</p>
<h2><a class="header" href="#obsah-hlaviÄkovÃ©ho-souboru" id="obsah-hlaviÄkovÃ©ho-souboru">Obsah hlaviÄkovÃ©ho souboru</a></h2>
<p>JelikoÅ¾ hlaviÄkovÃ© soubory jsou urÄeny k tomu, aby byly vyuÅ¾Ã­vÃ¡ny (vklÃ¡dÃ¡ny) v rÅ¯znÃ½ch zdrojovÃ½ch
souborech, tak se jejich obsah pÅ™irozenÄ› mÅ¯Å¾e vyskytnout ve vÃ­ce jednotkÃ¡ch pÅ™ekladu. Aby tak nebylo
poruÅ¡eno <a href="c/modularizace/pouzivani_kodu_z_jinych_souboru.html#pravidlo-jedn%C3%A9-definice">pravidlo jednÃ© definice</a>, je
dÅ¯leÅ¾itÃ© do hlaviÄkovÃ½ch souborÅ¯ dÃ¡vat <strong>pouze deklarace, a ne definice</strong> funkcÃ­ a promÄ›nnÃ½ch!</p>
<p>Pokud byste do hlaviÄkovÃ©ho souboru dali napÅ™Ã­klad definici funkce, a tento soubor by se vyskytnul
ve vÃ­ce jednotkÃ¡ch pÅ™ekladu, tak by linkovÃ¡nÃ­ selhalo kvÅ¯li vÃ­cenÃ¡sobnÃ© definici. Pokud byste
pÅ™ecejenom opravdu chtÄ›li definici nÄ›jakÃ© funkce &quot;propaÅ¡ovat&quot; do hlaviÄkovÃ©ho souboru, mÅ¯Å¾ete pÅ™ed
nÃ­ pouÅ¾Ã­t klÃ­ÄovÃ© slovo <code>inline</code>:</p>
<pre><code class="language-c">// soubor.h
inline void moje_funkce() { ... }
</code></pre>
<p>TÃ­mto klÃ­ÄovÃ½m slovem slibujete linkeru, Å¾e vÅ¡echny definice funkce s tÃ­mto nÃ¡zvem jsou stejnÃ©.
Pokud tak linker narazÃ­ na definici tÃ©to funkce vÃ­cekrÃ¡t (coÅ¾ nastane, kdyÅ¾ tento hlaviÄkovÃ½ soubor
bude vloÅ¾en ve vÃ­ce jednotkÃ¡ch pÅ™ekladu), tak nebude hlÃ¡sit chybu, ale prostÄ› si jednu z tÄ›chto
definicÃ­ vybere. Pokud by definice stejnÃ© nebyly, mÅ¯Å¾e to vÃ©st k <a href="c/modularizace/../../ruzne/nedefinovane_chovani.html">nedefinovanÃ©mu chovÃ¡nÃ­</a>
ğŸ’£. Pokuste se tak <code>inline</code> radÄ›ji nevyuÅ¾Ã­vat.</p>
<blockquote>
<p>U (globÃ¡lnÃ­ch) promÄ›nnÃ½ch nemÃ¡ smysl <code>inline</code> pouÅ¾Ã­vat.</p>
</blockquote>
<p>KromÄ› deklaracÃ­ funkcÃ­ a promÄ›nnÃ½ch se do hlaviÄkovÃ½ch souborÅ¯ takÃ© bÄ›Å¾nÄ› vklÃ¡dajÃ­ struktury, kterÃ©
jsou souÄÃ¡stÃ­ typÅ¯ sdÃ­lenÃ½ch promÄ›nnÃ½ch Äi parametrÅ¯ a nÃ¡vratovÃ½ch hodnot sdÃ­lenÃ½ch funkcÃ­.</p>
<p>Aby mohly zdrojovÃ© soubory pouÅ¾Ã­vat sdÃ­lenÃ© struktury i sdÃ­lenÃ© funkce v
<a href="c/modularizace/pouzivani_kodu_z_jinych_souboru.html#jednopr%C5%AFchodov%C3%BD-p%C5%99eklad">libovolnÃ©m poÅ™adÃ­</a>, tak obvykle zdrojovÃ©
soubory vklÃ¡dajÃ­ svÅ¯j vlastnÃ­ hlaviÄkovÃ½ soubor:</p>
<pre><code class="language-c">// soubor.h
typedef struct {
    int vek;
} Osoba;

int zpracuj_osobu(Osoba osoba);

// soubor.c
#include &quot;soubor.h&quot;
int zpracuj_osobu(Osoba osoba) { ... }
</code></pre>
<p>Pro pouÅ¾itÃ­ struktur nebo napÅ™.
<a href="c/modularizace/../struktury/struktury.html#vytv%C3%A1%C5%99en%C3%AD-nov%C3%BDch-jmen-pro-datov%C3%A9-typy"><code>typedefÅ¯</code></a> z ostatnÃ­ch souborÅ¯
je takÃ© bÄ›Å¾nÃ©, Å¾e hlaviÄkovÃ© soubory vklÃ¡dajÃ­ jinÃ© hlaviÄkovÃ© soubory.</p>
<h2><a class="header" href="#ochrana-vklÃ¡dÃ¡nÃ­" id="ochrana-vklÃ¡dÃ¡nÃ­">Ochrana vklÃ¡dÃ¡nÃ­</a></h2>
<p>U hlaviÄkovÃ½ch souborÅ¯ je nutnÃ© Å™eÅ¡it jeÅ¡tÄ› jednu dalÅ¡Ã­ vÄ›c. JelikoÅ¾ se bÄ›Å¾nÄ› pouÅ¾Ã­vajÃ­ v kombinaci
s <code>#include</code>, mÅ¯Å¾e se stÃ¡t, Å¾e i v rÃ¡mci jednÃ© jednotky pÅ™ekladu se jeden hlaviÄkovÃ½ soubor vloÅ¾Ã­ do
vÃ½slednÃ©ho zdrojovÃ©ho souboru vÃ­ce neÅ¾ jednou. To mÅ¯Å¾e zpÅ¯sobovat rÅ¯znÃ© typy problÃ©mÅ¯:</p>
<ul>
<li>Pokud se budou hlaviÄkovÃ© soubory vklÃ¡dat navzÃ¡jem, mohlo by dojÃ­t k cyklickÃ© zÃ¡vislosti. NapÅ™Ã­klad
zde by pÅ™eklad selhal, protoÅ¾e by se hlaviÄkovÃ© soubory snaÅ¾ili vloÅ¾it se navzÃ¡jem donekoneÄna:
<pre><code class="language-c">// a.h
#include &quot;b.h&quot;

// b.h
#include &quot;a.h&quot;
</code></pre>
</li>
<li>HlaviÄkovÃ½ soubor se zbyteÄnÄ› vÃ­cekrÃ¡t naÄÃ­tÃ¡ pÅ™ekladaÄem, coÅ¾ prodluÅ¾uje dobu pÅ™ekladu.</li>
<li>Pokud by hlaviÄkovÃ½ soubor obsahoval nÄ›jakou definici, tak i kdyby byl pouÅ¾it pouze v jednÃ©
jednotce pÅ™ekladu, doÅ¡lo by k chybÄ› pÅ™i linkovÃ¡nÃ­, protoÅ¾e by definice byla zduplikovanÃ¡. </li>
</ul>
<p>Abychom tÄ›mto situacÃ­m zamezili, tak u hlaviÄkovÃ½ch souborÅ¯ budeme pouÅ¾Ã­vat tzv. <strong>ochranu vklÃ¡dÃ¡nÃ­</strong>
(<em>include guard</em>). PomocÃ­ ochrany vklÃ¡dÃ¡nÃ­ zajistÃ­me, Å¾e jeden hlaviÄkovÃ½ soubor se v rÃ¡mci jednÃ©
jednotky pÅ™ekladu vloÅ¾Ã­ maximÃ¡lnÄ› jednou.</p>
<p>ZamezenÃ­ vÃ­cenÃ¡sobnÃ©ho vloÅ¾enÃ­ mÅ¯Å¾eme dosÃ¡hnout pomocÃ­
<a href="c/modularizace/../preprocesor/makra.html#podm%C3%ADn%C4%9Bn%C3%BD-p%C5%99eklad">podmÃ­nÄ›nÃ©ho pÅ™ekladu</a>:</p>
<pre><code class="language-c">// soubor.h
#ifndef SOUBOR_H
#define SOUBOR_H

void moje_funkce();

#endif
</code></pre>
<p>Tohle je nicmÃ©nÄ› trochu zdlouhavÃ©. ModernÃ­ pÅ™ekladaÄe obsahujÃ­ mnohem jednoduÅ¡Å¡Ã­ zpÅ¯sob. Na zaÄÃ¡tek
hlaviÄkovÃ©ho souboru staÄÃ­ vÅ¾dy vloÅ¾it Å™Ã¡dek <code>#pragma once</code> a dÃ¡l nemusÃ­te nic Å™eÅ¡it:</p>
<pre><code class="language-c">// soubor.h
#pragma once

void moje_funkce();
</code></pre>
<h1><a class="header" href="#knihovny" id="knihovny">Knihovny</a></h1>
<p>NynÃ­ uÅ¾ znÃ¡me vÅ¡e potÅ™ebnÃ© na to, abychom si rozdÄ›lili nÃ¡Å¡ vlastnÃ­ program do libovolnÃ©ho mnoÅ¾stvÃ­
zdrojovÃ½ch souborÅ¯. ÄŒasto takÃ© ale budeme chtÃ­t pouÅ¾Ã­vat kÃ³d, kterÃ½ uÅ¾ pÅ™ed nÃ¡mi napsal nÄ›kdo jinÃ½.
Pokud bychom si totiÅ¾ museli vÅ¡e psÃ¡t od nuly, tak bychom se daleko nedostali<sup class='margin-toggle sidenote-number'>1</sup>, respektive trvalo
by nÃ¡m to dlouho.</p>
<span class='sidenote'><p><sup class='number'>1</sup>I kdyÅ¾ napsat si nÄ›jakÃ½ systÃ©m &quot;od nuly&quot; je dobrÃ½ zpÅ¯sob, jak se
<a href="c/modularizace/../co_dal.html#co-se-d%C3%A1le-nau%C4%8Dit">zlepÅ¡it v programovÃ¡nÃ­</a>.</p>
</span>
<p>Aby programÃ¡toÅ™i mohli sdÃ­let svÅ¯j kÃ³d s ostatnÃ­mi programÃ¡tory, tak vyuÅ¾Ã­vajÃ­ tzv. <strong>knihovny</strong>
(<em>libraries</em>). Knihovna je kÃ³d, kterÃ½ Å™eÅ¡Ã­ nÄ›jakou ucelenou funkcionalitu (napÅ™.
<a href="https://www.libsdl.org/">vykreslovÃ¡nÃ­ grafiky</a>, <a href="https://www.freetype.org/">sazbu fontÅ¯</a> nebo
<a href="http://zlib.net/">kompresi dat</a>) a obsahuje nÃ¡vod (dokumentaci), jak tento kÃ³d pouÅ¾Ã­vat. KlÃ­ÄovÃ©
vlastnosti knihoven jsou znovupouÅ¾itelnost (mÅ¯Å¾eme je pouÅ¾Ã­t v rÅ¯znÃ½ch programech) a abstrakce
(nemusÃ­me rozumÄ›t, jak knihovna funguje, pouze ji vyuÅ¾ijeme k vyÅ™eÅ¡enÃ­ konkrÃ©tnÃ­ho problÃ©mu).</p>
<blockquote>
<p>Knihovna nenÃ­ program â€“ neobsahuje Å¾Ã¡dnou funkci <code>main</code> a nelze ji ani pÅ™Ã­mo spustit. V kontextu
jazyka <em>C</em> je knihovna typicky sada funkcÃ­, struktur a globÃ¡lnÃ­ch promÄ›nnÃ½ch.</p>
</blockquote>
<p>NapÅ™Ã­klad pokud bychom programovali hru, mÅ¯Å¾eme vyuÅ¾Ã­t knihovny na vykreslenÃ­ grafiky, na pÅ™ehrÃ¡vÃ¡nÃ­
zvuku, na snÃ­mÃ¡nÃ­ vstupu z klÃ¡vesnice nebo myÅ¡i atd. NÃ¡Å¡ kÃ³d se pak mÅ¯Å¾e zabÃ½vat zejmÃ©na logikou hry
a nemusÃ­ tolik Å™eÅ¡it problÃ©my, kterÃ© jiÅ¾ vyÅ™eÅ¡ila spousta programÃ¡torÅ¯ pÅ™ed nÃ¡mi.</p>
<p>Na internetu mÅ¯Å¾ete naleznout <a href="https://github.com/kozross/awesome-c">tisice rÅ¯znÃ½ch knihoven</a>,
kterÃ© Å™eÅ¡Ã­ rozliÅ¡nÃ© problÃ©my.</p>
<h2><a class="header" href="#sdÃ­lenÃ­-knihoven" id="sdÃ­lenÃ­-knihoven">SdÃ­lenÃ­ knihoven</a></h2>
<p>Teoreticky bychom mohli knihovny pouÅ¾Ã­vat prostÄ› tak, Å¾e si nÄ›jakou najdeme na internetu, stÃ¡hneme
jejÃ­ hlaviÄkovÃ© a zdrojovÃ© soubory k naÅ¡emu programu a zaÄneme je vyuÅ¾Ã­vat. I kdyÅ¾ i tak to lze nÄ›kdy
udÄ›lat, nenÃ­ to obvyklÃ©, protoÅ¾e tento pÅ™Ã­stup mÃ¡ spoustu nevÃ½hod:</p>
<ul>
<li>JelikoÅ¾ obvykle nebudeme autory knihovny, kterou chceme pouÅ¾Ã­t, tak nemusÃ­me ani bÃ½t schopnÃ­
danou knihovnu pÅ™eloÅ¾it. PotÅ™ebuje danÃ¡ knihovna konkrÃ©tnÃ­ pÅ™ekladaÄ nebo jeho specifickÃ© nastavenÃ­?
MÃ¡ zÃ¡vislosti na dalÅ¡Ã­ch knihovnÃ¡ch? PÅ™eloÅ¾it &quot;cizÃ­&quot; knihovnu ze zdrojovÃ½ch souborÅ¯ nemusÃ­ bÃ½t
zdaleka pÅ™Ã­moÄarÃ©.</li>
<li>Pokud dojde k vydÃ¡nÃ­ novÃ© verze knihovny, kterÃ¡ mÅ¯Å¾e pÅ™inÃ¡Å¡et opravy chyb a novou funkcionalitu,
museli bychom (kromÄ› potenciÃ¡lnÃ­ Ãºpravy naÅ¡eho kÃ³du) takÃ© pÅ™ekopÃ­rovat nebo sprÃ¡vnÄ› upravit novÃ© a
zmÄ›nÄ›nÃ© soubory knihovny, coÅ¾ by bylo nÃ¡roÄnÃ© a nÃ¡chylnÃ© na chyby.</li>
<li>ZdrojovÃ½ kÃ³d knihoven nenÃ­ vÅ¾dy zveÅ™ejnÄ›n, napÅ™Ã­klad aby si jejich autoÅ™i uchrÃ¡nili duÅ¡evnÃ­
vlastnictvÃ­. ÄŒasto se tak setkÃ¡me se situacÃ­, Å¾e mÃ¡me k dispozici pouze objektovÃ½ kÃ³d (napÅ™. <code>.so</code>
nebo <code>.dll</code>) a nemÅ¯Å¾eme tak zÃ­skat zdrojovÃ© soubory knihovny.</li>
</ul>
<p>Z tohoto dÅ¯vodu jsou knihovny obvykle sdÃ­leny ve formÄ› objektovÃ½ch souborÅ¯ (ty obsahujÃ­ implementaci
funkcÃ­) a odpovÃ­dajÃ­cÃ­ch hlaviÄkovÃ½ch souborÅ¯ (ty obsahujÃ­
<a href="c/modularizace/pouzivani_kodu_z_jinych_souboru.html#deklarace-vs-definice">deklarace</a>, aby Å¡lo knihovnu jednoduÅ¡e
pouÅ¾Ã­vat).</p>
<h2><a class="header" href="#statickÃ©-vs-dynamickÃ©-knihovny" id="statickÃ©-vs-dynamickÃ©-knihovny">StatickÃ© vs dynamickÃ© knihovny</a></h2>
<p>PÅ™edÃ¡vat pÅ™ekladaÄi desÃ­tky Äi stovky objektovÃ½ch souborÅ¯ by bylo docela nepraktickÃ©, proto se tyto
soubory pÅ™i distribuci knihovny balÃ­ do jednoho Äi vÃ­ce archivÅ¯, kterÃ© majÃ­ standardizovanÃ½ formÃ¡t
a pÅ™ekladaÄe s nimi umÃ­ pÅ™Ã­mo pracovat. Knihovna mÅ¯Å¾e bÃ½t distribuovÃ¡na v jednom ze dvou typÅ¯ archivÅ¯,
kterÃ© urÄujÃ­ to, jak bude danÃ¡ knihovna &quot;pÅ™ilinkovÃ¡na&quot; (pÅ™ipojena) k naÅ¡emu programu:</p>
<ul>
<li>
<p><strong>DynamickÃ¡ knihovna</strong> (<em>dynamic library</em>) - objektovÃ© soubory takovÃ©to knihovny nebudou souÄÃ¡stÃ­
naÅ¡eho programu (tj. nebudou obsaÅ¾eny ve spustitelnÃ©m souboru, kterÃ½ bude vytvoÅ™en pÅ™ekladaÄem).
K jejich naÄtenÃ­ dojde aÅ¾ &quot;dynamicky&quot; pÅ™i spuÅ¡tÄ›nÃ­ programu<sup class='margin-toggle sidenote-number'>2</sup>.</p>
<span class='sidenote'><p><sup class='number'>2</sup>O toto naÄÃ­tÃ¡nÃ­ se starÃ¡ tzv. <a href="https://man7.org/linux/man-pages/man8/ld.so.8.html">dynamickÃ½ linker</a>.</p>
</span>
<p>VÃ½hody tohoto pÅ™Ã­stupu jsou, Å¾e bude mÃ­t nÃ¡Å¡ spustitelnÃ½ soubor menÅ¡Ã­ velikost, a to jak na disku,
tak v operaÄnÃ­ pamÄ›ti. OperaÄnÃ­ systÃ©my totiÅ¾ dokÃ¡Å¾ou stejnou dynamickou knihovnu ÄÃ¡steÄnÄ› sdÃ­let
mezi vÃ­ce bÄ›Å¾Ã­cÃ­mi programy najednou. Dynamickou knihovnu takÃ© pÅ¯jde aktualizovat bez nutnosti
pÅ™eklÃ¡dat znovu nÃ¡Å¡ program a mÅ¯Å¾eme takÃ© pÅ™i spuÅ¡tÄ›nÃ­ programu knihovnu
<a href="https://stackoverflow.com/questions/426230/what-is-the-ld-preload-trick">nahradit jinou implementacÃ­</a>.</p>
<p>NevÃ½hodou je, Å¾e pÅ™i spuÅ¡tÄ›nÃ­ naÅ¡eho programu musÃ­me zajistit, Å¾e knihovna bude na danÃ©m systÃ©mu
k dispozici (pokud by nebyla nalezena, tak program nepÅ¯jde spustit). To mÅ¯Å¾e zpÅ¯sobovat problÃ©my
zejmÃ©na pÅ™i distribuci naÅ¡eho programu na jinÃ© poÄÃ­taÄe. KvÅ¯li tomu, Å¾e se knihovna naÄÃ­tÃ¡
dynamicky, takÃ© mÅ¯Å¾e v urÄitÃ½ch pÅ™Ã­padech bÃ½t jejÃ­ pouÅ¾itÃ­ mÃ©nÄ› efektivnÃ­ neÅ¾ v pÅ™Ã­padÄ› statickÃ©
knihovny.</p>
<p>Archivy s objektovÃ½mi soubory dynamickÃ½ch knihoven majÃ­ pÅ™Ã­ponu <code>.so</code>.</p>
</li>
<li>
<p><strong>StatickÃ¡ knihovna</strong> (<em>static library</em>) - objektovÃ© soubory takovÃ©to knihovny budou pÅ™Ã­mo pÅ™ibaleny
k naÅ¡emu programu (jako bychom je pÅ™Ã­mo jeden po druhÃ©m pÅ™edali pÅ™ekladaÄi).</p>
<p>VÃ½hody tohoto pÅ™Ã­stupu jsou, Å¾e nÃ¡Å¡ program bude &quot;samostatnÃ½&quot; â€“ knihovnu bude obsahovat uvnitÅ™
svÃ©ho spustitelnÃ©ho souboru, takÅ¾e nebude nutnÃ© ji mÃ­t dostupnou na cÃ­lovÃ©m systÃ©mu (narozdÃ­l
od dynamickÃ© knihovny).</p>
<p>NevÃ½hodou je, Å¾e vÃ½slednÃ½ spustitelnÃ½ soubor bude vÄ›tÅ¡Ã­ a knihovnu nepÅ¯jde aktualizovat bez
opÄ›tovnÃ©ho pÅ™ekladu celÃ©ho programu.</p>
<p>Archivy s objektovÃ½mi soubory statickÃ½ch knihoven majÃ­ pÅ™Ã­ponu <code>.a</code>.</p>
</li>
</ul>
<blockquote>
<p>NÃ¡zvy pÅ™Ã­pon statickÃ½ch a dynamickÃ½ch knihoven zÃ¡visÃ­ na operaÄnÃ­m systÃ©mu. NapÅ™Ã­klad na Windows
se mÅ¯Å¾ete setkat s pÅ™Ã­ponami <code>.lib</code> pro statickÃ© knihovny a <code>.dll</code> pro dynamickÃ© knihovny.</p>
</blockquote>
<h2><a class="header" href="#pouÅ¾itÃ­-knihoven-s-gcc" id="pouÅ¾itÃ­-knihoven-s-gcc">PouÅ¾itÃ­ knihoven s <code>gcc</code></a></h2>
<p>NynÃ­ si ukÃ¡Å¾eme, jak Å™Ã­ct pÅ™ekladaÄi <code>gcc</code>, aby pÅ™ipojil nÄ›jakou knihovnu k naÅ¡emu programu. Pro to
musÃ­me mÃ­t k dispozici archiv s objektovÃ½mi soubory knihovny (s pÅ™Ã­ponou <code>.a</code> nebo <code>.so</code>, v
zÃ¡vislosti na typu knihovny) a obvykle takÃ© i adresÃ¡Å™ s hlaviÄkovÃ½mi soubory knihovny.</p>
<p>Nejprve si ukÃ¡Å¾eme, jak pÅ™ekladaÄi pÅ™edat cestu k hlaviÄkovÃ½m souborÅ¯m knihovny. Ty obvykle nebudou
souÄÃ¡stÃ­ naÅ¡ich zdrojovÃ½ch kÃ³dÅ¯, ale budou nainstalovÃ¡ny v nÄ›jakÃ©m systÃ©movÃ©m adresÃ¡Å™i (jako tomu je
napÅ™. u <code>stdio.h</code>). Budeme je tedy chtÃ­t <a href="c/modularizace/../preprocesor/vkladani_souboru.html">vklÃ¡dat</a> pomocÃ­ syntaxe
<code>#include &lt;&gt;</code>. PÅ™ekladaÄi mÅ¯Å¾eme pÅ™edat dodateÄnÃ© adresÃ¡Å™e, ve kterÃ½ch mÃ¡ hledat (hlaviÄkovÃ©) soubory
pro vklÃ¡dÃ¡nÃ­, pomocÃ­ pÅ™epÃ­naÄe <code>-I</code>. Pokud bychom tak mÄ›li hlaviÄkovÃ© soubory knihovny napÅ™. v
adresÃ¡Å™i <code>/usr/foo/include</code>, tak pÅ™ekladaÄi pÅ™i pÅ™ekladu pÅ™edÃ¡me pÅ™epÃ­naÄ <code>-I/usr/foo/include</code>.</p>
<p>DÃ¡le je tÅ™eba pÅ™ekladaÄi Å™Ã­ct, kterÃ© archivy s objektovÃ½mi soubory knihovny mÃ¡ k naÅ¡emu programu
pÅ™ilinkovat. K tomu slouÅ¾Ã­ dva pÅ™epÃ­naÄe. <code>-L</code> udÃ¡vÃ¡ adresÃ¡Å™, ve kterÃ©m se budou vyhledÃ¡vat knihovny
a <code>-l</code> potÃ© specifikuje konkrÃ©tnÃ­ knihovnu, kterÃ¡ mÃ¡ bÃ½t pÅ™ilinkovÃ¡na k naÅ¡emu programu. Pokud bychom
tak mÄ›li napÅ™Ã­klad archiv knihovny v souboru <code>/usr/foo/lib/libknihovna.so</code>, tak pÅ™ekladaÄi pÅ™edÃ¡me
parametry<code>-L/usr/foo/lib</code> a <code>-lknihovna</code>. PÅ™i pouÅ¾itÃ­ pÅ™epÃ­naÄe <code>-l</code> je tÅ™eba si dÃ¡vat pozor na dvÄ›
vÄ›ci:</p>
<ul>
<li>VÅ¡imnÄ›te si, Å¾e se pouÅ¾ila zkrÃ¡cenÃ¡ konvence pro pojmenovÃ¡nÃ­ knihovny. ObecnÄ› se knihovny
pojmenovÃ¡vajÃ­ <code>lib&lt;nÃ¡zev&gt;.so</code> (nebo <code>lib&lt;nÃ¡zev&gt;.a</code>) a pÅ™ekladaÄi se potÃ© pÅ™edÃ¡vÃ¡ pouze jejich nÃ¡zev,
tj. <code>-l&lt;nÃ¡zev&gt;</code>.</li>
<li>PÅ™epÃ­naÄ <code>-l</code> se aplikuje na zdrojovÃ©/objektovÃ© soubory, kterÃ© byly v pÅ™Ã­kazovÃ© Å™Ã¡dce zadÃ¡ny pÅ™ed
nÃ­m. PouÅ¾Ã­vejte jej tedy aÅ¾ po pÅ™edÃ¡nÃ­ vaÅ¡ich zdrojovÃ½ch souborÅ¯:
<pre><code class="language-bash"># sprÃ¡vnÄ›
$ gcc main.c -lknihovna

# Å¡patnÄ›
$ gcc -lknihovna main.c
</code></pre>
</li>
</ul>
<p>CelÃ½ pÅ™Ã­kaz pro pÅ™ipojenÃ­ knihovny k vaÅ¡emu programu by tak mohl vypadat napÅ™. takto:</p>
<pre><code class="language-bash">$ gcc -o program main.c -L/usr/foo/lib/ -lfoo -I/usr/foo/include
</code></pre>
<h3><a class="header" href="#pÅ™edÃ¡nÃ­-cesty-k-dynamickÃ©-knihovnÄ›" id="pÅ™edÃ¡nÃ­-cesty-k-dynamickÃ©-knihovnÄ›">PÅ™edÃ¡nÃ­ cesty k dynamickÃ© knihovnÄ›</a></h3>
<p>Pokud pÅ™eloÅ¾Ã­te program s dynamickou knihovnou, mÅ¯Å¾e se stÃ¡t, Å¾e pÅ™i jeho spuÅ¡tÄ›nÃ­ nebude schopen
danou knihovnu najÃ­t. V takovÃ©m pÅ™Ã­padÄ› pÅ™i spuÅ¡tÄ›nÃ­ programu mÅ¯Å¾ete pomocÃ­
<a href="https://cs.wikipedia.org/wiki/Prom%C4%9Bnn%C3%A1_prost%C5%99ed%C3%AD"><strong>promÄ›nnÃ© prostÅ™edÃ­</strong></a><sup class='margin-toggle sidenote-number'>3</sup>
(<em>environment variable</em>) <code>LD_LIBRARY_PATH</code> pÅ™edat cestu k adresÃ¡Å™i, ve kterÃ© se danÃ¡ knihovna nachÃ¡zÃ­:</p>
<span class='sidenote'><p><sup class='number'>3</sup>PromÄ›nnÃ© prostÅ™edÃ­ jsou zpÅ¯sobem, jak pÅ™edÃ¡vat parametry programÅ¯m (podobnÄ› jako
napÅ™Ã­klad <a href="c/modularizace/../../ruzne/funkce_main.html#vstupn%C3%AD-parametry-funkce-main">parametry pÅ™Ã­kazovÃ©ho Å™Ã¡dku</a>).
V programu si mÅ¯Å¾ete pÅ™eÄÃ­st hodnotu konkrÃ©tnÃ­ promÄ›nnÃ© prostÅ™edÃ­ pomocÃ­ funkce
<a href="https://devdocs.io/c/program/getenv"><code>getenv</code></a>.</p>
</span>
<pre><code class="language-bash">$ LD_LIBRARY_PATH=/usr/foo/lib ./program
</code></pre>
<h3><a class="header" href="#zobrazenÃ­-vyÅ¾adovanÃ½ch-dynamickÃ½ch-knihoven" id="zobrazenÃ­-vyÅ¾adovanÃ½ch-dynamickÃ½ch-knihoven">ZobrazenÃ­ vyÅ¾adovanÃ½ch dynamickÃ½ch knihoven</a></h3>
<p>Pokud si pÅ™eloÅ¾Ã­te nÄ›jakÃ½ program a pouÅ¾ijete na nÄ›j program <code>ldd</code>, dozvÃ­te se, kterÃ© dynamickÃ©
knihovny vyÅ¾aduje ke svÃ©mu bÄ›hu. MÄ›li byste mezi nimi naleznout mj. i
<a href="c/modularizace/../funkce/stdlib.html">standardnÃ­ knihovnu <em>C</em></a> (<code>libc</code>) a dozvÄ›dÄ›t se tak jejÃ­ umÃ­stÄ›nÃ­ na disku:</p>
<pre><code class="language-bash">$ ldd ./program
libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007f0d3a328000)
</code></pre>
<blockquote>
<p><a href="c/modularizace/../funkce/stdlib.html">StandardnÃ­ knihovna jazyka <em>C</em></a> je pouÅ¾Ã­vÃ¡na tÃ©mÄ›Å™ kaÅ¾dÃ½m programem a i z
tohoto dÅ¯vodu je obvykle linkovÃ¡na dynamicky, aby jejÃ­ pamÄ›Å¥ Å¡la sdÃ­let mezi programy.</p>
</blockquote>
<h2><a class="header" href="#vytvoÅ™enÃ­-knihovny" id="vytvoÅ™enÃ­-knihovny">VytvoÅ™enÃ­ knihovny</a></h2>
<p>Pokud byste si chtÄ›li vytvoÅ™it vlastnÃ­ knihovnu, mÅ¯Å¾ete toho jednoduÅ¡e dosÃ¡hnout pomocÃ­ <code>gcc</code>. Dejme
tomu, Å¾e mÃ¡te soubory <code>a.c</code> a <code>b.c</code>, kterÃ© chcete zabalit do knihovny. Nejprve kaÅ¾dÃ½ zdrojovÃ½ soubor
pÅ™eloÅ¾Ã­me do objektovÃ©ho souboru<sup class='margin-toggle sidenote-number'>4</sup>:</p>
<span class='sidenote'><p><sup class='number'>4</sup>Parametr <code>-fPIC</code> je nutnÃ½ pÅ™i pÅ™ekladu zdrojovÃ½ch souborÅ¯, kterÃ© potÃ© chceme umÃ­stit do
knihovny. VÃ­ce se mÅ¯Å¾ete dozvÄ›dÄ›t napÅ™. <a href="https://stackoverflow.com/a/5311538/1107768">zde</a>.</p>
</span>
<pre><code class="language-bash">$ gcc -c -fPIC a.c
$ gcc -c -fPIC b.c
</code></pre>
<p>DalÅ¡Ã­ postup zÃ¡visÃ­ na tom, jakÃ½ typ knihovny chceme vytvoÅ™it:</p>
<ul>
<li><strong>VytvoÅ™enÃ­ statickÃ© knihovny</strong> - pouÅ¾ijeme program <code>ar</code> (archiver):
<pre><code class="language-bash">$ ar rcs libknihovna.a a.o b.o
</code></pre>
</li>
<li><strong>VytvoÅ™enÃ­ dynamickÃ© knihovny</strong> - pouÅ¾ijeme program <code>gcc</code> s pÅ™epÃ­naÄem <code>-shared</code>:
<pre><code class="language-bash">$ gcc -shared a.o b.o -o libknihovna.so
</code></pre>
</li>
</ul>
<h1><a class="header" href="#automatizace-pÅ™ekladu" id="automatizace-pÅ™ekladu">Automatizace pÅ™ekladu</a></h1>
<p>MoÅ¾nÃ¡ vÃ¡s napadlo, Å¾e v pÅ™Ã­padÄ› rozdÄ›lenÃ­ programu do vÃ­ce zdrojovÃ½ch souborÅ¯ a pÅ™i pouÅ¾itÃ­ knihoven
zaÄne bÃ½t docela namÃ¡havÃ© nÃ¡Å¡ program vÅ¯bec pÅ™eloÅ¾it. MusÃ­me pÅ™eloÅ¾it zvlÃ¡Å¡Å¥ kaÅ¾dou
<a href="c/modularizace/linker.html#p%C5%99eklad-programu">jednotku pÅ™ekladu</a>, nakonec je vÅ¡echny slinkovat dohromady
a pÅ™Ã­padnÄ› jeÅ¡tÄ› pÅ™edat potÅ™ebnÃ© cesty k pouÅ¾itÃ½m knihovnÃ¡m. A toto je tÅ™eba po jakÃ©koliv zmÄ›nÄ› v
kÃ³du naÅ¡eho programu, pokud ji budeme chtÃ­t otestovat.</p>
<p>Tento problÃ©m se dÃ¡ Å™eÅ¡it rÅ¯znÃ½mi zpÅ¯soby, od vytvoÅ™enÃ­ <a href="https://en.wikipedia.org/wiki/Shell_script">shell skriptu</a>,
pomocÃ­ kterÃ©ho mÅ¯Å¾eme vÅ¡echny tyto Ãºkony provÃ©st pomocÃ­ jedinÃ©ho pÅ™Ã­kazu v terminÃ¡lu, aÅ¾ po pokroÄilÃ©
<strong>sestavovacÃ­ systÃ©my</strong> (<em>build systems</em>), kterÃ© umÃ­ automaticky vyhledÃ¡vat cesty ke knihovnÃ¡m a
pÅ™eklÃ¡dat pouze zmÄ›nÄ›nÃ© soubory pro urychlenÃ­ opakovanÃ½ch pÅ™ekladÅ¯ programu.</p>
<p>BohuÅ¾el neexistuje jednotnÃ½ standardnÃ­ sestavovacÃ­ systÃ©m pro programy napsanÃ© v <em>C</em>. RÅ¯znÃ© projekty
Äi knihovny tak pouÅ¾Ã­vajÃ­ rÅ¯znÃ© sestavovacÃ­ systÃ©my, coÅ¾ mÅ¯Å¾e nÄ›kdy pÅ™edstavovat problÃ©m pÅ™i jejich
integraci do naÅ¡ich programÅ¯. SestavovacÃ­ systÃ©my se navÃ­c obvykle nastavujÃ­ pomocÃ­ konfiguraÄnÃ­ch
souborÅ¯, kterÃ© jsou psÃ¡ny v proprietÃ¡rnÃ­ch jazycÃ­ch, kterÃ© se musÃ­te nauÄit a pochopit, abyste danÃ½
sestavovacÃ­ systÃ©m mohli pouÅ¾Ã­vat. Situaci nepomÃ¡hÃ¡ ani to, Å¾e se od sebe jednotlivÃ© systÃ©my znaÄnÄ›
liÅ¡Ã­ a bÃ½vajÃ­ velmi komplikovanÃ©. </p>
<h2><a class="header" href="#a-hrefhttpsenwikipediaorgwikimake_softwaremakea" id="a-hrefhttpsenwikipediaorgwikimake_softwaremakea"><a href="https://en.wikipedia.org/wiki/Make_(software)"><code>make</code></a></a></h2>
<p>Asi stÃ¡le nejpouÅ¾Ã­vanÄ›jÅ¡Ã­m sestavovacÃ­m systÃ©mem je <code>make</code>, kterÃ½ existuje jiÅ¾ od roku 1976. Pro jeho
pouÅ¾itÃ­ musÃ­te vytvoÅ™it soubor <code>Makefile</code>, ve kterÃ©m popÃ­Å¡ete, jak se mÃ¡ vÃ¡Å¡ program pÅ™eloÅ¾it, a potÃ©
spustÃ­te program <code>make</code>, kterÃ½ jej dle konfiguraÄnÃ­ho souboru pÅ™eloÅ¾Ã­.</p>
<p>NÃ¡vod pro vytvoÅ™enÃ­ konfiguraÄnÃ­ho souboru <code>Makefile</code> a pouÅ¾itÃ­ <code>make</code> naleznete napÅ™Ã­klad
<a href="https://www.itnetwork.cz/cecko/linux/tutorial-c-linux-makefile">zde</a>.</p>
<h2><a class="header" href="#cmake" id="cmake"><code>CMake</code></a></h2>
<p>PonÄ›kud modernÄ›jÅ¡Ã­ alternativou je <a href="https://cmake.org/"><code>CMake</code></a>. JednÃ¡ se o tzv. meta systÃ©m, ve
skuteÄnosti totiÅ¾ neÅ™Ã­dÃ­ pÅ™eklad vaÅ¡eho programu, ale pouze generuje potÅ™ebnÃ© soubory pro nÄ›jakÃ½
jinÃ½ sestavovacÃ­ systÃ©m, kterÃ½ vÃ¡Å¡ program teprve pÅ™eloÅ¾Ã­. VÃ½hodou pak je, Å¾e z jednoho <code>CMake</code>
konfiguraÄnÃ­ho souboru tak mÅ¯Å¾ete vygenerovat napÅ™. <code>Makefile</code> pro pÅ™eloÅ¾enÃ­ na Linuxu anebo jinÃ©
konfiguraÄnÃ­ soubory pro pÅ™eloÅ¾enÃ­ stejnÃ©ho programu pod Windows.</p>
<p>DalÅ¡Ã­ vÃ½hodou <code>CMake</code> je, Å¾e nÄ›kterÃ¡ vÃ½vojovÃ¡ prostÅ™edÃ­ (napÅ™.
<a href="https://code.visualstudio.com/">Visual Studio Code</a> nebo <a href="https://www.jetbrains.com/clion/">CLion</a>)
mu rozumÃ­ a dokÃ¡Å¾Ã­ dÃ­ky nÄ›mu usnadnit analÃ½zu a ladÄ›nÃ­ vaÅ¡eho programu. </p>
<h3><a class="header" href="#instalace" id="instalace">Instalace</a></h3>
<p><code>CMake</code> mÅ¯Å¾ete na Ubuntu nainstalovat nÃ¡sledujÃ­cÃ­m pÅ™Ã­kazem v terminÃ¡lu:</p>
<pre><code class="language-bash">$ sudo apt install cmake
</code></pre>
<h3><a class="header" href="#pouÅ¾itÃ­" id="pouÅ¾itÃ­">PouÅ¾itÃ­</a></h3>
<p>Pro pouÅ¾itÃ­ <code>CMake</code> musÃ­te vytvoÅ™it konfiguraÄnÃ­ soubor <code>CMakeLists.txt</code>, ve kterÃ©m popÃ­Å¡ete jednotlivÃ©
zdrojovÃ© soubory vaÅ¡eho programu, a takÃ© zadÃ¡te knihovny, kterÃ© chcete k vaÅ¡emu programu pÅ™ipojit.
VzorovÃ½ soubor <code>CMakeLists.txt</code> mÅ¯Å¾e vypadat napÅ™. takto:</p>
<pre><code class="language-cmake">cmake_minimum_required(VERSION 3.4)

# NÃ¡zev projektu
project(hra)

# PÅ™idÃ¡nÃ­ pÅ™epÃ­naÄÅ¯ pÅ™ekladaÄe
set(CMAKE_C_FLAGS &quot;${CMAKE_C_FLAGS} -fsanitize=address&quot;)

# VyhledÃ¡nÃ­ knihovny SDL
find_package(SDL2)

# VytvoÅ™enÃ­ programu s nÃ¡zvem `hra`
# Program se bude sklÃ¡dat ze dvou zadanÃ½ch zdrojovÃ½ch souborÅ¯ (jednotek pÅ™ekladu)
add_executable(hra hra.c grafika.c)

# PÅ™idÃ¡nÃ­ adresÃ¡Å™Å¯ s hlaviÄkovÃ½mi soubory k programu (obdoba -I)
target_include_directories(hra PRIVATE ${SDL2_INCLUDE_DIRS})

# PÅ™ilinkovÃ¡nÃ­ knihoven k programu (obdoba -l)
target_link_libraries(hra ${SDL2_LIBRARIES} m)
</code></pre>
<p>Jakmile tento soubor vytvoÅ™Ã­te, musÃ­te pomocÃ­ pÅ™Ã­kazu <code>cmake</code> vytvoÅ™it <code>Makefile</code>:</p>
<pre><code class="language-bash">$ mkdir build
$ cd build
$ cmake ..
</code></pre>
<p>a potÃ© pomocÃ­ <code>make</code> program finÃ¡lnÄ› pÅ™eloÅ¾it:</p>
<pre><code class="language-bash">$ make
</code></pre>
<p>DobrÃ¡ zprÃ¡va je, Å¾e pokud pouÅ¾Ã­vÃ¡te kompatibilnÃ­ vÃ½vojovÃ© prostÅ™edÃ­, tak tyto Ãºkony typicky provÃ¡dÃ­
za vÃ¡s a vÃ¡m tak staÄÃ­ sprÃ¡vnÄ› nastavit soubor <code>CMakeLists.txt</code>.</p>
<p>NÃ¡vod k pouÅ¾itÃ­ <code>CMake</code> naleznete napÅ™Ã­klad <a href="https://cmake.org/cmake/help/latest/guide/tutorial/index.html">zde</a>.</p>
<h3><a class="header" href="#pouÅ¾itÃ­-ve-visual-studio-code" id="pouÅ¾itÃ­-ve-visual-studio-code">PouÅ¾itÃ­ ve Visual Studio Code</a></h3>
<p>Pokud chcete spustit Äi ladit <code>CMake</code> projekt ve VSCode, tak proveÄte tyto kroky:</p>
<ol>
<li>Nainstalujte si <a href="https://marketplace.visualstudio.com/items?itemName=ms-vscode.cmake-tools">toto</a> rozÅ¡Ã­Å™enÃ­ do VSCode</li>
<li>OtevÅ™ete ve VSCode adresÃ¡Å™, kterÃ½ bude obsahovat soubor <code>CMakeLists.txt</code></li>
<li>SpusÅ¥te program pomocÃ­ <code>Ctrl + F5</code></li>
</ol>
<h1><a class="header" href="#Ãšlohy" id="Ãšlohy">Ãšlohy</a></h1>
<p>V tÃ©to sekci si ukÃ¡Å¾eme nÄ›kolik jednoduchÃ½ch aplikovanÃ½ch pÅ™Ã­stupÅ¯ a knihoven, kterÃ© mÅ¯Å¾ete pouÅ¾Ã­t
napÅ™Ã­klad na:</p>
<ul>
<li>PrÃ¡ci s obrÃ¡zky pomocÃ­ formÃ¡tu <a href="c/aplikovane_ulohy/tga.html">TGA</a>.</li>
<li>PrÃ¡ci s animacemi pomocÃ­ formÃ¡tu <a href="c/aplikovane_ulohy/gif.html">GIF</a>.</li>
<li>TvorbÄ› interaktivnÃ­ch aplikacÃ­ a her pomocÃ­ knihovny <a href="c/aplikovane_ulohy/sdl.html">SDL</a>.</li>
<li>Simulaci fyzikÃ¡lnÃ­ch procesÅ¯ pomocÃ­ knihovny <a href="c/aplikovane_ulohy/chipmunk.html">Chipmunk</a>.</li>
</ul>
<h1><a class="header" href="#tga" id="tga">TGA</a></h1>
<p><a href="https://en.wikipedia.org/wiki/Truevision_TGA">TGA</a> je formÃ¡t pro uklÃ¡dÃ¡nÃ­ rastrovÃ½ch obrÃ¡zkÅ¯ na
disk. SlouÅ¾Ã­ tedy ke stejnÃ©mu ÃºÄelu jako znÃ¡mÄ›jÅ¡Ã­ formÃ¡ty <code>JPEG</code> nebo <code>PNG</code>, ale oproti nim je
mnohem jednoduÅ¡Å¡Ã­. DÃ­ky tomu mÅ¯Å¾eme naÄÃ­st i zapsat <code>TGA</code> soubor pomocÃ­ nÄ›kolika Å™Ã¡dkÅ¯ kÃ³du, zatÃ­mco
napÅ™. u <code>JPEG</code> nebo <code>PNG</code> bychom potÅ™ebovali buÄ pouÅ¾Ã­t jiÅ¾ existujÃ­cÃ­ knihovnu anebo naimplementovat
jejich relativnÄ› komplikovanÃ© standardy, kterÃ© ÄÃ­tajÃ­ stovky strÃ¡nek.</p>
<p>TGA soubory jsou uloÅ¾eny v binÃ¡rnÃ­m formÃ¡tu, coÅ¾ znamenÃ¡, Å¾e do nich budeme ÄÃ­selnÃ© hodnoty uklÃ¡dat ve formÃ¡tu,
v jakÃ©m jsou uloÅ¾eny v pamÄ›ti programu, a nebudeme je formÃ¡tovat pomocÃ­ textovÃ½ch kÃ³dovÃ¡nÃ­, napÅ™. ASCII. To sice
znamenÃ¡, Å¾e obsah TGA souboru nebude v &quot;lidsky ÄitelnÃ©m formÃ¡tu&quot;, nicmÃ©nÄ› zÃ¡roveÅˆ nÃ¡m to i ÄÃ¡steÄnÄ› usnadnÃ­ programatickÃ©
ÄtenÃ­ a zÃ¡pis tÄ›chto souborÅ¯.</p>
<h2><a class="header" href="#hlaviÄka-tga" id="hlaviÄka-tga">HlaviÄka <code>TGA</code></a></h2>
<p>Soubory ve formÃ¡tu <code>TGA</code> obsahujÃ­ na svÃ©m zaÄÃ¡tku tzv. <strong>hlaviÄku</strong> (<em>header</em>), kterÃ¡ obsahuje informace
popisujÃ­cÃ­ danÃ½ obrÃ¡zek. Tyto informace jsou reprezentovÃ¡ny byty, kterÃ© jsou umÃ­stÄ›ny na pevnÄ›
danÃ½ch pozicÃ­ch. Zde je seznam jednotlivÃ½ch ÄÃ¡stÃ­ hlaviÄky TGA:</p>
<table><thead><tr><th align="center">NÃ¡zev</th><th align="center">Pozice prvnÃ­ho bytu</th><th align="center">PoÄet bytÅ¯</th></tr></thead><tbody>
<tr><td align="center">ID</td><td align="center">0</td><td align="center">1</td></tr>
<tr><td align="center">Typ barevnÃ© mapy</td><td align="center">1</td><td align="center">1</td></tr>
<tr><td align="center"><strong>Typ obrÃ¡zku</strong></td><td align="center">2</td><td align="center">1</td></tr>
<tr><td align="center">BarevnÃ¡ mapa</td><td align="center">3</td><td align="center">5</td></tr>
<tr><td align="center">PoÄÃ¡tek X</td><td align="center">8</td><td align="center">2</td></tr>
<tr><td align="center">PoÄÃ¡tek Y</td><td align="center">10</td><td align="center">2</td></tr>
<tr><td align="center"><strong>Å Ã­Å™ka</strong></td><td align="center">12</td><td align="center">2</td></tr>
<tr><td align="center"><strong>VÃ½Å¡ka</strong></td><td align="center">14</td><td align="center">2</td></tr>
<tr><td align="center"><strong>BarevnÃ¡ hloubka</strong></td><td align="center">16</td><td align="center">1</td></tr>
<tr><td align="center">PopisovaÄ</td><td align="center">17</td><td align="center">1</td></tr>
</tbody></table>
<p>Tato tabulka udÃ¡vÃ¡, jak mÃ¡me interpretovat jednotlivÃ© byty na zaÄÃ¡tku <code>TGA</code> souboru. Pokud bychom tedy
napÅ™Ã­klad otevÅ™eli <code>TGA</code> soubor a pÅ™eÄteli si jeho 12. a 13. byte, tak se dozvÃ­me Å¡Ã­Å™ku tohoto obrÃ¡zku. 
NÃ¡s budou zajÃ­mat zejmÃ©na tuÄnÄ› vyznaÄenÃ© ÄÃ¡sti:</p>
<ul>
<li><strong>Typ obrÃ¡zku</strong>: Hodnota <code>2</code> udÃ¡vÃ¡ nekomprimovanÃ½ RGB obrÃ¡zek, hodnota <code>3</code> udÃ¡vÃ¡ nekomprimovanÃ½
obrÃ¡zek ve stupnÃ­ch Å¡edi (&quot;ÄernobÃ­lÃ½&quot; obrÃ¡zek). OstatnÃ­ platnÃ© hodnoty typu obrÃ¡zku mÅ¯Å¾ete nalÃ©zt
napÅ™. na <a href="https://en.wikipedia.org/wiki/Truevision_TGA">Wikipedii</a>.</li>
<li><strong>RozmÄ›ry</strong>: Tato ÄÃ¡st hlaviÄky urÄuje rozmÄ›ry obrÃ¡zku. KaÅ¾dÃ½ rozmÄ›r (<strong>Å¡Ã­Å™ka</strong> i <strong>vÃ½Å¡ka</strong>) zabÃ­rÃ¡
dva byty (aby formÃ¡t podporoval i obrÃ¡zky s rozmÄ›ry vÄ›tÅ¡Ã­mi neÅ¾ 255 pixelÅ¯).</li>
<li><strong>BarevnÃ¡ hloubka</strong>: UdÃ¡vÃ¡, kolik bitÅ¯ bude zabÃ­rat kaÅ¾dÃ½ pixel obrÃ¡zku. Pokud pouÅ¾ijeme typ obrÃ¡zku
RGB (typ <code>2</code>), mÄ›li bychom pouÅ¾Ã­t hloubku 24 bitÅ¯ (8 bitÅ¯ na kaÅ¾dou barevnou sloÅ¾ku), pokud pouÅ¾ijeme typ
obrÃ¡zku ve stupnÃ­ch Å¡edi (typ <code>3</code>), tak pouÅ¾ijeme hloubku 8 bitÅ¯.</li>
</ul>
<blockquote>
<p>PÅ™i naÄÃ­tÃ¡nÃ­ binÃ¡rnÃ­ch dat ze souborÅ¯ musÃ­me dÃ¡vat pozor na to, jestli jsou hodnoty uloÅ¾eny v
<strong>little-endian</strong> nebo <strong>big-endian</strong> formÃ¡tu. U <code>TGA</code> je urÄeno, Å¾e musÃ­ bÃ½t v little-endian, coÅ¾ je
zÃ¡roveÅˆ s velkou pravdÄ›podobnostÃ­ i formÃ¡t, kterÃ½ pouÅ¾Ã­vÃ¡ vÃ¡s poÄÃ­taÄ, nemusÃ­me tedy provÃ¡dÄ›t Å¾Ã¡dnou
konverzi. VÃ­ce o tzv. <strong>endianness</strong> mÅ¯Å¾ete nalÃ©zt napÅ™. <a href="https://en.wikipedia.org/wiki/Endianness">zde</a>.</p>
</blockquote>
<h2><a class="header" href="#naÄtenÃ­-hlaviÄky-ze-souboru" id="naÄtenÃ­-hlaviÄky-ze-souboru">NaÄtenÃ­ hlaviÄky ze souboru</a></h2>
<p>JednotlivÃ© ÄÃ¡sti z hlaviÄky bychom mohli naÄÃ­tat byte po bytu, nicmÃ©nÄ› to by bylo dosti nepraktickÃ©.
V pÅ™Ã­padÄ›, Å¾e formÃ¡t, kterÃ½ chceme naÄÃ­st, mÃ¡ pevnÄ› danÃ© rozloÅ¾enÃ­ bytÅ¯, je mnohem jednoduÅ¡Å¡Ã­
nadefinovat si <a href="c/aplikovane_ulohy/../struktury/struktury.html">strukturu</a>, kterÃ¡ bude danÃ©mu rozloÅ¾enÃ­ odpovÃ­dat, a potÃ©
celou strukturu naÄÃ­st ze souboru najednou.</p>
<p>JednotlivÃ© hodnoty v hlaviÄce jsou reprezentovÃ¡ny byty bez znamÃ©nka. JelikoÅ¾ tento datovÃ½ typ v <em>C</em>
mÃ¡ trochu zdlouhavÃ½ nÃ¡zev, vytvoÅ™me si pro nÄ›j nejprve novÃ© jmÃ©no <code>byte</code>:</p>
<pre><code class="language-c">typedef unsigned char byte;
</code></pre>
<p>NynÃ­ si vytvoÅ™me strukturu, kterÃ¡ bude reprezentovat <code>TGA</code> hlaviÄku. JednotlivÃ© atributy struktury
musÃ­ pÅ™esnÄ› odpovÃ­dat hodnotÃ¡m v hlaviÄce a musÃ­ bÃ½t takÃ© uvedeny ve stejnÃ©m poÅ™adÃ­:</p>
<pre><code class="language-c">typedef struct {
    byte id_length;
    byte color_map_type;
    byte image_type;
    byte color_map[5];
    byte x_origin[2];
    byte y_origin[2];
    byte width[2];
    byte height[2];
    byte depth;
    byte descriptor;
} TGAHeader;
</code></pre>
<blockquote>
<p>MoÅ¾nÃ¡ vÃ¡m pÅ™ijde zvlÃ¡Å¡tnÃ­, proÄ napÅ™. Å¡Ã­Å™ku definujeme jako pole dvou bytÅ¯ namÃ­sto pouÅ¾itÃ­
&quot;dvou-bajtovÃ©ho celÃ©ho ÄÃ­sla&quot;, tedy datovÃ©ho typu <code>short</code>. DÄ›lÃ¡me to, aby do tÃ©to struktury pÅ™ekladaÄ
nevloÅ¾il Å¾Ã¡dnÃ© <a href="c/aplikovane_ulohy/../struktury/pametova_reprezentace.html#struktury-a-zarovn%C3%A1n%C3%AD">mezery</a>. Pokud by je tam
vloÅ¾il, tak by naÅ¡e struktura v pamÄ›ti uÅ¾ neodpovÃ­dala hlaviÄce <code>TGA</code> v souboru a Äetli bychom tak
neplatnÃ© hodnoty. KdyÅ¾ pouÅ¾ijeme pro vÅ¡echny atributy datovÃ½ typ s velikostÃ­ 1 byte, tak pÅ™ekladaÄ
Å¾Ã¡dnÃ© mezery vklÃ¡dat nebude.</p>
<p>AlternativnÃ­m Å™eÅ¡enÃ­m by bylo Å™Ã­ct pÅ™ekladaÄi, aÅ¥ do danÃ© struktury Å¾Ã¡dnÃ© mezery
<a href="https://stackoverflow.com/a/40642888/1107768">nevklÃ¡dÃ¡</a>.</p>
</blockquote>
<p>NynÃ­ uÅ¾ staÄÃ­ pouze otevÅ™Ã­t nÄ›jakÃ½ <code>TGA</code> soubor (napÅ™. <a href="c/aplikovane_ulohy/../../static/img/carmack.tga">tento</a>),
<a href="c/aplikovane_ulohy/../soubory/cteni_ze_souboru.html">naÄÃ­st</a> z nÄ›j poÄet bytÅ¯ odpovÃ­dajÃ­cÃ­ naÅ¡Ã­ struktuÅ™e
a potÃ© si z nÃ­ mÅ¯Å¾eme pÅ™eÄÃ­st informace o danÃ©m obrÃ¡zku:</p>
<pre><code class="language-c mainbody">#include &lt;stdio.h&gt;
#include &lt;assert.h&gt;

int main() {
    FILE* file = fopen(&quot;carmack.tga&quot;, &quot;rb&quot;);
    assert(file);
    
    TGAHeader header = {};
    assert(fread(&amp;header, sizeof(TGAHeader), 1, file) == 1);
    
    printf(&quot;Image type: %d, pixel depth: %d\n&quot;, header.image_type, header.depth);

    return 0;
}
</code></pre>
<p>Pokud budeme chtÃ­t pracovat s hodnotami rozmÄ›rÅ¯, musÃ­me je nejprve pÅ™evÃ©st z pole bytÅ¯
na celÃ© ÄÃ­slo. Toho mÅ¯Å¾eme dosÃ¡hnout pomocÃ­ funkce <a href="https://devdocs.io/c/string/byte/memcpy"><code>memcpy</code></a>:</p>
<pre><code class="language-c">int width = 0;
int height = 0;

memcpy(&amp;width, header-&gt;width, 2);
memcpy(&amp;height, header-&gt;height, 2);
</code></pre>
<blockquote>
<p>DatovÃ½ typ <code>int</code> sice velmi pravdÄ›podobnÄ› bude mÃ­t vÃ­ce bytÅ¯, neÅ¾ <code>2</code> (pravdÄ›podobnÄ› bude mÃ­t <code>4</code> byty), ale jelikoÅ¾
v pamÄ›ti i v souboru jsou data uloÅ¾ena ve formÃ¡tu &quot;little-endian&quot;, tak staÄÃ­ do <code>int</code>u naÄÃ­st dva byty, a bude to fungovat
tak, jak oÄekÃ¡vÃ¡me. <strong>MusÃ­me vÅ¡ak nejprve promÄ›nnou <code>int</code>u inicializovat na nulu, jinak by vyÅ¡Å¡Ã­ dva byty mÄ›ly nedefinovanou
hodnotu!</strong></p>
</blockquote>
<h2><a class="header" href="#naÄtenÃ­-pixelÅ¯-ze-souboru" id="naÄtenÃ­-pixelÅ¯-ze-souboru">NaÄtenÃ­ pixelÅ¯ ze souboru</a></h2>
<p>Jakmile jsme naÄetli hlaviÄku, mÅ¯Å¾eme naÄÃ­st ze souboru i samotnÃ© pixely. Ty jsou umÃ­stÄ›ny v souboru
hned za hlaviÄkou, Å™Ã¡dek po Å™Ã¡dku, zleva doprava a shora dolÅ¯. To znamenÃ¡, Å¾e pixel v levÃ©m hornÃ­m rohu obrÃ¡zku je v souboru
uloÅ¾en jako prvnÃ­, tj. hned za hlaviÄkou, zatÃ­mco pixel v pravÃ©m dolnÃ­m rohu obrÃ¡zku je v souboru uloÅ¾en jako poslednÃ­,
na ÃºplnÃ©m konci souboru. KaÅ¾dÃ½ pixel mÃ¡ odpovÃ­dajÃ­cÃ­ poÄet bytÅ¯ podle typu obrÃ¡zku (u RGB obrÃ¡zkÅ¯ 3 byty<sup class='margin-toggle sidenote-number'>1</sup>,
u obrÃ¡zkÅ¯ ve stupnÃ­ch Å¡edi 1 byte) a celkovÃ½ poÄet pixelÅ¯ je potÃ© dÃ¡n rozmÄ›ry obrÃ¡zku (<code>Å¡Ã­Å™ka * vÃ½Å¡ka</code>).</p>
<span class='sidenote'><p><sup class='number'>1</sup>V <code>TGA</code> jsou jednotlivÃ© barevnÃ© sloÅ¾ky uloÅ¾enÃ© v poÅ™adÃ­ <code>blue</code>, <code>green</code>, <code>red</code>. JednÃ¡ se tedy
vlastnÄ› o formÃ¡t BGR.</p>
</span>
<p>MÅ¯Å¾eme si tak vytvoÅ™it pole pro pixely a naÄÃ­st je z obrÃ¡zku. Pro RGB obrÃ¡zky by naÄtenÃ­ pixelÅ¯
mohlo vypadat napÅ™. takto: </p>
<pre><code class="language-c">typedef struct {
    byte blue;
    byte green;
    byte red;
} Pixel;

Pixel* load_pixels(TGAHeader header, FILE* file) {
    int width = 0;
    int height = 0;
    
    memcpy(&amp;width, header.width, 2);
    memcpy(&amp;height, header.height, 2);

    Pixel* pixels = (Pixel*) malloc(sizeof(Pixel) * width * height);
    assert(fread(pixels, sizeof(Pixel) * width * height, 1, file) == 1);
    return pixels;
}
</code></pre>
<h2><a class="header" href="#prÃ¡ce-s-pixely" id="prÃ¡ce-s-pixely">PrÃ¡ce s pixely</a></h2>
<p>Jakmile mÃ¡me naÄtenÃ© pixely v mÅ™Ã­Å¾ce (poli pixelÅ¯) v pamÄ›ti, tak s nimi mÅ¯Å¾eme pracovat jako s
<a href="c/aplikovane_ulohy/../pole/vicerozmerna_pole.html">vÃ­cerozmÄ›rnÃ½m polem</a>. Pokud bychom napÅ™Ã­klad proÅ¡li vÅ¡echny hodnoty pixelÅ¯, a nastavili
jejich barevnou sloÅ¾ku <code>red</code> (reprezentujÃ­cÃ­ Äervenou barvu) na hodnotu <code>0</code>, tak z obrÃ¡zku zcela odstranÃ­me Äervenou barvu:</p>
<pre><code class="language-c">Pixel* pixels = load_pixels(header, file);
for (int row = 0; row &lt; height; row++) {
    for (int col = 0; col &lt; width; col++) {
        Pixel* pixel = pixels + (row * width + col);
        pixel-&gt;red = 0;
    }    
}
</code></pre>
<h2><a class="header" href="#zapsÃ¡nÃ­-tga-do-souboru" id="zapsÃ¡nÃ­-tga-do-souboru">ZapsÃ¡nÃ­ <code>TGA</code> do souboru</a></h2>
<p>Jakmile jsme nÄ›jakÃ½m zpÅ¯sobem upravili obsah naÄtenÃ©ho TGA obrÃ¡zku (nebo si vytvoÅ™ili prÃ¡zdnÃ½ TGA obrÃ¡zek v pamÄ›ti a nÄ›co
do nÄ›j nakreslili), tak musÃ­me pixely z pamÄ›ti zapsat zpÄ›t do <code>TGA</code> souboru na disku, abychom si obrÃ¡zek mohli prohlÃ©dnout
v nÄ›jakÃ©m prohlÃ­Å¾eÄi Äi editoru obrÃ¡zkÅ¯. ZÃ¡pis bude probÃ­hat v podstatÄ› ÃºplnÄ› stejnÄ›, jako naÄtenÃ­ obrÃ¡zku. OtevÅ™eme
soubor pro zÃ¡pis, uloÅ¾Ã­me do nÄ›j binÃ¡rnÄ› (pomocÃ­ funkce <a href="c/aplikovane_ulohy/../soubory/zapis_do_souboru.html#z%C3%A1pis-do-souboru"><code>fwrite</code></a>)
TGA hlaviÄku, a hned za nÃ­ do nÄ›j opÄ›t binÃ¡rnÄ› zapÃ­Å¡eme vÅ¡echny pixely obrÃ¡zku z pamÄ›ti, Å™Ã¡dek po Å™Ã¡dku.</p>
<h1><a class="header" href="#gif" id="gif">GIF</a></h1>
<p><a href="https://en.wikipedia.org/wiki/GIF">GIF</a> je velmi populÃ¡rnÃ­ formÃ¡t pro sdÃ­lenÃ­ animacÃ­. <code>GIF</code> animace
se sklÃ¡dÃ¡ z jednoho nebo vÃ­ce tzv. <strong>snÃ­mkÅ¯</strong> (<em>frames</em>), kterÃ© majÃ­ urÄenou dÃ©lku, po kterou se majÃ­
zobrazit. PÅ™i pÅ™ehrÃ¡nÃ­ animace se pak jednotlivÃ© snÃ­mky zobrazujÃ­ postupnÄ› jeden za druhÃ½m, coÅ¾
vytvÃ¡Å™Ã­ dojem animace.</p>
<p>PoÅ™Ã¡d se jednÃ¡ o relativnÄ› jednoduchÃ½ formÃ¡t, nicmÃ©nÄ› je uÅ¾ troÅ¡ku sloÅ¾itÄ›jÅ¡Ã­ neÅ¾ napÅ™. <a href="c/aplikovane_ulohy/tga.html">TGA</a>,
protoÅ¾e pouÅ¾Ã­vÃ¡ kompresi a pixely nejsou uloÅ¾eny v souboru pÅ™Ã­mo, mÃ­sto toho je kaÅ¾dÃ½ pixel reprezentovÃ¡n
indexem do tabulky (palety) pÅ™edpÅ™ipravenÃ½ch barev.</p>
<p>Pro vytvoÅ™enÃ­ <code>GIF</code> animace tak pouÅ¾ijeme kÃ³d, kterÃ½ uÅ¾ pro nÃ¡s pÅ™ipravil nÄ›kdo jinÃ½. KonkrÃ©tnÄ› se
bude jednat o <a href="https://github.com/lecram/gifenc">knihovnu <code>gifenc</code></a><sup class='margin-toggle sidenote-number'>1</sup>. StÃ¡hnÄ›te si soubory
<code>gifenc.c</code> a <code>gifenc.h</code> a pouÅ¾ijte je pÅ™i <a href="c/aplikovane_ulohy/../modularizace/pouzivani_kodu_z_jinych_souboru.html">pÅ™ekladu</a>
svÃ©ho programu.</p>
<span class='sidenote'><p><sup class='number'>1</sup>I kdyÅ¾ jsme se pÅ™edtÃ­m bavili o tom, Å¾e sdÃ­let knihovny ve formÄ› zdrojovÃ½ch kÃ³dÅ¯ nenÃ­
<a href="c/aplikovane_ulohy/../modularizace/knihovny.html#sd%C3%ADlen%C3%AD-knihoven">ÃºplnÄ› bÄ›Å¾nÃ©</a>, tato knihovna je velmi malÃ¡ a
jednoduchÃ¡ a zÃ¡roveÅˆ je open-source, takÅ¾e zkopÃ­rovat jejÃ­ zdrojovÃ© kÃ³dy do naÅ¡eho programu je asi
nejjednoduÅ¡Å¡Ã­ zpÅ¯sob, jak ji pouÅ¾Ã­t.</p>
</span>
<h2><a class="header" href="#vytvoÅ™enÃ­-gif-animace" id="vytvoÅ™enÃ­-gif-animace">VytvoÅ™enÃ­ <code>GIF</code> animace</a></h2>
<p>Pro prÃ¡ci s <code>GIF</code> souborem si nejprve musÃ­me nadefinovat tzv. <strong>paletu</strong> (<em>palette</em>). Paleta nenÃ­
nic jinÃ©ho neÅ¾ pole barev, kterÃ© mÅ¯Å¾eme v naÅ¡Ã­ animaci pouÅ¾Ã­vat. JednotlivÃ½m pixelÅ¯m kaÅ¾dÃ©ho snÃ­mku
pak pouze Å™ekneme, jakÃ½ index z tÃ©to palety se mÃ¡ pouÅ¾Ã­t pro jejich vykreslenÃ­. NapÅ™Ã­klad tato paleta
definuje ÄtyÅ™i barvy:</p>
<pre><code class="language-c">typedef unsigned char byte;

byte palette[] = {
    0x00, 0x00, 0x00, /* 0 -&gt; ÄernÃ¡   (R=0, G=0, B=0)   */
    0xFF, 0x00, 0x00, /* 1 -&gt; ÄervenÃ¡ (R=255, G=0, B=0) */
    0x00, 0xFF, 0x00, /* 2 -&gt; zelenÃ¡  (R=0, G=255, B=0) */
    0x00, 0x00, 0xFF, /* 3 -&gt; modrÃ¡   (R=0, G=0, B=255) */
};
</code></pre>
<p>Pokud pouÅ¾ijeme pro pixel index <code>1</code>, bude vykreslen Äervenou barvou, protoÅ¾e v tÃ©to paletÄ› se na
pozici <code>1</code> nachÃ¡zÃ­ ÄervenÃ¡ barva.</p>
<p>Jakmile mÃ¡me nadefinovanou paletu, mÅ¯Å¾eme pouÅ¾Ã­t funkci <code>ge_new_gif</code>, kterÃ¡ umoÅ¾Åˆuje vytvoÅ™it novÃ½
<code>GIF</code> soubor. Funkci musÃ­me pÅ™edat cestu k vÃ½stupnÃ­mu souboru, jeho rozmÄ›ry, informace o paletÄ› a o
tom, kolikrÃ¡t se mÃ¡ animace pÅ™ehrÃ¡t<sup class='margin-toggle sidenote-number'>2</sup>:</p>
<span class='sidenote'><p><sup class='number'>2</sup>Pro pouÅ¾itÃ­ hlaviÄkovÃ©ho souboru knihovny nezapomeÅˆte na zaÄÃ¡tku svÃ©ho programu
<a href="c/aplikovane_ulohy/../preprocesor/vkladani_souboru.html">vloÅ¾it</a> <a href="c/aplikovane_ulohy/../modularizace/hlavickove_soubory.html">hlaviÄkovÃ½ soubor</a>
<code>gifenc.h</code>.</p>
</span>
<pre><code class="language-c">int width = 300;
int height = 300;

ge_GIF* gif = ge_new_gif(
    &quot;output.gif&quot;,
    width,
    height,
    palette,
    2,  /* hloubka palety */
    0   /* opakovat neustÃ¡le dokola */
);
</code></pre>
<p>Parametr hloubky palety by mÄ›l bÃ½t nastaven na dvojkovÃ½ logaritmus poÄtu baret v paletÄ›. V naÅ¡Ã­
paletÄ› jsou 4 barvy, takÅ¾e jsme zde pÅ™edali hodnotu parametru <code>2</code>. PoslednÃ­ parametr udÃ¡vÃ¡, kolikrÃ¡t
se mÃ¡ animace pÅ™ehrÃ¡t. Hodnota <code>0</code> udÃ¡vÃ¡, Å¾e se mÃ¡ animace opakovat neustÃ¡le dokola<sup class='margin-toggle sidenote-number'>3</sup>.</p>
<span class='sidenote'><p><sup class='number'>3</sup>VÅ¡echny tyto Ãºdaje lze vyÄÃ­st z <a href="https://github.com/lecram/gifenc/blob/master/README#L25">dokumentace</a>
knihovny.</p>
</span>
<h3><a class="header" href="#zÃ¡pis-snÃ­mkÅ¯" id="zÃ¡pis-snÃ­mkÅ¯">ZÃ¡pis snÃ­mkÅ¯</a></h3>
<p>KdyÅ¾ nynÃ­ mÃ¡me vytvoÅ™enou animaci, mÅ¯Å¾eme do nÃ­ postupnÄ› zapisovat snÃ­mky. ZÃ¡pis probÃ­hÃ¡ nÃ¡sledovnÄ›:</p>
<ol>
<li>Do pole uloÅ¾enÃ©ho v atributu <code>gif-&gt;frame</code> zapÃ­Å¡eme hodnoty vÅ¡ech pixelÅ¯ jednoho snÃ­mku.
KaÅ¾dÃ¡ hodnota by mÄ›la bÃ½t indexem odpovÃ­dajÃ­cÃ­ barvy z nÃ¡mi zvolenÃ© palety. Pro adresovÃ¡nÃ­ pouÅ¾ijeme
klasickÃ½ pÅ™evod z <a href="c/aplikovane_ulohy/../pole/vicerozmerna_pole.html#indexov%C3%A1n%C3%AD">2D na 1D index</a>.</li>
<li>ZavolÃ¡me funkci <code>ge_add_frame</code>, kterÃ© Å™ekneme, na jak dlouhou dobu se mÃ¡ tento snÃ­mek zobrazit.
Tato doba je v setinÃ¡ch vteÅ™iny.</li>
</ol>
<p>Jakmile zapÃ­Å¡eme jeden snÃ­mek, mÅ¯Å¾eme celÃ½ proces opakovat pro zÃ¡pis dalÅ¡Ã­ch snÃ­mkÅ¯.</p>
<p>Uhodnete, jakou animaci vygeneruje nÃ¡sledujÃ­cÃ­ kÃ³d<sup class='margin-toggle sidenote-number'>4</sup>?</p>
<span class='sidenote'><p><sup class='number'>4</sup>Pro ovÄ›Å™enÃ­ tipu si program pÅ™eloÅ¾te a podÃ­vejte se na vÃ½slednou animaci. Zakomentujte Å™Ã¡dek
s <code>memset</code> a zkuste odhadnout, jak a proÄ to zmÄ›nÃ­ vÃ½slednou animaci.</p>
</span>
<pre><code class="language-c">for (int i = 0; i &lt; 100; i++) {
    memset(gif-&gt;frame, 0, sizeof(uint8_t) * width * height);

    for (int row = 0; row &lt; height; row++) {
        gif-&gt;frame[row * height + i] = ((i * 10) / 30) % 3 + 1;
    }
    for (int col = 0; col &lt; width; col++) {
        gif-&gt;frame[i * height + col] = ((i * 10) / 30) % 3 + 1;
    }

    ge_add_frame(gif, 8);
}
</code></pre>
<details>
<summary>VÃ½sledek animace</summary>
<p><img src="c/aplikovane_ulohy/../../static/img/animace.gif" alt="" /></p>
</details>
<h3><a class="header" href="#dokonÄenÃ­-prÃ¡ce-s-animacÃ­" id="dokonÄenÃ­-prÃ¡ce-s-animacÃ­">DokonÄenÃ­ prÃ¡ce s animacÃ­</a></h3>
<p>Jakmile zapÃ­Å¡eme vÅ¡echny snÃ­mky, kterÃ© chceme v animaci mÃ­t, nesmÃ­me zapomenout animaci uloÅ¾it do
souboru a uvolnit jejÃ­ pamÄ›Å¥ pomocÃ­ funkce <code>ge_close_gif</code>:</p>
<pre><code class="language-c">ge_close_gif(gif);
</code></pre>
<h2><a class="header" href="#naÄtenÃ­-gif-animace" id="naÄtenÃ­-gif-animace">NaÄtenÃ­ <code>GIF</code> animace</a></h2>
<p>Pokud byste naopak chtÄ›li nÄ›jakou <code>GIF</code> animaci naÄÃ­st ze souboru a nÄ›co s nÃ­ dÃ¡le provÃ©st, mÅ¯Å¾ete
pouÅ¾Ã­t knihovnu <a href="https://github.com/lecram/gifdec"><code>gifdec</code></a> od stejnÃ©ho autora, kterÃ¡ slouÅ¾Ã­ k
naÄÃ­tÃ¡nÃ­ <code>GIF</code> souborÅ¯.</p>
<hr />
<p><strong>CviÄenÃ­</strong> ğŸ‹</p>
<p>Zkuste pouÅ¾Ã­t knihovnu <code>gifdef</code> pro pÅ™evod animace z <code>GIF</code> do <code>TGA</code>:</p>
<ol>
<li>NaÄtÄ›te <code>GIF</code> animaci z disku.</li>
<li>ProjdÄ›te vÅ¡echny snÃ­mky animace.</li>
<li>Pro kaÅ¾dÃ½ snÃ­mek pÅ™eveÄte pixely snÃ­mku z indexovanÃ© palety do klasickÃ© mÅ™Ã­Å¾ky pixelÅ¯ pouÅ¾Ã­vanÃ©
ve formÃ¡tu <code>TGA</code>.</li>
<li>ZapiÅ¡te kaÅ¾dÃ½ snÃ­mek na disk jako individuÃ¡lnÃ­ <code>TGA</code> obrÃ¡zek. MÅ¯Å¾ete na kraj obrÃ¡zku vykreslit
informaci o poÅ™adÃ­ snÃ­mku.</li>
</ol>
<hr />
<h1><a class="header" href="#sdl" id="sdl">SDL</a></h1>
<blockquote>
<p>ğŸ“¹ K zÃ¡kladÅ¯m prÃ¡ce s SDL byl poÅ™Ã­zen zÃ¡znam SDL douÄovÃ¡nÃ­, kterÃ½ je k dispozici <a href="https://www.youtube.com/watch?v=jUktXOH5o1I">zde</a>
[01:23:06].</p>
</blockquote>
<p><a href="https://www.libsdl.org/"><code>SDL</code></a> je knihovna pro tvorbu interaktivnÃ­ch grafickÃ½ch aplikacÃ­ a her.
UmoÅ¾Åˆuje nÃ¡m vytvÃ¡Å™et okna, vykreslovat do nich jednotlivÃ© pixely, obrÃ¡zky Äi text, snÃ­mat vstup z
myÅ¡i a klÃ¡vesnice Äi tÅ™eba pÅ™ehrÃ¡vat zvuk. JednÃ¡ se tak v podstatÄ› o tzv. <strong>hernÃ­ engine</strong>, i kdyÅ¾
ve srovnÃ¡nÃ­ napÅ™. s enginy <a href="https://unity.com/">Unity</a> nebo <a href="https://www.unrealengine.com/">Unreal</a>
je tento engine velmi jednoduchÃ½.</p>
<p>V tÃ©to kapitole naleznete informace o tom, jak SDL nainstalovat, jak pÅ™eloÅ¾it program vyuÅ¾Ã­vajÃ­cÃ­ SDL funkcÃ­
a jak mÅ¯Å¾e vypadat zÃ¡kladnÃ­ SDL program, kterÃ½ nÄ›co vykresluje na obrazovku. V nÃ¡sledujÃ­cÃ­ch podkapitolÃ¡ch se potÃ© mÅ¯Å¾ete
dozvÄ›dÄ›t vÃ­ce o konceptech SDL uÅ¾iteÄnÃ½ch pro tvorbu her:</p>
<ul>
<li><a href="c/aplikovane_ulohy/sdl/herni_smycka.html">HernÃ­ smyÄka</a></li>
<li><a href="c/aplikovane_ulohy/sdl/kresleni.html">KreslenÃ­</a></li>
<li><a href="c/aplikovane_ulohy/sdl/vstup.html">ZpracovÃ¡nÃ­ vstupu</a></li>
</ul>
<h2><a class="header" href="#instalace-sdl" id="instalace-sdl">Instalace <code>SDL</code></a></h2>
<p>NarozdÃ­l od knihovny, kterou jsme si ukazovali pro vytvÃ¡Å™enÃ­ <a href="c/aplikovane_ulohy/gif.html"><code>GIF</code> animacÃ­</a>, <code>SDL</code> obsahuje
spoustu zdrojovÃ½ch i hlaviÄkovÃ½ch souborÅ¯, a nebylo by tak ideÃ¡lnÃ­ ji kopÃ­rovat k naÅ¡emu programu.
PÅ™ipojÃ­me ji tedy k naÅ¡emu programu jako klasickou
<a href="c/aplikovane_ulohy/../modularizace/knihovny.html#pou%C5%BEit%C3%AD-knihoven-s-gcc">knihovnu</a> ve formÄ› archivu. Abychom knihovnu
mohli pouÅ¾Ã­t, nejprve si ji musÃ­me stÃ¡hnout. To mÅ¯Å¾eme udÄ›lat dvÄ›ma zpÅ¯soby:</p>
<ul>
<li><strong>Instalace pomocÃ­ sprÃ¡vce balÃ­ÄkÅ¯</strong> (<em>doporuÄeno</em>): JelikoÅ¾ je <code>SDL</code> velmi znÃ¡mÃ¡ a pouÅ¾Ã­vanÃ¡
knihovna, ve vÄ›tÅ¡inÄ› distribucÃ­ Linuxu nenÃ­ problÃ©m ji nainstalovat pÅ™Ã­mo pomocÃ­ sprÃ¡vce balÃ­ÄkÅ¯.
V Ubuntu to mÅ¯Å¾ete provÃ©st pomocÃ­ nÃ¡sledujÃ­cÃ­ho pÅ™Ã­kazu v terminÃ¡lu, kterÃ½ nainstaluje kromÄ› zÃ¡kladnÃ­ SDL knihovny
takÃ© dvÄ› dalÅ¡Ã­ pomocnÃ© knihovny potÅ™ebnÃ© pro vykreslovÃ¡nÃ­ obrÃ¡zkÅ¯ a textu<sup class='margin-toggle sidenote-number'>1</sup>:
<pre><code class="language-bash">$ sudo apt install libsdl2-dev libsdl2-image-dev libsdl2-ttf-dev
</code></pre>
VÃ½hodou tohoto zpÅ¯sobu je, Å¾e knihovna bude nainstalovÃ¡na v systÃ©movÃ½ch cestÃ¡ch, a pÅ™ekladaÄ <code>gcc</code> ji tak
bude umÄ›t naleznout i bez toho, abychom mu museli zadat explicitnÃ­ cestu. NevÃ½hodou mÅ¯Å¾e bÃ½t, Å¾e verze
knihoven nabÃ­zenÃ© sprÃ¡vci balÃ­ÄkÅ¯ bÃ½vajÃ­ typicky docela zastaralÃ©.<span class='sidenote'><p><sup class='number'>1</sup>Pokud by vÃ¡s zajÃ­malo, kterÃ© vÅ¡echny soubory a kam se nainstalovaly, mÅ¯Å¾ete po instalaci balÃ­ÄkÅ¯
pouÅ¾Ã­t pÅ™Ã­kaz</p>
<pre><code class="language-bash">$ dpkg -L libsdl2-dev
</code></pre>
</span></li>
</ul>
<ul>
<li><strong>ManuÃ¡lnÃ­ staÅ¾enÃ­ knihovny</strong>: Knihovnu si mÅ¯Å¾ete takÃ© stÃ¡hnout manuÃ¡lnÄ›, napÅ™. z
<a href="https://github.com/libsdl-org/SDL/releases/download/release-2.28.3/SDL2-2.28.3.zip">GitHubu SDL</a>. NÄ›kterÃ© knihovny
mÅ¯Å¾ete naleznout na internetu uÅ¾ pÅ™eloÅ¾enÃ©, nicmÃ©nÄ› <code>SDL</code> oficiÃ¡lnÄ› pro Linux pÅ™eloÅ¾enÃ© knihovnÃ­ soubory (<code>.so</code>)
nenabÃ­zÃ­. V tomto pÅ™Ã­padÄ› tak musÃ­te knihovnu nejenom stÃ¡hnout, ale takÃ© ruÄnÄ› pÅ™eloÅ¾it, neÅ¾ ji budete moct pouÅ¾Ã­t ve
svÃ©m programu.</li>
</ul>
<h2><a class="header" href="#pÅ™ilinkovÃ¡nÃ­-knihovny-sdl" id="pÅ™ilinkovÃ¡nÃ­-knihovny-sdl">PÅ™ilinkovÃ¡nÃ­ knihovny <code>SDL</code></a></h2>
<p>Pokud jste nainstalovali <code>SDL</code> pomocÃ­ systÃ©movÃ½ch balÃ­ÄkÅ¯, staÄÃ­ pÅ™i pÅ™ekladu programu pÅ™ilinkovat
knihovnu <code>SDL2</code>:</p>
<pre><code class="language-bash">$ gcc main.c -omain -lSDL2
</code></pre>
<p>Pokud jste knihovnu pÅ™eklÃ¡dali manuÃ¡lnÄ›, musÃ­te jeÅ¡tÄ› pouÅ¾Ã­t parametry <code>-I</code> pro pÅ™edÃ¡nÃ­ cesty k
hlaviÄkovÃ½m souborÅ¯m a <code>-L</code> pro pÅ™edÃ¡nÃ­ cesty k adresÃ¡Å™i s pÅ™eloÅ¾enou knihovnou, jak jiÅ¾ bylo
vysvÄ›tleno <a href="c/aplikovane_ulohy/../modularizace/knihovny.html#pou%C5%BEit%C3%AD-knihoven-s-gcc">zde</a>.</p>
<p>Pro prÃ¡ci s obrÃ¡zky bude dÃ¡le nutnÃ© pÅ™ilinkovat knihovnu <code>SDL2_image</code> a pro prÃ¡ci s textem knihovnu
<code>SDL2_ttf</code>.</p>
<p>Pokud byste chtÄ›li pouÅ¾Ã­vat SDL v kombinaci s <a href="c/aplikovane_ulohy/../automatizace_prekladu.html#cmake">CMake</a>, mÅ¯Å¾ete pouÅ¾Ã­t
tento vzorovÃ½ <code>CMakeLists.txt</code> soubor:</p>
<details>
<summary>CMakeLists.txt soubor pro SDL</summary>
<pre><code class="language-cmake">cmake_minimum_required(VERSION 3.18)

project(sdlapp)

find_package(SDL2 REQUIRED)

add_executable(main main.c)
target_link_libraries(main SDL2 SDL2_image SDL2_ttf)
</code></pre>
</details>
<h2><a class="header" href="#zprovoznÄ›nÃ­-sdl-pod-wsl" id="zprovoznÄ›nÃ­-sdl-pod-wsl">ZprovoznÄ›nÃ­ SDL pod WSL</a></h2>
<p>Pokud chcete pouÅ¾Ã­t knihovnu SDL v kombinaci s pouÅ¾itÃ­m systÃ©mu <a href="c/aplikovane_ulohy/../../prostredi/linux/instalace.html">WSL</a>,
budete si muset nastavit zobrazovÃ¡nÃ­ grafickÃ½ch Linux aplikacÃ­ na Windows.</p>
<p>Pokud mÃ¡te aktuÃ¡lnÃ­ verzi Windows 11 a WSL, tak by mÄ›lo staÄit spustit grafickÃ½ program (napÅ™. C program
vyuÅ¾Ã­vajÃ­cÃ­ SDL). VÃ­ce detailÅ¯ se mÅ¯Å¾ete dozvÄ›dÄ›t <a href="https://learn.microsoft.com/en-us/windows/wsl/tutorials/gui-apps">zde</a>.
Pokud nemÃ¡te Windows 11 nebo se vÃ¡m grafickÃ½ vÃ½stup aplikace nezobrazuje, tak budete muset pouÅ¾Ã­t tzv. &quot;Emulaci X serveru&quot;,
popsanou nÃ­Å¾e.</p>
<details>
<summary>Emulace X serveru</summary>
<p>JednÃ­m ze zpÅ¯sobÅ¯, kterÃ½ se na Linuxu pouÅ¾Ã­vÃ¡ pro vykreslovÃ¡nÃ­ grafiky, je tzv.
<a href="https://en.wikipedia.org/wiki/X_Window_System">X server</a>. Funguje tak, Å¾e aplikace, kterÃ© chtÄ›jÃ­ nÄ›co
vykreslit, komunikujÃ­ s X serverem, kterÃ½ potÃ© grafiku vykreslÃ­ v nÄ›jakÃ©m oknÄ›.</p>
<p>Aby toto fungovalo pod Windows, tak musÃ­te na Windows spustit X server, ke kterÃ©mu se potÃ© pÅ™ipojÃ­
klient (vaÅ¡e C SDL aplikace) spuÅ¡tÄ›nÃ¡ pod systÃ©mem WSL.</p>
<p>NÃ¡vod, jak tento X server na Windows nainstalovat, naleznete napÅ™. <a href="https://techcommunity.microsoft.com/t5/windows-dev-appconsult/running-wsl-gui-apps-on-windows-10/ba-p/1493242">zde</a>.</p>
<p>ZkrÃ¡cenÃ¡ verze nÃ¡vodu:</p>
<ol>
<li>
<p>StÃ¡hnÄ›te a nainstalujte si program <a href="https://sourceforge.net/projects/vcxsrv/">VcXsrv</a>.</p>
</li>
<li>
<p>ZapnÄ›te na Windows program <code>XLaunch</code> a v nastavenÃ­ zaÅ¡krtnÄ›te volbu <code>Disable access control</code>.</p>
<p>Tento program musÃ­ bÄ›Å¾et na pozadÃ­, aby fungovalo spouÅ¡tÄ›nÃ­ grafickÃ½ch aplikacÃ­ pod WSL (pokud
restartujete poÄÃ­taÄ, budete ho muset spustit znovu).</p>
</li>
<li>
<p>Ve WSL terminÃ¡lu potÃ© musÃ­te nastavit promÄ›nnou prostÅ™edÃ­ <code>DISPLAY</code> na sprÃ¡vnou hodnotu, aby
spuÅ¡tÄ›nÃ½ program komunikoval s X serverem spuÅ¡tÄ›nÃ½m pod Windows. DosÃ¡hnout toho mÅ¯Å¾ete napÅ™. nÃ¡sledujÃ­cÃ­m
pÅ™Ã­kazem:</p>
<pre><code class="language-console">$ export DISPLAY=&quot;`grep nameserver /etc/resolv.conf | sed 's/nameserver //'`:0&quot;
</code></pre>
<p>Tento pÅ™Ã­kaz musÃ­te spustit v terminÃ¡lu, odkud budete vaÅ¡i SDL aplikaci spouÅ¡tÄ›t. Pokud spustÃ­te
novÃ½ terminÃ¡l, musÃ­te pÅ™Ã­kaz spustit znovu.</p>
</li>
<li>
<p>DÃ¡le by mÄ›lo staÄit spustit SDL aplikaci a jejÃ­ grafickÃ½ vÃ½stup by se mÄ›l objevit v novÃ©m oknÄ›
pod Windows.</p>
</li>
</ol>
</details>
<h2><a class="header" href="#dokumentace" id="dokumentace">Dokumentace</a></h2>
<p>Abyste mohli pouÅ¾Ã­vat nÄ›jakou sloÅ¾itÄ›jÅ¡Ã­ knihovnu, je nutnÃ© se zorientovat v jejÃ­ dokumentaci. V tÃ©
naleznete jednak deklarace a popis fungovÃ¡nÃ­ jednotlivÃ½ch funkcÃ­, kterÃ© knihovna nabÃ­zÃ­, ale takÃ©
rÅ¯znÃ© nÃ¡vody pro to, jak s knihovnou pracovat.</p>
<p>Dokumentaci funkcÃ­ <code>SDL</code> naleznete <a href="https://wiki.libsdl.org/APIByCategory">zde</a>, nÃ¡vody pro jeho
pouÅ¾itÃ­ napÅ™Ã­klad <a href="https://www.willusher.io/pages/sdl2/">tady</a>. V pÅ™edmÄ›tu <code>UPR</code> budeme pouÅ¾Ã­vat
pouze <code>SDL</code> verze 2, kterÃ© se znaÄnÄ› liÅ¡Ã­ od pÅ™edchozÃ­ verze. DÃ¡vejte si tedy u nÃ¡vodÅ¯ na internetu
pozor na to, jestli se tÃ½kajÃ­ sprÃ¡vnÃ© verze <code>SDL</code>.</p>
<blockquote>
<p><code>SDL</code> je relativnÄ› rozsÃ¡hlÃ¡ knihovna a nenÃ­ v silÃ¡ch tohoto textu, abychom ji plnÄ› popsali. Proto
nÃ­Å¾e naleznete pouze velmi struÄnÃ½ &quot;Hello world&quot; a seznam vÄ›cÃ­, kterÃ© vÃ¡m SDL umoÅ¾Åˆuje. Zbytek
naleznete v dokumentaci a nÃ¡vodech na internetu.</p>
</blockquote>
<h2><a class="header" href="#sdl-hello-world" id="sdl-hello-world"><code>SDL</code> hello world</a></h2>
<p>Abychom nÄ›co vykreslili, tak jako prvnÃ­ vÄ›c musÃ­me nainicializovat SDL a vytvoÅ™it okno<sup class='margin-toggle sidenote-number'>2</sup>:</p>
<span class='sidenote'><p><sup class='number'>2</sup>Pro zpÅ™ehlednÄ›nÃ­ kÃ³du bude v ukÃ¡zkÃ¡ch nÃ­Å¾e vynechÃ¡na kontrola chyb. CelÃ½ program i s kontrolou
chyb naleznete na konci tÃ©to sekce.</p>
</span>
<pre><code class="language-c">// VloÅ¾enÃ­ hlavnÃ­ho hlaviÄkovÃ©ho souboru SDL
#include &lt;SDL2/SDL.h&gt;

int main()
{
    // Inicializace SDL
    SDL_Init(SDL_INIT_VIDEO);

    // VytvoÅ™enÃ­ okna
    SDL_Window* window = SDL_CreateWindow(
        &quot;SDL experiments&quot;,  // Titulek okna
        100,                // SouÅ™adnice x
        100,                // SouÅ™adnice y
        800,                // Å Ã­Å™ka
        600,                // VÃ½Å¡ka
        SDL_WINDOW_SHOWN    // Okno se mÃ¡ po vytvoÅ™enÃ­ rovnou zobrazit
    );
</code></pre>
<p>Jakmile mÃ¡me otevÅ™enÃ© okno, mÅ¯Å¾eme do nÄ›j nÄ›co zaÄÃ­t vykreslovat. K tomu musÃ­me nejprve vytvoÅ™it
<code>SDL_Renderer</code>, neboli kreslÃ­tko:</p>
<pre><code class="language-c">    // VytvoÅ™enÃ­ kreslÃ­tka
    SDL_Renderer* renderer = SDL_CreateRenderer(
        window,
        -1,
        SDL_RENDERER_ACCELERATED | SDL_RENDERER_PRESENTVSYNC
    );
</code></pre>
<p>S kreslÃ­tkem uÅ¾ mÅ¯Å¾eme nÄ›co nakreslit na obrazovku. MusÃ­me vytvoÅ™it tzv.
<a href="https://en.wikipedia.org/wiki/Video_game_programming#Game_structure"><strong>hernÃ­ smyÄku</strong></a> (<em>game
loop</em>), kterÃ¡ se bude provÃ¡dÄ›t neustÃ¡le dokola. Ve smyÄce nejprve zÃ­skÃ¡me udÃ¡losti, kterÃ© nastaly
(napÅ™. doÅ¡lo ke stisknutÃ­ klÃ¡vesy nebo pohybu myÅ¡i), potÃ© je zpracujeme, vykreslÃ­me novÃ½ obsah
okna a odeÅ¡leme jej k vykreslenÃ­ (za pouÅ¾itÃ­ tzv.
<a href="https://en.wikipedia.org/wiki/Multiple_buffering#Double_buffering_in_computer_graphics"><strong>double bufferingu</strong></a>).</p>
<p>KonkrÃ©tnÄ› budeme vykreslovat jednoduchou posouvajÃ­cÃ­ se ÄÃ¡ru, dokud uÅ¾ivatel nezavÅ™e otevÅ™enÃ© okno:</p>
<pre><code class="language-c">    SDL_Event event;
    int running = 1;
    int line_x = 100;

    while (running == 1)
    {
        // Dokud jsou k dispozici nÄ›jakÃ© udÃ¡losti, uklÃ¡dej je do promÄ›nnÃ© `event`
        while (SDL_PollEvent(&amp;event))
        {
            // Pokud doÅ¡lo k uzavÅ™enÃ­ okna, nastav promÄ›nnou `running` na `0`
            if (event.type == SDL_QUIT)
            {
                running = 0;
            }
        }

        // PosuÅˆ pozici ÄÃ¡ry doprava
        line_x++;

        // Nastav barvu vykreslovÃ¡nÃ­ na Äernou
        SDL_SetRenderDrawColor(renderer, 0, 0, 0, 255);

        // Vykresli pozadÃ­
        SDL_RenderClear(renderer);

        // Nastav barvu vykreslovÃ¡nÃ­ na Äervenou
        SDL_SetRenderDrawColor(renderer, 255, 0, 0, 255);

        // Vykresli ÄÃ¡ru
        SDL_RenderDrawLine(renderer, line_x, 50, line_x, 250);

        // Zobraz vykreslenÃ© prvky na obrazovku
        SDL_RenderPresent(renderer);
    }
</code></pre>
<p>A na konci uÅ¾ akorÃ¡t vÅ¡e uvolnÃ­me:</p>
<pre><code class="language-c">    // UvolnÄ›nÃ­ prostÅ™edkÅ¯
    SDL_DestroyRenderer(renderer);
    SDL_DestroyWindow(window);
    SDL_Quit();

    return 0;
}
</code></pre>
<blockquote>
<p>Pokud spustÃ­te program vyuÅ¾Ã­vajÃ­cÃ­ <code>SDL</code> s Address sanitizerem, mÅ¯Å¾e se stÃ¡t, Å¾e vÃ¡m sanitizer
zobrazÃ­ nÄ›jakou <a href="c/aplikovane_ulohy/../../caste_chyby/pametove_chyby.html#memory-leak">neuvolnÄ›nou pamÄ›Å¥</a>. Pokud zdroj
alokace nepochÃ¡zÃ­ z vaÅ¡eho kÃ³du, mÅ¯Å¾ete tyto chyby ignorovat. Tyto chyby pochÃ¡zÃ­ pÅ™Ã­mo z SDL a nemÃ¡te
se jich jak zbavit.</p>
</blockquote>
<details>
<summary>CelÃ½ kÃ³d i s oÅ¡etÅ™enÃ­m chyb</summary>
<pre><code class="language-c">#include &lt;SDL2/SDL.h&gt;

int main()
{
    if (SDL_Init(SDL_INIT_VIDEO)) {
        fprintf(stderr, &quot;SDL_Init Error: %s\n&quot;, SDL_GetError());
        return 1;
    }
    SDL_Window* window = SDL_CreateWindow(&quot;SDL experiments&quot;, 100, 100, 800, 600, SDL_WINDOW_SHOWN);
    if (!window) {
        fprintf(stderr, &quot;SDL_CreateWindow Error: %s\n&quot;, SDL_GetError());
        SDL_Quit();
        return 1;
    }

    SDL_Renderer* renderer = SDL_CreateRenderer(window, -1, SDL_RENDERER_ACCELERATED | SDL_RENDERER_PRESENTVSYNC);
    if (!renderer) {
        SDL_DestroyWindow(window);
        fprintf(stderr, &quot;SDL_CreateRenderer Error: %s&quot;, SDL_GetError());
        SDL_Quit();
        return 1;
    }

    int line_x = 100;

    SDL_Event event;
    int running = 1;

    while (running == 1)
    {
        while (SDL_PollEvent(&amp;event))
        {
            if (event.type == SDL_QUIT)
            {
                running = 0;
            }
        }

        line_x++;
    
        SDL_SetRenderDrawColor(renderer, 0, 0, 0, 255); // NastavenÃ­ barvy na Äernou
        SDL_RenderClear(renderer);                      // VykreslenÃ­ pozadÃ­

        SDL_SetRenderDrawColor(renderer, 255, 0, 0, 255); // NastavenÃ­ barvy na Äervenou
        SDL_RenderDrawLine(renderer, line_x, 50, line_x, 250); // VykreslenÃ­ ÄÃ¡ry

        SDL_RenderPresent(renderer);  // Prezentace kreslÃ­tka
    }

    SDL_DestroyRenderer(renderer);
    SDL_DestroyWindow(window);
    SDL_Quit();

    return 0;
}
</code></pre>
</details>
<h2><a class="header" href="#co-lze-vÅ¡echno-dÄ›lat-pomocÃ­-sdl" id="co-lze-vÅ¡echno-dÄ›lat-pomocÃ­-sdl">Co lze vÅ¡echno dÄ›lat pomocÃ­ <code>SDL</code>?</a></h2>
<p>Knihovna <code>SDL</code> nabÃ­zÃ­ spoustu funkcionality k tvorbÄ› interaktivnÃ­ch aplikacÃ­ a her. MÅ¯Å¾ete s nÃ­
napÅ™Ã­klad:</p>
<ul>
<li><a href="https://wiki.libsdl.org/CategoryRender">Vykreslovat</a> body, ÄÃ¡ry Äi obdÃ©lnÃ­ky.</li>
<li>Reprezentovat <a href="https://wiki.libsdl.org/CategoryRect">obdÃ©lnÃ­ky</a> a poÄÃ­tat jejich prÅ¯niky (napÅ™.
pro detekci kolizÃ­ hernÃ­ch objektÅ¯).</li>
<li><a href="https://wiki.libsdl.org/CategoryEvents">Reagovat</a> na vstup uÅ¾ivatele, aÅ¥ uÅ¾ z klÃ¡vesnice nebo z myÅ¡i.</li>
<li>NaÄÃ­tat a vykreslovat <a href="https://wiki.libsdl.org/SDL_image/FrontPage">obrÃ¡zky</a>.</li>
<li>NaÄÃ­tat a vykreslovat <a href="https://wiki.libsdl.org/SDL_ttf/FrontPage">text</a>.</li>
<li>PÅ™ehrÃ¡vat <a href="https://wiki.libsdl.org/CategoryAudio">zvuk</a>.</li>
</ul>
<h1><a class="header" href="#hernÃ­-smyÄka" id="hernÃ­-smyÄka">HernÃ­ smyÄka</a></h1>
<p>ZÃ¡kladem vÃ­cemÃ©nÄ› vÅ¡ech &quot;real-time&quot; poÄÃ­taÄovÃ½ch her je tzv. hernÃ­ smyÄka. JednÃ¡ se o cyklus v programu,
kterÃ½ se starÃ¡ o aktualizaci stavu hry, a vykreslenÃ­ jednoho tzv. <strong>snÃ­mku</strong> (<em>frame</em>) na obrazovku. Hry typicky fungujÃ­
tak, Å¾e bÄ›Å¾Ã­ donekoneÄna v tomto cyklu (hernÃ­ smyÄce), a napÅ™. 60x za vteÅ™inu aktualizujÃ­ stav hry a potÃ© jej vykreslÃ­.
Z toho takÃ© pochÃ¡zÃ­ pojem <strong>SnÃ­mkÅ¯ za vteÅ™inu</strong> (<em>Frame per second</em>, <em>FPS</em>), kterÃ½ udÃ¡vÃ¡, jak Äasto je hra schopnÃ¡ se
vykreslit za vteÅ™inu.</p>
<p>HernÃ­ smyÄku vytvoÅ™Ã­me jednoduÅ¡e jako cyklus, kterÃ½ pobÄ›Å¾Ã­ aÅ¾ do doby, neÅ¾ bude potÅ™eba naÅ¡i hru vypnout:</p>
<pre><code class="language-c">int running = 1;
while (running == 1) {
    // TÄ›lo hernÃ­ smyÄky
}
</code></pre>
<p>V kaÅ¾dÃ© iteraci hernÃ­ smyÄky bychom mÄ›li provÃ©st nÃ¡sledujÃ­cÃ­ Äinnosti (ideÃ¡lnÄ› v tomto poÅ™adÃ­):</p>
<ol>
<li>PÅ™eÄÃ­st a zareagovat na udÃ¡losti operaÄnÃ­ho systÃ©mu
<ul>
<li>NapÅ™. Å¾Ã¡dost o vypnutÃ­ aplikace, stisk klÃ¡vesy, pohyb myÅ¡i</li>
</ul>
</li>
<li>Aktualizovat stav hry v pamÄ›ti
<ul>
<li>NapÅ™. pohnout postavou Äi projektilem, aktualizovat Äas cooldownu atd.</li>
</ul>
</li>
<li>Vykreslit aktuÃ¡lnÃ­ stav hry na obrazovku</li>
</ol>
<h2><a class="header" href="#reakce-na-udÃ¡losti" id="reakce-na-udÃ¡losti">Reakce na udÃ¡losti</a></h2>
<p>Jako ÃºplnÃ½ zÃ¡klad bychom mÄ›li mÃ­t v hernÃ­ smyÄce ÄtenÃ­ udÃ¡lostÃ­ operaÄnÃ­ho systÃ©mu, kterÃ© si mÅ¯Å¾eme pÅ™eÄÃ­st pomocÃ­
volÃ¡nÃ­ funkce <a href="https://wiki.libsdl.org/SDL2/SDL_PollEvent"><code>SDL_PollEvent</code></a>. Do tÃ©to funkce pÅ™edÃ¡me adresu struktury
<a href="https://wiki.libsdl.org/SDL2/SDL_Event"><code>SDL_Event</code></a>, a pokud funkce vrÃ¡tÃ­ hodnotu <code>1</code>, tak doÅ¡lo k nÄ›jakÃ© udÃ¡losti,
a my si mÅ¯Å¾eme informaci o tÃ©to udÃ¡losti z pÅ™edanÃ© struktury <code>SDL_Event</code> pÅ™eÄÃ­st:</p>
<pre><code class="language-c">SDL_Event event;
while (SDL_PollEvent(&amp;event)) {
    // Pokud doÅ¡lo k uzavÅ™enÃ­ okna, nastav promÄ›nnou `running` na `0`
    if (event.type == SDL_QUIT) {
        running = 0;
    }
}
</code></pre>
<p>Pokud dojde k udÃ¡losti <code>SQL_QUIT</code>, tak se uÅ¾ivatel snaÅ¾Ã­ naÅ¡i aplikaci vypnout (napÅ™. kliknutÃ­m na ikonku kÅ™Ã­Å¾ku v rohu
okna aplikace). Na tuto udÃ¡lost bychom mÄ›li zareagovat tak, Å¾e nÃ¡Å¡ program (hru) vypneme.<sup class='margin-toggle sidenote-number'>1</sup></p>
<span class='sidenote'><p><sup class='number'>1</sup>Pokud bychom tak neudÄ›lali, tak se aplikace &quot;zasekne&quot;, a zobrazÃ­ se nechvalnÄ› znÃ¡mÃ½ dialog operaÄnÃ­ho systÃ©mu o
neresponzivnÃ­ aplikaci.</p>
</span>
<p>PÅ™i kontrole udÃ¡lostÃ­ budeme chtÃ­t typicky reagovat na vstup uÅ¾ivatele z klÃ¡vesnice Äi myÅ¡i. VÃ­ce o zpracovÃ¡nÃ­ vstupu
se mÅ¯Å¾ete dozvÄ›dÄ›t <a href="c/aplikovane_ulohy/sdl/vstup.html">zde</a>.</p>
<h2><a class="header" href="#kompenzace-fps" id="kompenzace-fps">Kompenzace FPS</a></h2>
<p>PÅ™i aktualizaci stavu hry a provÃ¡dÄ›nÃ­ jakÃ©hokoliv pohybu, rotace apod. bychom mÄ›li vÅ¾dy brÃ¡t v potaz <strong>kompenzaci FPS</strong>
(snÃ­mkÅ¯ za vteÅ™inu). PÅ™edstavte si, Å¾e v naÅ¡Ã­ hÅ™e mÃ¡me nÄ›jakÃ½ pohybujÃ­cÃ­ se objekt, kterÃ½ chceme posouvat v
kaÅ¾dÃ©m snÃ­mku hry o nÄ›jakÃ½ poÄet pixelÅ¯ danÃ½m smÄ›rem:</p>
<pre><code class="language-c">int position = 0;
while (running == 1) {
    // ...

    position += 1;
    SDL_RenderDrawLine(renderer, position, 100, position, 200);

    // ...
}
</code></pre>
<p>V kÃ³du vÃ½Å¡e posouvÃ¡me v kaÅ¾dÃ© iteraci pozici ÄÃ¡ry o jeden pixel. Co se v tomto pÅ™Ã­padÄ› stane, kdyÅ¾ naÅ¡e aplikace bude mÃ­t
60 FPS? ÄŒÃ¡ra se za jednu vteÅ™inu posune o 60 pixelÅ¯. Pokud by naÅ¡e aplikace mÄ›la ale napÅ™. pouze 20 FPS, tak se ÄÃ¡ra posune
pouze o 20 pixelÅ¯! A kdyby mÄ›la 1000 FPS, tak se naopak posune o celÃ½ch 1000 pixelÅ¯.</p>
<p>Pokud by logika her zÃ¡visela na poÄtu FPS, tak by to jistÄ› zpÅ¯sobovalo problÃ©my. PÅ™edstavte si napÅ™Ã­klad, Å¾e v hrÃ¡ch,
jako je Call of Duty nebo Counter-Strike, by poÄet FPS ovlivÅˆoval, jak rychle postava pobÄ›Å¾Ã­ nebo jak rychle se budou
pohybovat projektily, kterÃ© postava vystÅ™elÃ­. S takovÃ½mto Å™eÅ¡enÃ­m by hrÃ¡Äi ani autoÅ™i hry urÄitÄ› nebyli spokojeni.</p>
<p>IdeÃ¡lnÄ› bychom chtÄ›li, aby se v naÅ¡Ã­ hÅ™e vÅ¡e pohybovalo stanovenou rychlostÃ­, nezÃ¡visle na souÄasnÃ© hodnotÄ› FPS.
Toho mÅ¯Å¾eme dosÃ¡hnout pomocÃ­ tzv. <strong>delta Äasu</strong> (<em>delta time</em>). Delta je oznaÄenÃ­ pro Äas vykonÃ¡nÃ­ jednÃ© iterace hernÃ­
smyÄky. ÄŒÃ­m vÃ­ce bude mÃ­t naÅ¡e hra FPS, tÃ­m menÅ¡Ã­ bude delta:</p>
<ul>
<li>PÅ™i <code>60 FPS</code> je delta <code>~0.016 s</code>, neboli <code>~16 ms</code></li>
<li>PÅ™i <code>10 FPS</code> je delta <code>~0.1 s</code>, neboli <code>~100 ms</code></li>
<li>PÅ™i <code>1 FPS</code> je delta <code>~1 s</code>, neboli <code>~1000 ms</code></li>
</ul>
<p>Deltu mÅ¯Å¾eme vypoÄÃ­tat pomocÃ­ funkcÃ­ na mÄ›Å™enÃ­ Äasu nabÃ­zenÃ½ch knihovnou SDL:</p>
<pre><code class="language-c">// UloÅ¾enÃ­ poslednÃ­ hodnoty ÄÃ­taÄe
Uint64 last = SDL_GetPerformanceCounter();

while (running == 1) {
    // ZjiÅ¡tÄ›nÃ­ souÄasnÃ© hodnoty ÄÃ­taÄe
    Uint64 now = SDL_GetPerformanceCounter();
    
    // VÃ½poÄet delty, Äasu od poslednÃ­ho provedenÃ­ tohoto Å™Ã¡dku (tj. dÃ©lky iterace hernÃ­ smyÄky)
    double deltaTime = (double)((now - last) / (double)SDL_GetPerformanceFrequency());

    // UloÅ¾enÃ­ poslednÃ­ hodnoty ÄÃ­taÄe
    last = now;

    // ...
}
</code></pre>
<blockquote>
<p>Pokud si chcete namÄ›Å™it a vypisovat hodnotu FPS svÃ© hry, staÄÃ­ vypsat pÅ™evrÃ¡cenou hodnotu delty, tj. platÃ­
<code>FPS = 1 / deltaTime</code>.</p>
</blockquote>
<p>Jakmile mÃ¡me k dispozici hodnotu delty, mÅ¯Å¾eme ji vyuÅ¾Ã­t k tomu, abychom pohyb ve hÅ™e pÅ™izpÅ¯sobili poÄtu FPS. Toho dosÃ¡hneme
tak, Å¾e budeme kaÅ¾dÃ½ pohyb ve hÅ™e &quot;Å¡kÃ¡lovat&quot; (neboli nÃ¡sobit) hodnotou delty:</p>
<pre><code class="language-c">position += 100 * deltaTime;
</code></pre>
<p>KdyÅ¾ budeme mÃ­t hodnÄ› FPS (tj. malou hodnotu delty), tak budeme hÃ½bat (a vykreslovat) objekty spoustakrÃ¡t za vteÅ™inu, takÅ¾e
chceme, aby objekty dÄ›laly malÃ© kroky, a hÃ½baly se plynule. V tomto pÅ™Ã­padÄ› bude delta mÃ­t malou hodnotu, takÅ¾e pohyb
se bude provÃ¡dÄ›t po malÃ½ch krocÃ­ch. Pokud budeme mÃ­t naopak mÃ¡lo FPS (tj. velkou hodnotu delty), tak budeme hÃ½bat
objekty pouze nÄ›kolikrÃ¡t za vteÅ™inu, takÅ¾e potÃ© musÃ­ objekty udÄ›lat vÄ›tÅ¡Ã­ krok, aby urazily stejnou vzdÃ¡lenost za stejnou
Äasovou jednotku. V tomto pÅ™Ã­padÄ› bude delta mÃ­t velkou hodnotu, takÅ¾e pohyb se bude provÃ¡dÄ›t po velkÃ½ch krocÃ­ch.</p>
<p>Tento princip si mÅ¯Å¾eme demonstrovat na nÃ¡sledujÃ­cÃ­ch animaci, kterÃ© zobrazujÃ­ pohyb tÅ™Ã­ obdÃ©lnÃ­kÅ¯ s rÅ¯znÃ½m poÄtem
snÃ­mkÅ¯ za vteÅ™inu. PrvnÃ­ obdÃ©lnÃ­k se pohybuje s 60 FPS, druhÃ½ obdÃ©lnÃ­k s 10 FPS, a tÅ™etÃ­ obdÃ©lnÃ­k s 1 FPS.
VÅ¡imnÄ›te si, Å¾e za stejnou dobu vÅ¡echny obdÃ©lnÃ­ky urazÃ­ cca stejnou vzdÃ¡lenost. DÃ­ky kompenzaci pohybu pomocÃ­
delta Äasu jsou tak rychlosti obdÃ©lnÃ­kÅ¯ nezÃ¡vislÃ© na FPS.</p>
<img src="c/aplikovane_ulohy/sdl/../../../static/img/sdl/fps-compensation.gif" width="300" height="200" alt="FPS compensation demonstration" />
<p><strong>NezapomeÅˆte tak ve svÃ½ch hrÃ¡ch vÅ¡echny pohyby, rotace, animace, aktualizace Äasu, cooldownÅ¯ atd. nÃ¡sobit deltou!</strong></p>
<p>U nÃ¡sobenÃ­ hodnot deltou je potÅ™eba dÃ¡t si pozor na jednu vÄ›c, a to jsou desetinnÃ¡ ÄÃ­sla. Pokud budeme mÃ­t napÅ™. pozici
nÄ›jakÃ©ho objektu ve hÅ™e reprezentovanou celÃ½m ÄÃ­slem (<code>int</code>), tak mÅ¯Å¾e dojÃ­t k problÃ©mu se zaokrouhlovÃ¡nÃ­m. Pokud napÅ™.
budeme chtÃ­t tento objekt posunout rychlostÃ­ 10, a budeme mÃ­t 60 FPS, tak <code>10 * 0.016</code> je <code>0.16</code>, coÅ¾ se pÅ™i pÅ™evodu
na <code>int</code> zaokrouhlÃ­ na hodnotu <code>0</code>! PÅ™i nÃ¡sobenÃ­ deltou bychom se tedy mohli dostat do situace, kdy se naÅ¡e objekty
vÅ¯bec nebudou hÃ½bat, protoÅ¾e jednotlivÃ© kroky budou moc malÃ© na to, aby se vÅ¯bec na hodnotÄ› celÃ©ho ÄÃ­sla projevily. Proto
se snaÅ¾te reprezentovat veÅ¡kerÃ© pozice a podobnÃ© hodnoty, kterÃ© musÃ­te nÃ¡sobit deltou, pomocÃ­ desetinnÃ½ch ÄÃ­sel, tj.
datovÃ½ch typÅ¯ <code>float</code> nebo <code>double</code>.</p>
<h2><a class="header" href="#v-sync" id="v-sync">V-sync</a></h2>
<p>Pokud spustÃ­te svou hru a namÄ›Å™Ã­te si poÄet FPS, tak moÅ¾nÃ¡ zjistÃ­te, Å¾e poÄet snÃ­mkÅ¯ je &quot;zamknutÃ½&quot; na nÄ›jakÃ© pevnÃ© hodnotÄ›,
napÅ™. 60 FPS, a nestoupÃ¡ vÃ½Å¡e. Toto je pravdÄ›podobnÄ› zpÅ¯sobeno tÃ­m, Å¾e jste si nastavili pÅ™i vytvÃ¡Å™enÃ­ kreslÃ­tka (tj.
volÃ¡nÃ­ funkce <a href="https://wiki.libsdl.org/SDL2/SDL_CreateRenderer"><code>SDL_CreateRenderer</code></a>) vlastnost (&quot;flag&quot;)
<a href="https://wiki.libsdl.org/SDL2/SDL_RendererFlags"><code>SDL_RENDERER_PRESENTVSYNC</code></a>. Tento parametr zapÃ­nÃ¡ tzv. V-sync, coÅ¾ je
mechanismus pro synchronizaci FPS vaÅ¡Ã­ hry a vykreslovacÃ­ frekvence vaÅ¡eho monitoru. VÃ¡Å¡ monitor mÃ¡ pravdÄ›podobnÄ› nÄ›jakou
omezenou maximÃ¡lnÃ­ vykreslovacÃ­ frekvenci, typicky napÅ™. 60, 120, 144 FPS. Pokud by vaÅ¡e hra mÄ›la vÃ­ce snÃ­mkÅ¯ za vteÅ™inu,
napÅ™. 1000 FPS, tak by se vykreslovala vÃ½raznÄ› jinou frekvenci, neÅ¾ vÃ¡Å¡ monitor, coÅ¾ by mohlo zpÅ¯sobovat nepÅ™Ã­jemnÃ©
vizuÃ¡lnÃ­ artefakty.</p>
<p>Mechanismus V-sync tomuto zabraÅˆuje tÃ­m, Å¾e vytvoÅ™Ã­ maximÃ¡lnÃ­ limit pro FPS vaÅ¡Ã­ hry, kterÃ½ bude odpovÃ­dat vykreslovacÃ­
frekvenci vaÅ¡eho monitoru. Z toho dÅ¯vodu pÅ™i zapnutÃ©m V-syncu vaÅ¡e hra bude typicky mÃ­t maximÃ¡lnÄ› tÅ™eba 60 FPS. Pro
jednoduchÃ© SDL hry v UPR doporuÄujeme nechat V-sync zapnutÃ½, aby vaÅ¡e hra nemÄ›la zbyteÄnÄ› moc FPS. Pokud byste totiÅ¾
dlouhodobÄ› vykreslovali vaÅ¡i hru bez omezenÃ­ FPS, mÅ¯Å¾e to mÃ­t negativnÃ­ vliv na vÃ¡Å¡ hardware (napÅ™. grafickou kartu),
kterÃ¡ se tÃ­m mÅ¯Å¾e pÅ™etÃ­Å¾it, zaÄÃ­t pÃ­skat nebo se i dokonce zniÄit. Proto radÄ›ji pouÅ¾Ã­vejte V-sync a ujistÄ›te se, Å¾e vaÅ¡e
hra nemÃ¡ nesmyslnÄ› vysokou hodnotu (napÅ™. 1000+) FPS.</p>
<h2><a class="header" href="#double-buffering" id="double-buffering">Double buffering</a></h2>
<p>PÅ™i vykreslovÃ¡nÃ­ stavu hry do &quot;kreslÃ­tka&quot; (<code>SDL_Renderer</code>) vÅ¾dy vykreslujeme vÄ›ci postupnÄ› - nejprve nakreslÃ­me pozadÃ­,
potÃ© napÅ™. hrÃ¡Äovu postavu, potÃ© letÃ­cÃ­ projektily atd. Pokud by se ihned po vykreslenÃ­ nakreslenÃ© objekty zobrazovaly
na monitoru, nepÅ¯sobilo by to graficky pÄ›knÄ›, protoÅ¾e by hrÃ¡Ä vidÄ›l ÄÃ¡steÄnÄ› vykreslenÃ½ stav, kterÃ½ by vÅ¯bec nemusel dÃ¡vat
smysl.</p>
<p>Z toho dÅ¯vodu se pÅ™i vykreslovÃ¡nÃ­ her vyuÅ¾Ã­vÃ¡ princip tzv. <a href="https://en.wikipedia.org/wiki/Multiple_buffering#Double_buffering_in_computer_graphics"><strong>double bufferingu</strong></a>,
kterÃ½ je zabudovanÃ½ pÅ™Ã­mo v SDL. MyÅ¡lenka double bufferingu je takovÃ¡, Å¾e v pamÄ›ti budeme mÃ­t dvÄ› plÃ¡tna. Do jednoho plÃ¡tna
budeme vÅ¾dy postupnÄ› kreslit souÄasnÃ½ stav hry, a druhÃ© plÃ¡tno se bude ukazovat hrÃ¡Äovi na monitoru. V momentÄ›, kdy
nakreslÃ­me celÃ½ stav hry, tak pouze Å™ekneme, Å¾e se majÃ­ plÃ¡tna prohodit, tj. naÅ¡e nakreslenÃ© plÃ¡tno se zobrazÃ­ na monitoru,
a dÃ¡le budeme kreslit na plÃ¡tno z minulÃ© iterace hernÃ­ smyÄky. DÃ­ky tomu, Å¾e prohozenÃ­ je velmi rychlÃ¡ operace, tak pÅ™i
tomto pÅ™Ã­stupu hrÃ¡Ä vÅ¾dy uvidÃ­ pouze kompletnÄ› vykreslenÃ© snÃ­mky, a ne Å¾Ã¡dnÃ½ ÄÃ¡steÄnÄ› vykreslenÃ½ stav. V SDL dosÃ¡hneme
prohozenÃ­ tÄ›chto dvou plÃ¡ten pomocÃ­ zavolÃ¡nÃ­ funkce <a href="https://wiki.libsdl.org/SDL2/SDL_RenderPresent"><code>SDL_RenderPresent</code></a>.
VolÃ¡nÃ­ tÃ©to funkce by se mÄ›lo vyskytovat na ÃºplnÃ©m konci naÅ¡Ã­ hernÃ­ smyÄky, a mÄ›lo by ukonÄit vykreslovÃ¡nÃ­ stavu naÅ¡Ã­ hry.</p>
<p>JelikoÅ¾ pÅ™i pouÅ¾itÃ­ double bufferingu neustÃ¡le pracujeme se stejnÃ½mi dvÄ›mi plÃ¡tny, a plÃ¡tno, do kterÃ©ho kreslÃ­me, mÅ¯Å¾e
obsahovat libovolnÃ© pixely (napÅ™. ty, kterÃ© jsme vykreslili v minulÃ© iteraci hernÃ­ smyÄky), mÄ›li bychom vÅ¾dy na zaÄÃ¡tku
vykreslovÃ¡nÃ­ toto plÃ¡tno celÃ© pÅ™ekreslit barvou pozadÃ­, ideÃ¡lnÄ› pomocÃ­ funkce <a href="https://wiki.libsdl.org/SDL2/SDL_RenderClear"><code>SDL_RenderClear</code></a>.
Pokud tak neuÄinÃ­te, mÅ¯Å¾ou na plÃ¡tnÄ› bÃ½t vizuÃ¡lnÃ­ artefakty, obsah plÃ¡tna z minulÃ© iterace, pÅ™Ã­padnÄ› cokoliv jinÃ©ho,
coÅ¾ urÄitÄ› nenÃ­ Å¾Ã¡doucÃ­.</p>
<h1><a class="header" href="#kreslenÃ­" id="kreslenÃ­">KreslenÃ­</a></h1>
<p>HlavnÃ­m dÅ¯vodem, proÄ pouÅ¾Ã­vÃ¡me knihovnu SDL, je samozÅ™ejmÄ› to, abychom mohli vykreslovat grafickÃ© prvky na obrazovku.
K tomu nÃ¡m SDL nabÃ­zÃ­ spoustu uÅ¾iteÄnÃ½ch funkcÃ­. V podstatÄ› vÅ¡echny funkce pro vykreslovÃ¡nÃ­ berou jako svÅ¯j (prvnÃ­)
parametr hodnotu typu <code>SDL_Renderer*</code>, kterÃ¡ reprezentuje &quot;kreslÃ­tko&quot;, do kterÃ©ho se mÃ¡ nÄ›co vykreslit.</p>
<h2><a class="header" href="#souÅ™adnÃ½-systÃ©m" id="souÅ™adnÃ½-systÃ©m">SouÅ™adnÃ½ systÃ©m</a></h2>
<p>Pro vykreslovÃ¡nÃ­ je nejprve nutnÃ© vzÃ­t v potaz, jakÃ½ mÃ¡ SDL souÅ™adnÃ½ systÃ©m. Ten je znÃ¡zornÄ›nÃ½ na nÃ¡sledujÃ­cÃ­m obrÃ¡zku:</p>
<p><img src="c/aplikovane_ulohy/sdl/../../../static/img/sdl/sdl-coordinates.png" alt="SDL systÃ©m koordinÃ¡tÅ¯" /></p>
<p>ZaÄÃ¡tek souÅ™adnÃ© soustavy je v bodÄ› <code>(0, 0)</code>, kterÃ½ je umÃ­stÄ›n v levÃ©m hornÃ­m rohu okna. PrvnÃ­ souÅ™adnice (<code>x</code>) urÄuje
sloupec, a roste zleva doprava. DruhÃ¡ souÅ™adnice (<code>y</code>) urÄuje Å™Ã¡dek, a roste shora dolÅ¯. TakÅ¾e napÅ™. v oknÄ› s Å¡Ã­Å™kou <code>800</code>
a vÃ½Å¡kou <code>600</code> pixelÅ¯ jsou souÅ™adnice rohÅ¯ nÃ¡sledujÃ­cÃ­:</p>
<ul>
<li>LevÃ½ hornÃ­ roh: <code>(0, 0)</code></li>
<li>PravÃ½ hornÃ­ roh: <code>(799, 0)</code></li>
<li>LevÃ½ dolnÃ­ roh: <code>(0, 599)</code></li>
<li>PravÃ½ dolnÃ­ roh: <code>(799, 599)</code></li>
</ul>
<p>Pokud je pro vÃ¡s neintuitivnÃ­, Å¾e souÅ™adnice <code>y</code> roste shora dolÅ¯ (a ne zdola nahoru), mÅ¯Å¾ete si ve vaÅ¡Ã­ hÅ™e tuto souÅ™adnici
virtuÃ¡lnÄ› upravit a zmÄ›nit si tak souÅ™adnÃ½ systÃ©m. V pamÄ›Å¥ovÃ© reprezentaci vaÅ¡Ã­ hry mÅ¯Å¾ete klidnÄ› pouÅ¾Ã­vat souÅ™adnÃ½ systÃ©m,
kde <code>y</code> roste nahoru, a pÅ™i vykreslovÃ¡nÃ­ pomocÃ­ funkcÃ­ SDL pak akorÃ¡t souÅ™adnici <code>y</code> pÅ™epoÄÃ­tÃ¡te, aby odpovÃ­dala souÅ™adnÃ©mu
systÃ©mu SDL. Tento pÅ™epoÄet lze provÃ©st jednoduÅ¡e, staÄÃ­ odeÄÃ­st souÅ™adnici <code>y</code> od vÃ½Å¡ky okna.</p>
<h2><a class="header" href="#nastavenÃ­-barvy-Å¡tÄ›tce" id="nastavenÃ­-barvy-Å¡tÄ›tce">NastavenÃ­ barvy Å¡tÄ›tce</a></h2>
<p>Pokud chceme v SDL nÄ›co vykreslit, tak musÃ­me nejprve nastavit barvu, kterou se mÃ¡ kreslit. To mÅ¯Å¾eme udÄ›lat zavolÃ¡nÃ­m
funkce <a href="https://wiki.libsdl.org/SDL2/SDL_SetRenderDrawColor"><code>SDL_SetRenderDrawColor</code></a>, kterÃ¡ bere (kromÄ› kreslÃ­tka)
ÄtyÅ™i parametry (<code>r</code>, <code>g</code>, <code>b</code>, <code>a</code>). Parametry <code>r</code>, <code>g</code> a <code>b</code> odpovÃ­dajÃ­ ÄervenÃ©, zelenÃ© a modrÃ© komponentÄ› barvy, kterou
chceme nastavit pro kreslenÃ­. Hodnoty tÄ›chto komponent lze nastavovat v rozsahu <code>0</code> aÅ¾ <code>255</code>. Hodnota <code>a</code> odpovÃ­dÃ¡ tzv.
alfa kanÃ¡lu, kterÃ½ urÄuje prÅ¯hlednost zvolenÃ© barvy. Obvykle prÅ¯hlednost nemusÃ­te Å™eÅ¡it, a staÄÃ­ tento parametr nastavit
na hodnotu <code>255</code>.</p>
<p>NastavenÃ¡ barva zÅ¯stane aktivnÃ­, dokud ji nezmÄ›nÃ­me. Pokud tedy chceme vykreslit napÅ™. pÄ›t rÅ¯znÃ½ch vÄ›cÃ­ stejnou barvou,
staÄÃ­ barvu nastavit jednou, a potÃ© vykreslit vÅ¡echny poÅ¾adovanÃ© objekty.</p>
<h2><a class="header" href="#ÄŒÃ¡ry" id="ÄŒÃ¡ry">ÄŒÃ¡ry</a></h2>
<p>ÄŒÃ¡ru mÅ¯Å¾ete nakreslit pomocÃ­ funkce <a href="https://wiki.libsdl.org/SDL2/SDL_RenderDrawLine"><code>SDL_RenderDrawLine</code></a>. Ta bere
(kromÄ› kreslÃ­tka) ÄtyÅ™i parametry (<code>x1</code>, <code>y1</code>, <code>x2</code> a <code>y2</code>), kterÃ© reprezentujÃ­ souÅ™adnice zaÄÃ¡tku a konce ÄÃ¡ry.</p>
<pre><code class="language-c">SDL_RenderDrawLine(renderer, 100, 100, 200, 200);
</code></pre>
<h2><a class="header" href="#obdÃ©lnÃ­ky" id="obdÃ©lnÃ­ky">ObdÃ©lnÃ­ky</a></h2>
<p>NevyplnÄ›nÃ½ obdÃ©lnÃ­k mÅ¯Å¾ete vykreslit pomocÃ­ funkce <a href="https://wiki.libsdl.org/SDL2/SDL_RenderDrawRect"><code>SDL_RenderDrawRect</code></a>,
vyplnÄ›nÃ½ obdÃ©lnÃ­k potÃ© pomocÃ­ funkce <a href="https://wiki.libsdl.org/SDL2/SDL_RenderFillRect"><code>SDL_RenderFillRect</code></a>. Tyto funkce
vyÅ¾adujÃ­ pÅ™edÃ¡nÃ­ adresy na hodnotu struktury <a href="https://wiki.libsdl.org/SDL2/SDL_Rect"><code>SDL_Rect</code></a>, kterÃ¡ reprezentuje
obdÃ©lnÃ­k. Pro vykreslenÃ­ obdÃ©lnÃ­ku tedy nejprve musÃ­me vytvoÅ™it promÄ›nnou typu <code>SDL_Rect</code>, nastavit jÃ­ pozici a rozmÄ›ry,
a potÃ© zavolat jednu z tÄ›chto dvou funkcÃ­.</p>
<pre><code class="language-c">SDL_Rect rect = {
    .x = 100,
    .y = 200,
    .w = 500,
    .h = 200
};
SDL_RenderFillRect(renderer, &amp;rect);
</code></pre>
<p>DatovÃ½ typ <code>SDL_Rect</code> se hodÃ­ nejenom pro vykreslovÃ¡nÃ­ obdÃ©lnÃ­kÅ¯. MÅ¯Å¾ete jej pouÅ¾Ã­t takÃ© na reprezentaci pozice a rozmÄ›ru
rÅ¯znÃ½ch objektÅ¯ ve svÃ© hÅ™e. SDL takÃ© nabÃ­zÃ­ funkce pro kontrolu toho, jestli se dva obdÃ©lnÃ­ky protÃ­najÃ­, napÅ™. pomocÃ­
funkce <a href="https://wiki.libsdl.org/SDL2/SDL_HasIntersection"><code>SDL_HasIntersection</code></a>. DÃ­ky tomu mÅ¯Å¾ete pouÅ¾Ã­t tyto obdÃ©lnÃ­ky
takÃ© na detekci kolizÃ­ (napÅ™. na zjiÅ¡tÄ›nÃ­, jestli projektil trefil hrÃ¡Äe).</p>
<p>DatovÃ½ typ <code>SDL_Rect</code> uklÃ¡dÃ¡ pozici a rozmÄ›ry obdÃ©lnÃ­ku pomocÃ­ datovÃ©ho typu <code>int</code>. Pokud byste potÅ™ebovali obdÃ©lnÃ­k,
kde tyto atributy budou reprezentovanÃ© desetinnÃ½mi ÄÃ­sly, mÅ¯Å¾ete pouÅ¾Ã­t <a href="https://wiki.libsdl.org/SDL2/SDL_FRect"><code>SDL_FRect</code></a>.</p>
<h2><a class="header" href="#obrÃ¡zky" id="obrÃ¡zky">ObrÃ¡zky</a></h2>
<p>SDL mÃ¡ takÃ© samozÅ™ejmÄ› podporu nejenom pro kreslenÃ­ Äar Äi obdÃ©lnÃ­kÅ¯, ale takÃ© pro kreslenÃ­ (bitmapovÃ½ch) obrÃ¡zkÅ¯
(kterÃ© mÅ¯Å¾eme naÄÃ­st napÅ™. ze souborÅ¯ ve formÃ¡tu PNG nebo JPEG). Ke kreslenÃ­ vÅ¡ak budeme muset vyuÅ¾Ã­t dodateÄnou knihovnu
zvanou <code>SDL2_image</code>, kterou potÃ© musÃ­me pÅ™ilinkovat k naÅ¡emu programu pÅ™i pÅ™ekladu:</p>
<pre><code class="language-bash">$ gcc main.c -omain -lSDL2 -lSDL2_image
</code></pre>
<p>PotÃ© musÃ­me na zaÄÃ¡tku souboru, kde chceme funkce pro naÄÃ­tÃ¡nÃ­ obrÃ¡zkÅ¯ pouÅ¾Ã­t, vloÅ¾it odpovÃ­dajÃ­cÃ­ hlaviÄkovÃ½ soubor:</p>
<pre><code class="language-c">#include &lt;SDL2/SDL_image.h&gt;
</code></pre>
<p>Jakmile tohle udÄ›lÃ¡me, tak mÅ¯Å¾eme pouÅ¾Ã­t funkci <a href="https://wiki.libsdl.org/SDL2_image/IMG_LoadTexture"><code>IMG_LoadTexture</code></a>,
kterÃ¡ bere jako parametr kreslÃ­tko, a cestu k souboru na disku, ze kterÃ©ho se mÃ¡ naÄÃ­st obrÃ¡zek, kterÃ½ potÃ© budeme
vykreslovat:</p>
<pre><code class="language-c">SDL_Texture* image = IMG_LoadTexture(renderer, &quot;image.png&quot;);
</code></pre>
<p>Z funkce se nÃ¡m vrÃ¡tÃ­ ukazatel na strukturu <a href="https://wiki.libsdl.org/SDL2/SDL_Texture"><code>SDL_Texture</code></a>, kterÃ¡ reprezentuje
obrÃ¡zek naÄtenÃ½ v pamÄ›ti grafickÃ© kartÄ›, kterÃ½ je pÅ™ipravenÃ½ k vykreslenÃ­.</p>
<blockquote>
<p>PÅ™i naÄÃ­tÃ¡nÃ­ obrÃ¡zkÅ¯ (stejnÄ› jako jakÃ½chkoliv jinÃ½ch souborÅ¯) bychom si mÄ›li dÃ¡t pozor na to, abychom k nÄ›mu udali
<a href="c/aplikovane_ulohy/sdl/../../soubory/otevirani_souboru.html#cesta-k-souboru">sprÃ¡vnou cestu</a>. MÄ›li bychom takÃ© zkontrolovat, jestli se obrÃ¡zek
sprÃ¡vnÄ› naÄetl, tj. jestli funkce nevrÃ¡tila hodnotu <code>NULL</code><sup class='margin-toggle sidenote-number'>1</sup>. Kontrolu si mÅ¯Å¾eme usnadnit pomocÃ­ makra <a href="c/aplikovane_ulohy/sdl/../../soubory/otevirani_souboru.html#pou%C5%BEit%C3%AD-assert"><code>assert</code></a>.</p>
<span class='sidenote'><p><sup class='number'>1</sup>Pokud by funkce vrÃ¡tila <code>NULL</code>, a my bychom se potÃ© snaÅ¾ili tuto hodnotu vykreslit jako obrÃ¡zek, tak mÅ¯Å¾e dojÃ­t
k <a href="c/aplikovane_ulohy/sdl/../../../ruzne/nedefinovane_chovani.html"><strong>nedefinovanÃ©mu chovÃ¡nÃ­</strong></a> ğŸ’£. Proto bychom mÄ›li vÅ¾dy kontrolovat nÃ¡vratovou hodnotu tÃ©to funkce.</p>
</span></blockquote>
<p>Jakmile mÃ¡me obrÃ¡zek sprÃ¡vnÄ› naÄtenÃ½, tak jej mÅ¯Å¾eme vykreslit pomocÃ­ funkce <a href="https://wiki.libsdl.org/SDL2/SDL_RenderCopy"><code>SDL_RenderCopy</code></a>.
TÃ©to funkci musÃ­me pÅ™edat kreslÃ­tko, obrÃ¡zek, kterÃ½ chceme vykreslit a dva obdÃ©lnÃ­ky (<code>srcrect</code> a <code>dstrect</code>).
Parametr <code>srcrect</code> urÄuje vÃ½Å™ez z obrÃ¡zku, kterÃ½ chceme kreslit. Pokud chceme obrÃ¡zek vykreslit celÃ½, tak pro parametr
<code>srcrect</code> pÅ™edÃ¡me hodnotu <code>NULL</code>. Parametr <code>dstrect</code> urÄuje, do jakÃ©ho vÃ½Å™ezu (obdÃ©lnÃ­ku v plÃ¡tnu) se mÃ¡ obrÃ¡zek vykreslit.
Zde bychom si mÄ›li dÃ¡t pozor, aby cÃ­lovÃ½ obdÃ©lnÃ­k mÄ›l stejnÃ½ pomÄ›r stran, jako nÃ¡Å¡ obrÃ¡zek, jinak po vykreslenÃ­ mÅ¯Å¾e bÃ½t
obrÃ¡zek znaÄnÄ› zdeformovanÃ½.</p>
<pre><code class="language-c">SDL_Rect rect = {
    .x = 100,
    .y = 100,
    .w = 400,
    .h = 400
};
SDL_RenderCopy(renderer, image, NULL, &amp;rect);
</code></pre>
<p>UÅ¾iteÄnÃ¡ je takÃ© funkce <a href="https://wiki.libsdl.org/SDL2/SDL_RenderCopyEx"><code>SDL_RenderCopyEx</code></a>, kterÃ¡ nÃ¡m umoÅ¾Åˆuje vykreslit
obrÃ¡zek, kterÃ½ je zarotovanÃ½, pÅ™Ã­padnÄ› zrcadlenÃ½ podÃ©l vertikÃ¡lnÃ­ Äi horizontÃ¡lnÃ­ osy.</p>
<p>Jakmile pÅ™estaneme obrÃ¡zek potÅ™ebovat, mÄ›li bychom jeho texturu uvolnit pomocÃ­ volÃ¡nÃ­ funkce <a href="https://wiki.libsdl.org/SDL2/SDL_DestroyTexture"><code>SDL_DestroyTexture</code></a>:</p>
<pre><code class="language-c">SDL_DestroyTexture(image);
</code></pre>
<h2><a class="header" href="#text-1" id="text-1">Text</a></h2>
<p>DalÅ¡Ã­ uÅ¾iteÄnou funkcionalitou, kterou nÃ¡m SDL nabÃ­zÃ­, a kterÃ¡ je potÅ™eba pro vÄ›tÅ¡inu her Äi grafickÃ½ch aplikacÃ­, je
vykreslovÃ¡nÃ­ textu. K tomu budeme opÄ›t vyÅ¾adovat dodateÄnou knihovnu, kterÃ¡ se jmenuje <code>SDL2_ttf</code>:</p>
<pre><code class="language-bash">$ gcc main.c -omain -lSDL2 -lSDL2_ttf
</code></pre>
<p>Pro prÃ¡ci s touto knihovnou budeme opÄ›t muset vloÅ¾it odpovÃ­dajÃ­cÃ­ hlaviÄkovÃ½ soubor:</p>
<pre><code class="language-c">#include &lt;SDL2/SDL_ttf.h&gt;
</code></pre>
<p>a dÃ¡le takÃ© zavolat inicializaÄnÃ­ funkci <a href="https://wiki.libsdl.org/SDL2_ttf/TTF_Init"><code>TTF_Init</code></a>, kterou bychom mÄ›li
zavolat v programu nÄ›kdy po zavolÃ¡nÃ­ funkce <a href="https://wiki.libsdl.org/SDL2/SDL_Init"><code>SDL_Init</code></a>:</p>
<pre><code class="language-c">SDL_Init(SDL_INIT_VIDEO);
TTF_Init();
</code></pre>
<p>Abychom mohli pÅ™i vykreslovÃ¡nÃ­ znakÅ¯ pouÅ¾Ã­vat prÅ¯hlednost, a aby byly vykreslovanÃ© obrÃ¡zky jednotlivÃ½ch znakÅ¯ pÄ›knÄ›jÅ¡Ã­,
je vhodnÃ© na kreslÃ­tku (<code>SDL_Renderer</code>) zapnout takzvanÃ½ <code>Alpha blending</code>, a takÃ© povolit lineÃ¡rnÃ­ vzorkovÃ¡nÃ­ pixelÅ¯.
Na zaÄÃ¡tek programu (tÄ›snÄ› po vytvoÅ™enÃ­ kreslÃ­tka) si tedy pÅ™idejte tyto dva Å™Ã¡dky:</p>
<pre><code class="language-c">SDL_SetRenderDrawBlendMode(renderer, SDL_BLENDMODE_BLEND);
SDL_SetHint(SDL_HINT_RENDER_SCALE_QUALITY, &quot;1&quot;);
</code></pre>
<p>Na konci programu bychom potÃ© mÄ›li prostÅ™edky tÃ©to knihovny opÄ›t uvolnit pomocÃ­ zavolÃ¡nÃ­ funkce <a href="https://wiki.libsdl.org/SDL2_ttf/TTF_Quit"><code>TTF_Quit</code></a>:</p>
<pre><code class="language-c">TTF_Quit();
</code></pre>
<p>Pro vykreslenÃ­ nÄ›jakÃ©ho textu budeme nejprve potÅ™ebovat nÄ›jakÃ½ (bitmapovÃ½) <a href="https://en.wikipedia.org/wiki/Typeface">font</a>,
ideÃ¡lnÄ› ve formÃ¡tu TTF. MÅ¯Å¾ete pouÅ¾Ã­t napÅ™. <a href="c/aplikovane_ulohy/sdl/../../../static/Arial.ttf">tento</a> font nebo si nÄ›jakÃ½ font stÃ¡hnout z internetu.
Font urÄuje, jak budou vypadat jednotlivÃ© znaky textu, kterÃ½ se bude vykreslovat na obrazovku. Jakmile mÃ¡te pÅ™ipravenÃ½
soubor s fontem, mÅ¯Å¾ete ho ve svÃ©m programu naÄÃ­st pomocÃ­ funkce <a href="https://wiki.libsdl.org/SDL2_ttf/TTF_OpenFont"><code>TTF_OpenFont</code></a>:</p>
<pre><code class="language-c">TTF_Font* font = TTF_OpenFont(&quot;Arial.ttf&quot;, 20);
</code></pre>
<p>PrvnÃ­ parametr udÃ¡vÃ¡ cestu k souboru s fontem, druhÃ½ parametr udÃ¡vÃ¡ velikost, ve kterÃ© se mÃ¡ font naÄÃ­st.
AÅ¾ s fontem pÅ™estaneme pracovat (na konci programu), tak bychom jej mÄ›li opÄ›t uvolnit:</p>
<pre><code class="language-c">TTF_CloseFont(font);
</code></pre>
<p>Jakmile mÃ¡me naÄtenÃ½ font, tak mÅ¯Å¾eme do kreslÃ­tka vykreslit nÄ›jakÃ½ text. MÅ¯Å¾eme k tomu vyuÅ¾Ã­t nÃ¡sledujÃ­cÃ­ funkci,
kterÃ¡ vyÅ¾aduje kreslÃ­tko, naÄtenÃ½ font, barvu v podobÄ› struktury <a href="https://wiki.libsdl.org/SDL2/SDL_Color"><code>SDL_Color</code></a>,
obdÃ©lnÃ­k oznaÄujÃ­cÃ­ pozici, kam se mÃ¡ text vykreslit, a potÃ© samotnÃ½ text, kterÃ½ se mÃ¡ vykreslit, ve formÄ› Å™etÄ›zce:</p>
<pre><code class="language-c">void sdl_draw_text(SDL_Renderer* renderer, TTF_Font* font, SDL_Color color, SDL_Rect location, const char* text)
{
    // VykreslenÃ­ textu se zadanÃ½m fontem a barvou do obrÃ¡zku (surface)
    SDL_Surface* surface = TTF_RenderText_Blended(font, text, color);
    // PÅ™evod surface na hardwarovou texturu
    SDL_Texture* texture = SDL_CreateTextureFromSurface(renderer, surface);

    // VykreslenÃ­ obrÃ¡zku
    SDL_RenderCopy(renderer, texture, NULL, &amp;location);

    // UvolnÄ›nÃ­ textury a surface
    SDL_DestroyTexture(texture);
    SDL_FreeSurface(surface);
}
</code></pre>
<p>Tato funkce nejprve vytvoÅ™Ã­ obrÃ¡zek s vykreslenÃ½m textem, a potÃ© obrÃ¡zek vykreslÃ­ do kreslÃ­tka, stejnÄ› jako kdybychom
<a href="c/aplikovane_ulohy/sdl/kresleni.html#obr%C3%A1zky">kreslili</a> jakÃ½koliv jinÃ½ obrÃ¡zek.</p>
<blockquote>
<p>Tento kÃ³d je relativnÄ› neefektivnÃ­, neboÅ¥ pÅ™i kaÅ¾dÃ©m vykreslenÃ­ vytvÃ¡Å™Ã­ dva novÃ© obrÃ¡zky (surface a texture), a potÃ©
je hned uvolÅˆuje. Pro jednoduchÃ© hry by to vÅ¡ak nemÄ›l bÃ½t vÃ½konnostnÃ­ problÃ©m.</p>
</blockquote>
<h1><a class="header" href="#vstup-1" id="vstup-1">Vstup</a></h1>
<p>Aby naÅ¡e hry Äi jinÃ© SDL programy byly interaktivnÃ­, tak budeme muset reagovat na vstup od uÅ¾ivatele. ZejmÃ©na se bude
jednat o vstup z klÃ¡vesnice (zmÃ¡ÄknutÃ­ klÃ¡vesy) Äi myÅ¡i (pohyb, zmÃ¡ÄknutÃ­ tlaÄÃ­tka, otoÄenÃ­ koleÄka).</p>
<h2><a class="header" href="#reakce-na-udÃ¡losti-operaÄnÃ­ho-systÃ©mu" id="reakce-na-udÃ¡losti-operaÄnÃ­ho-systÃ©mu">Reakce na udÃ¡losti operaÄnÃ­ho systÃ©mu</a></h2>
<p>V kapitole o <a href="c/aplikovane_ulohy/sdl/herni_smycka.html#reakce-na-ud%C3%A1losti">hernÃ­ smyÄce</a> uÅ¾ jsme si ukÃ¡zali, jak mÅ¯Å¾eme ÄÃ­st udÃ¡losti operaÄnÃ­ho
systÃ©mu. JelikoÅ¾ se ÄtenÃ­ udÃ¡lostÃ­ vÃ½raznÄ› dotÃ½kÃ¡ i vstupu od uÅ¾ivatele, tak si jej zde popÃ­Å¡eme vÃ­ce do detailu. Pro
pÅ™ipomenutÃ­, takto mÅ¯Å¾eme vyÄÃ­st vÅ¡echny udÃ¡losti, kterÃ© nastaly od poslednÃ­ iterace hernÃ­ smyÄky:</p>
<pre><code class="language-c">SDL_Event event;
while (SDL_PollEvent(&amp;event)) {
    // Zde mÅ¯Å¾eme pracovat s promÄ›nnou `event`
}
</code></pre>
<p>KdyÅ¾ se podÃ­vÃ¡te na dokumentaci struktury <a href="https://wiki.libsdl.org/SDL2/SDL_Event"><code>SDL_Event</code></a>, tak tam najdete
rÅ¯znÃ© typy udÃ¡lostÃ­, ke kterÃ½m mÅ¯Å¾e dojÃ­t. Abyste zjistili, k jakÃ©mu typu udÃ¡losti doÅ¡lo, musÃ­te se podÃ­vat na
atribut <code>type</code> struktury <code>SDL_Event</code>. Tento atribut mÅ¯Å¾e nabÃ½vat hodnot, kterÃ© jsou znÃ¡zornÄ›ny v prvnÃ­m sloupci
<a href="https://wiki.libsdl.org/SDL2/SDL_Event#table"><strong>tÃ©to tabulky</strong></a>. JednÃ¡ se napÅ™Ã­klad o nÃ¡sledujÃ­cÃ­ typy udÃ¡lostÃ­:</p>
<ul>
<li>Å½Ã¡dost o vypnutÃ­ aplikace <code>SDL_QUIT</code></li>
<li>PohnutÃ­ myÅ¡i <code>SDL_MOUSEMOTION</code></li>
<li>ZmÃ¡ÄknutÃ­ tlaÄÃ­tka myÅ¡i <code>SDL_MOUSEBUTTONDOWN</code></li>
<li>ZmÃ¡ÄknutÃ­ tlaÄÃ­tka klÃ¡vesnice <code>SDL_KEYDOWN</code></li>
</ul>
<p>V programu byste potÃ© mÄ›li mÃ­t podmÃ­nku, kterou zkontrolujete, jestli doÅ¡lo k udÃ¡losti, na kterou chcete zareagovat.
UvnitÅ™ podmÃ­nky potÃ© mÅ¯Å¾ete pÅ™istupovat k atributu struktury <code>SDL_Event</code>, kterÃ½ odpovÃ­dÃ¡ danÃ©mu typu udÃ¡losti. NÃ¡zev
tohoto atributu se dozvÃ­te ve tÅ™etÃ­m sloupci zmÃ­nÄ›nÃ© tabulky, a datovÃ½ typ tohoto atributu potÃ© najdete ve druhÃ©m sloupci.</p>
<p>Pokud by tedy napÅ™. doÅ¡lo k udÃ¡losti otoÄenÃ­ koleÄka myÅ¡i (<code>SDL_MOUSEWHEEL</code>), tak potÃ© mÅ¯Å¾ete pÅ™istoupit k atributu
<code>event.wheel</code>, kterÃ½ bude mÃ­t typ <a href="https://wiki.libsdl.org/SDL2/SDL_MouseWheelEvent"><code>SDL_MouseWheelEvent</code></a>, a z tohoto
atributu si potÃ© mÅ¯Å¾ete vyÄÃ­st dodateÄnÃ© informace o udÃ¡losti:</p>
<pre><code class="language-c">if (event.type == SDL_MOUSEWHEEL) {
    SDL_MouseWheelEvent wheel_event = event.wheel;
    printf(
        &quot;Kolecko mysi se pohnulo o %d vertikalne a %d horizontalne\n&quot;,
        wheel_event.y,
        wheel_event.x
    );
}
</code></pre>
<p>KromÄ› ÄtenÃ­ udÃ¡lostÃ­ pomocÃ­ smyÄky vyuÅ¾Ã­vajÃ­cÃ­ funkce <code>SDL_PollEvent</code> mÅ¯Å¾eme takÃ© pomocÃ­ rÅ¯znÃ½ch SDL funkcÃ­ kdykoliv v
programu zÃ­skat souÄasnÃ½ stav myÅ¡i Äi klÃ¡vesnice. Oba dva pÅ™Ã­stupy nÃ¡m pÅ™ijdou vhod. NapÅ™Ã­klad, ve hÅ™e se mÅ¯Å¾eme kdykoliv
zeptat, jestli je zrovna zmÃ¡ÄknutÃ© tlaÄÃ­tko myÅ¡i. Pokud ale budeme chtÃ­t zareagovat na pohyb myÅ¡i, tak spÃ­Å¡e budeme chtÃ­t
dostat upozornÄ›nÃ­ na to, Å¾e doÅ¡lo k pohybu (pomocÃ­ ÄtenÃ­ udÃ¡lostÃ­), protoÅ¾e pohyb nenÃ­ vyjÃ¡dÅ™en souÄasnÃ½m stavem, ale spÃ­Å¡e
zmÄ›nou stavu (tedy udÃ¡lostÃ­). PÅ™i popisu klÃ¡vesnice i myÅ¡i nÃ­Å¾e si tedy vÅ¾dy ukÃ¡Å¾eme oba dva zpÅ¯soby, jak vstup zÃ­skat,
pomocÃ­ udÃ¡lostÃ­ i pomocÃ­ zÃ­skÃ¡nÃ­ souÄasnÃ©ho stavu.</p>
<h2><a class="header" href="#myÅ¡" id="myÅ¡">MyÅ¡</a></h2>
<p>U myÅ¡i nÃ¡s bude zajÃ­mat primÃ¡rnÄ› jejÃ­ pozice, pÅ™Ã­padnÄ› stav tlaÄÃ­tek. MÅ¯Å¾eme ale takÃ© zjistit napÅ™. jestli uÅ¾ivatel otoÄil
koleÄkem.</p>
<h3><a class="header" href="#udÃ¡losti" id="udÃ¡losti">UdÃ¡losti</a></h3>
<p>NÃ¡sledujÃ­cÃ­ udÃ¡losti jsou uÅ¾iteÄnÃ© pro prÃ¡ci s myÅ¡Ã­:</p>
<ul>
<li><a href="https://wiki.libsdl.org/SDL2/SDL_MouseMotionEvent"><code>SDL_MOUSEMOTION</code></a> HrÃ¡Ä pohnul s myÅ¡Ã­.
<ul>
<li>V atributech <code>event.motion.x</code> a <code>event.motion.y</code> potÃ© naleznete souÄasnou pozici myÅ¡i.</li>
</ul>
</li>
<li><a href="https://wiki.libsdl.org/SDL2/SDL_MouseButtonEvent"><code>SDL_MOUSEBUTTONDOWN</code></a>, <a href="https://wiki.libsdl.org/SDL2/SDL_MouseButtonEvent"><code>SDL_MOUSEBUTTONUP</code></a>
HrÃ¡Ä stisknul (<code>DOWN</code>) Äi uvolnil (<code>UP</code>) tlaÄÃ­tko myÅ¡i.
<ul>
<li>V atributu <code>event.button.button</code> naleznete informace o tlaÄÃ­tku, kterÃ© bylo zmÃ¡Äknuto Äi uvolnÄ›no (napÅ™. <code>SDL_BUTTON_LEFT</code> nebo <code>SDL_BUTTON_RIGHT</code>).</li>
</ul>
</li>
<li><a href="https://wiki.libsdl.org/SDL2/SDL_MouseWheelEvent"><code>SDL_MOUSEWHEEL</code></a> HrÃ¡Ä otoÄil koleÄkem myÅ¡i.
<ul>
<li>V atributu <code>event.wheel.y</code> naleznete hodnotu vertikÃ¡lnÃ­ho posunu, v atributu <code>event.wheel.x</code> potÃ© hodnotu horizontÃ¡lnÃ­ho posunu.</li>
</ul>
</li>
</ul>
<p>MÅ¯Å¾ete si vÅ¡imnout, Å¾e &quot;kliknutÃ­ myÅ¡i&quot; je rozdÄ›leno na dvÄ› udÃ¡losti - stisknutÃ­ a povolenÃ­ tlaÄÃ­tka. Pokud byste tedy
chtÄ›li ve svÃ© hÅ™e reagovat na opravdovÃ© &quot;kliknutÃ­&quot; (tÅ™eba na nÄ›jakÃ½ hernÃ­ objekt), a ne pouze na stisknutÃ­ tlaÄÃ­tka, tak
si nejprve musÃ­te zapamatovat, Å¾e uÅ¾ivatel tlaÄÃ­tko stisknul, a potÃ© jej upustil (a obojÃ­ provedl nad stejnÃ½m objektem).</p>
<h3><a class="header" href="#souÄasnÃ½-stav" id="souÄasnÃ½-stav">SouÄasnÃ½ stav</a></h3>
<p>Pokud bychom chtÄ›li zÃ­skat souÄasnÃ½ stav pozice a tlaÄÃ­tek myÅ¡i, mÅ¯Å¾eme vyuÅ¾Ã­t funkci <a href="https://wiki.libsdl.org/SDL2/SDL_GetMouseState"><code>SDL_GetMouseState</code></a>.
Ta jako parametry bere ukazatele na ÄÃ­sla (souÅ™adnice <code>x</code> a <code>y</code>), do kterÃ½ch uloÅ¾Ã­ souÄasnou pozici myÅ¡i. SouÅ™adnice budou
relativnÃ­ vzhledem k oknu, nad kterÃ½m se zrovna myÅ¡ nachÃ¡zÃ­, coÅ¾ je obvykle to, co chceme. NÃ¡vratovÃ¡ hodnota tÃ©to funkce
potÃ© obsahuje ÄÃ­slo, jehoÅ¾ jednotlivÃ© bity oznaÄujÃ­, kterÃ¡ tlaÄÃ­tka myÅ¡i jsou zrovna stisknuta. Stav tlaÄÃ­tek potÃ© mÅ¯Å¾eme
zjistit pomocÃ­ makra <code>SDL_BUTTON</code>:</p>
<pre><code class="language-c">int x = 0;
int y = 0;
Uint32 buttons = SDL_GetMouseState(&amp;x, &amp;y);
int left = (buttons &amp; SDL_BUTTON(SDL_BUTTON_LEFT)) != 0;
int right = (buttons &amp; SDL_BUTTON(SDL_BUTTON_RIGHT)) != 0;

printf(&quot;Mouse is at (%d, %d). Left button: %d, right button: %d\n&quot;, x, y, left, right);
</code></pre>
<h2><a class="header" href="#klÃ¡vesnice" id="klÃ¡vesnice">KlÃ¡vesnice</a></h2>
<p>U klÃ¡vesnice nÃ¡s bude zajÃ­mat zejmÃ©na to, zda doÅ¡lo ke stisknutÃ­ Äi uvolnÄ›nÃ­ nÄ›jakÃ© klÃ¡vesy.</p>
<h3><a class="header" href="#udÃ¡losti-1" id="udÃ¡losti-1">UdÃ¡losti</a></h3>
<p>U klÃ¡vesnice jsou k dispozici udÃ¡losti <a href="https://wiki.libsdl.org/SDL2/SDL_KeyboardEvent"><code>SDL_KEYDOWN</code></a> (stisk klÃ¡vesy)
a <a href="https://wiki.libsdl.org/SDL2/SDL_KeyboardEvent"><code>SDL_KEYUP</code></a> (uvolnÄ›nÃ­ klÃ¡vesy). U obou udÃ¡lostÃ­ mÅ¯Å¾ete pÅ™istoupit k
atributu <code>event.key.keysym.sym</code>, kterÃ½ obsahuje hodnotu datovÃ©ho typu <a href="https://wiki.libsdl.org/SDL2/SDL_Keycode"><code>SDL_Keycode</code></a>,
kterÃ¡ reprezentuje stisknutou klÃ¡vesu. Seznam moÅ¾nÃ½ch hodnot klÃ¡ves, na kterÃ© mÅ¯Å¾ete reagovat, je k dispozici v tÅ™etÃ­m
sloupci <a href="https://wiki.libsdl.org/SDL2/SDL_Scancode">tÃ©to tabulky</a>. NapÅ™. mezernÃ­k je reprezentovÃ¡n hodnotou <code>SDLK_SPACE</code>,
klÃ¡vesa <code>a</code> hodnotou <code>SDLK_a</code> a Å¡ipka doprava hodnotou <code>SDLK_RIGHT</code>.</p>
<p>Zde je ukÃ¡zka toho, jak mÅ¯Å¾eme zareagovat na stisk jednotlivÃ½ch klÃ¡ves:</p>
<pre><code class="language-c">if (event.type == SDL_KEYDOWN) {
    SDL_Keycode code = event.key.keysym.sym;
    if (code == SDLK_SPACE) {
        printf(&quot;Uzivatel stisknul mezernik\n&quot;);
    } else if (code == SDLK_RIGHT) {
        printf(&quot;Uzivatel stisknul sipku doprava\n&quot;);
    }
}
</code></pre>
<p>Reakce na udÃ¡losti klÃ¡vesnice se hodÃ­ pro pÅ™Ã­pady, kdy chceme zareagovat na nÄ›jakou jednorÃ¡zovou udÃ¡lost, napÅ™. kdyÅ¾ hrÃ¡Ä
stiskne klÃ¡vesu, kterÃ¡ zpÅ¯sobuje vystÅ™elenÃ­ projektilu. NenÃ­ vÅ¡ak vhodnÃ© pÅ™Ã­mo vyuÅ¾Ã­vat reakce na
udÃ¡losti klÃ¡vesnice pro zpracovÃ¡nÃ­ klÃ¡ves, kterÃ© hrÃ¡Ä bude typicky &quot;drÅ¾et&quot;, napÅ™. Å¡ipky pro pohyb postavy.
Pokud hrÃ¡Ä klÃ¡vesu bude drÅ¾et stisknutou, operaÄnÃ­ systÃ©m sice vaÅ¡Ã­ hÅ™e bude pÅ™edÃ¡vat pravidelnÄ› novÃ© udÃ¡losti typu
<code>SDL_KEYDOWN</code>, nicmÃ©nÄ› bude to dÄ›lat dost pomalu, v Å™Ã¡du jednotek udÃ¡lostÃ­ za vteÅ™inu. To by znamenalo, Å¾e pokud byste
ve svÃ© hÅ™e pÅ™Ã­mo vyvolÃ¡vali napÅ™. pohyb hrÃ¡Äovy postavy v reakci na udÃ¡lost stisknutÃ­ klÃ¡vesy, tak by se postava pohybovala
trhanÄ›.</p>
<pre><code class="language-c">if (event.type == SDL_KEYDOWN) {
    // Toto je Å¡patnÃ© Å™eÅ¡enÃ­ pohybu!
    if (event.key.keysym.sym == SDLK_RIGHT) {
        hrac.pozice.x += 10 * deltaTime;
    }
}
</code></pre>
<p>Mnohem lepÅ¡Ã­ Å™eÅ¡enÃ­ je pouÅ¾Ã­t nÃ¡sledujÃ­cÃ­ pÅ™Ã­stup:</p>
<ol>
<li>MÃ­t v pamÄ›ti uloÅ¾enÃ½ souÄasnÃ½ stav stisknutÃ½ch klÃ¡ves. To mÅ¯Å¾ete udÄ›lat buÄ pomocÃ­ funkce na
<a href="c/aplikovane_ulohy/sdl/vstup.html#sou%C4%8Dasn%C3%BD-stav-1">zÃ­skÃ¡nÃ­ stavu klÃ¡vesnice</a>, nebo si mÅ¯Å¾ete vytvoÅ™it promÄ›nnÃ©, kterÃ© si budou pamatovat stav klÃ¡ves,
kterÃ© vÃ¡s zajÃ­majÃ­, a potÃ© aktualizovat jejich stav pÅ™i ÄtenÃ­ udÃ¡lostÃ­. Pokud obdrÅ¾Ã­te udÃ¡lost <code>SDL_KEYDOWN</code>, tak nastavÃ­te
stav klÃ¡vesy na <code>stisknuto</code>, pokud obdrÅ¾Ã­te udÃ¡lost <code>SDL_KEYUP</code>, tak nastavÃ­te stav na <code>uvolnÄ›no</code>.</li>
<li>V ÄÃ¡sti hernÃ­ smyÄky, kde aktualizujete stav hry, se podÃ­vÃ¡te, jakÃ½ je stav klÃ¡ves, a podle tohoto stavu udÄ›lÃ¡te danou
akci (napÅ™. posunete postavou hrÃ¡Äe). DÃ­ky tomu se bude pohyb provÃ¡dÄ›t plynule (napÅ™. 60 za vteÅ™inu). ZÃ¡roveÅˆ bude takÃ©
tento pohyb synchronizovanÃ½ s pohybem ostatnÃ­ch objektÅ¯ hry, kterÃ© nejsou ovlÃ¡dÃ¡ny klÃ¡vesami.</li>
</ol>
<p>Pokud pouÅ¾ijete tento pÅ™Ã­stup, tak si musÃ­te dÃ¡t pozor na to, aby se nÄ›kterÃ© akce neopakovaly vÃ­cekrÃ¡t. NapÅ™Ã­klad, pokud
budete pÅ™i zmÃ¡ÄknutÃ­ klÃ¡vesy vyvolÃ¡vat nÄ›jakou jednorÃ¡zovou akci (napÅ™. vystÅ™elenÃ­ projektilu), tak byste mÄ›li pÅ™idat do
hry kontrolu, jestli od poslednÃ­ho vyvolÃ¡nÃ­ tÃ©to akce ubÄ›hl dostateÄnÃ½ Äas (&quot;cooldown&quot;). I kdyÅ¾ totiÅ¾ uÅ¾ivatel zmÃ¡Äkne
klÃ¡vesu velmi krÃ¡tce, tak bude klÃ¡vesa zmÃ¡ÄknutÃ¡ pravdÄ›podobnÄ› alespoÅˆ po dobu nÄ›kolika snÃ­mkÅ¯! Pokud bychom tedy
nekontrolovali Äas od poslednÃ­ho vyvolÃ¡nÃ­ akce, tak by se akce provedla opakovanÄ›, coÅ¾ nemusÃ­ bÃ½t Å¾Ã¡doucÃ­. Pro poÄÃ­tÃ¡nÃ­
Äasu, kterÃ½ ve hÅ™e ubÄ›hl, mÅ¯Å¾ete pouÅ¾Ã­t <a href="c/aplikovane_ulohy/sdl/herni_smycka.html#kompenzace-fps">delta Äas</a>, kterÃ½ si staÄÃ­ v kaÅ¾dÃ© iteraci
pÅ™iÄÃ­tat do nÄ›jakÃ© promÄ›nnÃ©, kterÃ¡ si bude pamatovat, kolik uÅ¾ ubÄ›hlo ve hÅ™e Äasu.</p>
<h3><a class="header" href="#souÄasnÃ½-stav-1" id="souÄasnÃ½-stav-1">SouÄasnÃ½ stav</a></h3>
<p>Pokud bychom chtÄ›li zÃ­skat souÄasnÃ½ stav vÅ¡ech klÃ¡ves, mÅ¯Å¾eme vyuÅ¾Ã­t funkci <a href="https://wiki.libsdl.org/SDL2/SDL_GetKeyboardState"><code>SDL_GetKeyboardState</code></a>.
Tato funkce vrÃ¡tÃ­ adresu pole, kterÃ© mÅ¯Å¾eme indexovat pomocÃ­ hodnot datovÃ©ho typu <a href="https://wiki.libsdl.org/SDL2/SDL_Scancode"><code>SDL_Scancode</code></a>.
JednotlivÃ© hodnoty mÅ¯Å¾eme naleznout v druhÃ©m sloupci <a href="https://wiki.libsdl.org/SDL2/SDL_Scancode">tÃ©to tabulky</a>. NapÅ™.
mezernÃ­k je reprezentovÃ¡n hodnotou <code>SDL_SCANCODE_SPACE</code>, klÃ¡vesa <code>a</code> hodnotou <code>SDL_SCANCODE_A</code> a Å¡ipka doprava hodnotou
<code>SDL_SCANCODE_RIGHT</code>. Pokud je hodnota na danÃ©m indexu klÃ¡vesy v poli nenulovÃ¡, tak to znamenÃ¡, Å¾e je tato klÃ¡vesa
zrovna stisknutÃ¡:</p>
<pre><code class="language-c">const Uint8* key_state = SDL_GetKeyboardState(NULL);
if (key_state[SDL_SCANCODE_SPACE]) {
    printf(&quot;Prave ted je stisknut mezernik\n&quot;);
}
</code></pre>
<h1><a class="header" href="#chipmunk" id="chipmunk">Chipmunk</a></h1>
<p>PÅ™i tvorbÄ› interaktivnÃ­ch grafickÃ½ch aplikacÃ­ nebo her mÅ¯Å¾eme chtÃ­t simulovat pohyb objektÅ¯ tak, aby
dodrÅ¾oval fyzikÃ¡lnÃ­ zÃ¡kony (pÅ¯sobenÃ­ gravitace, tÅ™enÃ­ a kolize objektÅ¯, pohyb lana atd.). K tomu
mÅ¯Å¾eme pouÅ¾Ã­t nÄ›jakou knihovnu na simulaci fyziky. <a href="https://chipmunk-physics.net"><code>Chipmunk</code></a> je
knihovna pro simulovÃ¡nÃ­ jednoduchÃ½ch fyzikÃ¡lnÃ­ch procesÅ¯ ve 2D prostoru.
<a href="https://www.youtube.com/watch?v=K84I4qqU8wg">Zde</a> se mÅ¯Å¾ete podÃ­vat, co vÅ¡echno se s takovou
knihovnou dÃ¡ udÄ›lat.</p>
<p>MoÅ¾nÃ¡ znÃ¡te hry jako <a href="https://youtu.be/aiiQ8btusrs?t=399">Angry Birds</a> nebo
<a href="https://youtu.be/3bdBToxbGqg?t=212">Fruit Ninja</a>. PodobnÃ© typy her by se bez nÄ›jakÃ© knihovny pro
simulaci fyziky neobeÅ¡ly.</p>
<h2><a class="header" href="#instalace-1" id="instalace-1">Instalace</a></h2>
<p>Knihovna Chipmunk nenabÃ­zÃ­ distribuci jiÅ¾ pÅ™eloÅ¾enÃ½ch objektovÃ½ch souborÅ¯, musÃ­me tedy jejÃ­ zdrojovÃ©
soubory pÅ™idat k naÅ¡emu projektu a pÅ™eloÅ¾it je ruÄnÄ›.</p>
<p>StÃ¡hnÄ›te si poslednÃ­ verzi <a href="https://chipmunk-physics.net/release/ChipmunkLatest.tgz">zdrojovÃ½ch kÃ³dÅ¯ knihovny</a>
z webu <a href="https://chipmunk-physics.net/downloads.php">Chipmunku</a>, rozbalte je a vÃ½slednou sloÅ¾ku
(napÅ™. <code>Chipmunk-X.Y.Z</code> nebo <code>ChipmunkLatest</code>) pÅ™ejmenujte na <code>Chipmunk</code>.</p>
<p>DÃ¡le mÅ¯Å¾ete knihovnu pÅ™idat ke svÃ©mu <code>CMake</code> projektu pomocÃ­ nÃ¡sledujÃ­cÃ­ <code>CMakeLists.txt</code> souboru:</p>
<details>
<summary>UkÃ¡zkovÃ½ CMakeLists.txt soubor pro Chipmunk</summary>
<pre><code class="language-cmake">cmake_minimum_required(VERSION 3.4)

project(physics)

# Parametr -pthread je nutnÃ½ pÅ™i pouÅ¾itÃ­ tÃ©to knihovny
set(CMAKE_C_FLAGS &quot;${CMAKE_C_FLAGS} -pthread&quot;)

# VloÅ¾enÃ­ adresÃ¡Å™e Chipmunk
add_subdirectory(Chipmunk)

# VytvoÅ™enÃ­ programu
add_executable(physics main.c)

# PÅ™idÃ¡nÃ­ knihovny k naÅ¡emu programu
target_include_directories(physics PRIVATE Chipmunk/include/chipmunk)
target_link_libraries(physics chipmunk)
</code></pre>
</details>
<h2><a class="header" href="#chipmunk-hello-world" id="chipmunk-hello-world"><code>Chipmunk</code> hello world</a></h2>
<p>StejnÄ› jako u <a href="c/aplikovane_ulohy/sdl.html"><code>SDL</code></a> nenÃ­ v silÃ¡ch tohoto textu poskytnout kompletnÃ­ho prÅ¯vodce touto
knihovnou. Pro to mÅ¯Å¾ete pouÅ¾Ã­t <a href="https://chipmunk-physics.net/release/ChipmunkLatest-Docs/">manuÃ¡l</a>
nebo podrobnou <a href="https://chipmunk-physics.net/release/ChipmunkLatest-API-Reference/modules.html">dokumentaci funkcÃ­</a>.</p>
<p>Zde je okomentovanÃ¡ ukÃ¡zka &quot;hello-world&quot; pÅ™Ã­kladu, kterÃ½ simuluje pÃ¡d sady kostek a vykresluje je
pomocÃ­ SDL:</p>
<details>
<summary>OkomentovanÃ½ program vyuÅ¾Ã­vajÃ­cÃ­ knihovny Chipmunk a SDL</summary>
<pre><code class="language-c">#include &lt;chipmunk.h&gt;
#include &lt;SDL2/SDL.h&gt;
#include &lt;SDL2/SDL_image.h&gt;
#include &lt;assert.h&gt;
#include &lt;stdbool.h&gt;

const int WIDTH = 800;
const int HEIGHT = 600;

int main() {
    // VytvoÅ™enÃ­ SDL okna a kreslÃ­tka
    assert(!SDL_Init(SDL_INIT_VIDEO));

    SDL_Window* window = SDL_CreateWindow(&quot;Physics&quot;, 100, 100, WIDTH, HEIGHT, SDL_WINDOW_SHOWN);
    SDL_Renderer* renderer = SDL_CreateRenderer(window, -1, SDL_RENDERER_ACCELERATED | SDL_RENDERER_PRESENTVSYNC);

    // NaÄtenÃ­ obrÃ¡zku z disku
    SDL_Texture* image = IMG_LoadTexture(renderer, &quot;wood.jpg&quot;);
    assert(image);

    SDL_SetRenderDrawColor(renderer, 0, 0, 0, 255);

    // VytvoÅ™enÃ­ prostoru, ve kterÃ©m bude probÃ­hat fyzikÃ¡lnÃ­ simulace
    cpSpace* space = cpSpaceNew();
    // NastavenÃ­ sÃ­ly gravitace
    cpSpaceSetGravity(space, (cpVect) { .x = 0, .y = -100.0f });

    // VytvoÅ™enÃ­ zemÄ›
    cpShape* ground = cpSegmentShapeNew(
        cpSpaceGetStaticBody(space),
        (cpVect) { .x = 0, .y = 10},
        (cpVect) { .x = WIDTH, .y = 10},
        0
    );
    cpShapeSetFriction(ground, 1.0f);    // NastavenÃ­ tÅ™enÃ­ zemÄ›
    cpSpaceAddShape(space, ground);      // PÅ™idÃ¡nÃ­ zemÄ› do svÄ›ta

    const float mass = 10.0f;            // VÃ¡ha kostky
    const int dimension = 30;            // RozmÄ›r kostky

    cpShape* boxes[10];                  // Pole kostek
    for (int i = 0; i &lt; 10; i++) {
        // VytvoÅ™enÃ­ tÄ›la kostky, kterÃ© se bude hÃ½bat
        cpBody* body = cpBodyNew(mass, cpMomentForBox(mass, dimension, dimension));
        // PÅ™idÃ¡nÃ­ tÄ›la do prostoru
        cpSpaceAddBody(space, body);
        // NastavenÃ­ pozice kostky
        cpBodySetPosition(body, (cpVect) {
            .x = 100 + 5 * i,
            .y = 40 + i * (dimension + 10)
        });

        // VytvoÅ™enÃ­ tvaru kostky, kterÃ½ bude pouÅ¾ito pro detekci kolizÃ­
        cpShape* shape = cpBoxShapeNew(body, dimension, dimension, 1);
        // PÅ™idÃ¡nÃ­ tvaru do prostoru
        cpSpaceAddShape(space, shape);
        // NastavenÃ­ tÅ™enÃ­ kostky
        cpShapeSetFriction(shape, 1.0f);

        boxes[i] = shape;
    }

    Uint64 last = SDL_GetPerformanceCounter();   // PoÄÃ­tÃ¡nÃ­ Äasu vykreslovÃ¡nÃ­
    float physics_counter = 0.0f;                // PoÄÃ­tÃ¡nÃ­ Äasu fyziky
    float timestep = 1.0f / 60.0f;               // ÄŒasovÃ½ krok, o kterÃ½ se bude fyzika posouvat

    bool quit = false;
    while (!quit) {
        SDL_Event event;
        while (SDL_PollEvent(&amp;event)) {
            if (event.type == SDL_QUIT) {
                quit = true;
            }
        }

        Uint64 now = SDL_GetPerformanceCounter();

        // PoÄet vteÅ™in od poslednÃ­ iterace hernÃ­ smyÄky
        float delta_time_s = ((float)(now - last) / (float)SDL_GetPerformanceFrequency());
        last = now;

        // OdsimulovÃ¡nÃ­ Äasu fyziky
        physics_counter += delta_time_s;
        while (physics_counter &gt;= timestep) {
            cpSpaceStep(space, timestep);  // ProvedenÃ­ jednoho ÄasovÃ©ho kroku
            physics_counter -= timestep;
        }

        SDL_RenderClear(renderer);

        for (int i = 0; i &lt; 10; i++) {
            cpShape* shape = boxes[i];
            cpBody* body = cpShapeGetBody(shape);

            cpVect position = cpBodyGetPosition(body);  // ZÃ­skÃ¡nÃ­ pozice kostky
            float angle_radians = cpBodyGetAngle(body); // ZÃ­skÃ¡nÃ­ Ãºhlu kostky (v radiÃ¡nech)
            float angle_deg = angle_radians * (180 / M_PI); // PÅ™evod na stupnÄ›

            SDL_Rect rect = {
                .x = position.x - dimension / 2,
                .y = HEIGHT - (position.y + dimension / 2),  // V Chipmunku jde Y nahoru, v SDL dolÅ¯, musÃ­me jej vymÄ›nit
                .w = dimension,
                .h = dimension
            };

            SDL_RenderCopyEx(renderer, image, NULL, &amp;rect, -angle_deg, NULL, SDL_FLIP_NONE);
        }

        SDL_RenderPresent(renderer);
    }

    // UvolnÄ›nÃ­ prostÅ™edkÅ¯
    for (int i = 0; i &lt; 10; i++) {
        cpShape* shape = boxes[i];
        cpBody* body = cpShapeGetBody(shape);

        cpSpaceRemoveShape(space, shape);
        cpSpaceRemoveBody(space, body);
        cpShapeFree(shape);
        cpBodyFree(body);
    }
    cpSpaceRemoveShape(space, ground);
    cpShapeFree(ground);
    cpSpaceFree(space);
    SDL_DestroyTexture(image);
    SDL_DestroyRenderer(renderer);
    SDL_DestroyWindow(window);
    SDL_Quit();

    return 0;
}
</code></pre>
</details>
<p>UkÃ¡zka fungovÃ¡nÃ­ programu:</p>
<p><video src="../../static/video/chipmunk-boxes.webm" controls></video></p>
<p>Tento program spolu s <code>CMakeLists.txt</code> souborem a knihovnou Chipmunk si mÅ¯Å¾ete stÃ¡hnout
<a href="c/aplikovane_ulohy/../../static/snippets/physics.zip">zde</a>. PÅ™eloÅ¾it a spustit ho mÅ¯Å¾ete pomocÃ­ nÃ¡sledujÃ­cÃ­ch pÅ™Ã­kazÅ¯:</p>
<pre><code class="language-bash">$ mkdir build
$ cd build
$ cmake ..
$ make -j
$ cd ..
$ ./build/physics
</code></pre>
<h1><a class="header" href="#co-dÃ¡l" id="co-dÃ¡l">Co dÃ¡l?</a></h1>
<p><em>C</em> je relativnÄ› malÃ½ jazyk, pokud jste si tedy pÅ™eÄetli pÅ™edchozÃ­ ÄÃ¡st tohoto textu, tak znÃ¡te
vÄ›tÅ¡inu dÅ¯leÅ¾itÃ½ch konstrukcÃ­, kterÃ¡ jsou v <em>C</em> dostupnÃ©. NicmÃ©nÄ› neukÃ¡zali jsme si ÃºplnÄ› vÅ¡echny â€“
zde je seznam nÄ›kolika vybranÃ½ch vÄ›cÃ­, kterÃ© byly buÄ moc pokroÄilÃ© pro UPR anebo jsme je jednoduÅ¡e
nepotÅ™ebovali pouÅ¾Ã­t:</p>
<ul>
<li><a href="https://en.cppreference.com/w/c/variadic"><strong>VariadiackÃ© funkce</strong></a> umoÅ¾ÅˆujÃ­ pÅ™ijÃ­mat
libovolnÃ½ poÄet parametrÅ¯ (takto funguje napÅ™Ã­klad i nÃ¡m znÃ¡mÃ¡ funkce
<a href="https://devdocs.io/c/io/fprintf"><code>printf</code></a>).</li>
<li><a href="https://en.cppreference.com/w/c/language/enum"><strong>Enumerace</strong></a> (<em>enumerations</em>) umoÅ¾ÅˆujÃ­
seskupit pojmenovanÃ© konstanty.</li>
<li><a href="https://en.cppreference.com/w/c/language/union"><strong>SjednocenÃ© struktury</strong></a> (<em>unions</em>)
umoÅ¾ÅˆujÃ­ interpretovat strukturu jako vÃ­ce rÅ¯znÃ½ch datovÃ½ch typÅ¯.</li>
<li><a href="https://en.cppreference.com/w/c/language/bit_field"><strong>BitovÃ¡ pole</strong></a> (<em>bit fields</em>)
umoÅ¾ÅˆujÃ­ rozdÄ›lit pamÄ›Å¥ struktury na Ãºrovni jednotlivÃ½ch bitÅ¯. </li>
<li><a href="http://www.cplusplus.com/reference/cwchar/"><strong>Å irokÃ© znaky</strong></a> (<em>wide chars</em>) a s nimi souvisejÃ­cÃ­
funkce standardnÃ­ knihovny umoÅ¾ÅˆujÃ­ pouÅ¾Ã­vat sloÅ¾itÄ›jÅ¡Ã­ kÃ³dovÃ¡nÃ­ neÅ¾ ASCII.</li>
<li><a href="https://en.cppreference.com/w/c/numeric/complex"><strong>KomplexnÃ­ ÄÃ­sla</strong></a> (<em>complex numbers</em>) vÃ¡m
umoÅ¾nÃ­ pracovat s datovÃ½mi typy reprezentujÃ­cÃ­mi komplexnÃ­ ÄÃ­sla.</li>
</ul>
<blockquote>
<p>Pokud si chcete ovÄ›Å™it, jak jste na tom se znalostÃ­ jazyka <em>C</em>, projdÄ›te si tyto
<a href="c/../static/files/deepc.pdf">slidy</a>. Pokud budete umÄ›t odpovÃ­dat jako blonÄatÃ½
kluk, tak znÃ¡te zÃ¡klady jazyka <em>C</em>. Pokud budete umÄ›t odpovÃ­dat jako dÃ­vka s rÅ¯Å¾ovÃ½mi vlasy,
tak uÅ¾ vÃ¡s v jazyce <em>C</em> tÃ©mÄ›Å™ nic nepÅ™ekvapÃ­.</p>
</blockquote>
<h2><a class="header" href="#co-se-dÃ¡le-nauÄit" id="co-se-dÃ¡le-nauÄit">Co se dÃ¡le nauÄit</a></h2>
<p>Se znalostÃ­ samotnÃ©ho jazyka <em>C</em> souvisÃ­ i spousta dalÅ¡Ã­ch konceptÅ¯, se kterÃ½mi se postupnÄ› musÃ­te
seznÃ¡mit, pokud chcete opravdu dopodrobna pochopit, co pÅ™esnÄ› se v poÄÃ­taÄi dÄ›je, kdyÅ¾ spustÃ­te
vÃ¡mi napsanÃ½ program. PotÃ© mÅ¯Å¾ete tÄ›chto znalostÃ­ vyuÅ¾Ã­t k tvorbÄ› robustnÄ›jÅ¡Ã­ch a rychlejÅ¡Ã­ch
programÅ¯. Na nÃ¡sledujÃ­cÃ­ch odkazech se mÅ¯Å¾ete dozvÄ›dÄ›t napÅ™Ã­klad:</p>
<ul>
<li>Jak fungujÃ­ <a href="http://poli.cs.vsb.cz/edu/osy/osnova.html">operaÄnÃ­ systÃ©my</a>.
<ul>
<li>Nebo dokonce jak si nÄ›jakÃ½ <a href="https://littleosbook.github.io/">napsat od nuly</a>.</li>
</ul>
</li>
<li>Jak komunikovat s jinÃ½mi programy po <a href="http://www.beej.us/guide/bgnet/">sÃ­ti</a>.</li>
<li>Jak psÃ¡t programy pÅ™Ã­mo pomocÃ­ <a href="http://poli.cs.vsb.cz/edu/soj/down/soj-skripta.pdf">instrukcÃ­ procesoru</a></li>
<li>Jak urychlit provÃ¡dÄ›nÃ­ programÅ¯:
<ul>
<li>PomocÃ­ <a href="https://computing.llnl.gov/tutorials/pthreads/">vlÃ¡ken</a>, kterÃ© umÃ­ vyuÅ¾Ã­t potenciÃ¡l
vÃ­cejÃ¡drovÃ½ch procesorÅ¯.</li>
<li>PomocÃ­ <a href="http://www.cs.uu.nl/docs/vakken/magr/2017-2018/files/SIMD%20Tutorial.pdf">vektorovÃ½ch instrukcÃ­</a>,
kterÃ© umÃ­ pracovat s vÃ­ce neÅ¾ jednou hodnotou najednou.</li>
<li>PomocÃ­ pochopenÃ­ <a href="https://github.com/Kobzol/hardware-effects">architektury procesoru</a>, kterÃ¡
silnÄ› ovlivÅˆuje vÃ½kon programÅ¯.</li>
</ul>
</li>
<li>Jak si napsat vlastnÃ­ <a href="https://www3.nd.edu/%7Edthain/compilerbook/compilerbook.pdf">pÅ™ekladaÄ</a> Äi
<a href="http://www.buildyourownlisp.com/chapter1_introduction">programovacÃ­ jazyk</a>.</li>
<li>Jak si napsat vlastnÃ­ <a href="https://cstack.github.io/db_tutorial/">databÃ¡zi</a>.</li>
<li>Jak funguje <a href="http://mrl.cs.vsb.cz/people/fabian/pg1_course.html">poÄÃ­taÄovÃ¡ grafika</a>.
<ul>
<li>MÅ¯Å¾ete si napsat vlastnÃ­ <a href="https://learnopengl.com/">3D hernÃ­ engine</a> pomocÃ­ OpenGL.</li>
</ul>
</li>
<li>Jak si napsat program pro nÄ›jakÃ© vestavÄ›nÃ© (<em>embedded</em>) zaÅ™Ã­zenÃ­, napÅ™Ã­klad <a href="https://www.arduino.cc/en/Tutorial/BuiltInExamples/Blink">Arduino</a>.</li>
</ul>
<h1><a class="header" href="#rÅ¯znÃ©" id="rÅ¯znÃ©">RÅ¯znÃ©</a></h1>
<p>Tato sekce obsahuje rÅ¯znÃ¡ tÃ©mata a nÃ¡vody, kterÃ© nezapadajÃ­ do zbytku textu, ale je dobrÃ© o nich
vÄ›dÄ›t.</p>
<h1><a class="header" href="#rozklad-problÃ©mu" id="rozklad-problÃ©mu">Rozklad problÃ©mu</a></h1>
<p>ÄŒasto se setkÃ¡te s tÃ­m, Å¾e dostanete k naprogramovÃ¡nÃ­ Ãºlohu, se kterou si nevÃ­te rady a netuÅ¡Ã­te ani
jak zaÄÃ­t. NapÅ™Ã­klad:</p>
<p><code>NaÄti obrÃ¡zek z disku, zmÄ›Åˆ jeho velikost, uloÅ¾ ho do jinÃ©ho souboru a vykresli jej na obrazovku.</code></p>
<p>Tato Ãºloha vypadÃ¡ velmi jednoduÅ¡e, kdyÅ¾ je zadanÃ¡ vÄ›tou (v ÄeÅ¡tinÄ›), ale obzvlÃ¡Å¡tÄ› pro zaÄÃ­najÃ­cÃ­
programÃ¡tory je obtÃ­Å¾nÃ© pÅ™evÃ©st takovouto Ãºlohu do programovacÃ­ho jazyka. ObecnÃ½m pravidlem k usnadnÄ›nÃ­
Å™eÅ¡enÃ­ sloÅ¾itÃ½ch Ãºloh je rozdÄ›lovat je na menÅ¡Ã­ a jednoduÅ¡Å¡Ã­ podÃºlohy tak dlouho, dokud se nedostaneme
k podÃºloze, kterou jiÅ¾ umÃ­me vyÅ™eÅ¡it. PotÃ© z tÄ›chto malÃ½ch kouskÅ¯, kterÃ© mÃ¡me vyÅ™eÅ¡enÃ©, zpÄ›tnÄ› posklÃ¡dÃ¡me
celÃ½ program, kterÃ½ vyÅ™eÅ¡Ã­ pÅ¯vodnÃ­ Ãºlohu.</p>
<p>NapÅ™Ã­klad zmÃ­nÄ›nou Ãºlohu mÅ¯Å¾eme rozdÄ›lit na nÃ¡sledujÃ­cÃ­ podÃºlohy: </p>
<ul>
<li>NaÄti obrÃ¡zek z disku
<ul>
<li>OtevÅ™i soubor se vstupnÃ­m obrÃ¡zkem</li>
<li>NaÄti hlaviÄku obrÃ¡zku</li>
<li>VytvoÅ™ pamÄ›Å¥ pro pixely obrÃ¡zku
<ul>
<li>Naalokuj dostatek pamÄ›ti dle hlaviÄky (Å¡Ã­Å™ka x vÃ½Å¡ka)</li>
</ul>
</li>
</ul>
</li>
<li>ZmÄ›Åˆ velikost obrÃ¡zku
<ul>
<li>VytvoÅ™ obrÃ¡zek s novÃ½m rozmÄ›rem</li>
<li>PÅ™ekopÃ­ruj pÅ¯vodnÃ­ obrÃ¡zek do novÃ©ho obrÃ¡zku
<ul>
<li>Projdi vÅ¡echny pixely novÃ©ho obrÃ¡zku
<ul>
<li>Projdi kaÅ¾dÃ½ Å™Ã¡dek</li>
<li>Pro kaÅ¾dÃ½ Å™Ã¡dek projdi kaÅ¾dÃ½ sloupec</li>
</ul>
</li>
<li>Pro kaÅ¾dÃ½ pixel spoÄÃ­tej pÅ¯vodnÃ­ pozici pixelu
<ul>
<li>Pro vÃ½poÄet pouÅ¾ij pomÄ›r Å¡Ã­Å™ky/vÃ½Å¡ky novÃ©ho/starÃ©ho obrÃ¡zku</li>
</ul>
</li>
<li>PÅ™ekopÃ­ruj pixel ze starÃ©ho obrÃ¡zku do novÃ©ho</li>
</ul>
</li>
<li>VraÅ¥ novÃ½ obrÃ¡zek</li>
</ul>
</li>
<li>ZapiÅ¡ upravenÃ½ obrÃ¡zek
<ul>
<li>OtevÅ™i soubor k zÃ¡pisu</li>
<li>ZapiÅ¡ hlaviÄku obrÃ¡zku do souboru</li>
<li>ZapiÅ¡ pixely obrÃ¡zku do souboru</li>
</ul>
</li>
<li>Vykresli upravenÃ½ obrÃ¡zek
<ul>
<li>VytvoÅ™ okno pro vykreslenÃ­ obrÃ¡zku</li>
<li>PÅ™ekopÃ­ruj pixely obrÃ¡zku do otevÅ™enÃ©ho okna</li>
<li>Zobraz okno s obrÃ¡zkem</li>
</ul>
</li>
</ul>
<p>PomocÃ­ tohoto univerzÃ¡lnÃ­ho postupu se dÅ™Ã­ve Äi pozdÄ›ji dostanete k (pod)Ãºloze, kterou byste jiÅ¾ mÄ›li umÄ›t
vyÅ™eÅ¡it (napÅ™. otevÅ™enÃ­ souboru). Jakmile danou podÃºlohu vyÅ™eÅ¡Ã­te, tak budete o krok blÃ­Å¾e k Å™eÅ¡enÃ­
pÅ¯vodnÃ­ sloÅ¾itÃ© Ãºlohy.</p>
<p>TÃ­mto zpÅ¯sobem mÅ¯Å¾eme programy rovnou od zaÄÃ¡tku zaÄÃ­t psÃ¡t. NapÅ™Ã­klad pÅ™i Å™eÅ¡enÃ­ vÃ½Å¡e zmÃ­nÄ›nÃ© Ãºlohy
mÅ¯Å¾eme zaÄÃ­t nadefinovÃ¡nÃ­m hlavnÃ­ logiky programu pomocÃ­ volÃ¡nÃ­ funkcÃ­, kde kaÅ¾dÃ¡ funkce bude reprezentovat
jednu podÃºlohu. I kdyÅ¾ funkce zatÃ­m nebudou naprogramovanÃ© a pozdÄ›ji se tÅ™eba jejich nÃ¡zev nebo rozhranÃ­
trochu zmÄ›nÃ­, tak nÃ¡m toto rozdÄ›lenÃ­ mÅ¯Å¾e pomoct pÅ™emÃ½Å¡let nad problÃ©mem abstraktnÄ›ji, zorientovat s
v nÄ›m a takÃ© zÃ­skat nadÄ›ji, Å¾e se nÃ¡m Ãºlohu vÅ¯bec podaÅ™Ã­ vyÅ™eÅ¡it. StejnÃ½ princip opÄ›t mÅ¯Å¾eme pouÅ¾Ã­t
pÅ™i implementaci jednotlivÃ½ch funkcÃ­. Program (Äi funkci) pak lze pÅ™eÄÃ­st jako vÄ›tu a je tak jednoduÅ¡Å¡Ã­
pochopit, co mÃ¡ vlastnÄ› dÄ›lat.</p>
<pre><code class="language-c">int main() {
    // NaÄti obrÃ¡zek
    FILE* vstupni_soubor = otevri_soubor(...);
    Img obrazek = nacti_obrazek(vstupni_soubor);

    // Uprav jeho velikost
    Img upraveny_obrazek = uprav_velikost_obrazku(&amp;obrazek);

    // ZapiÅ¡ obrÃ¡zek
    FILE* vystupni_soubor = otevri_soubor(...);
    zapis_obrazek(vystupni_soubor, &amp;upraveny_obrazek);

    // Vykresli obrÃ¡zek
    vykresli_obrazek(&amp;upraveny_obrazek);

    return 0;
}
</code></pre>
<h1><a class="header" href="#vyhodnocovÃ¡nÃ­-vÃ½razÅ¯" id="vyhodnocovÃ¡nÃ­-vÃ½razÅ¯">VyhodnocovÃ¡nÃ­ vÃ½razÅ¯</a></h1>
<p>Abyste pochopili, co se dÄ›je, kdyÅ¾ vÃ¡Å¡ program bÄ›Å¾Ã­, a umÄ›li ho odladit, tak je dÅ¯leÅ¾itÃ©, abyste si
umÄ›li myÅ¡lenkovÄ› &quot;odsimulovat&quot;, co pÅ™esnÄ› procesor provÃ¡dÃ­, kdyÅ¾ vykonÃ¡vÃ¡ pÅ™Ã­kazy vaÅ¡eho programu.
Asi nejlepÅ¡Ã­m nÃ¡strojem pro tento ÃºÄel je pouÅ¾itÃ­ <a href="ruzne/../prostredi/ladeni.html#krokov%C3%A1n%C3%AD">debuggeru</a>,
pomocÃ­ kterÃ©ho mÅ¯Å¾ete provÃ¡dÄ›t vÃ¡Å¡ program pÅ™Ã­kaz po pÅ™Ã­kazu a sledovat, jak se bÄ›hem toho mÄ›ni
jeho vÃ½stup a hodnoty v pamÄ›ti.</p>
<p>DÅ¯leÅ¾itÃ© je zejmÃ©na vÄ›dÄ›t, jak fungujÃ­ pÅ™Ã­kazy <a href="ruzne/../c/rizeni_toku/rizeni_toku.html">Å™Ã­zenÃ­ toku</a> a
jak funguje vyhodnocovÃ¡nÃ­ <a href="ruzne/../c/prikazy_vyrazy.html">vÃ½razÅ¯</a>. NÃ­Å¾e naleznete nÄ›kolik pÅ™Ã­kladÅ¯, kterÃ©
slouÅ¾Ã­ k demonstraci toho, jak se postupnÄ› vyhodnocujÃ­ vÃ½razy v jazyce <em>C</em>.<sup class='margin-toggle sidenote-number'>1</sup></p>
<span class='sidenote'><p><sup class='number'>1</sup>Procesor ve skuteÄnosti s nejvÄ›tÅ¡Ã­ pravdÄ›podobnostÃ­ nebude vÃ½razy vyhodnocovat pÅ™esnÄ› tak,
jak je zde ukÃ¡zÃ¡no, ale mnohem efektivnÄ›ji. VÃ½sledek by vÅ¡ak mÄ›l bÃ½t stejnÃ½, proto se vyplatÃ­ umÄ›t
vyhodnocovat vÃ½razy &quot;v hlavÄ›&quot;, abychom si ovÄ›Å™ili, Å¾e program dÄ›lÃ¡ to, co oÄekÃ¡vÃ¡me.</p>
</span>
<ul>
<li>AritmetickÃ© <a href="ruzne/../c/datove_typy/celociselne_typy.html">operace</a> a ÄtenÃ­ <a href="ruzne/../c/promenne/promenne.html">promÄ›nnÃ½ch</a>
<pre><code class="language-c">int a = 5;
int b = 8;
int c = 6;

// NÃ­Å¾e je rozepsanÃ© vyhodnocenÃ­ vÃ½razu `c = (a + b) * c + 1 - b`
c = (a + b) * c + 1 - b;

// c = (a + b) * c + 1 - b
// c = (5 + b) * c + 1 - b
// c = (5 + 8) * c + 1 - b
// c = (13) * c + 1 - b
// c = 13 * c + 1 - b
// c = 13 * 6 + 1 - b
// c = 78 + 1 - b
// c = 79 - b
// c = 79 - 8
// c = 71

// Hodnota promÄ›nnÃ© c je nynÃ­ 71
</code></pre>
</li>
<li>VolÃ¡nÃ­ <a href="ruzne/../c/funkce/funkce.html">funkcÃ­</a>
<pre><code class="language-c">int foo(int a, int b) {
    int c = a + b;
    return c * 2 + b;
}
int main() {
    int x = 8;
    int y = foo(x, 5 + 2);
    // y = foo(x, 5 + 2)
    // y = foo(8, 5 + 2)
    // y = foo(8, 7)
    // y = 37

    int z = foo(foo(x, x), foo(y, 1) + 8);
    // z = foo(foo(x, x), foo(y, 1) + 8)
    // z = foo(foo(8, x), foo(y, 1) + 8)
    // z = foo(foo(8, 8), foo(y, 1) + 8)
    // z = foo(40, foo(y, 1) + 8)
    // z = foo(40, foo(37, 1) + 8)
    // z = foo(40, 77 + 8)
    // z = foo(40, 85)
    // z = foo(40, 85)
    // z = 335

    return 0;
}
</code></pre>
</li>
</ul>
<h1><a class="header" href="#generovÃ¡nÃ­-nÃ¡hodnÃ½ch-ÄÃ­sel" id="generovÃ¡nÃ­-nÃ¡hodnÃ½ch-ÄÃ­sel">GenerovÃ¡nÃ­ nÃ¡hodnÃ½ch ÄÃ­sel</a></h1>
<p>PoÄÃ­taÄe jsou <strong>deterministickÃ©</strong> stroje, coÅ¾ znamenÃ¡, Å¾e stejnÃ½ program vÅ¾dy na stejnÃ½ vstup
vrÃ¡tÃ­ stejnÃ½ vÃ½stup. ÄŒasto ovÅ¡em chceme, aby naÅ¡e programy obsahovaly prvky &quot;nÃ¡hody&quot;, kdyÅ¾ chceme
napÅ™Ã­klad:</p>
<ul>
<li>Hodit si kostkou v deskovÃ© hÅ™e</li>
<li>UdÄ›lit nÃ¡hodnÃ½ poÄet zranÄ›nÃ­ v rozsahu zbranÄ›</li>
<li>OÅ¾ivit hrÃ¡Äe na nÃ¡hodnÃ© pozici na mapÄ›</li>
</ul>
<p>PoÄÃ­taÄe samy o sobÄ› opravdovou nÃ¡hodu vytvoÅ™it nemohou, nicmÃ©nÄ› mÅ¯Å¾ou ji simulovat pomocÃ­ tzv.
<strong>pseudo-nÃ¡hodnÃ½ch generÃ¡torÅ¯ ÄÃ­sel</strong> (<em>pseudo-random number generation</em>).</p>
<p>Vygenerovat (pseudo-)nÃ¡hodnou sekvenci ÄÃ­sel pomocÃ­ deterministickÃ½ch operacÃ­ mÅ¯Å¾eme napÅ™Ã­klad
nÃ¡sledujÃ­cÃ­m algoritmem:</p>
<ol>
<li>ZaÄneme s ÄÃ­slem <code>S</code>, kterÃ© se nazÃ½vÃ¡ <strong>poÄÃ¡teÄnÃ­ nÃ¡hodnÃ¡ hodnota</strong> (<em>random seed</em>).</li>
<li>Aplikujeme nÄ›jakou matematickou operaci na <code>S</code> a vyjde nÃ¡m novÃ© ÄÃ­slo <code>N</code>.</li>
<li><code>N</code> pouÅ¾ijeme jako vygenerovanÃ© &quot;nÃ¡hodnÃ© ÄÃ­slo&quot;.</li>
<li>NastavÃ­me <code>S = N</code>.</li>
<li>Opakujeme postup od bodu 2).</li>
</ol>
<p>UkÃ¡zka kÃ³du, kterÃ½ takovÃ½to algoritmus implementuje:</p>
<pre><code class="language-c editable">int S = 5;
int vygeneruj_cislo() {
    int N = S;
    N = (5 * N + 3) % 6323;
    N = (4 * N + 2) % 8127;
    S = N;
    return N;
}
int main() {
    int r1 = vygeneruj_cislo(); // 114
    int r2 = vygeneruj_cislo(); // 2294
    int r3 = vygeneruj_cislo(); // 4348
    int r4 = vygeneruj_cislo(); // 2971
    int r5 = vygeneruj_cislo(); // 723
    return 0;
}
</code></pre>
<p>TakovÃ½to algoritmus bude generovat (nekoneÄnou) sekvenci ÄÃ­sel, kterÃ¡ bude lidem pÅ™ipadat &quot;nÃ¡hodnÃ¡&quot;
(bude tÄ›Å¾kÃ© uhodnout, jakÃ© ÄÃ­slo algoritmus vrÃ¡tÃ­ pÅ™Ã­Å¡tÄ›).</p>
<h3><a class="header" href="#volba-poÄÃ¡teÄnÃ­-hodnoty-s" id="volba-poÄÃ¡teÄnÃ­-hodnoty-s">Volba poÄÃ¡teÄnÃ­ hodnoty <code>S</code></a></h3>
<p>UrÄite jste si vÅ¡imli, Å¾e vÃ½Å¡e zmÃ­nÄ›nÃ½ algoritmus bude pokaÅ¾dÃ© generovat stejnou sekvenci ÄÃ­sel pro
stejnÃ© poÄÃ¡teÄnÃ­ <code>S</code>. To se mÅ¯Å¾e hodit, chceme-li napÅ™Ã­klad mÃ­t moÅ¾nost zpÄ›tnÄ› pÅ™ehrÃ¡t sekvenci
pseudo-nÃ¡hodnÃ½ch ÄÃ­sel, napÅ™Ã­klad pro odladÄ›nÃ­ chyby v programu. NicmÃ©nÄ› pokud by sekvence byla pokaÅ¾dÃ©
stejnÃ¡, tak o (pseudo-)nÃ¡hodÄ› nemÅ¯Å¾e bÃ½t Å™eÄ.</p>
<p>Proto se obvykle hodnota <em>seedu</em> volÃ­ tak, aby pÅ™i kaÅ¾dÃ©m spuÅ¡tÄ›nÃ­ programu byla jinÃ¡. PÅ™irozenou
volbou pro poÄÃ¡teÄnÃ­ hodnotu <code>S</code> je tak napÅ™Ã­klad Äas<sup class='margin-toggle sidenote-number'>1</sup> pÅ™i spuÅ¡tÄ›nÃ­ programu. Lze ale takÃ© pouÅ¾Ã­t
napÅ™Ã­klad pohyby myÅ¡i nebo stisky klÃ¡ves, kterÃ© nedÃ¡vno na poÄÃ­taÄi probÄ›hly.</p>
<span class='sidenote'><p><sup class='number'>1</sup>Ve formÄ› <a href="https://en.wikipedia.org/wiki/Unix_time">UNIX ÄasovÃ©ho razÃ­tka</a>, tedy poÄtu vteÅ™in
ubÄ›hlÃ½ch od 1. 1. 1970.</p>
</span>
<h3><a class="header" href="#pseudo-nÃ¡hodnÃ½-generÃ¡tor-ve-standardnÃ­-knihovnÄ›-c" id="pseudo-nÃ¡hodnÃ½-generÃ¡tor-ve-standardnÃ­-knihovnÄ›-c">Pseudo-nÃ¡hodnÃ½ generÃ¡tor ve standardnÃ­ knihovnÄ› <em>C</em></a></h3>
<p>PÅ™i praktickÃ©m pouÅ¾itÃ­ si obvykle nebudete psÃ¡t generÃ¡tor pseudo-nÃ¡hodnÃ½ch sami, ale pouÅ¾ijete jiÅ¾
hotovÃ© Å™eÅ¡enÃ­. To nabÃ­zÃ­ napÅ™Ã­klad standardnÃ­ knihovna <em>C</em> ve formÄ› funkcÃ­ <code>srand</code> (nastav hodnotu
<em>seed</em>u) a <code>rand</code> (vygeneruj pseudo-nÃ¡hodnÃ© ÄÃ­slo):</p>
<pre><code class="language-c editable">#include &lt;stdlib.h&gt;
#include &lt;time.h&gt;

int main() {
    int cas = (int) time(NULL); // zÃ­skej souÄasnÃ½ Äas
    srand(cas); // nastav S na souÄasnÃ½ Äas

    int cislo1 = rand(); // pseudo-nÃ¡hodnÃ© ÄÃ­slo z intervalu [0, RAND_MAX]
    int cislo2 = rand() % 100; // z intervalu [0, 99]
    int cislo3 = rand() % 100 + 5; // z intervalu [5, 104]
    float cislo4 = rand() / (float) RAND_MAX; // z intervalu [0.0, 1.0]

    return 0;
}
</code></pre>
<h1><a class="header" href="#dynamicky-rostoucÃ­-pole" id="dynamicky-rostoucÃ­-pole">Dynamicky rostoucÃ­ pole</a></h1>
<p>V kapitolÃ¡ch o <a href="ruzne/../c/pole/staticka_pole.html">statickÃ½ch</a> a <a href="ruzne/../c/pole/dynamicka_pole.html">dynamickÃ½ch</a>
polÃ­ch jsme si ukÃ¡zali, jak mÅ¯Å¾eme vytvoÅ™it pamÄ›Å¥ pro vÃ­ce promÄ›nnÃ½ch uloÅ¾enÃ½ch sekvenÄnÄ› za sebou
v pamÄ›ti. Tato pole vÅ¡ak mÄ›la vÅ¾dy jedno omezenÃ­, protoÅ¾e jejich velikost se po jejich vytvoÅ™enÃ­ nedala
mÄ›nit. Jakmile vÅ¡ak naÅ¡e programy zaÄnou bÃ½t sloÅ¾itÄ›jÅ¡Ã­, budeme si urÄitÄ› chtÃ­t pamatovat vÃ­ce hodnot
bez toho, abychom museli nutnÄ› dopÅ™edu vÄ›dÄ›t, kolik tÄ›chto hodnot bude. NapÅ™Ã­klad:</p>
<ul>
<li>ÄŒteme Å™Ã¡dky z textovÃ©ho souboru, a nevÃ­me dopÅ™edu, kolik tÄ›ch Å™Ã¡dkÅ¯ bude.</li>
<li>Chceme projÃ­t existujÃ­cÃ­ pole a vytÃ¡hnout z nÄ›j pouze ty prvky, kterÃ© splÅˆujÃ­ nÄ›jakou vlastnost.</li>
<li>UÅ¾ivatel v naÅ¡Ã­ <a href="ruzne/../c/aplikovane_ulohy/sdl.html">SDL</a> aplikaci klikÃ¡ na obrazovku a my chceme na kaÅ¾dÃ©m
bodu kliknutÃ­ nÄ›co vykreslit.</li>
</ul>
<p>Proto je vhodnÃ© nauÄit se vytvoÅ™it pole, kterÃ© mÅ¯Å¾eme postupnÄ› naplÅˆovat, a jehoÅ¾ velikost se mÅ¯Å¾e
v Äase zvÄ›tÅ¡ovat. TakovÃ©mu poli budeme Å™Ã­kat <strong>dynamicky rostoucÃ­ pole</strong> (dÃ¡le pouze <em>rostoucÃ­ pole</em>).
Tato datovÃ¡ struktura je tak uÅ¾iteÄnÃ¡ a Äasto vyuÅ¾Ã­vanÃ¡, Å¾e se ve spoustÄ› programovacÃ­ch jazycÃ­ch
vyskytuje jako vestavÄ›nÃ½ stavebnÃ­ blok<sup class='margin-toggle sidenote-number'>1</sup>.</p>
<span class='sidenote'><p><sup class='number'>1</sup>C++: <a href="https://en.cppreference.com/w/cpp/container/vector">std::vector</a>, Java: <a href="https://docs.oracle.com/javase/8/docs/api/java/util/ArrayList.html">ArrayList</a>, C#: <a href="https://learn.microsoft.com/en-us/dotnet/api/system.collections.generic.list-1">List</a>, JavaScript: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array">Array</a></p>
</span>
<h2><a class="header" href="#implementace" id="implementace">Implementace</a></h2>
<p>RostoucÃ­ pole bude muset bÃ½t naalokovanÃ© na haldÄ›, protoÅ¾e na zÃ¡sobnÃ­ku bychom nebyli
schopni jeho velikost mÄ›nit, a museli bychom ji znÃ¡t v dobÄ› pÅ™ekladu, coÅ¾ by nÃ¡m nepomohlo. RostoucÃ­
pole bude fungovat zhruba takto:</p>
<ol>
<li>Naalokujeme na haldÄ› dynamickÃ© pole s nÄ›jakou poÄÃ¡teÄnÃ­ velikostÃ­.
<ul>
<li>Pole bude na zaÄÃ¡tku &quot;prÃ¡zdnÃ©&quot;, tj. nebudou v nÄ›m uloÅ¾eny Å¾Ã¡dnÃ© validnÃ­ hodnoty, ale bude
obsahovat dostateÄnou kapacitu na uloÅ¾enÃ­ nÄ›jakÃ©ho poÄtu hodnot.</li>
</ul>
</li>
<li>Budeme do nÄ›j postupnÄ› pÅ™idÃ¡vat prvky.</li>
<li>Jakmile bude pole zcela zaplnÄ›nÃ©, tak jej zvÄ›tÅ¡Ã­me, abychom udÄ›lali mÃ­sto pro dalÅ¡Ã­ prvky.</li>
</ol>
<p>Zde je ukÃ¡zka struktury, kterÃ¡ bude implementovat rostoucÃ­ pole celÃ½ch ÄÃ­sel (<code>int</code>Å¯):</p>
<pre><code class="language-c">typedef struct {
    int* data;
    int pocet;
    int kapacita;
} PoleIntu;
</code></pre>
<p>Pro implementaci budeme potÅ™ebovat minimÃ¡lnÄ› tyto tÅ™i Ãºdaje:</p>
<ul>
<li><code>data</code> - ukazatel na data na haldÄ›, kterÃ¡ budou naalokovanÃ¡ funkcÃ­ <a href="https://devdocs.io/c/memory/malloc"><code>malloc</code></a>.</li>
<li><code>pocet</code> - souÄasnÃ½ poÄet prvkÅ¯ v poli. PÅ™i prÃ¡ci s jakÃ½mkoliv polem potÅ™ebujeme vÅ¾dy vÄ›dÄ›t, kolik
prvkÅ¯ v nÄ›m je. Abychom si tuto informaci nemuseli pamatovat nÄ›kde bokem, dÃ¡me ji pÅ™Ã­mo do struktury
rostoucÃ­ho pole.</li>
<li><code>kapacita</code> - maximÃ¡lnÃ­ poÄet prvkÅ¯, kterÃ© pole mÅ¯Å¾e obsahovat. Tato hodnota odpovÃ­dÃ¡ tomu, pro kolik
prvkÅ¯ jsme vyalokovali pamÄ›Å¥ funkcÃ­ <code>malloc</code>.</li>
</ul>
<p>NynÃ­ si ukÃ¡Å¾eme jak naimplementovat funkce, kterÃ© budou s tÃ­mto polem pracovat.</p>
<h3><a class="header" href="#vytvoÅ™enÃ­-pole" id="vytvoÅ™enÃ­-pole">VytvoÅ™enÃ­ pole</a></h3>
<p>Pro vytvoÅ™enÃ­ pole potÅ™ebujeme naalokovat pamÄ›Å¥ na haldÄ› s nÄ›jakou ÃºvodnÃ­ <code>kapacitou</code>, kterou si mÅ¯Å¾eme
do funkce na vytvoÅ™enÃ­ pole poslat jako argument:</p>
<pre><code class="language-c">void poleintu_vytvor(PoleIntu* pole, int kapacita) {
    // Naalokujeme pamet na halde
    pole-&gt;data = (int*) malloc(sizeof(int) * kapacita);
    // Na zacatku je pole prazdne, takze je pocet prvku 0
    pole-&gt;pocet = 0;
    // Kapacita odpovida tomu, kolik je pole schopne udrzet prvku, nez mu dojde misto
    pole-&gt;kapacita = kapacita;
}
</code></pre>
<h3><a class="header" href="#pÅ™idÃ¡nÃ­-prvku-do-pole" id="pÅ™idÃ¡nÃ­-prvku-do-pole">PÅ™idÃ¡nÃ­ prvku do pole</a></h3>
<p>PÅ™i pÅ™idÃ¡vÃ¡nÃ­ prvku do pole musÃ­me danÃ½ prvek zapsat na prvnÃ­ &quot;volnÃ©&quot; mÃ­sto v poli. Na jakÃ½ index
musÃ­me prvek zapsat?</p>
<ul>
<li>KdyÅ¾ je pole prÃ¡zdnÃ© (<code>pocet = 0</code>), tak zapÃ­Å¡eme novÃ½ prvek na index <code>0</code>:
<pre><code>[?, ?, ?, ?]
 ^
</code></pre>
</li>
<li>KdyÅ¾ mÃ¡ pole jeden prvek (<code>pocet = 1</code>), tak zapÃ­Å¡eme novÃ½ prvek na index <code>1</code>:
<pre><code>[8, ?, ?, ?]
    ^
</code></pre>
</li>
<li>KdyÅ¾ mÃ¡ pole dva prvky (<code>pocet = 2</code>), tak zapÃ­Å¡eme novÃ½ prvek na index <code>2</code>:
<pre><code>[8, 4, ?, ?]
       ^
</code></pre>
</li>
</ul>
<p>PoÄet prvkÅ¯ v poli tedy vÅ¾dy pÅ™Ã­mo odpovÃ­dÃ¡ indexu, na kterÃ½ bychom mÄ›li zapsat pÅ™Ã­Å¡tÃ­ prvek.</p>
<p>Dejme tomu, Å¾e mÃ¡me pole s kapacitou <code>4</code>, s dvÄ›ma prvky (<code>pocet</code> je <code>2</code>) a chceme do nÄ›j uloÅ¾it
novou hodnotu <code>8</code>. Tuto hodnotu musÃ­me zapsat na index <code>2</code>. A po zÃ¡pisu prvku musÃ­me takÃ© zvÃ½Å¡it
poÄet prvkÅ¯ v poli, protoÅ¾e jsme do pole vloÅ¾ili novÃ½ prvek!</p>
<pre><code>[5, 4, ?, ?]
       ^
       (pocet = 2)

[5, 4, 8, ?]
          ^
          (pocet = 3)
</code></pre>
<p>V kÃ³du by to mohlo vypadat takto:</p>
<pre><code class="language-c">void poleintu_pridej(PoleIntu* pole, int hodnota) {
    // Zapiseme novy prvek na index dany soucasnemu poctu prvku
    pole-&gt;data[pole-&gt;pocet] = hodnota;
    // Zvysime pocet prvku o jednicku
    pole-&gt;pocet += 1;
}
</code></pre>
<h3><a class="header" href="#zvÄ›tÅ¡enÃ­-velikosti-pole" id="zvÄ›tÅ¡enÃ­-velikosti-pole">ZvÄ›tÅ¡enÃ­ velikosti pole</a></h3>
<p>NicmÃ©nÄ› to samo o sobÄ› nestaÄÃ­. Co kdyÅ¾ je totiÅ¾ pole uÅ¾ plnÃ©? V tom pÅ™Ã­padÄ› nesmÃ­me zapsat hodnotu
do pamÄ›ti na indexu <code>pocet</code>, protoÅ¾e bychom zapsali data mimo validnÃ­ pamÄ›Å¥ a doÅ¡lo by tak k
<a href="ruzne/../caste_chyby/pametove_chyby.html#segmentation-fault">pamÄ›Å¥ovÃ© chybÄ›</a> ğŸ’£!</p>
<p>Pokud tedy dojde k situaci, Å¾e uÅ¾ je naÅ¡e pole plnÃ©, tak jej nejprve musÃ­me zvÄ›tÅ¡it. To mÅ¯Å¾eme udÄ›lat
nÃ¡sledujÃ­cÃ­m postupem:</p>
<ol>
<li>Naalokujeme novÃ©, vÄ›tÅ¡Ã­ pole na haldÄ›.
<ul>
<li>Jakou velikost (kapacitu) zvolit pro novÃ© pole? Pokud bychom zvyÅ¡ovali velikost o <code>1</code>, tak budeme
muset pole zvÄ›tÅ¡ovat pÅ™i pÅ™idÃ¡nÃ­ kaÅ¾dÃ©ho prvku, coÅ¾ by bylo velmi neefektivnÃ­. Obvykle se kapacita
rostoucÃ­ch polÃ­ zdvojnÃ¡sobÃ­, dÃ­ky ÄehoÅ¾ bude velikost rÅ¯st exponenciÃ¡lnÄ› a my tak nebudeme muset
Äasto velikost zvÄ›tÅ¡ovat.</li>
</ul>
</li>
<li>PÅ™ekopÃ­rujeme pÅ¯vodnÃ­ data ze starÃ©ho pole do novÃ©ho pole.</li>
<li>UvolnÃ­me pamÄ›Å¥ starÃ©ho pole.</li>
<li>NastavÃ­me ukazatel (<code>data</code>) na novÃ© pole na haldÄ›.</li>
</ol>
<p>V kÃ³du by to mohlo vypadat napÅ™. takto:</p>
<pre><code class="language-c">// Pokud je pole plne
if (pole-&gt;pocet == pole-&gt;kapacita) {
    // Zdvojnasobime kapacitu
    pole-&gt;kapacita = pole-&gt;kapacita * 2;
    // Naalokujeme nove pole s dvojnasobnou kapacitou
    int* nove_pole = (int*) malloc(sizeof(int) * pole-&gt;kapacita);
    // Prekopirujeme hodnoty ze stareho pole do noveho
    for (int i = 0; i &lt; pole-&gt;pocet; i++) {
        nove_pole[i] = pole-&gt;data[i];
    }
    // Uvolnime pamet stareho pole
    free(pole-&gt;data);
    // Nastavime ukazatel na nove pole
    pole-&gt;data = nove_pole;
}
</code></pre>
<p>JelikoÅ¾ je tato funkcionalita v jazyce <em>C</em> relativnÄ› Äasto pouÅ¾Ã­vanÃ¡, standardnÃ­ knihovna <em>C</em> obsahuje
funkci <a href="https://devdocs.io/c/memory/realloc"><code>realloc</code></a>, kterÃ¡ toto zvÄ›tÅ¡enÃ­ pole umÃ­ udÄ›lat za nÃ¡s.
KÃ³d vÃ½Å¡e tak lze zjednoduÅ¡it:</p>
<pre><code class="language-c">if (pole-&gt;pocet == pole-&gt;kapacita) {
    pole-&gt;kapacita = pole-&gt;kapacita * 2;
    pole-&gt;data = (int*) realloc(pole-&gt;data, sizeof(int) * pole-&gt;kapacita);
}
</code></pre>
<p>KompletnÃ­ kÃ³d funkce na pÅ™idÃ¡nÃ­ prvku do rostoucÃ­ho pole naleznete nÃ­Å¾e. </p>
<h3><a class="header" href="#smazÃ¡nÃ­-pole" id="smazÃ¡nÃ­-pole">SmazÃ¡nÃ­ pole</a></h3>
<p>NesmÃ­me samozÅ™ejmÄ› zapomenout ani na to po sobÄ› uklidit. Po skonÄenÃ­ prÃ¡ce s polem bychom tedy mÄ›li
jeho pamÄ›Å¥ smazat:</p>
<pre><code class="language-c">void poleintu_smaz(PoleIntu* pole) {
    free(pole-&gt;data);
}
</code></pre>
<p>CelÃ½ kÃ³d dynamicky rostoucÃ­ho pole <code>int</code>Å¯ mÅ¯Å¾ete naleznout zde:</p>
<details>
<summary>Dynamicky rostoucÃ­ pole intÅ¯</summary>
<pre><code class="language-c">typedef struct {
    // Ukazatel na data na haldÄ›
    int* data;
    // Soucasny pocet prvku v poli
    int pocet;
    // Pocet prvku, ktery lze v poli maximalne mit.
    // Maximalni hodnota, ktere muze nabyvat `pocet`.
    int kapacita;
} PoleIntu;

void poleintu_vytvor(PoleIntu* pole, int kapacita) {
    // Naalokujeme pamet na halde
    pole-&gt;data = (int*) malloc(sizeof(int) * kapacita);
    // Na zacatku je pole prazdne, takze je pocet prvku 0
    pole-&gt;pocet = 0;
    // Kapacita odpovida tomu, kolik je pole schopne udrzet prvku, nez mu dojde misto
    pole-&gt;kapacita = kapacita;
}

void poleintu_pridej(PoleIntu* pole, int hodnota) {
    // Pokud je pole plne
    if (pole-&gt;pocet == pole-&gt;kapacita) {
        // Zdvojnasobime kapacitu
        pole-&gt;kapacita = pole-&gt;kapacita * 2;
        // Naalokujeme nove pole s dvojnasobnou kapacitou a nastavime ukazatel na nove pole
        pole-&gt;data = (int*) realloc(pole-&gt;data, sizeof(int) * pole-&gt;kapacita);
    }

    // Zapiseme novy prvek na index dany soucasnemu poctu prvku
    pole-&gt;data[pole-&gt;pocet] = hodnota;
    // Zvysime pocet prvku o jednicku
    pole-&gt;pocet += 1;
}

void poleintu_smaz(PoleIntu* pole) {
    // Smazeme dynamicke pole
    free(pole-&gt;data);
}
</code></pre>
</details>
<h2><a class="header" href="#zobecnÄ›nÃ­-pro-vÃ­ce-datovÃ½ch-typÅ¯" id="zobecnÄ›nÃ­-pro-vÃ­ce-datovÃ½ch-typÅ¯">ZobecnÄ›nÃ­ pro vÃ­ce datovÃ½ch typÅ¯</a></h2>
<p>VÃ½Å¡e popsanÃ© pole je velmi uÅ¾iteÄnÃ©, nicmÃ©nÄ› mÅ¯Å¾eme jej pouÅ¾Ã­t pouze s jednÃ­m datovÃ½m typem (<code>int</code>).
V naÅ¡ich programech si urÄitÄ› budeme chtÃ­t uklÃ¡dat do rostoucÃ­ho pole vÃ­ce datovÃ½ch typÅ¯. Jak toho
mÅ¯Å¾eme dosÃ¡hnout?</p>
<h3><a class="header" href="#separÃ¡tnÃ­-kÃ³d-pro-kaÅ¾dÃ½-datovÃ½-typ" id="separÃ¡tnÃ­-kÃ³d-pro-kaÅ¾dÃ½-datovÃ½-typ">SeparÃ¡tnÃ­ kÃ³d pro kaÅ¾dÃ½ datovÃ½ typ</a></h3>
<p>Asi nejjednoduÅ¡Å¡Ã­ zpÅ¯sob je prostÄ› vzÃ­t kÃ³d tohoto pole a zkopÃ­rovat jej pro kaÅ¾dÃ½ datovÃ½ typ, kterÃ½
budeme chtÃ­t do pole uklÃ¡dat. TakÅ¾e nÃ¡m vzniknou struktury <code>PoleIntu</code>, <code>PoleCharu</code>, <code>PoleBoolu</code> atd.</p>
<p>I kdyÅ¾ je tento zpÅ¯sob relativnÄ› jednoduchÃ½ na provedenÃ­ (<code>Ctrl + C</code>, <code>Ctrl + V</code> a pÅ™ejmenovÃ¡nÃ­ nÃ¡zvÅ¯),
tak asi tuÅ¡Ã­te, Å¾e mÃ¡ Å™adu nevÃ½hod. V naÅ¡em programu by vznikla spousta kÃ³du, kterÃ½ by byl silnÄ›
zduplikovanÃ½ a pokud bychom narazili na nÄ›jakou chybu, tak bychom ji museli opravit na vÃ­ce mÃ­stech.
Tento opakujÃ­cÃ­ se kÃ³d by takÃ© pravdÄ›podobnÄ› byl dost nepÅ™ehlednÃ½.</p>
<p>MÅ¯Å¾eme si trochu pomoct vyuÅ¾itÃ­m <a href="ruzne/../c/preprocesor/makra.html">maker</a>:</p>
<pre><code class="language-c">#define VYTVOR_LIST(nazev, typ)\
typedef struct {\
   typ* data;\
   int pocet;\
   int kapacita;\
} nazev;

VYTVOR_LIST(PoleIntu, int)
VYTVOR_LIST(PoleFloatu, float)
</code></pre>
<p>NicmÃ©nÄ› to mÃ¡ takÃ© svÃ© nevÃ½hody (upravovat kÃ³d makra je relativnÄ› namÃ¡havÃ©) a poÅ™Ã¡d budeme mÃ­t separÃ¡tnÃ­
datovou strukturu pro kaÅ¾dÃ½ datovÃ½ typ.</p>
<h3><a class="header" href="#pole-ukazatelÅ¯" id="pole-ukazatelÅ¯">Pole ukazatelÅ¯</a></h3>
<p>Pokud se zamyslÃ­me nad tÃ­m, proÄ nemÅ¯Å¾eme pouÅ¾Ã­t <code>PoleIntu</code> pro libovolnÃ½ datovÃ½ typ, je to zpÅ¯sobeno
tÃ­m, Å¾e kaÅ¾dÃ½ prvek v tomto poli mÃ¡ fixnÃ­ velikost (<code>sizeof(int)</code>, tedy pravdÄ›podobnÄ› <code>4</code> byty). Do
tohoto pole tedy nemÅ¯Å¾eme jednoduÅ¡e uklÃ¡dat prvky, kterÃ© majÃ­ jinou velikost, coÅ¾ je problÃ©m.</p>
<p>Abychom tento problÃ©m obeÅ¡li, mÅ¯Å¾eme vytvoÅ™it pole, jehoÅ¾ prvky budou mÃ­t takÃ© fixnÃ­ velikost, ale
zÃ¡roveÅˆ budou schopny poskytovat pÅ™Ã­stup k libovolnÃ© hodnotÄ› libovolnÃ©ho datovÃ©ho typu. Toho mÅ¯Å¾eme
dosÃ¡hnout tak, Å¾e do pole nebudeme uklÃ¡dat pÅ™Ã­mo hodnoty, kterÃ© si chceme zapamatovat, ale pouze jejich
adresy. VytvoÅ™Ã­me tedy pole ukazatelÅ¯! JelikoÅ¾ nevÃ­me, s jakÃ½m datovÃ½m typem bude chtÃ­t uÅ¾ivatel toto
pole pouÅ¾Ã­t, tak nezvolÃ­me pro typ ukazatele <code>int*</code> nebo napÅ™. <code>float*</code>, ale pouÅ¾ijeme datovÃ½ typ
&quot;obecnÃ©ho&quot; ukazatele, kterÃ½ prostÄ› obsahuje adresu, ale neÅ™Ã­kÃ¡, co na danÃ© adrese leÅ¾Ã­. TÃ­m je typ
<code>void*</code>.</p>
<p>Strukturu pole bychom tedy mohli upravit takto:</p>
<pre><code class="language-c">typedef struct {
    void** data;
    int pocet;
    int kapacita;
} RostouciPole;
</code></pre>
<p>PÅ™edtÃ­m jsme uchovÃ¡vali ukazatel, v nÄ›mÅ¾ byla adresa, na kterÃ© leÅ¾el datovÃ½ typ <code>int</code>, proto byl typ
atributu <code>data</code> <code>int*</code>. NynÃ­ uchovÃ¡vÃ¡me ukazatel, v nÄ›mÅ¾ bude adrese, na kterÃ© bude leÅ¾et datovÃ½ typ
<code>void*</code>, proto bude typ atributu <code>data</code> <code>void**</code>.</p>
<p>V pamÄ›ti bude tedy pole vypadat cca takto:</p>
<pre><code>// Predtim
[5, 8, 6, 4]

// Ted
 5
 ^   6
 |   ^
[|,|,|,|]
   |   |
   |   v
   |   4
   |
   â•°-&gt; 8
</code></pre>
<p>KaÅ¾dÃ½ prvek pole bude mÃ­t fixnÃ­ velikost (<code>sizeof(void*)</code>, tedy pravdÄ›podobnÄ› <code>8</code> bytÅ¯), a bude obsahovat
pouze adresu nÄ›jakÃ©ho prvku (libovolnÃ©ho datovÃ©ho typu).</p>
<p>KdyÅ¾ si tedy pole pamatuje adresy, odkud je vzÃ­t? Pokud bychom do pole dÃ¡vali adresy napÅ™. lokÃ¡lnÃ­ch
promÄ›nnÃ½ch, tak pravdÄ›podobnÄ› brzy narazÃ­me na problÃ©my:</p>
<pre><code class="language-c">RostouciPole pole;
pole_vytvor(&amp;pole, 10);
for (int i = 0; i &lt; 10; i++) {
    // Vloz do pole adresu promenne i
    pole_pridej(&amp;pole, &amp;i);
}
</code></pre>
<ol>
<li>LokÃ¡lnÃ­ promÄ›nnÃ¡ mÅ¯Å¾e zaniknout dÅ™Ã­ve, neÅ¾ pole. V ten moment bude adresa v poli neplatnÃ¡ a dojde
k <a href="ruzne/nedefinovane_chovani.html">nedefinovanÃ©mu chovÃ¡nÃ­</a> ğŸ’£.</li>
<li>V pÅ™Ã­padÄ› vÃ½Å¡e si uklÃ¡dÃ¡me do pole adresu tÃ© stejnÃ© promÄ›nnÃ©, takÅ¾e vÅ¡echny prvky v poli budou mÃ­t
stejnou hodnotu.</li>
<li>I pokud lokÃ¡lnÃ­ promÄ›nnÃ¡ bude existovat dostateÄnÄ› dlouho, a budeme do pole uklÃ¡dat adresy rÅ¯znÃ½ch
promÄ›nnÃ½ch, tak poÅ™Ã¡d budeme mÃ­t problÃ©m v tom, Å¾e si budeme muset tuto promÄ›nnou uklÃ¡dat &quot;nÄ›kde bokem&quot;,
protoÅ¾e v poli bude pouze jejÃ­ adresa. TÃ­m nevyÅ™eÅ¡Ã­me nÃ¡Å¡ pÅ¯vodnÃ­ problÃ©m s pole rostoucÃ­ velikosti,
pouze jej pÅ™esuneme jinam.</li>
</ol>
<p>Z toho dÅ¯vodu se nÃ¡m vyplatÃ­ uklÃ¡dat do pole takovÃ© adresy, jejichÅ¾ Å¾ivotnost bude neomezenÃ¡, a nebudeme
se tak muset starat o to, jestli nÃ¡hodou nejsou dealokovÃ¡ny moc brzy. Jinak Å™eÄeno, mÅ¯Å¾eme do pole
uklÃ¡dat pamÄ›Å¥ alokovanou na <a href="ruzne/../c/prace_s_pameti/dynamicka_pamet.html">haldÄ›</a>.</p>
<p>TakovÃ©to pole by pak Å¡lo pouÅ¾Ã­vat napÅ™. takto:</p>
<pre><code class="language-c">RostouciPole pole;
pole_vytvor(&amp;pole, 10);

for (int i = 0; i &lt; 10; i++) {
    int* pamet = malloc(sizeof(int));
    *pamet = i + 1;
    pole_pridej(&amp;pole, pamet);
}

for (int i = 0; i &lt; 10; i++) {
    int* pamet = (int*) pole-&gt;data[i];
    printf(&quot;Prvek cislo %d: %d\n&quot;, i, *pamet);
}

pole_smaz(pole);
</code></pre>
<p>PÅ™i mazÃ¡nÃ­ pole bychom nemÄ›li zapomenout na uvolnÄ›nÃ­ vÅ¡ech adres, kterÃ© jsou v nÄ›m uloÅ¾eny:</p>
<pre><code class="language-c">void pole_smaz(RostouciPole* pole) {
    for (int i = 0; i &lt; pole-&gt;pocet; i++) {
        free(pole-&gt;data[i]);
    }
    free(pole-&gt;data);
}
</code></pre>
<blockquote>
<p>V souÄasnÃ© podobÄ› lze funkci <code>pole_vloz</code> Å¡patnÄ› pouÅ¾Ã­t. Pokud do nÃ­ dÃ¡me adresu, kterÃ¡ nepochÃ¡zÃ­
z funkce <code>malloc</code>, tak dojde k nedefinovanÃ©mu chovÃ¡nÃ­ pÅ™i mazÃ¡nÃ­ pole. Zkuste navrhnout jinou verzi
funkce <code>pole_vloz</code>, kterÃ¡ nepÅ¯jde pouÅ¾Ã­t Å¡patnÄ›, a kterÃ¡ zajistÃ­, Å¾e pamÄ›Å¥ bude vÅ¾dy vytvoÅ™ena na
haldÄ›. MÅ¯Å¾ete (musÃ­te!) pro to zmÄ›nit signaturu funkce.</p>
</blockquote>
<h4><a class="header" href="#typovÃ¡-kontrola" id="typovÃ¡-kontrola">TypovÃ¡ kontrola</a></h4>
<p>U obecnÃ©ho rostoucÃ­ho pole je tÅ™eba dÃ¡vat si velkÃ½ pozor na to, Å¾e do nÄ›j budeme vklÃ¡dat a potÃ© z nÄ›j
vybÃ­rat stejnÃ© datovÃ© typy! TÃ­m, Å¾e pouÅ¾Ã­vÃ¡me typ <code>void*</code>, tak nÃ¡s pÅ™ekladaÄ nebude upozorÅˆovat na
prÃ¡ci s nekompatibilnÃ­mi datovÃ½mi typy. Pokud do pole nejprve vloÅ¾Ã­te adresu <code>int</code>u, a potÃ© se k tÃ©to
adrese budete chovat, jako by to byla adresa napÅ™. <code>float</code>u (<code>float*</code>), tak se vÃ¡Å¡ program nebude
chovat sprÃ¡vnÄ›!</p>
<p>CelÃ½ kÃ³d dynamicky rostoucÃ­ho pole <code>int</code>Å¯ mÅ¯Å¾ete naleznout zde:</p>
<details>
<summary>Dynamicky rostoucÃ­ pole adres</summary>
<pre><code class="language-c">typedef struct {
    // Ukazatel na data na haldÄ›
    void** data;
    // Soucasny pocet prvku v poli
    int pocet;
    // Pocet prvku, ktery lze v poli maximalne mit.
    // Maximalni hodnota, ktere muze nabyvat `pocet`.
    int kapacita;
} RostouciPole;

void pole_vytvor(RostouciPole* pole, int kapacita) {
    // Naalokujeme pamet na halde
    pole-&gt;data = (void**) malloc(sizeof(void*) * kapacita);
    // Na zacatku je pole prazdne, takze je pocet prvku 0
    pole-&gt;pocet = 0;
    // Kapacita odpovida tomu, kolik je pole schopne udrzet prvku, nez mu dojde misto
    pole-&gt;kapacita = kapacita;
}

void pole_pridej(RostouciPole* pole, void* adresa) {
    // Pokud je pole plne
    if (pole-&gt;pocet == pole-&gt;kapacita) {
        // Zdvojnasobime kapacitu
        pole-&gt;kapacita = pole-&gt;kapacita * 2;
        // Naalokujeme nove pole s dvojnasobnou kapacitou a nastavime ukazatel na nove pole
        pole-&gt;data = (void**) realloc(pole-&gt;data, sizeof(void*) * pole-&gt;kapacita);
    }

    // Zapiseme novy prvek na index dany soucasnemu poctu prvku
    pole-&gt;data[pole-&gt;pocet] = adresa;
    // Zvysime pocet prvku o jednicku
    pole-&gt;pocet += 1;
}

void pole_smaz(RostouciPole* pole) {
    for (int i = 0; i &lt; pole-&gt;pocet; i++) {
        free(pole-&gt;data[i]);
    }
    free(pole-&gt;data);
}
</code></pre>
</details>
<h3><a class="header" href="#pole-bytÅ¯" id="pole-bytÅ¯">Pole bytÅ¯</a></h3>
<p>Pole ukazatelÅ¯ je relativnÄ› jednoduchÃ© na pouÅ¾itÃ­, ale mÃ¡ takÃ© nevÃ½hody, hlavnÄ› co se tÃ½Äe plÃ½tvÃ¡nÃ­
pamÄ›tÃ­, protoÅ¾e musÃ­me vÅ¡echny hodnoty alokovat na haldÄ›, a takÃ© s tÃ­m souvisejÃ­cÃ­ neefektivitou.</p>
<p>RostoucÃ­ pole mÅ¯Å¾eme navrhnout jeÅ¡tÄ› jinak, pokud se k nÄ›mu budeme chovat v podstatÄ› jako k poli bytÅ¯,
do kterÃ½ch budeme byte po bytu kopÃ­rovat hodnoty, kterÃ© v nÄ›m chceme uklÃ¡dat. V tÃ©to variantÄ› bychom
si ve struktuÅ™e uklÃ¡dali pole bytÅ¯ (znakÅ¯), a takÃ© velikost datovÃ©ho typu, kterÃ½ chceme do pole uklÃ¡dat.</p>
<pre><code class="language-c">typedef struct {
    // Pole bytÅ¯/znakÅ¯
    char* data;
    // Velikost datovÃ©ho typu
    int velikost_prvku;
    int pocet;
    int kapacita;
} RostouciPole;
</code></pre>
<p>PÅ™i vklÃ¡dÃ¡nÃ­ novÃ©ho prvku pak staÄÃ­ jeho byty nakopÃ­rovat do naÅ¡eho pole, a pÅ™i zÃ­skÃ¡vÃ¡nÃ­ prvku zase
byty zpÄ›t vykopÃ­rovat na adresu, kterou poskytne uÅ¾ivatel:</p>
<pre><code class="language-c">void pole_pridej(RostouciPole* pole, void* adresa) {
    if (pole-&gt;pocet == pole-&gt;kapacita) { /* zvetseni pole */ }

    // Vypocteme cilovou adresu, kterÃ¡ bude na &quot;indexu&quot; `pocet` * `velikost_prvku`
    void* cil = pole-&gt;data + (pole-&gt;pocet * pole-&gt;velikost_prvku);
    // Zapiseme na danou adresu vsechny byty nasi vkladane hodnoty
    memcpy(cil, adresa, pole-&gt;velikost_prvku);
}

void pole_vrat(RostouciPole* pole, int index, void* adresa) {
    // Vypocteme cilovou adresu, kterÃ¡ bude na &quot;indexu&quot; `index` * `velikost_prvku`
    void* zdroj = pole-&gt;data + (indexu * pole-&gt;velikost_prvku);
    // Zapiseme na predanou adresu vsechny byty nasi ziskavane hodnoty
    memcpy(adresa, zdroj, pole-&gt;velikost_prvku);
}
</code></pre>
<p>Aby toto Å™eÅ¡enÃ­ bylo plnÄ› korektnÃ­, museli bychom implementaci jeÅ¡tÄ› rozÅ¡Ã­Å™it tak, aby brala v potaz
<a href="ruzne/../c/struktury/pametova_reprezentace.html#zarovn%C3%A1n%C3%AD">zarovnÃ¡nÃ­</a> danÃ©ho datovÃ©ho typu, jinak by se mohlo
stÃ¡t, Å¾e bude vloÅ¾enÃ¡ hodnota v poli leÅ¾et na nezarovnanÃ© adrese.</p>
<h1><a class="header" href="#funkce-main" id="funkce-main">Funkce <code>main</code></a></h1>
<p>Funkce <code>main</code> je speciÃ¡lnÃ­ funkce, kterÃ¡ se zaÄne vykonÃ¡vat pÅ™i spuÅ¡tÄ›nÃ­ programu. MÅ¯Å¾e vypadat
napÅ™Ã­klad takto:</p>
<pre><code class="language-c">int main() {
    return 0;
}
</code></pre>
<p>ProÄ tato funkce vracÃ­ ÄÃ­slo (<code>int</code>) a proÄ se obvykle z tÃ©to funkce vracÃ­ hodnota <code>0</code>? OperaÄnÃ­
systÃ©my majÃ­ zavedenou konvenci, Å¾e kaÅ¾dÃ½ spuÅ¡tÄ›nÃ½ program by mÄ›l po svÃ©m vykonÃ¡nÃ­ vrÃ¡tit ÄÃ­selnou
hodnotu, kterÃ¡ systÃ©mu napovÃ­, jestli program probÄ›hl ÃºspÄ›Å¡nÄ›, nebo ne. DÃ­ky tomu pak lze relativnÄ›
jednoduÅ¡e detekovat, jestli v programu nastala chyba, a pÅ™Ã­padnÄ› na ni nÄ›jak zareagovat (z Windows
moÅ¾nÃ¡ znÃ¡te dialog &quot;Program neprobÄ›hl sprÃ¡vnÄ›â€¦&quot;).</p>
<p>ÄŒÃ­slo, kterÃ© vrÃ¡tÃ­te z funkce <code>main</code>, se pouÅ¾ije prÃ¡vÄ› jako nÃ¡vratovÃ¡ hodnota programu pro operaÄnÃ­
systÃ©m. VÃ½znam navrÃ¡cenÃ½ch ÄÃ­sel nenÃ­ nijak standardizovÃ¡n, jedinÃ©, co platÃ­ obecnÄ›, je, Å¾e hodnota
<code>0</code> znaÄÃ­ ÃºspÄ›ch a jakÃ¡koliv jinÃ¡ hodnota znaÄÃ­ neÃºspÄ›ch. Proto tedy za normÃ¡lnÃ­ch okolnostÃ­ z
<code>main</code>u vracÃ­me <code>0</code>, abychom dali systÃ©mu najevo, Å¾e program probÄ›hl ÃºspÄ›Å¡nÄ›.</p>
<h3><a class="header" href="#vstupnÃ­-parametry-funkce-main" id="vstupnÃ­-parametry-funkce-main">VstupnÃ­ parametry funkce <code>main</code></a></h3>
<p>Funkce <code>main</code> je speciÃ¡lnÃ­ ve vÃ­ce ohledech. KromÄ› formy bez parametrÅ¯, kterou jste vidÄ›li vÃ½Å¡e,
mÅ¯Å¾ete <code>main</code> pouÅ¾Ã­t takÃ© takto, s dvÄ›ma parametry:</p>
<pre><code class="language-c">int main(int argc, char** argv) {
    return 0;
}
</code></pre>
<p>PrvnÃ­ parametr je typu <code>int</code> a druhÃ½ parametr typu <a href="ruzne/../c/prace_s_pameti/ukazatele.html">ukazatel</a> na
<a href="ruzne/../c/text/retezce.html">Å™etÄ›zec</a>. Do tÄ›chto parametrÅ¯ se uloÅ¾Ã­ hodnoty zadanÃ© pÅ™i spuÅ¡tÄ›nÃ­ programu v
terminÃ¡lu, tzv. <strong>argumenty pÅ™Ã­kazovÃ©ho Å™Ã¡dku</strong> (<em>command line arguments</em>). Parametr <code>argc</code>
(<em>argument count</em>) bude obsahovat poÄet pÅ™edanÃ½ch argumentÅ¯ a parametr <code>argv</code> obsahuje ukazatel na
prvnÃ­ prvek <a href="ruzne/../c/pole/pole.html">pole</a> <em>C</em> <a href="ruzne/../c/text/retezce.html">Å™etÄ›zcÅ¯</a>, kde kaÅ¾dÃ½ Å™etÄ›zec bude obsahovat
jeden argument. PrvnÃ­m argumentem je dle konvence vÅ¾dy cesta k spustitelnÃ©mu souboru programu,
kterÃ½ je prÃ¡vÄ› spouÅ¡tÄ›n, dalÅ¡Ã­ argumenty se nastavÃ­ podle zadanÃ©ho textu v terminÃ¡lu (argumenty
jsou oddÄ›lenÃ© mezerou).</p>
<p>NapÅ™Ã­klad, pokud program spustÃ­te takto: <code>./program hello world</code>, tak parametry funkce <code>main</code> budou
mÃ­t nÃ¡sledujÃ­cÃ­ hodnoty:</p>
<ul>
<li><code>argc</code> bude obsahovat celÃ© ÄÃ­slo <code>3</code> </li>
<li><code>argv[0]</code> bude obsahovat Å™etÄ›zec <code>&quot;./program&quot;</code></li>
<li><code>argv[1]</code> bude obsahovat Å™etÄ›zec <code>&quot;hello&quot;</code></li>
<li><code>argv[2]</code> bude obsahovat Å™etÄ›zec <code>&quot;world&quot;</code></li>
</ul>
<h1><a class="header" href="#parametry-pÅ™ekladaÄe" id="parametry-pÅ™ekladaÄe">Parametry pÅ™ekladaÄe</a></h1>
<p>PÅ™ekladaÄ <code>gcc</code> obsahuje sadu nÄ›kolika stovek parametrÅ¯, pomocÃ­ kterÃ½ch mÅ¯Å¾eme ovlivnit, jak pÅ™eklad
programu probÄ›hne. MÅ¯Å¾eme napÅ™Ã­klad urÄit, pro jakÃ½ procesor se majÃ­ vygenerovat instrukce, jakou
variantu jazyka <em>C</em> mÃ¡ pÅ™ekladaÄ oÄekÃ¡vat nebo jestli mÃ¡ nÃ¡Å¡ program zoptimalizovat, aby bÄ›Å¾el
rychleji.</p>
<blockquote>
<p>KromÄ› <code>gcc</code> existuje Å™ada dalÅ¡Ã­ch pÅ™ekladaÄÅ¯ <em>C</em>, napÅ™Ã­klad <a href="https://clang.llvm.org/"><code>clang</code></a>.
NejÄastÄ›jÅ¡Ã­ parametry (jako je napÅ™. <code>-O</code>) obvykle fungujÃ­ ve vÅ¡ech pÅ™ekladaÄÃ­ch obdobnÄ›, kaÅ¾dÃ½
pÅ™ekladaÄ ale obsahuje sadu specifickÃ½ch parametrÅ¯, kterÃ© mÅ¯Å¾ete naleznout v jeho
<a href="https://clang.llvm.org/docs/ClangCommandLineReference.html">dokumentaci</a>.</p>
</blockquote>
<p>Seznam vÅ¡ech parametrÅ¯ mÅ¯Å¾ete naleznout v
<a href="https://gcc.gnu.org/onlinedocs/gcc/Invoking-GCC.html">dokumentaci <code>gcc</code></a>, zde je uveden seznam
nejuÅ¾iteÄnÄ›jÅ¡Ã­ch parametrÅ¯:</p>
<ul>
<li>
<p><strong>Optimalizace</strong>: Existuje spousta parametrÅ¯, pomocÃ­ kterÃ½ch mÅ¯Å¾ete ovlivnit, jak pÅ™ekladaÄ pÅ™evede
vÃ¡Å¡ zdrojovÃ½ kÃ³d na strojovÃ© instrukce a jak je zoptimalizuje. NejzÃ¡kladnÄ›jÅ¡Ã­m parametrem je <code>-O</code>:</p>
<ul>
<li><code>-O0</code> Nebudou pouÅ¾ity tÃ©mÄ›Å™ Å¾Ã¡dnÃ© optimalizace. Toto je implicitnÃ­ nastavenÃ­,
pokud ho nezmÄ›nÃ­te. Program v tomto stavu lze dobÅ™e <a href="ruzne/../prostredi/ladeni.html#krokov%C3%A1n%C3%AD">krokovat</a>,
ale mÅ¯Å¾e bÃ½t dost pomalÃ½.</li>
<li><code>-O1</code> Aplikuje zÃ¡kladnÃ­ optimalizace.</li>
<li><code>-O2</code> Aplikuje nejuÅ¾iteÄnÄ›jÅ¡Ã­ optimalizace. Pokud chcete zÃ­skat rozumnÄ› rychlÃ½ program,
doporuÄujeme pouÅ¾Ã­t tento mÃ³d. DÃ­ky nÄ›mu mÅ¯Å¾e bÃ½t program tÅ™eba aÅ¾ 1000x rychlejÅ¡Ã­ neÅ¾ s <code>-O0</code>.<sup class='margin-toggle sidenote-number'>1</sup><span class='sidenote'><p><sup class='number'>1</sup>Anebo nemusÃ­ bÃ½t rychlejÅ¡Ã­ vÅ¯bec, zÃ¡leÅ¾Ã­ na programu.</p>
</span></li>
<li><code>-O3</code> Aplikuje jeÅ¡tÄ› vÃ­ce optimalizacÃ­. Program tak mÅ¯Å¾e bÃ½t jeÅ¡tÄ› rychlejÅ¡Ã­ neÅ¾ s <code>-O2</code>.
ObecnÄ› pÅ™i pouÅ¾itÃ­ optimalizacÃ­ vÅ¡ak platÃ­, Å¾e ÄÃ­m vyÅ¡Å¡Ã­ optimalizaÄnÃ­ stupeÅˆ, tÃ­m vÃ­ce hrozÃ­,
Å¾e se vÃ¡Å¡ program pÅ™estane chovat sprÃ¡vnÄ›, pokud program obsahuje jakÃ©koliv
<a href="ruzne/../c/promenne/promenne.html#v%C5%BEdy-inicializujte-prom%C4%9Bnn%C3%A9">nedefinovanÃ© chovÃ¡nÃ­</a>. Je tak tÅ™eba dÃ¡vat
pozor na to, aby k tomu nedoÅ¡lo.</li>
</ul>
<p>KromÄ› parametru <code>-O</code> lze pouÅ¾Ã­t spousty dalÅ¡Ã­ch parametrÅ¯, kterÃ© ovlivÅˆujÃ­ napÅ™Ã­klad pouÅ¾itÃ­
<a href="ruzne/../c/co_dal.html">vektorovÃ½ch instrukcÃ­</a>.</p>
</li>
<li>
<p><strong>LadÄ›nÃ­ programu</strong>:
Jak uÅ¾ jste jistÄ› poznali, pÅ™i pouÅ¾itÃ­ jazyka <em>C</em> je velmi jednoduchÃ© zpÅ¯sobit nÄ›jakÃ© nedefinovanÃ©
chovÃ¡nÃ­, napÅ™Ã­klad nÄ›jakou <a href="ruzne/../caste_chyby/pametove_chyby.html">pamÄ›Å¥ovou chybou</a>. Aby Å¡lo tyto
chyby detekovat, obsahujÃ­ pÅ™ekladaÄe tzv. <em>sanitizery</em>. PÅ™i pouÅ¾itÃ­ sanitizeru se do vaÅ¡eho
programu pÅ™idajÃ­ dodateÄnÃ© instrukce, kterÃ© potÃ© pÅ™i bÄ›hu programu kontrolujÃ­, jestli nedochÃ¡zÃ­
k nÄ›jakÃ©mu problÃ©mu. Cenou za tuto kontrolu je pomalejÅ¡Ã­ bÄ›h programu (cca 2-5x). Sanitizery tak
radÄ›ji pouÅ¾Ã­vejte pouze pÅ™i vÃ½voji programu.</p>
<p>Existuje vÃ­ce <a href="https://gcc.gnu.org/onlinedocs/gcc/Instrumentation-Options.html">typÅ¯ sanitizerÅ¯</a>,
my si ukÃ¡Å¾eme dva:</p>
<ul>
<li><code>-fsanitize=address</code> PouÅ¾ije tzv. <em>Address Sanitizer</em>, kterÃ½ hlÃ­dÃ¡ pamÄ›Å¥ovÃ© chyby, napÅ™Ã­klad
pÅ™Ã­stup k nevalidnÃ­ pamÄ›ti nebo neuvolnÄ›nÃ­ <a href="ruzne/../c/prace_s_pameti/dynamicka_pamet.html">dynamickÃ© pamÄ›ti</a>.
Tento sanitizer je nesmÃ­rnÄ› uÅ¾iteÄnÃ½ a doporuÄujeme ho vÅ¾dy pouÅ¾Ã­vat pÅ™i vÃ½voji programÅ¯ v <em>C</em>.</li>
<li><code>-fsanitize=undefined</code> PouÅ¾ije tzv. <em>Undefined behaviour sanitizer</em>, kterÃ½ hlÃ­dÃ¡ dodateÄnÃ©
situace, pÅ™i kterÃ½ch mÅ¯Å¾e dojÃ­t k nedefinovanÃ©mu chovÃ¡nÃ­ (kromÄ› pamÄ›Å¥ovÃ½ch chyb).</li>
</ul>
<p>ObecnÄ› pÅ™i ladÄ›nÃ­ programu je taky vhodnÃ© vÅ¾dy pouÅ¾Ã­t pÅ™epÃ­naÄ <code>-g</code>. Ten zpÅ¯sobÃ­, Å¾e pÅ™ekladaÄ
pÅ™idÃ¡ do vÃ½slednÃ©ho spustitelnÃ©ho souboru informace o zdrojovÃ©m kÃ³du (ty jinak ve spustitelnÃ©m
souboru chybÃ­). DÃ­ky tomu budou sanitizery schopny zobrazit konkrÃ©tnÃ­ Å™Ã¡dek, na kterÃ©m vznikl
nÄ›jakÃ½ problÃ©m a takÃ© pÅ¯jde program ladit a krokovat. </p>
</li>
<li>
<p><strong>AnalÃ½za kÃ³du</strong>: KromÄ› sanitizerÅ¯, kterÃ© kontrolujÃ­ vÃ¡Å¡ program za bÄ›hu, lze takÃ© spoustu chyb
odhalit jiÅ¾ pÅ™i pÅ™ekladu programu. BohuÅ¾el pÅ™ekladaÄ <code>gcc</code> v implicitnÃ­m mÃ³du nenÃ­ moc striktnÃ­ a
nÄ›kterÃ© vyloÅ¾enÄ› chybnÃ© situace vÃ¡m promine a program pÅ™eloÅ¾Ã­, i kdyÅ¾ je jiÅ¾ dopÅ™edu jasnÃ©, Å¾e pÅ™i
bÄ›hu pak dojde napÅ™. k pÃ¡du programu. Abychom tomu pÅ™edeÅ¡li, mÅ¯Å¾eme zapnout pÅ™i pÅ™ekladu dodateÄnÃ¡
<strong>varovÃ¡nÃ­</strong> (<em>warnings</em>), kterÃ¡ nÃ¡s mohou na potenciÃ¡lnÄ› problematickÃ© situace upozornit:</p>
<ul>
<li><code>-Wall</code> Zapne sadu nÄ›kolika desÃ­tek zÃ¡kladnÃ­ch varovÃ¡nÃ­.</li>
<li><code>-Wextra</code> Zapne dodateÄnou sadu varovÃ¡nÃ­.</li>
<li><code>-Wconversion</code> Zapne detekci situacÃ­, kdy implicitnÃ­ konverze mezi rÅ¯znÃ½mi datovÃ½mi typy
mÅ¯Å¾e zpÅ¯sobit neÅ¾Ã¡doucÃ­ nebo neoÄekÃ¡vanÃ© chovÃ¡nÃ­. Pokud je chovÃ¡nÃ­ detekovanÃ© touto analÃ½zou
Å¾Ã¡doucÃ­, je tÅ™eba provÃ©st explicitnÃ­ pÅ™etypovÃ¡nÃ­.</li>
<li><code>-pedantic</code> Zapne striktnÃ­ kontrolu toho, Å¾e dodrÅ¾ujete pÅ™edepsanÃ½ standard <em>C</em>. V kombinaci
s tÃ­mto pÅ™epÃ­naÄem byste takÃ© mÄ›li explicitnÄ› Å™Ã­ct, kterÃ½ standard chcete pouÅ¾Ã­t. V UPR pouÅ¾Ã­vÃ¡me
standard <em>C99</em>, kterÃ½ lze zadat pomocÃ­ <code>-std=c99</code>.</li>
<li><code>-Werror</code> ZpÅ¯sobÃ­, Å¾e libovolnÃ© varovÃ¡nÃ­ bude vnÃ­mÃ¡no jako chyba. Pokud tak
v programu <code>gcc</code> nalezne jakoukoliv situaci, kterÃ¡ vytvoÅ™Ã­ varovÃ¡nÃ­, program se nepÅ™eloÅ¾Ã­.</li>
</ul>
<p>Pokud chcete mÃ­t pÅ™i pÅ™ekladu co nejvÄ›tÅ¡Ã­ zpÄ›tnou vazbu od pÅ™ekladaÄe a zajistit co nejvÄ›tÅ¡Ã­
&quot;bezpeÄnost&quot; vaÅ¡eho programu, doporuÄujeme pouÅ¾Ã­vat tuto kombinaci pÅ™epÃ­naÄÅ¯:</p>
<pre><code class="language-bash">$ gcc -g -fsanitize=address -Wall -Wextra -Wconversion -pedantic -std=c99
</code></pre>
</li>
</ul>
<h1><a class="header" href="#nedefinovanÃ©-chovÃ¡nÃ­" id="nedefinovanÃ©-chovÃ¡nÃ­">NedefinovanÃ© chovÃ¡nÃ­</a></h1>
<p>V tÄ›chto skriptech Äasto zmiÅˆujeme pojem <strong>nedefinovanÃ© chovÃ¡nÃ­</strong> ğŸ’£ (<em>undefined behaviour</em> neboli <em>UB</em>).
Tento mechanismus jazyka <em>C</em> je Äasto tÄ›Å¾ko uchopitelnÃ½, a nemusÃ­ bÃ½t jasnÃ©, proÄ jej vlastnÄ› tento jazyk obsahuje,
a jak velkÃ© nebezpeÄÃ­ pro korektnost programÅ¯ pÅ™edstavuje. Tato kapitola se pokusÃ­ situaci trochu vÃ­ce osvÄ›tlit.</p>
<blockquote>
<p>PÅ™Ã­klady v tÃ©to kapitole pÅ™edpoklÃ¡dajÃ­ znalost nÄ›kterÃ½ch konstrukcÃ­ <em>C</em>, kterÃ© jsou postupnÄ› vysvÄ›tlovÃ¡ny ve skriptech.
Pokud jste se k tÄ›mto konstrukcÃ­m jeÅ¡tÄ› nedostali a pÅ™Ã­kladÅ¯m nerozumÃ­te, tak se k nim vraÅ¥te pozdÄ›ji, aÅ¾ toho budete
znÃ¡t z <em>C</em> vÃ­ce.</p>
</blockquote>
<p>Jazy <em>C</em> mÃ¡ svÅ¯j <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n1256.pdf">standard</a>, coÅ¾ je dokument, kterÃ½ definuje,
jakÃ¡ jsou pravidla programÅ¯ napsanÃ½ch v <em>C</em>, a jakÃ½m zpÅ¯sobem se musÃ­ chovat pÅ™ekladaÄe, aby <em>C</em> programy korektnÄ› pÅ™eloÅ¾ily.
Tento dokument popisuje napÅ™Ã­klad jakÃ© velikosti mÅ¯Å¾ou mÃ­t datovÃ© typy, jak mÃ¡ fungovat volÃ¡nÃ­ funkcÃ­ atd. ZÃ¡roveÅˆ ale
takÃ© popisuje Å™adu situacÃ­, kterÃ© jsou oznaÄeny jako <strong>nedefinovanÃ© chovÃ¡nÃ­</strong>, odkud pochÃ¡zÃ­ nÃ¡zev UB (undefined behaviour).
TÃ­m, Å¾e jsou tyto situace oznaÄeny jako nedefinovanÃ©, tak pÅ™ekladaÄe pÅ™i pÅ™ekladu programu mohou <strong>pÅ™edpoklÃ¡dat, Å¾e k nim
nikdy nedojde</strong>.</p>
<p>DÃ­ky tomuto pÅ™edpokladu jsou pÅ™ekladaÄe schopny lÃ©pe optimalizovat <em>C</em> programy, a generovat tak efektivnÄ›jÅ¡Ã­
strojovÃ½ kÃ³d<sup class='margin-toggle sidenote-number'>1</sup>. ZÃ¡roveÅˆ to ale znamenÃ¡, Å¾e pokud programÃ¡tor ve svÃ©m <em>C</em> programu takovouto nedefinovanou situaci vytvoÅ™Ã­,
tak budou poruÅ¡eny pÅ™edpoklady pÅ™ekladaÄe, coÅ¾ znamenÃ¡, Å¾e mÅ¯Å¾e dojÃ­t k tomu, Å¾e pÅ™ekladaÄ nÃ¡Å¡ <strong>program pÅ™eloÅ¾Ã­ Å¡patnÄ›</strong>.
Pokud tedy ve vaÅ¡em programu je situace zpÅ¯sobujÃ­cÃ­ UB, nemÃ¡ Å¾Ã¡dnÃ½ smysl bavit se o tom, co program dÄ›lÃ¡ nebo co by mohl dÄ›lat.
Program je prostÄ› Å¡patnÄ› z pohledu pravidel jazyka <em>C</em>, a pÅ™ekladaÄ z nÄ›j mÅ¯Å¾e vygenerovat program, kterÃ½ provÃ¡dÃ­ nÄ›co
naprosto nesmyslnÃ©ho (nebo neprovÃ¡dÃ­ vÅ¯bec nic). ProblematickÃ© chovÃ¡nÃ­ programÅ¯ zpÅ¯sobenÃ© UB se projevÃ­ zejmÃ©na, pokud
pÅ™eklÃ¡dÃ¡te program s <a href="ruzne/parametry_prekladace.html">optimalizacemi</a>, nicmÃ©nÄ› to neznamenÃ¡, Å¾e bez optimalizacÃ­ je UB neÅ¡kodnÃ©!</p>
<span class='sidenote'><p><sup class='number'>1</sup>Toto je takÃ© pÅ¯vodnÃ­ motivacÃ­, proÄ vÅ¯bec nÄ›co jako UB bylo vytvoÅ™eno - aby pÅ™ekladaÄe mohly generovat efektivnÄ›jÅ¡Ã­
kÃ³d, dÃ­ky tomu, Å¾e mÅ¯Å¾ou spolÃ©hat na vÃ­ce pÅ™edpokladÅ¯ o naÅ¡ich programech.</p>
</span>
<p>NÄ›kdy lze nedefinovanÃ© chovÃ¡nÃ­ detekovat jiÅ¾ pomocÃ­ statickÃ© analÃ½zy, kterou provÃ¡dÃ­ kompilÃ¡tor.
VelkÃ© mnoÅ¾stvÃ­ statickÃ© analÃ½zy, kterou kompilÃ¡tor dokÃ¡Å¾e provÃ©st, ovÅ¡em nenÃ­ implicitnÄ› zapnuto,
a musÃ­me je vynutit pÅ™i pÅ™ekladu pomocÃ­ <a href="ruzne/parametry_prekladace.html">parametrÅ¯ kompilÃ¡toru</a>.
PÅ™i kompilaci je vhodnÃ© vyuÅ¾Ã­vat alespoÅˆ parametry <code>-Wall -Wextra -Wconversion -Wuninitialized</code>.</p>
<p>Ne vÅ¡echny situace zpÅ¯sobujÃ­cÃ­ nedefinovanÃ© chovÃ¡nÃ­ je ovÅ¡em moÅ¾nÃ© zachytit statickou analÃ½zou.
MusÃ­te se tak spolehnout na to, Å¾e budete pozornÄ› zkoumat svÅ¯j kÃ³d, a pÅ™Ã­padnÄ› vyuÅ¾Ã­vat nÃ¡strojÅ¯,
jako je <a href="ruzne/../prostredi/ladeni.html#address-sanitizer">Address sanitizer</a>, Undefined behaviour
sanitizer nebo <a href="ruzne/../prostredi/ladeni.html#valgrind">Valgrind</a>, kterÃ© vÃ¡m mohou pomoci detekovat
nÃ¡sledky pÅ™Ã­tomnosti UB ve vaÅ¡ich programech za bÄ›hu programu.</p>
<h1><a class="header" href="#pÅ™Ã­klad" id="pÅ™Ã­klad">PÅ™Ã­klad</a></h1>
<p>Zde si ukÃ¡Å¾eme pÅ™Ã­klad UB zpÅ¯sobenÃ©ho pÅ™Ã­stupem mimo validnÃ­ pamÄ›Å¥ pole. Na tomto pÅ™Ã­kladu si mÅ¯Å¾eme ukÃ¡zat, Å¾e pÅ™Ã­tomnost
UB v naÅ¡em zdrojovÃ©m kÃ³du mÅ¯Å¾e zpÅ¯sobit kompletnÃ­ rozklad programu, a Å¾e nemÃ¡ smysl spekulovat nad tÃ­m, jak se program
obsahujÃ­cÃ­ UB bude nebo nebude chovat.</p>
<p>V tÃ©to funkci dochÃ¡zÃ­ k zjiÅ¡Å¥ovÃ¡nÃ­, jestli se pÅ™edanÃ½ argument nachÃ¡zÃ­ v poli ÄtyÅ™ ÄÃ­sel. V cyklu dochÃ¡zÃ­ k UB - naleznete
jej?</p>
<pre><code class="language-c">int je_cislo_v_poli(int v) {
    int table[4] = { 5, 13, 8, 12 };

    for (int i = 0; i &lt;= 4; i++) {
        if (table[i] == v) return 1;
    }
    return 0;
}
</code></pre>
<p>JednÃ¡ se o pÅ™Ã­stup mimo pole, protoÅ¾e podmÃ­nka for cyklu je <code>i &lt;= 4</code>, mÃ­sto <code>i &lt; 4</code>. Pokud uvidÃ­te takovÃ½to kÃ³d, mÅ¯Å¾e
vÃ¡s napadnout, Å¾e pÅ™i pÃ¡tÃ© iteraci cyklu dojde k pÅ™Ã­stupu mimo pamÄ›Å¥, moÅ¾nÃ¡ se vyvolÃ¡
<a href="ruzne/../caste_chyby/pametove_chyby.html#segmentation-fault">segmentation fault</a>, ale pokud je funkce zavolÃ¡na napÅ™. s argumentem
<code>5</code>, tak vlastnÄ› funkce probÄ›hne &quot;normÃ¡lnÄ›&quot;. NenÃ­ tomu tak! Tento program obsahuje UB, takÅ¾e jej pÅ™ekladaÄ mÅ¯Å¾e pÅ™eloÅ¾it,
jak se mu zachce.</p>
<p>NapÅ™Ã­klad mÅ¯Å¾e dojÃ­t k tomuto:</p>
<ol>
<li>PÅ™ekladaÄ vidÃ­, Å¾e <code>table[4]</code> je UB, tj. k tÃ©to situaci nikdy nemÅ¯Å¾e dojÃ­t.</li>
<li>TÃ­m pÃ¡dem <code>i</code> nikdy nemÅ¯Å¾e bÃ½t <code>4</code>.</li>
<li>Pokud <code>i</code> nikdy nemÅ¯Å¾e bÃ½t <code>4</code>, tak logicky nikdy nemÅ¯Å¾e bÃ½t ani <code>5</code> (protoÅ¾e jinak by pÅ™edtÃ­m muselo bÃ½t <code>i=4</code>).</li>
<li>JelikoÅ¾ <code>i</code> nemÅ¯Å¾e bÃ½t <code>5</code>, tak smyÄka je nekoneÄnÃ¡, a jedinÃ½ zpÅ¯sob, jak se mÅ¯Å¾e uvnitÅ™ smyÄky funkce ukonÄit, je
provedenÃ­m <code>return 1;</code>.</li>
<li>TÃ­m pÃ¡dem pÅ™ekladaÄ funkci pÅ™eloÅ¾Ã­ takto:
<pre><code class="language-c">int je_cislo_v_poli(int v) {
    return 1;
}
</code></pre>
</li>
</ol>
<p>ZdÃ¡ se vÃ¡m to moc divokÃ©? PÅ™esnÄ› toto <a href="https://godbolt.org/z/e8da3qYnx">udÄ›lÃ¡</a> pÅ™ekladaÄ GCC, pokud takovouto funkci
pÅ™eloÅ¾Ã­te s optimalizacemi.</p>
<p>NicmÃ©nÄ›, neznamenÃ¡ to, Å¾e se takto program musÃ­ zachovat vÅ¾dy. Kdybyste pouÅ¾ili jinÃ½ pÅ™ekladaÄ, jinou verzi stejnÃ©ho
pÅ™ekladaÄe, jinÃ© <a href="ruzne/parametry_prekladace.html">parametry pÅ™ekladu</a> nebo dokonce program prostÄ› spustili vÃ­cekrÃ¡t, pokaÅ¾dÃ©
by se mohlo stÃ¡t nÄ›co jinÃ©ho. <strong>NemÃ¡ cenu Å™eÅ¡it, jak se zachovÃ¡ program obsahujÃ­cÃ­ UB</strong>. MÃ­sto toho je nutnÃ© UB najÃ­t a
z kÃ³du odstranit :)</p>
<h1><a class="header" href="#kterÃ©-situace-vedou-k-ub" id="kterÃ©-situace-vedou-k-ub">KterÃ© situace vedou k UB?</a></h1>
<p>Neexistuje jednotnÃ½ seznam, kterÃ½ by vyjmenovÃ¡val vÅ¡echny moÅ¾nÃ© situace vedoucÃ­ k UB, nicmÃ©nÄ› zde je alespoÅˆ seznam bÄ›Å¾nÄ›
se vyskytujÃ­cÃ­ch problÃ©movÃ½ch situacÃ­:</p>
<ul>
<li><strong>DÄ›lenÃ­ nulou</strong></li>
<li><strong>ÄŒtenÃ­ neinicializovanÃ© pamÄ›ti</strong>
U tÃ©to situace si obÄas programÃ¡toÅ™i myslÃ­, Å¾e kdyÅ¾ budou napÅ™. ÄÃ­st z neinicializovanÃ© promÄ›nnÃ©, tak program prostÄ›
pÅ™eÄte nÄ›jakÃ¡ &quot;nÃ¡hodnÃ¡&quot; data, kterÃ¡ se zrovna vyskytujÃ­ v pamÄ›ti. To nenÃ­ pravda! ÄŒtenÃ­ neinicializovanÃ© pamÄ›ti je UB,
a tÃ­m pÃ¡dem program mÅ¯Å¾e udÄ›lat cokoliv. NapÅ™Ã­klad:
<pre><code class="language-c">int foo(int a) {
    int b;
    if (a == 5 || b == 6) {
        return 1;
    }
    return 2;
}
</code></pre>
Pokud tento program <a href="https://godbolt.org/z/G5E5Y16cb">pÅ™eloÅ¾Ã­te</a> s optimalizacemi, tak se celÃ¡ funkce mÅ¯Å¾e zredukovat
pouze na:
<pre><code class="language-c">int foo(int a) {
    return 1;
}
</code></pre>
Jak je to moÅ¾nÃ©? ÄŒtenÃ­ neinicializovanÃ© promÄ›nnÃ© je UB, takÅ¾e pÅ™ekladaÄ klidnÄ› mÅ¯Å¾e pÅ™edpoklÃ¡dat, Å¾e <code>b</code> bude vÅ¾dy <code>6</code>,
a tÃ­m pÃ¡dem bude z funkce vÅ¾dy vrÃ¡cena jedniÄka.</li>
<li><strong>ChybÄ›jÃ­cÃ­ <code>return</code> ve funkci, kterÃ¡ nevracÃ­ <code>void</code></strong>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int foo() {}
int bar() {
  printf(&quot;bar\n&quot;);
}
</code></pre>
Zde je UB, protoÅ¾e <code>foo</code> nevracÃ­ hodnotu typu <code>int</code>. KdyÅ¾ se podÃ­vÃ¡me, jak pÅ™ekladaÄ mÅ¯Å¾e tuto funkci
<a href="https://godbolt.org/z/aacGjqhzE">pÅ™eloÅ¾eit</a>, tak se napÅ™. mÅ¯Å¾e stÃ¡t to, Å¾e <code>foo</code> bude na stejnÃ© adrese jako <code>bar</code>,
takÅ¾e kdyby nÄ›kdo zavolal funkci <code>foo</code>, ve skuteÄnosti se zaÄne provÃ¡dÄ›t funkce <code>bar</code>!</li>
<li><strong>PÅ™eteÄenÃ­ celÃ©ho ÄÃ­sla se znamÃ©nkem</strong>
ÄŒÃ­sla se znamÃ©nkem (napÅ™. <code>int</code>) nesmÃ­ &quot;pÅ™etÃ©ct&quot;, tj. dostat se pÅ™es svou nejvyÅ¡Å¡Ã­ hodnotu. Tato situace je v jazyce <em>C</em>
UB.</li>
<li><strong>PÅ™Ã­stup mimo validnÃ­ pamÄ›Å¥</strong> PÅ™Ã­stup mimo validnÃ­ pamÄ›Å¥ (napÅ™. mimo rozsah pole) je klasickÃ½ pÅ™Ã­klad UB.</li>
<li><strong>Derefence NULL ukazatele</strong> Toto je opÄ›t klasickÃ½ pÅ™Ã­klad UB.</li>
<li><strong>VÃ­cenÃ¡sobnÃ© uvolnÄ›nÃ­ dynamickÃ© pamÄ›ti</strong> Viz <a href="http://localhost:3000/caste_chyby/pametove_chyby.html#segmentation-fault">Segmentation fault</a>.</li>
<li><strong>PÅ™Ã­stup k uvolnÄ›nÃ© dynamickÃ© pamÄ›ti</strong> Viz <a href="http://localhost:3000/caste_chyby/pametove_chyby.html#segmentation-fault">Segmentation fault</a>.</li>
</ul>
<h1><a class="header" href="#provedenÃ­-ub" id="provedenÃ­-ub">ProvedenÃ­ UB</a></h1>
<p>UB zpÅ¯sobuje problÃ©my &quot;pouze&quot;, pokud je kÃ³d obsahujÃ­cÃ­ UB opravdu proveden za bÄ›hu programu. PÅ™esnÄ›ji Å™eÄeno, pokud se
program kdykoliv dostane do stavu, Å¾e nÄ›kdy v budoucnu nutnÄ› musÃ­ dojÃ­t k provedenÃ­ UB (tj. napÅ™Ã­klad program je na Å™Ã¡dku
5, UB je na Å™Ã¡dku 8, ale mezi tÄ›mito Å™Ã¡dky nenÃ­ Å¾Ã¡dnÃ½ skok/podmÃ­nka/cyklus/nÄ›co, co by mohlo pÅ™eruÅ¡it chod programu), tak
v tento moment mÅ¯Å¾e UB zpÅ¯sobit problÃ©my.</p>
<p>NapÅ™Ã­klad, v tomto konkrÃ©tnÃ­m programu nenÃ­ chyba, protoÅ¾e UB (dÄ›lenÃ­ nulou) na Å™Ã¡dku 4 se nikdy neprovede.</p>
<pre><code class="language-c mainbody">int main() {
    int a = 5;
    if (a &gt; 6) {
        a / 0;
    }

    return 0;
}
</code></pre>
<p>Naproti tomu, v nÃ¡sledujÃ­cÃ­m programu mÅ¯Å¾e dojÃ­t k nesmyslnÃ©mu chovÃ¡nÃ­ (nevypÃ­Å¡e se nic na vÃ½stup, i kdyÅ¾ funkce dostane
nulu jako argument), i kdyÅ¾ samotnÃ© UB v ten moment vznikÃ¡ aÅ¾ na Å™Ã¡dku <code>5 / a</code>:</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int foo(int a) {
  if (a == 0) {
    printf(&quot;spatny vstup\n&quot;);
  }
  return 5 / a;
}
</code></pre>
<p>ProÄ? ProtoÅ¾e pÅ™ekladaÄ mÅ¯Å¾e pÅ™edpoklÃ¡dat, Å¾e k dÄ›lenÃ­ nulou nemÅ¯Å¾e nikdy dojÃ­t (protoÅ¾e dÄ›lenÃ­ nulou je UB). JelikoÅ¾
nemÅ¯Å¾eme dÄ›lit nulou, a ve funkci dochÃ¡zÃ­ k dÄ›lenÃ­ <code>a</code>, tak <code>a == 0</code> musÃ­ bÃ½t nutnÄ› <code>false</code>! TÃ­m pÃ¡dem k vÃ½pisu nikdy
nemusÃ­ dojÃ­t, ani kdyby do funkce byl zaslÃ¡n argument <code>0</code>.</p>
<p>VÃ­ce informacÃ­ o UB se mÅ¯Å¾ete dozvÄ›dÄ›t napÅ™. <a href="https://blog.llvm.org/2011/05/what-every-c-programmer-should-know.html">zde</a>.</p>
<h1><a class="header" href="#tahÃ¡k" id="tahÃ¡k">TahÃ¡k</a></h1>
<p>Tato strÃ¡nka obsahuje zkomprimovanÃ© informace o vÅ¡ech dÅ¯leÅ¾itÃ½ch syntaktickÃ½ch konstrukcÃ­ch jazyka <em>C</em>, kterÃ© budeme
v UPR pouÅ¾Ã­vat. ZejmÃ©na ze zaÄÃ¡tku mÅ¯Å¾e bÃ½t uÅ¾iteÄnÃ¡ pro to, abyste si mohli rychle pÅ™ipomenout, jak v <em>C</em> zapsat nÄ›jakÃ½
konkrÃ©tnÃ­ pÅ™Ã­kaz. PodobnÃ© tahÃ¡ky mÅ¯Å¾ete naleznout takÃ© tÅ™eba <a href="https://quickref.me/c.html">zde</a> nebo
<a href="https://cheatography.com/ashlyn-black/cheat-sheets/c-reference/">zde</a>.</p>
<h3><a class="header" href="#zÃ¡kladnÃ­-program-a-hrefruznecprikazy_vyrazyhtmlvc3bdpis-vc3bdrazc5afuÄivoa" id="zÃ¡kladnÃ­-program-a-hrefruznecprikazy_vyrazyhtmlvc3bdpis-vc3bdrazc5afuÄivoa">ZÃ¡kladnÃ­ program (<a href="ruzne/../c/prikazy_vyrazy.html#v%C3%BDpis-v%C3%BDraz%C5%AF">uÄivo</a>)</a></h3>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int main() {
  // Radkovy komentar
  /*
   * Blokovy komentar
   */
  printf(&quot;Hello world\n&quot;);
  return 0;
}
</code></pre>
<h3><a class="header" href="#pÅ™eklad-a-spuÅ¡tÄ›nÃ­-programu-a-hrefruzneprostredipreklad_programuhtmlpc599eklad-prvnc3adho-programuuÄivoa" id="pÅ™eklad-a-spuÅ¡tÄ›nÃ­-programu-a-hrefruzneprostredipreklad_programuhtmlpc599eklad-prvnc3adho-programuuÄivoa">PÅ™eklad a spuÅ¡tÄ›nÃ­ programu (<a href="ruzne/../prostredi/preklad_programu.html#p%C5%99eklad-prvn%C3%ADho-programu">uÄivo</a>)</a></h3>
<pre><code class="language-bash">$ gcc main.c -g -fsanitize=address -o main
$ ./main
</code></pre>
<h3><a class="header" href="#zÃ¡kladnÃ­-vÃ½pis-a-hrefruznecprikazy_vyrazyhtmlvc3bdpis-vc3bdrazc5afuÄivoa" id="zÃ¡kladnÃ­-vÃ½pis-a-hrefruznecprikazy_vyrazyhtmlvc3bdpis-vc3bdrazc5afuÄivoa">ZÃ¡kladnÃ­ vÃ½pis (<a href="ruzne/../c/prikazy_vyrazy.html#v%C3%BDpis-v%C3%BDraz%C5%AF">uÄivo</a>)</a></h3>
<ul>
<li>Textu
<pre><code class="language-c">printf(&quot;Ahoj UPR\n&quot;);
</code></pre>
</li>
<li>ÄŒÃ­selnÃ©ho vÃ½razu
<pre><code class="language-c">printf(&quot;Cislo: %d\n&quot;, &lt;vÃ½raz&gt;);
printf(&quot;Cislo: %d\n&quot;, 1 + 2);
</code></pre>
</li>
</ul>
<h3><a class="header" href="#promÄ›nnÃ©-a-hrefruznecpromennepromennehtmluÄivoa" id="promÄ›nnÃ©-a-hrefruznecpromennepromennehtmluÄivoa">PromÄ›nnÃ© (<a href="ruzne/../c/promenne/promenne.html">uÄivo</a>)</a></h3>
<ul>
<li>VytvoÅ™enÃ­: <code>&lt;datovÃ½ typ&gt; &lt;nÃ¡zev&gt; = &lt;ÃºvodnÃ­ vÃ½raz&gt;;</code>
<pre><code class="language-c">int vek = 18;
</code></pre>
<ul>
<li>UÅ¾iteÄnÃ© datovÃ© typy:
<ul>
<li><code>int</code>: celÃ© ÄÃ­slo se znamÃ©nkem</li>
<li><code>float</code>, <code>double</code>: desetinnÃ© ÄÃ­slo</li>
<li><code>char</code>: znak</li>
</ul>
</li>
</ul>
</li>
<li>ÄŒtenÃ­: <code>&lt;nÃ¡zev promÄ›nnÃ©&gt;</code>
<pre><code class="language-c">printf(&quot;%d\n&quot;, vek);
int x = vek + 1;
</code></pre>
</li>
<li>ZÃ¡pis: <code>&lt;nÃ¡zev promÄ›nnÃ©&gt; = vÃ½raz;</code>
<pre><code class="language-c">vek = 42;
</code></pre>
</li>
</ul>
<h3><a class="header" href="#vÃ½razy-a-hrefruznecdatove_typycelociselne_typyhtmltabulka-aritmetickc3bdch-operc3a1torc5afuÄivoa" id="vÃ½razy-a-hrefruznecdatove_typycelociselne_typyhtmltabulka-aritmetickc3bdch-operc3a1torc5afuÄivoa">VÃ½razy (<a href="ruzne/../c/datove_typy/celociselne_typy.html#tabulka-aritmetick%C3%BDch-oper%C3%A1tor%C5%AF">uÄivo</a>)</a></h3>
<ul>
<li>SÄÃ­tÃ¡nÃ­: <code>a + b</code></li>
<li>OdÄÃ­tÃ¡nÃ­: <code>a - b</code></li>
<li>NÃ¡sobenÃ­: <code>a * b</code></li>
<li>DÄ›lenÃ­: <code>a / b</code></li>
<li>Zbytek po dÄ›lenÃ­: <code>a % b</code></li>
<li>RovnÃ¡ se: <code>a == b</code></li>
<li>MenÅ¡Ã­ neÅ¾: <code>a &lt; b</code></li>
<li>MenÅ¡Ã­ nebo rovno neÅ¾: <code>a &lt;= b</code></li>
<li>VÄ›tÅ¡Ã­ neÅ¾: <code>a &gt; b</code></li>
<li>VÄ›tÅ¡Ã­  nebo rovno neÅ¾: <code>a &gt;= b</code></li>
<li>A zÃ¡roveÅˆ: <code>a &amp;&amp; b</code></li>
<li>Nebo: <code>a || b</code></li>
</ul>
<h3><a class="header" href="#podmÃ­nky-a-hrefruznecrizeni_tokupodminkyhtmlcisloa" id="podmÃ­nky-a-hrefruznecrizeni_tokupodminkyhtmlcisloa">PodmÃ­nky (<a href="ruzne/../c/rizeni_toku/podminky.html">cislo</a>)</a></h3>
<ul>
<li><a href="ruzne/../c/rizeni_toku/if.html">If</a></li>
</ul>
<pre><code class="language-c">if (&lt;vyraz 1&gt;) {
  // Provede se, pokud je &lt;vyraz 1&gt; pravdivÃ½
} else if (&lt;vyraz 2) {
  // Provede se, pokud &lt;vyraz 1&gt; nenÃ­ pravdivÃ½, a &lt;vyraz 2&gt; je pravdivÃ½
} else {
  // Provede se, pokud &lt;vyraz 1&gt; nenÃ­ pravdivÃ½, a &lt;vyraz 2&gt; takÃ© nenÃ­ pravdivÃ©
}
</code></pre>
<pre><code class="language-c editable mainbody">#include &lt;stdio.h&gt;

int main() {
  int a = 10;
  if (a &gt; 5) {
    printf(&quot;a je vetsi nez 5\n&quot;);
  } else {
    printf(&quot;a je mensi nebo rovno 5\n&quot;);
  }
  return 0;
}
</code></pre>
<h3><a class="header" href="#cykly-a-hrefruznecrizeni_tokucyklyhtmluÄivoa" id="cykly-a-hrefruznecrizeni_tokucyklyhtmluÄivoa">Cykly (<a href="ruzne/../c/rizeni_toku/cykly.html">uÄivo</a>)</a></h3>
<ul>
<li>
<p><a href="ruzne/../c/rizeni_toku/while.html">While</a></p>
<pre><code class="language-c">// &lt;vyraz&gt; -&gt; &lt;telo&gt; -v
//    ^               |
//    -----------------
// Dokud je &lt;vyraz&gt; pravdivÃ½
while (&lt;vyraz&gt;) {
  &lt;telo&gt;
}
</code></pre>
<pre><code class="language-c editable mainbody">#include &lt;stdio.h&gt;

int main() {
  int a = 10;
  while (a &gt; 0) {
    printf(&quot;a=%d\n&quot;, a);
    a = a - 1;
  }
  return 0;
}
</code></pre>
</li>
<li>
<p><a href="ruzne/../c/rizeni_toku/for.html">For</a></p>
<pre><code class="language-c">// &lt;prikaz&gt; -&gt; &lt;vyraz 1&gt; -&gt; &lt;telo&gt; -&gt; &lt;vyraz 2&gt; -v
//                ^                              |
//                -------------------------------&lt;
// Dokud je &lt;vyraz 1&gt; pravdivÃ½
for (&lt;prikaz&gt;; &lt;vyraz 1&gt;; &lt;vyraz 2&gt;) {
  &lt;telo&gt;
}
</code></pre>
<pre><code class="language-c editable mainbody">#include &lt;stdio.h&gt;

int main() {
  for (int i = 0; i &lt; 10; i++) {
    printf(&quot;i = %d, i * 2 = %d\n&quot;, i, i * 2);
  }
  return 0;
}
</code></pre>
</li>
</ul>
<h3><a class="header" href="#funkce-a-hrefruznecfunkcefunkcehtmluÄivoa" id="funkce-a-hrefruznecfunkcefunkcehtmluÄivoa">Funkce (<a href="ruzne/../c/funkce/funkce.html">uÄivo</a>)</a></h3>
<ul>
<li>Deklarace
<pre><code class="language-c">&lt;datovÃ½ typ&gt; &lt;nÃ¡zev funkce&gt;(
  &lt;dat. typ par. 1&gt; &lt;nÃ¡zev par. 1&gt;,
  &lt;dat. typ par. 2&gt; &lt;nÃ¡zev par. 2&gt;, â€¦
) {
  // tÄ›lo
}
</code></pre>
</li>
<li>Funkce, kterÃ¡ nic nevracÃ­
<pre><code class="language-c">void vypis_text() {
  printf(&quot;Ahoj\n&quot;);
}
</code></pre>
</li>
<li>Funkce, kterÃ¡ vracÃ­ hodnotu
<pre><code class="language-c">int secti(int a, int b) {
  return a + b;
}
</code></pre>
</li>
<li>VolÃ¡nÃ­ funkce
<pre><code class="language-c">int main() {
  int c = secti(1, 2);
  return 0;
}
</code></pre>
</li>
</ul>
<h3><a class="header" href="#ukazatele-a-hrefruznecprace_s_pametiukazatelehtmluÄivoa" id="ukazatele-a-hrefruznecprace_s_pametiukazatelehtmluÄivoa">Ukazatele (<a href="ruzne/../c/prace_s_pameti/ukazatele.html">uÄivo</a>)</a></h3>
<ul>
<li>VytvoÅ™enÃ­ ukazatele
<pre><code class="language-c">int* p = NULL;
</code></pre>
</li>
<li>ZÃ­skÃ¡nÃ­ adresy promÄ›nnÃ©
<pre><code class="language-c">int a = 5;
int* p = &amp;a;
</code></pre>
</li>
<li>Dereference ukazatele
<pre><code class="language-c">int a = 5;
int* p = &amp;a;
printf(&quot;%d\n&quot;, *p);
</code></pre>
</li>
</ul>
<h3><a class="header" href="#pole-a-hrefruznecpolestaticka_polehtmluÄivoa" id="pole-a-hrefruznecpolestaticka_polehtmluÄivoa">Pole (<a href="ruzne/../c/pole/staticka_pole.html">uÄivo</a>)</a></h3>
<ul>
<li>VytvoÅ™enÃ­ pole na zÃ¡sobnÃ­ku
<pre><code class="language-c">int arr[10] = {};
</code></pre>
</li>
<li>Inicializace prvkÅ¯ pole
<pre><code class="language-c">int arr[5] = {1, 2, 3, 4, 5};
</code></pre>
</li>
<li>ÄŒtenÃ­ z pole
<pre><code class="language-c">int arr[5] = {1, 2, 3, 4, 5};
int druhy_prvek = arr[1];
</code></pre>
</li>
<li>ZÃ¡pis do pole
<pre><code class="language-c">int arr[5] = {1, 2, 3, 4, 5};
arr[1] = 1;
</code></pre>
</li>
</ul>
<h3><a class="header" href="#dynamickÃ¡-pamÄ›Å¥-a-hrefruznecprace_s_pametidynamicka_pamethtmluÄivoa" id="dynamickÃ¡-pamÄ›Å¥-a-hrefruznecprace_s_pametidynamicka_pamethtmluÄivoa">DynamickÃ¡ pamÄ›Å¥ (<a href="ruzne/../c/prace_s_pameti/dynamicka_pamet.html">uÄivo</a>)</a></h3>
<ul>
<li>Alokace promÄ›nnÃ© na haldÄ›
<pre><code class="language-c">int* mem = (int*) malloc(sizeof(int));
</code></pre>
</li>
<li>Alokace pole na haldÄ›
<pre><code class="language-c">int* mem = (int*) malloc(sizeof(int) * 10);
</code></pre>
</li>
<li>UvolnÄ›nÃ­ dynamickÃ© pamÄ›ti
<pre><code class="language-c">free(mem);  
</code></pre>
</li>
</ul>
<h3><a class="header" href="#Å˜etÄ›zce-a-hrefruznectextretezcehtmluÄivoa" id="Å˜etÄ›zce-a-hrefruznectextretezcehtmluÄivoa">Å˜etÄ›zce (<a href="ruzne/../c/text/retezce.html">uÄivo</a>)</a></h3>
<ul>
<li>VytvoÅ™enÃ­ Å™etÄ›zce pro ÄtenÃ­ (nelze modifikovat)
<pre><code class="language-c">const char* text = &quot;Hello UPR&quot;;
</code></pre>
</li>
<li>VytvoÅ™enÃ­ Å™etÄ›zce na zÃ¡sobnÃ­ku (lze modifikovat)
<pre><code class="language-c">char text[] = &quot;Hello UPR&quot;;
</code></pre>
</li>
<li>VypsÃ¡nÃ­ Å™etÄ›zce
<pre><code class="language-c">printf(&quot;%s\n&quot;, text);
</code></pre>
</li>
<li>PÅ™Ã­stup k znaku Å™etÄ›zce
<pre><code class="language-c">char c = text[1];
</code></pre>
</li>
<li>ZjiÅ¡tÄ›nÃ­ dÃ©lky Å™etÄ›zce
<pre><code class="language-c">#include &lt;string.h&gt;
â€¦
const char* text = &quot;Hello UPR&quot;;
int delka = strlen(text);
</code></pre>
</li>
<li>PorovnÃ¡nÃ­ dvou Å™etÄ›zcÅ¯
<pre><code class="language-c">#include &lt;string.h&gt;
â€¦
const char* text1 = &quot;Hello UPR&quot;;
const char* text2 = &quot;Hello&quot;;
if (strcmp(text1, text2) == 0) {
  // Å˜etÄ›zce jsou stejnÃ©
}
</code></pre>
</li>
<li>PÅ™evod textu na ÄÃ­slo
<pre><code class="language-c">#include &lt;stdlib.h&gt;
â€¦
const char* text = &quot;123&quot;;
int cislo = strtol(text, NULL, 10);
</code></pre>
</li>
</ul>
<h3><a class="header" href="#vstup-a-hrefruznectextvstuphtmluÄivoa" id="vstup-a-hrefruznectextvstuphtmluÄivoa">Vstup (<a href="ruzne/../c/text/vstup.html">uÄivo</a>)</a></h3>
<ul>
<li>NaÄtenÃ­ Å™Ã¡dku
<pre><code class="language-c">char buf[80];
fgets(buf, sizeof(buf), stdin);
</code></pre>
</li>
<li>NaÄtenÃ­ formÃ¡tovanÃ©ho vstupu
<pre><code class="language-c">int a;
scanf(&quot;%d&quot;, &amp;a);
</code></pre>
</li>
</ul>
<h3><a class="header" href="#struktury-a-hrefruznecstrukturystrukturyhtmluÄivoa" id="struktury-a-hrefruznecstrukturystrukturyhtmluÄivoa">Struktury (<a href="ruzne/../c/struktury/struktury.html">uÄivo</a>)</a></h3>
<ul>
<li>
<p>Deklarace struktury</p>
<pre><code class="language-c">struct &lt;nÃ¡zev struktury&gt; {
  &lt;datovÃ½ typ prvnÃ­ho Älenu&gt; &lt;nÃ¡zev prvnÃ­ho Älenu&gt;;
  &lt;datovÃ½ typ druhÃ©ho Älenu&gt; &lt;nÃ¡zev druhÃ©ho Älenu&gt;;
  &lt;datovÃ½ typ tÅ™etÃ­ho Älenu&gt; &lt;nÃ¡zev tÅ™etÃ­ho Älenu&gt;;
  â€¦
};
</code></pre>
<pre><code class="language-c">typedef struct {
  const char* login;
  int age;
} Student;
</code></pre>
</li>
<li>
<p>Inicializace promÄ›nnÃ© typu struktury</p>
<pre><code class="language-c">Student s = { .login = &quot;BER0134&quot;, age = 29 };
</code></pre>
</li>
<li>
<p>ÄŒtenÃ­ atributu</p>
<pre><code class="language-c">int age = s.age;
</code></pre>
</li>
<li>
<p>ZÃ¡pis atributu</p>
<pre><code class="language-c">s.age = s.age + 1;
</code></pre>
</li>
<li>
<p>PÅ™Ã­stup k atributu pÅ™es ukazatel</p>
<pre><code class="language-c">Student* p = &amp;s;
p-&gt;age = p-&gt;age + 1;
</code></pre>
</li>
</ul>
<h3><a class="header" href="#soubory-a-hrefruznecsouborysouboryhtmluÄivoa" id="soubory-a-hrefruznecsouborysouboryhtmluÄivoa">Soubory (<a href="ruzne/../c/soubory/soubory.html">uÄivo</a>)</a></h3>
<ul>
<li>OtevÅ™enÃ­ souboru pro ÄtenÃ­
<pre><code class="language-c">FILE* file = fopen(&quot;file.txt&quot;, &quot;r&quot;); // TextovÃ½ mÃ³d
FILE* file2 = fopen(&quot;file.txt&quot;, &quot;rb&quot;); // BinÃ¡rnÃ­ mÃ³d
</code></pre>
</li>
<li>OtevÅ™enÃ­ souboru pro zÃ¡pis
<pre><code class="language-c">FILE* file = fopen(&quot;file.txt&quot;, &quot;w&quot;); // TextovÃ½ mÃ³d
FILE* file2 = fopen(&quot;file.txt&quot;, &quot;wb&quot;); // BinÃ¡rnÃ­ mÃ³d
</code></pre>
</li>
<li>ZavÅ™enÃ­ souboru
<pre><code class="language-c">fclose(file);
</code></pre>
</li>
<li>TextovÃ½ zÃ¡pis do souboru (vyÅ¾aduje textovÃ½ mÃ³d)
<pre><code class="language-c">fprintf(file, &quot;%d&quot;, 1);
</code></pre>
</li>
<li>TextovÃ© ÄtenÃ­ ze souboru (vyÅ¾aduje textovÃ½ mÃ³d)
<pre><code class="language-c">char row[80];
fgets(row, sizeof(radek), file);
</code></pre>
</li>
<li>ZjiÅ¡tÄ›nÃ­, jestli pÅ™edchozÃ­ pokus o ÄtenÃ­ vyÃºstil v konec souboru
<pre><code class="language-c">if (feof(file)) { â€¦ }
</code></pre>
</li>
<li>BinÃ¡rnÃ­ zÃ¡pis do souboru (vyÅ¾aduje binÃ¡rnÃ­ mÃ³d)
<pre><code class="language-c">int arr[5] = { 1, 2, 3, 4, 5 };
fwrite(arr, sizeof(int), 5, file);
</code></pre>
</li>
<li>BinÃ¡rnÃ­ ÄtenÃ­ ze souboru (vyÅ¾aduje binÃ¡rnÃ­ mÃ³d)
<pre><code class="language-c">int arr[5] = { 1, 2, 3, 4, 5 };
fread(arr, sizeof(int), 5, file);
</code></pre>
</li>
</ul>
<h3><a class="header" href="#modularizace-a-hrefruznecmodularizacemodularizacehtmluÄivoa" id="modularizace-a-hrefruznecmodularizacemodularizacehtmluÄivoa">Modularizace (<a href="ruzne/../c/modularizace/modularizace.html">uÄivo</a>)</a></h3>
<ul>
<li>HlaviÄkovÃ½ soubor <code>functions.h</code>
<pre><code class="language-c">#pragma once

int secti(int a, int b);
</code></pre>
</li>
<li>ZdrojovÃ½ soubor <code>functions.c</code>
<pre><code class="language-c">#include &quot;functions.h&quot;

int secti(int a, int b) {
  return a + b;
}
</code></pre>
</li>
<li>ZdrojovÃ½ soubor <code>main.c</code>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &quot;functions.h&quot;

int main() {
  printf(&quot;%d\n&quot;, secti(1, 2));
  return 0;
}
</code></pre>
</li>
<li>PÅ™eklad
<pre><code class="language-bash">$ gcc -c functions.c
$ gcc -c main.c
$ gcc functions.o main.o -o main
</code></pre>
</li>
</ul>
<h1><a class="header" href="#Ãšlohy-1" id="Ãšlohy-1">Ãšlohy</a></h1>
<p>V tÃ©to sekci naleznete rÅ¯znÃ© Ãºlohy, kterÃ© si mÅ¯Å¾ete zkusit naimplementovat, abyste se zlepÅ¡ili
v programovÃ¡nÃ­.</p>
<h2><a class="header" href="#Å˜eÅ¡enÃ©-Ãºlohy" id="Å˜eÅ¡enÃ©-Ãºlohy">Å˜eÅ¡enÃ© Ãºlohy</a></h2>
<p>ğŸ“¹ K nÃ¡sledujÃ­cÃ­m ÃºlohÃ¡m je k dispozici video, ve kterÃ©m je ukÃ¡zanÃ©, jak dojÃ­t k Å™eÅ¡enÃ­ danÃ© Ãºlohy.</p>
<ul>
<li><a href="ulohy/promenne.html#prohozen%C3%AD-dvou-%C4%8D%C3%ADsel">ProhozenÃ­ dvou ÄÃ­sel</a> [5:45]</li>
<li><a href="ulohy/podminky_a_cykly.html#fizzbuzz">FizzBuzz</a> [14:40]</li>
<li><a href="ulohy/pole.html#po%C4%8D%C3%ADt%C3%A1n%C3%AD-v%C3%BDskyt%C5%AF-%C4%8D%C3%ADsla">PoÄÃ­tÃ¡nÃ­ vÃ½skytÅ¯ ÄÃ­sla</a> [13:31]</li>
</ul>
<h2><a class="header" href="#dalÅ¡Ã­-Ãºlohy" id="dalÅ¡Ã­-Ãºlohy">DalÅ¡Ã­ Ãºlohy</a></h2>
<p>DalÅ¡Ã­ Ãºlohy mÅ¯Å¾ete najÃ­t takÃ© napÅ™Ã­klad na tÄ›chto odkazech:</p>
<ul>
<li><a href="https://adventofcode.com/2018/events">Advent of Code</a></li>
<li><a href="https://projecteuler.net/archives">Project Euler</a></li>
<li><a href="https://onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;category=3">Online Judge</a></li>
<li><a href="https://w3resource.com/c-programming-exercises/">W3 C programming exercises</a></li>
</ul>
<h1><a class="header" href="#promÄ›nnÃ©-1" id="promÄ›nnÃ©-1">PromÄ›nnÃ©</a></h1>
<p>K vyÅ™eÅ¡enÃ­ tÄ›chto Ãºloh by vÃ¡m mÄ›lo staÄit znÃ¡t <a href="ulohy/../c/promenne/promenne.html">promÄ›nnÃ©</a>, <a href="ulohy/../c/datove_typy/datove_typy.html">datovÃ© typy</a>
a zÃ¡kladnÃ­ <a href="ulohy/../c/prikazy_vyrazy.html#v%C3%BDpis-v%C3%BDraz%C5%AF">vÃ½pis vÃ½razÅ¯</a>.</p>
<h2><a class="header" href="#obvod-a-obsah-obdÃ©lnÃ­ku" id="obvod-a-obsah-obdÃ©lnÃ­ku">Obvod a obsah obdÃ©lnÃ­ku</a></h2>
<p>Program bude mÃ­t jako vstup dvÄ› promÄ›nnÃ© (\( a \), \( b \)), kterÃ© budou udÃ¡vat velikosti stran
obdÃ©lnÃ­ku (hodnoty promÄ›nnÃ½ch si nastavte na zaÄÃ¡tku programu). Podle znÃ¡mÃ©ho vzorce (viz nÃ­Å¾e) potÃ© program vypoÄÃ­tÃ¡ a
vypÃ­Å¡e hodnoty obou stran, spolu s obvodem a obsahem obdÃ©lnÃ­ku s danÃ½mi dÃ©lkami stran.</p>
<div style="display: flex; justify-content: center">
  <svg>
    <rect width=200 height=100 fill=#eee stroke=black />
    <text x=100 y=115 fill=black text-anchor=middle font-style=italic>a</text>
    <text x=210 y=50 fill=black text-anchor=middle font-style=italic>b</text>
  </svg>
  <div>
    $$\begin{aligned}
    o &= 2 \cdot (a + b) \\
    S &= a \cdot b
    \end{aligned}$$
  </div>
</div>
<details>
<summary>UkÃ¡zkovÃ½ vÃ½stup</summary>
<pre><code>a = 200
b = 100
o = 600
S = 20000
</code></pre>
</details>
<h2><a class="header" href="#prohozenÃ­-dvou-ÄÃ­sel" id="prohozenÃ­-dvou-ÄÃ­sel">ProhozenÃ­ dvou ÄÃ­sel</a></h2>
<blockquote>
<p>ğŸ“¹ K tÃ©to Ãºloze je k dispozici <a href="https://www.youtube.com/watch?v=arzJllZi_oY">video</a> [5:45] s popisem Å™eÅ¡enÃ­.</p>
</blockquote>
<p>Program prohodÃ­ hodnotu dvou promÄ›nnÃ½ch. Na zaÄÃ¡tku programu budou dvÄ› celoÄÃ­selnÃ© promÄ›nnÃ© (<code>a</code> a <code>b</code>) s libovolnÄ›
zvolenÃ½mi hodnotami. Tyto promÄ›nnÃ© budou na zaÄÃ¡tku programu vypsÃ¡ny na vÃ½stup.</p>
<p>DÃ¡le program prohodÃ­ hodnoty tÄ›chto dvou promÄ›nnÃ½ch, tj. napÅ™. pokud promÄ›nnÃ¡ <code>a</code> mÄ›la hodnotu
<code>5</code> a promÄ›nnÃ¡ <code>b</code> mÄ›la hodnotu <code>10</code>, tak po prohozenÃ­ by mÄ›la promÄ›nnÃ¡ <code>a</code> mÃ­t hodnotu <code>10</code> a promÄ›nnÃ¡ <code>b</code> hodnotu <code>5</code>.
Pro prohozenÃ­ pouÅ¾ijte tÅ™etÃ­ promÄ›nnou. KÃ³d pro prohozenÃ­ dvou promÄ›nnÃ½ch napiÅ¡te obecnÄ› - mÄ›l by fungovat pro libovolnÃ©
hodnoty promÄ›nnÃ½ch <code>a</code> a <code>b</code>. Po prohozenÃ­ program opÄ›t obÄ› promÄ›nnÃ© vypÃ­Å¡e.</p>
<details>
<summary>UkÃ¡zkovÃ½ vÃ½stup</summary>
<pre><code>a = 10
b = 50

a = 50
b = 10
</code></pre>
</details>
<h1><a class="header" href="#podmÃ­nky-a-cykly" id="podmÃ­nky-a-cykly">PodmÃ­nky a cykly</a></h1>
<p>K vyÅ™eÅ¡enÃ­ tÄ›chto Ãºloh by vÃ¡m mÄ›lo staÄit znÃ¡t <a href="ulohy/../c/rizeni_toku/podminky.html">podmÃ­nky</a> a <a href="ulohy/../c/rizeni_toku/cykly.html">cykly</a>
(a samozÅ™ejmÄ› veÅ¡kerÃ© pÅ™edchozÃ­ uÄivo).</p>
<h2><a class="header" href="#vÃ½poÄet-danÄ›" id="vÃ½poÄet-danÄ›">VÃ½poÄet danÄ›</a></h2>
<p>Na zaÄÃ¡tku programu si vytvoÅ™te dvÄ› celoÄÃ­selnou promÄ›nnÃ©. PrvnÃ­ promÄ›nnÃ¡ bude ÄÃ¡stku utracenou za nÃ¡kup akciÃ­ v loÅˆskÃ©m
roce. DruhÃ¡ promÄ›nnÃ¡ bude obsahovat souÄasnou hodnotu prÅ¯mÄ›rnÃ© mzdy v ÄŒR. PotÃ© vypoÄtÄ›te daÅˆ, kterou je potÅ™eba zaplatit
za nÃ¡kup akciÃ­. DaÅˆ se vypoÄÃ­tÃ¡vÃ¡ nÃ¡sledovnÄ›:</p>
<ol>
<li>Pokud byly nakoupeny akcie za mÃ©nÄ›, neÅ¾ 100 000 KÄ, tak se neplatÃ­ Å¾Ã¡dnÃ¡ daÅˆ.</li>
<li>Pokud byly nakoupeny akcie za vÃ­ce, neÅ¾ 48nÃ¡sobek prÅ¯mÄ›rnÃ© mzdy, tak se platÃ­ daÅˆ 23 %.</li>
<li>Ve zbylÃ½ch pÅ™Ã­padech se platÃ­ daÅˆ 15 %.</li>
</ol>
<p>DaÅˆ zaokrouhlete smÄ›rem k nule na celÃ© ÄÃ­slo pomocÃ­ <a href="ulohy/../c/datove_typy/konverze.html">pÅ™evodu</a> z desetinnÃ© na celoÄÃ­selnou
hodnotu.</p>
<p>Po vÃ½poÄtu danÄ› vypiÅ¡te utracenou ÄÃ¡stku, prÅ¯mÄ›rnou mzdu a vÃ½slednou hodnotu danÄ›.</p>
<details>
<summary>UkÃ¡zkovÃ© vÃ½stupy</summary>
<pre><code>utraceno = 10021
mzda = 41265
dan = 0
</code></pre>
<pre><code>utraceno = 10412
mzda = 41265
dan = 1561
</code></pre>
<pre><code>utraceno = 2000000
mzda = 41265
dan = 460000
</code></pre>
</details>
<h2><a class="header" href="#maximum-ze-tÅ™Ã­-ÄÃ­sel" id="maximum-ze-tÅ™Ã­-ÄÃ­sel">Maximum ze tÅ™Ã­ ÄÃ­sel</a></h2>
<p>Na zaÄÃ¡tku programu vytvoÅ™te tÅ™i celoÄÃ­selnÃ© promÄ›nnÃ© a nastavte do nich nÄ›jakÃ© hodnoty. PotÃ© napiÅ¡te kÃ³d, kterÃ½ nalezne
maximum z tÄ›chto tÅ™Ã­ ÄÃ­sel, a vypÃ­Å¡e jej na vÃ½stup.</p>
<p><img src="ulohy/../mdbook-plantuml-img/75ac180089a811ef0b0f84fad12f3b915d26d791.svg" alt="" /></p>
<details>
<summary>UkÃ¡zkovÃ½ vÃ½stup</summary>
<pre><code>a = 10
b = 40
c = 20

maximum je 40
</code></pre>
</details>
<h2><a class="header" href="#vÃ½pis-druhÃ½ch-monicn-ÄÃ­sel" id="vÃ½pis-druhÃ½ch-monicn-ÄÃ­sel">VÃ½pis druhÃ½ch monicn ÄÃ­sel</a></h2>
<p>VypiÅ¡te vÅ¡echna ÄÃ­sla od 0 do 20 (vÄetnÄ›), spolu s jejich druhou mocninou.</p>
<details>
<summary>UkÃ¡zkovÃ½ vÃ½stup</summary>
<pre><code>0 na druhou je 0
1 na druhou je 1
2 na druhou je 4
3 na druhou je 9
...
19 na druhou je 361
20 na druohu je 400
</code></pre>
</details>
<h2><a class="header" href="#vÃ½pis-sudÃ½ch-ÄÃ­sel" id="vÃ½pis-sudÃ½ch-ÄÃ­sel">VÃ½pis sudÃ½ch ÄÃ­sel</a></h2>
<p>VypiÅ¡te vÅ¡echna sudÃ¡ ÄÃ­sla od 0 do 100 (vÄetnÄ›). VÃ½slednÃ½ program by nemÄ›l mÃ­t vÃ­ce neÅ¾ ~15 Å™Ã¡dkÅ¯ kÃ³du.</p>
<details>
<summary>UkÃ¡zkovÃ½ vÃ½stup</summary>
<pre><code>0
2
4
...
98
100
</code></pre>
</details>
<h2><a class="header" href="#fizzbuzz" id="fizzbuzz">FizzBuzz</a></h2>
<blockquote>
<p>ğŸ“¹ K tÃ©to Ãºloze je k dispozici <a href="https://www.youtube.com/watch?v=VNYnSFGhdWo">video</a> [14:40] s popisem Å™eÅ¡enÃ­.</p>
</blockquote>
<p>Naimplementujte program zvanÃ½ <a href="https://en.wikipedia.org/wiki/Fizz_buzz">FizzBuzz</a><sup class='margin-toggle sidenote-number'>1</sup>. VypiÅ¡te ÄÃ­sla 1 aÅ¾ 100 tak, Å¾e:</p>
<span class='sidenote'><p><sup class='number'>1</sup>Tento program Äasto bÃ½vÃ¡ obsahem interview programÃ¡torÅ¯ ve firmÃ¡ch.</p>
</span>
<ul>
<li>pokud je ÄÃ­slo nÃ¡sobkem 3, tak vypiÅ¡te mÃ­sto ÄÃ­sla text <code>Fizz</code></li>
<li>pokud je ÄÃ­slo nÃ¡sobkem 5, tak vypiÅ¡te mÃ­sto ÄÃ­sla text <code>Buzz</code></li>
<li>pokud je ÄÃ­slo nÃ¡sobkem 3 i nÃ¡sobkem 5, tak vypÃ­Å¡e mÃ­sto ÄÃ­sla text <code>FizzBuzz</code></li>
</ul>
<details>
<summary>VÃ½stup programu</summary>
<pre><code>1
2
Fizz
4
Buzz
Fizz
7
8
Fizz
Buzz
11
Fizz
13
14
Fizz Buzz
16
...
</code></pre>
</details>
<p><strong>SloÅ¾itÃ¡ varianta</strong>: Naimplementujte tento program bez pouÅ¾itÃ­ podmÃ­nek. Nesimulujte ani podmÃ­nku
Å¾Ã¡dnÃ½m cyklem. PouÅ¾ijte jedinÃ½ cyklus <code>for</code> pro prÅ¯chod ÄÃ­sly 1 aÅ¾ 100 a uvnitÅ™ tohoto cyklu nepouÅ¾ijte
Å¾Ã¡dnou podmÃ­nku. K vyÅ™eÅ¡enÃ­ tÃ©to varianty budete potÅ™ebovat znÃ¡t koncepty z pozdÄ›jÅ¡Ã­ch lekcÃ­.</p>
<h2><a class="header" href="#textovÃ©-kreslenÃ­-obrazcÅ¯" id="textovÃ©-kreslenÃ­-obrazcÅ¯">TextovÃ© kreslenÃ­ obrazcÅ¯</a></h2>
<p>NapiÅ¡te program, kterÃ½ bude umÄ›t vykreslovat nÃ¡sledujÃ­cÃ­ obrazce. NapiÅ¡te kÃ³d pro jejich vykreslovÃ¡nÃ­ tak, aby poÄet
Å™Ã¡dkÅ¯, na kterÃ½ se obrazec vykreslÃ­ (pÅ™Ã­padnÄ› rozmÄ›ry obrazce), byl jednoduÅ¡e konfigurovatelnÃ½ pomocÃ­ zmÄ›ny hodnoty jednÃ©
promÄ›nnÃ©. Jinak Å™eÄeno, napÅ™Ã­klad pro zmÄ›nu poÄtu Å™Ã¡dkÅ¯/sloupcÅ¯ vykreslenÃ©ho Ätverce by mÄ›lo staÄit zmÄ›nit hodnotu jednÃ©
promÄ›nnÃ©, zbytek kÃ³du by mÄ›l zÅ¯stat stejnÃ½.</p>
<details>
<summary>VyplnÄ›nÃ½ Ätverec</summary>
<pre><code>xxxx
xxxx
xxxx
xxxx
</code></pre>
</details>
<details>
<summary>NevyplnÄ›nÃ½ Ätverec</summary>
<pre><code>xxxx
x  x
x  x
xxxx
</code></pre>
</details>
<details>
<summary>ÄŒtverec vyplnÄ›nÃ½ rostoucÃ­mi ÄÃ­sly</summary>
<pre><code>xxxxx
x012x
x345x
x678x
xxxxx
</code></pre>
</details>
<details>
<summary>DiagonÃ¡la</summary>
<pre><code>x
 x
  x
   x
    x
</code></pre>
</details>
<details>
<summary>TrojÃºhelnÃ­k</summary>
<pre><code>  x  
 x x 
xxxxx
</code></pre>
</details>
<details>
<summary>PÃ­smeno T</summary>
<pre><code>xxxxxxx
   x 
   x
   x
   x
   x
</code></pre>
</details>
<details>
<summary>PÃ­smeno H</summary>
<pre><code>x     x
x     x 
x     x
xxxxxxx
x     x
x     x
x     x
</code></pre>
</details>
<details>
<summary>PÃ­smeno Z</summary>
<pre><code>xxxxxx
    x 
   x  
  x 
 x
xxxxxx
</code></pre>
</details>
<h1><a class="header" href="#odrÃ¡Å¾ejÃ­cÃ­-se-kuliÄka-v-terminÃ¡lu" id="odrÃ¡Å¾ejÃ­cÃ­-se-kuliÄka-v-terminÃ¡lu">OdrÃ¡Å¾ejÃ­cÃ­ se kuliÄka v terminÃ¡lu</a></h1>
<p>Vykreslujte do terminÃ¡lu obdÃ©lnÃ­k spolu s pohybujÃ­cÃ­ se kuliÄkou. Jakmile kuliÄka narazÃ­ do stÄ›ny
Ätverce, zvyÅ¡te poÄÃ­tadlo nÃ¡razÅ¯ pro danou zeÄ. DodrÅ¾ujte princip
<a href="https://cs.wikipedia.org/wiki/Odraz_vln%C4%9Bn%C3%AD">zÃ¡konu odrazu</a>.</p>
<details>
<summary>PÅ™ibliÅ¾nÃ½ postup Å™eÅ¡enÃ­</summary>
KuliÄku reprezentujte dvÄ›mi promÄ›nÃ½mi (pozice X a Y). OpakovanÄ› provÃ¡dÄ›jte nÃ¡sledujÃ­cÃ­ akce:
<ul>
<li>PosuÅˆte kuliÄku ve smÄ›ru jejÃ­ho pohybu.</li>
<li>Pokud kuliÄka narazÃ­ do stÄ›ny, zmÄ›Åˆte smÄ›r jejÃ­ho pohybu.</li>
<li>VyÄistÄ›te terminÃ¡l, aby zmizelo hernÃ­ pole z minulÃ© iterace. Lze to provÃ©st vÃ­ce zpÅ¯soby:
<ul>
<li>VytisknÄ›te velkÃ© mnoÅ¾stvÃ­ prÃ¡zdnÃ½ch Å™Ã¡dkÅ¯.</li>
<li>VytisknÄ›te text <code>&quot;\e[1;1H\e[2J&quot;</code>, kterÃ½ terminÃ¡l bude interpretovat jako vyÄistÄ›nÃ­ obrazovky.</li>
</ul>
</li>
<li>Vykreslete kuliÄku a obdÃ©lnÃ­k.</li>
<li>UspÄ›te na chvÃ­li program, abyste mohli pozorovat zmÄ›nÄ›nÃ½ stav hry. MÅ¯Å¾ete pouÅ¾Ã­t napÅ™Ã­klad funkci
<a href="https://man7.org/linux/man-pages/man3/usleep.3.html"><code>usleep</code></a>: <code>usleep(100 * 1000)</code>.</li>
</ul>
</details>
<p>VÃ½sledek by mÄ›l vypadat zhruba takto:</p>
<p><img src="ulohy/../static/video/ball_terminal.gif" alt="OdrÃ¡Å¾ejÃ­cÃ­ se kuliÄka v terminÃ¡lu" /></p>
<h1><a class="header" href="#vykreslovÃ¡nÃ­-grafu-funkce" id="vykreslovÃ¡nÃ­-grafu-funkce">VykreslovÃ¡nÃ­ grafu funkce</a></h1>
<p>NapiÅ¡te program, kterÃ½ dokÃ¡Å¾e vykreslit graf funkce. Graf vykreslujte do terminÃ¡lu, nenÃ­ tÅ™eba
implementovat grafickou aplikaci. VyuÅ¾ijte napÅ™Ã­klad znak <code>|</code> pro znÃ¡zornÄ›nÃ­ osy y, znak <code>-</code>
pro znÃ¡zornÄ›nÃ­ osy x, a <code>+</code> pro znÃ¡zornÄ›nÃ­ poÄÃ¡tku. PomocÃ­ znaku <code>*</code> mÅ¯Å¾ete znÃ¡zornit funkci
vlastnÃ­ho vÃ½bÄ›ru.</p>
<h2><a class="header" href="#ukÃ¡zka" id="ukÃ¡zka">UkÃ¡zka</a></h2>
<details>
<summary>Graf lineÃ¡rnÃ­ funkce</summary>
<pre><code>                              |
                              |     *
                              |
                              |    *
                              |
                              |   *
                              |
                              |  *
                              |
                              | *
                              |
                              |*
                              |
                              *
                              |
                             *|
------------------------------+------------------------------
                            * |
                              |
                           *  |
                              |
                          *   |
                              |
                         *    |
                              |
                        *     |
                              |
                       *      |
                              |
                      *       |
                              |
</code></pre>
</details>
<details>
<summary>Graf exponenciÃ¡lnÃ­ funkce</summary>
<pre><code>                              |   *
                              |
                              |
                              |
                              |
                              |
                              |
                              |
                              |  *
                              |
                              |
                              |
                              | *
                              |
                              |*
                              *
******************************+------------------------------
                              |
                              |
                              |
                              |
                              |
                              |
                              |
                              |
                              |
                              |
                              |
                              |
                              |
                              |
</code></pre>
</details>
<h2><a class="header" href="#tipy" id="tipy">Tipy</a></h2>
<ul>
<li>Zvolte si fixnÃ­ Å¡Ã­Å™ku a vÃ½Å¡ku grafu, aby se graf veÅ¡el do rozumnÄ› velkÃ©ho okna terminÃ¡lu
(v ukÃ¡zkÃ¡ch je vyuÅ¾ita velikost 61x31).</li>
<li>Funkci vykreslujte jen pro celÃ© hodnoty <code>x</code> (graf tedy bude nespojitÃ½).</li>
<li>Experimentujte s funkcemi a zkuste vykreslit grafy rÅ¯znÃ½ch funkcÃ­ (napÅ™. logaritmus,
exponenciÃ¡lnÃ­ funkce, kvadratickÃ¡ a kubickÃ¡ funkce, ...).</li>
<li>Pro vÃ½poÄet funkcÃ­ lze vyuÅ¾Ã­t matematickou knihovnu <code>math.h</code>, kterÃ¡ je souÄÃ¡stÃ­ standardnÃ­
knihovny jazyka C. Knihovnu je ovÅ¡em potÅ™eba pÅ™i kompilaci explicitnÄ› slinkovat pÅ™epÃ­naÄem <code>-lm</code>,
kterÃ½ pouze pÅ™edÃ¡te kompilÃ¡toru (<code>gcc main.c -o main -lm</code>).</li>
<li>Nehledejte v Ãºloze zbyteÄnou komplexitu. NejjednoduÅ¡Å¡Ã­ variantu Ãºlohy (viz ukÃ¡zka) lze
naprogramovat na 30 Å™Ã¡dkÅ¯ za vyuÅ¾itÃ­ dvou cyklÅ¯, podmÃ­nek a parametrickÃ© rovnice pÅ™Ã­mky
(<code>y = ax + b</code>).</li>
</ul>
<h2><a class="header" href="#sloÅ¾itÄ›jÅ¡Ã­-varianta" id="sloÅ¾itÄ›jÅ¡Ã­-varianta">SloÅ¾itÄ›jÅ¡Ã­ varianta</a></h2>
<p>Zkuste graf vykreslovat spojitÄ›. VyuÅ¾Ã­t mÅ¯Å¾ete napÅ™Ã­klad
<a href="https://en.wikipedia.org/wiki/Bresenham%27s_line_algorithm">BresenhamÅ¯m algoritmus pro vykreslenÃ­ pÅ™Ã­mky</a>.</p>
<p>Nebo zkuste vykreslovÃ¡nÃ­ grafÅ¯ implementovat jako interaktivnÃ­ terminÃ¡lovou aplikaci. VyuÅ¾Ã­t lze
napÅ™Ã­klad knihovnu <a href="https://man.archlinux.org/man/ncurses.3x.en">ncurses</a>, nebo pÅ™Ã­mo ANSI
escape sekvence. Aplikace mÅ¯Å¾e umoÅ¾nit panning (posouvÃ¡nÃ­ doleva, doprava, nahoru a dolÅ¯)
a zooming (zmÄ›nÃ¡ Å¡kÃ¡ly souÅ™adnicovÃ½ch os).</p>
<p>InteraktivnÃ­ aplikace by takÃ© mohla na okrajÃ­ch okna znÃ¡zorÅˆovat, na jakÃ© souÅ™adnice se uÅ¾ivatel
dÃ­vÃ¡ (aÅ¥ se pÅ™i prochÃ¡zenÃ­ grafu neztratÃ­) a aktuÃ¡lnÃ­ ÃºroveÅˆ pÅ™iblÃ­Å¾enÃ­, a implementovat klÃ¡vesovou
zkratku pro reset nÃ¡hledu na graf (vycentrovÃ¡nÃ­ poÄÃ¡tku a nastavenÃ­ zoomu na <code>1.0</code>).</p>
<p>Pokud si chcete s Ãºlohou opravdu vyhrÃ¡t, mÅ¯Å¾ete takÃ© naprogramovat moÅ¾nost zadat vlastnÃ­ funkci
za bÄ›hu programu. Toho lze dosÃ¡hnout jak manuÃ¡lnÃ­m parsovÃ¡nÃ­m uÅ¾ivatelskÃ©ho vstupu, tak
embeddovÃ¡nÃ­m nÄ›jakÃ©ho skriptovacÃ­ho jazyka (napÅ™. <a href="https://www.lua.org/pil/24.html">Lua</a>) do svÃ©ho
programu, a umoÅ¾nÄ›nÃ­m uÅ¾ivateli naprogramovat si vlastnÃ­, libovolnÄ› sloÅ¾itou funkci (vyuÅ¾Ã­vajÃ­cÃ­
napÅ™Ã­klad podmÃ­nky, atp.). Fantazii se meze nekladou.</p>
<p>SloÅ¾itÄ›jÅ¡Ã­ varianta <strong>nenÃ­ vhodnÃ¡</strong> pro ÃºplnÃ© zaÄÃ¡teÄnÃ­ky.</p>
<h1><a class="header" href="#funkce-1" id="funkce-1">Funkce</a></h1>
<p>K vyÅ™eÅ¡enÃ­ tÄ›chto Ãºloh by vÃ¡m mÄ›lo staÄit znÃ¡t <a href="ulohy/../c/funkce/funkce.html">funkce</a> (a samozÅ™ejmÄ› veÅ¡kerÃ© pÅ™edchozÃ­ uÄivo).</p>
<h2><a class="header" href="#maximum" id="maximum">Maximum</a></h2>
<p>NapiÅ¡te funkci <code>max</code>, kterÃ¡ pÅ™ijme dva celoÄÃ­selnÃ© argumenty a vrÃ¡tÃ­ vÄ›tÅ¡Ã­ z nich.</p>
<details>
<summary>UkÃ¡zka pouÅ¾itÃ­ funkce</summary>
<pre><code class="language-c">printf(&quot;%d&quot;, max(0, 0));    // VypÃ­Å¡e 0
printf(&quot;%d&quot;, max(1, 5));    // VypÃ­Å¡e 5
printf(&quot;%d&quot;, max(2, -3));   // VypÃ­Å¡e 2
</code></pre>
</details>
<h2><a class="header" href="#vÃ½poÄet-danÄ›-funkce" id="vÃ½poÄet-danÄ›-funkce">VÃ½poÄet danÄ› (funkce)</a></h2>
<p>Naimplementujte Ãºlohu <a href="ulohy/./podminky_a_cykly.html#v%C3%BDpo%C4%8Det-dan%C4%9B">VÃ½poÄet danÄ›</a> pomocÃ­ funkce <code>vypocti_dan</code>. Funkce dostane
ÄÃ¡stku utracenou za nÃ¡kupy akciÃ­ a prÅ¯mÄ›rnou mzdu, a vrÃ¡tÃ­ vypoÄtenou daÅˆ ve formÄ› celÃ©ho ÄÃ­sla.</p>
<details>
<summary>UkÃ¡zka pouÅ¾itÃ­ funkce</summary>
<pre><code class="language-c">printf(&quot;Dan=%d&quot;, vypocti_dan(10021, 41265));    // VypÃ­Å¡e Dan=0
printf(&quot;%d&quot;, vypocti_dan(10412, 41265));        // VypÃ­Å¡e 1561
printf(&quot;%d&quot;, vypocti_dan(2000000, 41265));      // VypÃ­Å¡e 460000

int dan = vypocti_dan(100000, 40000) + vypocti_dan(200000, 38000);
// dan bude 45000
</code></pre>
</details>
<h2><a class="header" href="#textovÃ©-kreslenÃ­-obrazcÅ¯-funkce" id="textovÃ©-kreslenÃ­-obrazcÅ¯-funkce">TextovÃ© kreslenÃ­ obrazcÅ¯ (funkce)</a></h2>
<p>Naimplementujte Ãºlohu <a href="ulohy/./podminky_a_cykly.html#textov%C3%A9-kreslen%C3%AD-obrazc%C5%AF">TextovÃ© kreslenÃ­ obrazcÅ¯</a> pomocÃ­ funkcÃ­. Pro
kaÅ¾dÃ½ typ obrazce udÄ›lejte separÃ¡tnÃ­ funkci, kterÃ¡ obdrÅ¾Ã­ parametry nutnÃ© pro vykreslenÃ­ danÃ©ho obrazce, a vykreslÃ­ jej
na vÃ½stup pomocÃ­ znaku <code>x</code>.
Parametry mÅ¯Å¾ou bÃ½t napÅ™:</p>
<ul>
<li>dÃ©lka strany pro funkci <code>ctverec</code></li>
<li>dÃ©lka dvou stran (Å¡Ã­Å™ka Ã— vÃ½Å¡ka) pro funkci <code>obdelnik</code></li>
<li>dÃ©lka a smÄ›r diagonÃ¡ly pro funkci <code>diagonala</code></li>
</ul>
<details>
<summary>UkÃ¡zka pouÅ¾itÃ­ funkce</summary>
<pre><code class="language-c">ctverec(4); // VykreslÃ­:
// xxxx
// xxxx
// xxxx
// xxxx

obdelnik(2, 3); // VykreslÃ­:
// xx
// xx
// xx

obdelnik(3, 1); // VykreslÃ­:
// xxx
</code></pre>
</details>
<h2><a class="header" href="#fibonacciho-ÄÃ­slo" id="fibonacciho-ÄÃ­slo">Fibonacciho ÄÃ­slo</a></h2>
<p>NapiÅ¡te funkci <code>fibonacci</code>, kterÃ¡ vypoÄte <code>n</code>-tÃ© <a href="https://cs.wikipedia.org/wiki/Fibonacciho_posloupnost">Fibonacciho ÄÃ­slo</a>
(<code>n</code> bude parametrem funkce).</p>
<details>
<summary>UkÃ¡zka pouÅ¾itÃ­ funkce</summary>
<pre><code class="language-c">printf(&quot;%d&quot;, fibonacci(0));   // VypÃ­Å¡e 0
printf(&quot;%d&quot;, fibonacci(1));   // VypÃ­Å¡e 1
printf(&quot;%d&quot;, fibonacci(2));   // VypÃ­Å¡e 1
printf(&quot;%d&quot;, fibonacci(3));   // VypÃ­Å¡e 2
printf(&quot;%d&quot;, fibonacci(4));   // VypÃ­Å¡e 3
printf(&quot;%d&quot;, fibonacci(5));   // VypÃ­Å¡e 5
printf(&quot;%d&quot;, fibonacci(6));   // VypÃ­Å¡e 8
</code></pre>
</details>
<h2><a class="header" href="#faktoriÃ¡l" id="faktoriÃ¡l">FaktoriÃ¡l</a></h2>
<p>NapiÅ¡te funkci <code>factorial</code>, kterÃ¡ vypoÄte <a href="https://cs.wikipedia.org/wiki/Faktori%C3%A1l">faktoriÃ¡l</a> pÅ™edanÃ©ho
parametru.</p>
<details>
<summary>UkÃ¡zka pouÅ¾itÃ­ funkce</summary>
<pre><code class="language-c">printf(&quot;%d&quot;, factorial(0));   // VypÃ­Å¡e 1
printf(&quot;%d&quot;, factorial(1));   // VypÃ­Å¡e 1
printf(&quot;%d&quot;, factorial(4));   // VypÃ­Å¡e 24
printf(&quot;%d&quot;, factorial(5));   // VypÃ­Å¡e 120
</code></pre>
</details>
<h1><a class="header" href="#ukazatele-1" id="ukazatele-1">Ukazatele</a></h1>
<p>K vyÅ™eÅ¡enÃ­ tÄ›chto Ãºloh by vÃ¡m mÄ›lo staÄit znÃ¡t <a href="ulohy/../c/prace_s_pameti/ukazatele.html">ukazatele</a> (a samozÅ™ejmÄ› veÅ¡kerÃ©
pÅ™edchozÃ­ uÄivo).</p>
<h2><a class="header" href="#nastavenÃ­-maxima" id="nastavenÃ­-maxima">NastavenÃ­ maxima</a></h2>
<p>VytvoÅ™te funkci <code>set_max</code>, kterÃ¡ pÅ™ijme adresu celÃ©ho ÄÃ­sla (<code>int</code>) pomocÃ­ ukazatele a dvÄ› dalÅ¡Ã­
ÄÃ­sla a nastavÃ­ pamÄ›Å¥ na danÃ© adrese na vÄ›tÅ¡Ã­ ze dvou zadanÃ½ch ÄÃ­sel.</p>
<pre><code class="language-c">int res;
set_max(&amp;res, 5, 6);
// res == 6
</code></pre>
<h2><a class="header" href="#prohozenÃ­-hodnoty" id="prohozenÃ­-hodnoty">ProhozenÃ­ hodnoty</a></h2>
<p>VytvoÅ™te funkci <code>swap</code>, kterÃ¡ pÅ™ijme dva ukazatele a prohodÃ­ hodnoty promÄ›nnÃ½ch, na kterÃ© ukazujÃ­.</p>
<pre><code class="language-c">int a = 5, b = 6;
swap(&amp;a, &amp;b);
// a == 6, b == 5
</code></pre>
<h2><a class="header" href="#vÃ½poÄet-koÅ™enÅ¯-kvadratickÃ©-rovnice" id="vÃ½poÄet-koÅ™enÅ¯-kvadratickÃ©-rovnice">VÃ½poÄet koÅ™enÅ¯ kvadratickÃ© rovnice</a></h2>
<p>VytvoÅ™te funkci <code>quadratic_roots</code>, kterÃ¡ vrÃ¡tÃ­ poÄet koÅ™enÅ¯ kvadratickÃ© rovnice \( ax^2 + bx + c = 0 \) pomocÃ­ <code>return</code> a vypoÄÃ­tanÃ© koÅ™eny vrÃ¡tÃ­ pomocÃ­ pÅ™edanÃ½ch ukazatelÅ¯ v argumentech funkce.</p>
<pre><code class="language-c">int quadratic_roots(float a, float b, float c, float *x1, float *x2);
</code></pre>
<p>PoÄet koÅ™enÅ¯ lze zjistit vypoÄÃ­tÃ¡nÃ­m diskriminantu \( D = b^2 - 4ac \).
Pokud vyjde diskriminant zÃ¡pornÃ½, tak funkce vrÃ¡tÃ­ nulu, protoÅ¾e Å¾Ã¡dnÃ© Å™eÅ¡enÃ­ v \( \mathbb{R} \) neexistuje.
Pro nulovÃ½ diskriminant funkce vrÃ¡tÃ­ <code>1</code> a uloÅ¾Ã­ dvojnÃ¡sobnÃ½ koÅ™en na adresu ukazatelÅ¯ <code>x1</code>, <code>x2</code>.
Pro kladnÃ½ diskriminant funkce vrÃ¡tÃ­ <code>2</code> a vypoÄÃ­tÃ¡ koÅ™eny pomocÃ­:
$$ x_{1, 2} = \frac{-b \pm \sqrt{D}}{2a} $$</p>
<p><upr-parabola></upr-parabola></p>
<h1><a class="header" href="#pole-1" id="pole-1">Pole</a></h1>
<p>K vyÅ™eÅ¡enÃ­ tÄ›chto Ãºloh by vÃ¡m mÄ›lo staÄit znÃ¡t <a href="ulohy/../c/pole/pole.html">pole</a> (a samozÅ™ejmÄ› veÅ¡kerÃ©
pÅ™edchozÃ­ uÄivo).</p>
<h2><a class="header" href="#naplnÄ›nÃ­-pole" id="naplnÄ›nÃ­-pole">NaplnÄ›nÃ­ pole</a></h2>
<p>VytvoÅ™te funkci <code>fill_array</code>, kterÃ¡ naplnÃ­ pole <code>array</code> ÄÃ­sly zvÄ›tÅ¡ujÃ­cÃ­mi se po pÅ™Ã­rÅ¯stku <code>increment</code> a
zaÄÃ­najÃ­cÃ­mi od hodnoty <code>start</code>. </p>
<pre><code class="language-c">void fill_array(int* array, int len, int start, int increment);
</code></pre>
<p>NÃ­Å¾e je interaktivnÃ­ diagram znÃ¡zorÅˆujÃ­cÃ­, jak mÃ¡ vypadat pole po provedenÃ­ funkce. JednotlivÃ© argumenty
volanÃ© funkce mÅ¯Å¾ete v diagramu mÄ›nit.</p>
<p><upr-array-fill></upr-array-fill></p>
<h2><a class="header" href="#poÄÃ­tÃ¡nÃ­-vÃ½skytÅ¯-ÄÃ­sla" id="poÄÃ­tÃ¡nÃ­-vÃ½skytÅ¯-ÄÃ­sla">PoÄÃ­tÃ¡nÃ­ vÃ½skytÅ¯ ÄÃ­sla</a></h2>
<blockquote>
<p>ğŸ“¹ K tÃ©to Ãºloze je k dispozici <a href="https://www.youtube.com/watch?v=QCmH3uN9Au8">video</a> [13:31] s popisem Å™eÅ¡enÃ­.</p>
</blockquote>
<p>VytvoÅ™te funkci <code>num_count</code>, kterÃ¡ spoÄÃ­tÃ¡ a vrÃ¡tÃ­ poÄet vÃ½skytÅ¯ ÄÃ­sla <code>num</code> v poli <code>array</code>.</p>
<pre><code class="language-c">int num_count(int* array, int len, int num);
</code></pre>
<p>NÃ­Å¾e je interaktivnÃ­ animace, kterÃ¡ zobrazuje prÅ¯bÄ›h programu.</p>
<p><upr-array-interval array="[10, 2, 4, 3, 4, 8, 9, 4]" from="4" to="4"></upr-array-interval></p>
<h2><a class="header" href="#poÄÃ­tÃ¡nÃ­-ÄÃ­sel-v-intervalu" id="poÄÃ­tÃ¡nÃ­-ÄÃ­sel-v-intervalu">PoÄÃ­tÃ¡nÃ­ ÄÃ­sel v intervalu</a></h2>
<p>VytvoÅ™te funkci <code>in_interval</code>, kterÃ¡ spoÄÃ­tÃ¡ poÄet ÄÃ­sel z uzavÅ™enÃ©ho intervalu <code>[from, to]</code> v poli
<code>array</code>.</p>
<pre><code class="language-c">int in_interval(int* array, int len, int from, int to);
</code></pre>
<p>NÃ­Å¾e je interaktivnÃ­ animace, kterÃ¡ zobrazuje prÅ¯bÄ›h programu.</p>
<p><upr-array-interval array="[10, 2, 4, 3, 4, 8, 9, 4]" from="2" to="5"></upr-array-interval></p>
<h2><a class="header" href="#prÅ¯mÄ›rnÃ¡-hodnota" id="prÅ¯mÄ›rnÃ¡-hodnota">PrÅ¯mÄ›rnÃ¡ hodnota</a></h2>
<p>VytvoÅ™te funkci <code>average</code>, kterÃ¡ spoÄÃ­tÃ¡ prÅ¯mÄ›r ÄÃ­sel v poli <code>array</code>.</p>
<pre><code class="language-c">double average(int* array, int len);
</code></pre>
<p>PÅ™i dÄ›lenÃ­ nezapomeÅˆte pÅ™etypovat alespoÅˆ jeden operand na typ <code>double</code>, aby nedoÅ¡lo k
celoÄÃ­selnÃ©mu dÄ›lenÃ­. Pokud bude pole prÃ¡zdnÃ©, vraÅ¥te hodnotu <code>0.0</code>.</p>
<h2><a class="header" href="#minimÃ¡lnÃ­-hodnota-v-poli" id="minimÃ¡lnÃ­-hodnota-v-poli">MinimÃ¡lnÃ­ hodnota v poli</a></h2>
<p>VytvoÅ™te funkci, kterÃ¡ v poli <code>array</code> nalezne minimÃ¡lnÃ­ hodnotu.</p>
<pre><code class="language-c">int array_min(int *array, int len);
</code></pre>
<p>NÃ­Å¾e je interaktivnÃ­ animace, kterÃ¡ zobrazuje prÅ¯bÄ›h programu.</p>
<p><upr-array-min array="[3, 5, 2, 8, 7, 1, 3]"></upr-array-min></p>
<p>NÃ¡slednÄ› funkci upravte, aby funkce vrÃ¡tila pomocÃ­ ukazatele poslednÃ­ index v poli, na kterÃ©m je minimÃ¡lnÃ­ hodnota
danÃ©ho pole.</p>
<pre><code class="language-c">int array_min(int *array, int len, int *min_index);
</code></pre>
<h2><a class="header" href="#minimÃ¡lnÃ­-a-maximÃ¡lnÃ­-hodnota" id="minimÃ¡lnÃ­-a-maximÃ¡lnÃ­-hodnota">MinimÃ¡lnÃ­ a maximÃ¡lnÃ­ hodnota</a></h2>
<p>PÅ™edchozÃ­ funkci upravte, aby hledala minimum a maximum zÃ¡roveÅˆ.
NalezenÃ© extrÃ©my vraÅ¥te pomocÃ­ ukazatelÅ¯ <code>min</code> a <code>max</code>.</p>
<pre><code class="language-c">void min_max(int* array, int len, int *min, int *max);
</code></pre>
<p>Ve funkci si nejprve nastavte index minimÃ¡lnÃ­ a maximÃ¡lnÃ­ hodnoty na nultÃ½ prvek.
Parametr <code>min</code> je ukazatel, a je tedy nutnÃ© pÅ™istupovat k jeho hodnotÄ› pomoci dereference - <code>*min</code>,
protoÅ¾e vÃ½raz <code>min</code> obsahuje pouze adresu, kde je minimÃ¡lnÃ­ index uloÅ¾en. NÃ¡slednÄ› projdÄ›te
pole a pokud bude hodnota aktuÃ¡lnÃ­ho prvku menÅ¡Ã­ neÅ¾ hodnota prvku na dosud nalezenÃ©m indexu,
nastavte hodnotu minimÃ¡lnÃ­ho indexu na aktuÃ¡lnÃ­ index. StejnÃ½ postup aplikujte i pro nalezenÃ­
maximÃ¡lnÃ­ho prvku (staÄÃ­ udÄ›lat jeden prÅ¯chod polem).</p>
<h2><a class="header" href="#obrÃ¡cenÃ­-pole" id="obrÃ¡cenÃ­-pole">ObrÃ¡cenÃ­ pole</a></h2>
<p>VytvoÅ™te funkci <code>array_reverse</code>, kterÃ¡ obrÃ¡tÃ­ prvky v poli.</p>
<pre><code class="language-c">void array_reverse(int* array, int len);
</code></pre>
<p>Pole projdÄ›te pomoci cyklu do jeho pÅ¯lky a vÅ¾dy prohazujte prvky z obou koncÅ¯.</p>
<p>NÃ­Å¾e je interaktivnÃ­ animace, kterÃ¡ zobrazuje prÅ¯bÄ›h programu.</p>
<p><upr-array-reverse array="[10, 20, 30, 40, 50, 60]"></upr-array-reverse></p>
<p>PÅ™ehozenÃ­ dvou prvkÅ¯ nemÅ¯Å¾ete udÄ›lat najednou. UloÅ¾te si napÅ™Ã­klad prvek z levÃ©ho konce do promÄ›nnÃ©
a nÃ¡slednÄ› do tohoto prvku zapiÅ¡te hodnotu z pravÃ©ho konce. PotÃ© hodnotu z promÄ›nnÃ© uloÅ¾te do pravÃ©ho
konce. AlternativnÄ› takÃ© mÅ¯Å¾ete vyuÅ¾Ã­t <a href="ulohy/ukazatele.html#prohozen%C3%AD-hodnoty">dÅ™Ã­ve</a> naimplementovanou funkci
<code>void swap(int* a, int* b)</code>.</p>
<h2><a class="header" href="#skalÃ¡rnÃ­-souÄin" id="skalÃ¡rnÃ­-souÄin">SkalÃ¡rnÃ­ souÄin</a></h2>
<p>VytvoÅ™te funkci <code>dot</code>, kterÃ¡ spoÄÃ­tÃ¡
<a href="https://cs.wikipedia.org/wiki/Skal%C3%A1rn%C3%AD_sou%C4%8Din">skalÃ¡rnÃ­ souÄin</a> dvou vektorÅ¯.</p>
<pre><code class="language-c">int dot(int* a, int* b, int len);
</code></pre>
<h2><a class="header" href="#naÄtenÃ­-dynamickÃ©ho-poÄtu-hodnot" id="naÄtenÃ­-dynamickÃ©ho-poÄtu-hodnot">NaÄtenÃ­ dynamickÃ©ho poÄtu hodnot</a></h2>
<p>NaÄtÄ›te od uÅ¾ivatele ÄÃ­slo <code>n</code>. PotÃ© naalokujte pamÄ›Å¥ o velikosti <code>n</code> <code>int</code>Å¯ a 
naÄtÄ›te ze vstupu <code>n</code> ÄÃ­sel, kterÃ© postupnÄ› uloÅ¾te do vytvoÅ™enÃ©ho pole. VypiÅ¡te souÄet naÄtenÃ©ho
pole.</p>
<h2><a class="header" href="#tÅ™Ã­zenÃ­" id="tÅ™Ã­zenÃ­">TÅ™Ã­zenÃ­</a></h2>
<p>Naimplementujte funkci, kterÃ¡ setÅ™Ã­dÃ­ pole. MÅ¯Å¾ete pouÅ¾Ã­t napÅ™Ã­klad algoritmus
<a href="https://en.wikipedia.org/wiki/Bubble_sort">bubble sort</a>.</p>
<h2><a class="header" href="#counting-sort" id="counting-sort">Counting sort</a></h2>
<p>Vygenerujte pole 10 000 000 <a href="ulohy/../ruzne/nahodna_cisla.html">nÃ¡hodnÃ½ch ÄÃ­sel</a> z intervalu \( \langle 1000, 2000 \rangle \).
PomocÃ­ algoritmu counting sort seÅ™aÄte ÄÃ­sla v poli od nejmenÅ¡Ã­ho po nejvÄ›tÅ¡Ã­.</p>
<ol>
<li>vytvoÅ™te pole poÄÃ­tadel pro vÅ¡echny moÅ¾nÃ© hodnoty v poli</li>
<li>vynulujte poÄitadla na 0</li>
<li>sekvenÄnÄ› projdÄ›te pole ÄÃ­sel a inkrementujte odpovÃ­dajÃ­cÃ­ poÄÃ­tadlo</li>
<li>projdÄ›te pole poÄÃ­tadel a tisknÄ›te hodnotu tolikrÃ¡t, kolik je hodnota poÄÃ­tadla</li>
</ol>
<p><upr-counting-sort></upr-counting-sort></p>
<h1><a class="header" href="#pvp-bitevnÃ­-hra" id="pvp-bitevnÃ­-hra">PvP bitevnÃ­ hra</a></h1>
<p><asciinema-player src="pvp.cast"></asciinema-player></p>
<p>VytvoÅ™te simulaci PvP bitevnÃ­ hry dle vaÅ¡ich pÅ™edstav.
Hra bude simulovÃ¡na dle nÃ¡hody v hernÃ­ch kolech dle nÃ¡sledujÃ­cÃ­ kostry programu:</p>
<pre><code class="language-c">while(nepratele_nebo_hrac_nazivu()) {
  // zvolim si nepritele
  // zautocim na nej a sebere mu zivoty
  // nepritel zautoci na me a sebere mi zivoty
  
  // smazani terminalu
  printf(&quot;\e[1;1H\e[2J&quot;);

  // nove vykresleni

  // uspani na 500 ms
  usleep(500 * 1000);
}
</code></pre>
<p>Å½ivoty nepÅ™Ã¡tel reprezentujme pomocÃ­ pole ÄÃ­sel a na zaÄÃ¡tku hry jim nÃ¡hodnÄ› pÅ™iÅ™aÄme ÄÃ­sla z intervalu napÅ™. 150 - 400.
Hrdinovi Å¾ivoty vygenerujme obdobnÄ› - vyuÅ¾ijte tedy <strong>funkci</strong> pro vygenerovanÃ­ Å¾ivotÅ¯, aÅ¥ zbyteÄnÄ› nekopÃ­rujeme kÃ³d.
ObdobnÄ› mÅ¯Å¾eme takÃ© vytvoÅ™it pole Å¡tÃ­tÅ¯ a zbranÃ­.
KonkrÃ©tnÃ­ho nepÅ™Ã­tele mÅ¯Å¾eme vybrat pomocÃ­ nÄ›kolika strategiÃ­ - kaÅ¾dÃ¡ mÅ¯Å¾e bÃ½t naimplementovanÃ¡ ve funkci pÅ™ijÃ­majÃ­cÃ­ pole Å¾ivotÅ¯/Å¡tÃ­tÅ¯/zbranÃ­ a poÄet nepÅ™Ã¡tel.
Funkce pak mÅ¯Å¾e vracet index vybranÃ©ho hrdiny na kterÃ©ho zaÃºtoÄÃ­me.</p>
<ol>
<li>vybrat nepÅ™Ã­tele nÃ¡hodnÄ›</li>
<li>vybrat nepÅ™Ã­tele s nejmenÅ¡Ã­m poÄtem Å¾ivotÅ¯</li>
<li>vybrat nepÅ™Ã­tele s nejmenÅ¡Ã­m poÄtem Å¾ivotÅ¯ a Å¡tÃ­tu</li>
<li>vybrat nepÅ™Ã­tele s nejslabÅ¡Ã­ zbranÃ­</li>
</ol>
<p>Po zaÃºtoÄenÃ­ ubereme nepÅ™Ã­teli Å¾ivoty a zajistÃ­me, aby nemohly bÃ½t zÃ¡pornÃ© - napÅ™Ã­klad pomocÃ­ ternÃ¡rnÃ­ho vÃ½razu.
Pokud mÃ¡ vÅ¡ak Å¡tÃ­t, tak musÃ­me mu nejprve ubrat Å¾ivoty ze Å¡tÃ­tu a potÃ© z Å¾ivotÅ¯.</p>
<p>ZranÄ›nÃ½ nepÅ™Ã­tel potÃ© zaÃºtoÄÃ­ na nÃ¡s a odebere nÃ¡m Å¡tÃ­t Äi Å¾ivoty - pouÅ¾ijme funkci aÅ¥ nekopÃ­rujeme kÃ³d.</p>
<p>PotÃ© naimplementujeme funkci v podmÃ­nce cyklu - funkce bude vracet <code>TRUE</code>, pokud je hrdina naÅ¾ivu a zÃ¡roveÅˆ je naÅ¾ivu alespoÅˆ jeden nepÅ™Ã­tel.</p>
<p>Hru mÅ¯Å¾eme dÃ¡le vylepÅ¡it o:</p>
<ul>
<li>critical damage 4%
<ul>
<li>pokud vygenerujeme ÄÃ­slo z rozsahu 0-99 a hodnota bude menÅ¡Ã­ neÅ¾ napÅ™. 4, tak zaÃºtoÄÃ­me s dvojnÃ¡sobnÃ½m poÅ¡kozenÃ­m</li>
</ul>
</li>
<li>degradace zbranÃ­
<ul>
<li>po kaÅ¾dÃ©m Ãºtoku se poÅ¡kozeni zbranÄ› zmenÅ¡Ã­ o 5%</li>
</ul>
</li>
<li>inventÃ¡Å™ zbranÄ› hrdiny
<ul>
<li>hrdina bude mÃ­t nÄ›kolik zbranÃ­</li>
<li>po kaÅ¾dÃ©m Ãºtoku si hrdina vymÄ›nÃ­ zbraÅˆ za nÃ¡sledujÃ­cÃ­ v inventÃ¡Å™i
<ul>
<li>realizujte to posunovÃ¡nÃ­m zbranÃ­ v inventÃ¡Å™i
<ul>
<li>zazÃ¡lohujeme si nultÃ½ prvek v poli do promÄ›nnÃ©</li>
<li>prvnÃ­ prvek nakopÃ­rujeme do nultÃ©ho prvku</li>
<li>druhÃ½ prvek nakopÃ­rujeme do prvnÃ­ho prvku atd</li>
<li>nÃ¡slednÄ› na poslednÃ­ index uloÅ¾Ã­me hodnotu zazÃ¡lohovanou v promÄ›nnÃ©</li>
</ul>
</li>
<li>alternativnÄ› si pamatujte index aktuÃ¡lnÃ­ zbranÄ› a ten inkrementujeme
<ul>
<li>pokud bude index vetÅ¡Ã­ nebo roven poÄtu prvkÅ¯, tak jej vrÃ¡tÃ­me opÄ›t na zaÄÃ¡tek</li>
<li>mÅ¯Å¾eme elegantnÄ› takÃ© vyuÅ¾Ã­t operÃ¡tor zbytku po dÄ›lenÃ­ - tÃ­m nÃ¡m odpadne podmÃ­nka Äi ternÃ¡rnÃ­ vÃ½raz</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>prohazovÃ¡nÃ­ zbranÃ­ dvou nepÅ™Ã¡tel po kaÅ¾dÃ©m Ãºtoku</li>
<li>nÃ¡hodnÃ© uzdravovÃ¡nÃ­ a postupnÃ¡ regenerace Å¡tÃ­tu</li>
</ul>
<p><a href="https://en.wikipedia.org/wiki/Box-drawing_character">RÃ¡meÄky</a> mÅ¯Å¾eme kreslit pomocÃ­ Unicode znakÅ¯ - staÄÃ­ je jenom zkopÃ­rovat a vloÅ¾it do <code>printf</code>.</p>
<p>Barvy v terminÃ¡lu mÅ¯Å¾eme mÄ›nit pomocÃ­ escape sekvencÃ­:</p>
<pre><code class="language-c">#define RESET &quot;\x1B[0m&quot;
#define RED &quot;\x1B[31m&quot;
#define GREEN &quot;\x1B[32m&quot;
#define YELLOW &quot;\x1B[33m&quot;
#define BLUE &quot;\x1B[34m&quot;
#define MAGENTA &quot;\x1B[35m&quot;
#define CYAN &quot;\x1B[36m&quot;
#define WHITE &quot;\x1B[37m&quot;
...
printf(RED &quot;%d&quot; RESET, hp_left); 
</code></pre>
<p>NÃ¡vrh hry takÃ© mÅ¯Å¾ete pozdÄ›ji vylepÅ¡it pomocÃ­ <a href="ulohy/../c/struktury/vlastni_datove_typy.html">struktury</a> <code>Player</code>, kterÃ¡ by obsahovala Å¾ivoty, Å¡tÃ­t a zbranÄ› jednoho hrÃ¡Äe po kupÄ›.</p>
<h1><a class="header" href="#dvourozmÄ›rnÃ©-pole" id="dvourozmÄ›rnÃ©-pole">DvourozmÄ›rnÃ© pole</a></h1>
<h2><a class="header" href="#vytisknutÃ­-matice" id="vytisknutÃ­-matice">VytisknutÃ­ matice</a></h2>
<p>VytvoÅ™te funkci <code>print_matrix</code>, kterÃ¡ vypÃ­Å¡e obrÃ¡zek reprezentovanÃ½
<a href="ulohy/../c/pole/vicerozmerna_pole.html">dvourozmÄ›rnÃ½m</a> (2D) polem.</p>
<pre><code class="language-c">void print_matrix(int* matrix, int rows, int cols);
</code></pre>
<p>ProjdÄ›te matici po Å™Ã¡dcÃ­ch a sloupcÃ­ch a vypiÅ¡te jednotlivÃ© prvky.</p>
<h2><a class="header" href="#vykreslenÃ­-hvÄ›zdice" id="vykreslenÃ­-hvÄ›zdice">VykreslenÃ­ hvÄ›zdice</a></h2>
<p>VytvoÅ™te funkci <code>draw_star</code>, kterÃ¡ do 2D matice vykreslÃ­ hvÄ›zdici.</p>
<pre><code class="language-c">void draw_star(int* matrix, int rows, int cols);
</code></pre>
<pre><code>X    X    X
 X   X   X 
  X  X  X  
   X X X   
    XXX    
XXXXXXXXXXX
    XXX    
   X X X   
  X  X  X  
 X   X   X 
X    X    X
</code></pre>
<p>HvÄ›zdici mÅ¯Å¾ete vykreslit do pole pomocÃ­ jedinÃ©ho cyklu.
Zkuste vytvoÅ™it funkce na vykreslenÃ­ dalÅ¡Ã­ch tvarÅ¯ (ÄÃ¡ra, Ätverec, kruÅ¾nice, trojÃºhelnÃ­k, â€¦).</p>
<h2><a class="header" href="#nÃ¡sobenÃ­-matice-skalÃ¡rem" id="nÃ¡sobenÃ­-matice-skalÃ¡rem">NÃ¡sobenÃ­ matice skalÃ¡rem</a></h2>
<p>VytvoÅ™te funkci <code>matrix_mul_scalar</code>, kterÃ¡ vynÃ¡sobÃ­ kaÅ¾dÃ½ prvek matice ÄÃ­slem <code>k</code>. </p>
<pre><code class="language-c">void matrix_mul_scalar(int* matrix, int rows, int cols, int k);
</code></pre>
<p><img src="ulohy/../static/img/matrix_scalar.svg" alt="NÃ¡sobenÃ­ matice skalÃ¡rem" /></p>
<h2><a class="header" href="#nÃ¡sobenÃ­-matice-vektorem" id="nÃ¡sobenÃ­-matice-vektorem">NÃ¡sobenÃ­ matice vektorem</a></h2>
<p>VytvoÅ™te funkci <code>matrix_mul_vector</code>, kterÃ¡ vynÃ¡sobÃ­ matici vektorem.</p>
<pre><code class="language-c">int* matrix_mul_vec(int* matrix, int rows, int cols, int *vec, int len);
</code></pre>
<!--
![NÃ¡sobenÃ­ matice vektorem](../static/img/matrix_vector.svg)
-->
<p><upr-matrix-mul a="[[1, 2, 3], [4, 5, 6], [7, 8, 9]]" b="[[10], [20], [30]]"></upr-matrix-mul></p>
<h2><a class="header" href="#nÃ¡sobenÃ­-matice-maticÃ­" id="nÃ¡sobenÃ­-matice-maticÃ­">NÃ¡sobenÃ­ matice maticÃ­</a></h2>
<p>VytvoÅ™te funkci pro nÃ¡sobenÃ­ matice \( A \) o rozmÄ›rech \( rows_1 \times cols_1 \) s druhou matici \( B \) o rozmÄ›rech \( rows_2 \times cols_2 \).
Funkce vrÃ¡tÃ­ <code>NULL</code> v pÅ™Ã­padÄ›, Å¾e matice nepÅ¯jdou vynÃ¡sobit napÅ™. v pÅ™Ã­padÄ›, Å¾e poÄet Å™Ã¡dkÅ¯ prvnÃ­ matice nenÃ­ shodnÃ½ s poÄtem sloupcÅ¯ druhÃ© matice.
VÃ½slednou matici o rozmÄ›rech \( rows_1 \times cols_1 \) alokujte dynamicky.</p>
<upr-container>
  <upr-matrix-mul a="[[1, 2, 3], [4, 5, 6]]" b="[[10, 20], [30, 40], [50, 60]]"></upr-matrix-mul>
  <!--
  <upr-arrow dst="table" dst-anchor="south" src-anchor="north">a</upr-arrow>
  <upr-arrow dst="table:nth-of-type(2)" dst-anchor="south" src-anchor="north">b</upr-arrow>
  <upr-arrow dst="table:nth-of-type(3)" dst-anchor="south" src-anchor="north">result</upr-arrow>
  -->
</upr-container>
<h1><a class="header" href="#digitÃ¡lnÃ­-hodiny" id="digitÃ¡lnÃ­-hodiny">DigitÃ¡lnÃ­ hodiny</a></h1>
<upr-segment />
<p>VytvoÅ™me real-time digitÃ¡lnÃ­ hodiny ukazujÃ­cÃ­ aktuÃ¡lnÃ­ Äas ve stylu <a href="https://en.wikipedia.org/wiki/Seven-segment_display">7-segmentovÃ½ch</a> displejÅ¯.</p>
<p>Cifry hodin budeme vykreslovat do 2D matice realizovanÃ© pomocÃ­ jednodimenzionÃ¡lnÃ­ho pole.
Jeden segmentovÃ½ displej bude mÃ­t dÃ©lku Äi vÃ½Å¡ku napÅ™Ã­klad 3 znaky.
Mezi kaÅ¾dou cifrou bude jeden znak volnÃ½.
Na zÃ¡kladÄ› tÄ›chto parametrÅ¯ vypoÄÃ­tÃ¡me potÅ™ebnou velikost 2D matice a nÃ¡slednÄ› alokujeme potÅ™ebnou pamÄ›Å¥.</p>
<p>Pro ÄitelnÄ›jÅ¡Ã­ kÃ³d bude vhodnÃ© vytvoÅ™it nÃ¡sledujÃ­cÃ­ funkci:</p>
<pre><code class="language-c">void screen_draw_pixel(char* screen, int width, int height, int x, int y, char c)
</code></pre>
<p>Tato funkce vykreslÃ­ znak <code>c</code> (mÅ™Ã­Å¾ku nebo mezeru) na souÅ™adnici <code>[x, y]</code>.
UvnitÅ™ funkce by takÃ© mÄ›la byt kontrola, zda se souÅ™adnice nevyskytuje mimo vykreslovanou plochu pro rychlejÅ¡Ã­ detekci pÅ™Ã­padnÃ½ch chyb.</p>
<p>Segmenty jsou reprezentovanÃ© vodorovnou Äi svislou Äarou.
VytvoÅ™Ã­me si funkci pro kreslenÃ­ vodorovnÃ© ÄÃ¡ry:</p>
<pre><code class="language-c">void screen_draw_hline(char* screen, int width, int height, int x, int y, int len)
</code></pre>
<p>V cyklu dÃ©lky <code>len</code> budeme nÃ¡slednÄ› vykreslovat pixely pomocÃ­ dÅ™Ã­ve vytvoÅ™enÃ© funkce <code>screen_draw_pixel</code>.
ObdobnÄ› vytvoÅ™Ã­me i funkci <code>screen_draw_vline</code> pro vykreslenÃ­ vertikÃ¡lnÃ­ ÄÃ¡ry.</p>
<p>NÃ¡slednÄ› si vytvoÅ™Ã­me funkci, kterÃ¡ nÃ¡m vykreslÃ­ pro <code>n</code>-tou cifru segment <code>s</code> pomocÃ­ dÅ™Ã­ve vytvoÅ™enÃ½ch funkcÃ­ kreslenÃ­ ÄÃ¡r:</p>
<pre><code class="language-c">void screen_draw_segment(char* screen, int width, int height, int n, int s);
</code></pre>
<p>A potÃ© si udÄ›lÃ¡me funkci pro vykreslenÃ­ ÄÃ­slice <code>num</code>:</p>
<pre><code class="language-c">void screen_draw_num(char* screen, int width, int height, int n, int num);
</code></pre>
<p>AlternativnÄ› takÃ© mÅ¯Å¾eme obÄ› funkce spojit do jednÃ© a informaci o zobrazovanÃ½ch segmentech zakÃ³dovat do bitÅ¯, kde na nejniÅ¾Å¡Ã­m bitu je jedniÄka, pokud mÃ¡ svÃ­tit segment G.
DÃ­ky tÃ©to ÃºpravÄ› se nÃ¡m kod zjednoduÅ¡Ã­.</p>
<pre><code>//     ABCDEFG
// 0 - 1111110
// 1 - 0110000
</code></pre>
<p>Po ÃºspÄ›Å¡nÃ©m otestovÃ¡nÃ­ vÅ¡ech cifer si mÅ¯Å¾eme vytvoÅ™it nekoneÄnou smyÄku a zobrazovat aktuÃ¡lnÃ­ Äas:</p>
<pre><code class="language-c">#include &lt;time.h&gt;

int main() {
  char *display = ...;

  for(;;) {
    // vymazani terminalu
    printf(&quot;\e[1;1H\e[2J&quot;);

    // TODO: vykresleni aktualniho casu
    time_t t = time(NULL);
    struct tm *tm = localtime(&amp;t);
    printf(&quot;%d:%d:%d\n&quot;, tm-&gt;tm_hour, tm-&gt;tm_min, tm-&gt;tm_sec);

    usleep(1000 * 1000);
  }
}
</code></pre>
<h1><a class="header" href="#text-2" id="text-2">Text</a></h1>
<p>K vyÅ™eÅ¡enÃ­ tÄ›chto Ãºloh by vÃ¡m mÄ›lo staÄit znÃ¡t <a href="ulohy/../c/text/retezce.html">Å™etÄ›zce</a> a <a href="ulohy/../c/text/vstupavystup.html">vstupnÄ›/vÃ½stupnÃ­ operace</a>
(a samozÅ™ejmÄ› veÅ¡kerÃ© pÅ™edchozÃ­ uÄivo).</p>
<h2><a class="header" href="#pÅ™evod-na-velkÃ©-znaky" id="pÅ™evod-na-velkÃ©-znaky">PÅ™evod na velkÃ© znaky</a></h2>
<p>VytvoÅ™te funkci, kterÃ¡ pÅ™evede textovÃ½ Å™etÄ›zec na velkÃ© znaky.</p>
<pre><code class="language-c">char str[] = { &quot;hello&quot; };
uppercase(str);
// str by se zde mÄ›l rovnat &quot;HELLO&quot;
</code></pre>
<h2><a class="header" href="#nahrazenÃ­-znaku" id="nahrazenÃ­-znaku">NahrazenÃ­ znaku</a></h2>
<p>VytvoÅ™te funkci, kterÃ¡ v Å™etÄ›zci nahradÃ­ vÅ¡echny vÃ½skyty danÃ©ho znaku za znak <code>'X'</code>.</p>
<pre><code class="language-c">char str[] = { &quot;hello&quot; };
replace(str, 'l');
// str by se zde mÄ›l rovnat &quot;heXXo&quot;
</code></pre>
<h2><a class="header" href="#Å ifrovÃ¡nÃ­-Å™etÄ›zce" id="Å ifrovÃ¡nÃ­-Å™etÄ›zce">Å ifrovÃ¡nÃ­ Å™etÄ›zce</a></h2>
<p>VytvoÅ™te funkci, kterÃ¡ &quot;zaÅ¡ifruje&quot; Å™etÄ›zec tÃ­m, Å¾e ke kaÅ¾dÃ©mu znaku pÅ™iÄte ÄÃ­slo (klÃ­Ä).
K nÃ­ vytvoÅ™te funkci, kterÃ¡ Å™etÄ›zec opÄ›t odÅ¡ifruje (odeÄtenÃ­m klÃ­Äe).</p>
<pre><code class="language-c">char str[] = { &quot;abc&quot; };
encrypt(str, 1);
// str by se zde mÄ›l rovnat &quot;bcd&quot;
decrypt(str, 1);
// str by se zde mÄ›l opÄ›t rovnat &quot;abc&quot;
</code></pre>
<h2><a class="header" href="#dÃ©lka-Å™etÄ›zce" id="dÃ©lka-Å™etÄ›zce">DÃ©lka Å™etÄ›zce</a></h2>
<p>VytvoÅ™te funkci <code>my_strlen</code>, kterÃ¡ vypoÄte dÃ©lku Å™etÄ›zce (obdoba funkce
<a href="https://devdocs.io/c/string/byte/strlen"><code>strlen</code></a> ze standardnÃ­ knihovny <em>C</em>).</p>
<pre><code class="language-c">my_strlen(&quot;&quot;);          // 0
my_strlen(&quot;abc&quot;);       // 3
my_strlen(&quot;abc 0 asd&quot;); // 9
</code></pre>
<h2><a class="header" href="#porovnÃ¡vÃ¡nÃ­-Å™etÄ›zcÅ¯" id="porovnÃ¡vÃ¡nÃ­-Å™etÄ›zcÅ¯">PorovnÃ¡vÃ¡nÃ­ Å™etÄ›zcÅ¯</a></h2>
<p>VytvoÅ™te funkci, kterÃ¡ vrÃ¡tÃ­ <code>true</code>, pokud jsou dva pÅ™edanÃ© Å™etÄ›zce stejnÃ©.
VytvoÅ™te i variantu funkce, kterÃ¡ porovnÃ¡vÃ¡ Å™etÄ›zce bez ohledu na velikosti znakÅ¯.</p>
<pre><code class="language-c">strequal(&quot;ahoj&quot;, &quot;ahoj&quot;);               // 1
strequal(&quot;ahoj&quot;, &quot;aho&quot;);                // 0
strequal_ignorecase(&quot;ahoj&quot;, &quot;AhOj&quot;);    // 1
</code></pre>
<h2><a class="header" href="#palindrom" id="palindrom">Palindrom</a></h2>
<p>VytvoÅ™te funkci, kterÃ¡ vrÃ¡tÃ­ <code>true</code>, pokud je pÅ™edanÃ½ Å™etÄ›zec
<a href="https://cs.wikipedia.org/wiki/Palindrom">palindrom</a> (slovo, kterÃ© se Äte stejnÄ› zepÅ™edu i pozpÃ¡tku).</p>
<p><img src="ulohy/../static/img/palindrom.svg" alt="palindrom" /></p>
<h2><a class="header" href="#histogram" id="histogram">Histogram</a></h2>
<p>VytvoÅ™te funkci, kterÃ¡ vypoÄte <a href="https://cs.wikipedia.org/wiki/Histogram">histogram</a> znakÅ¯ v Å™etÄ›zci.
Histogram je pole, ve kterÃ©m prvek na pozici <code>x</code> udÃ¡vÃ¡, kolikrÃ¡t se znak <code>x</code> vyskytoval v danÃ©m Å™etÄ›zci.</p>
<pre><code class="language-c">int histogram[255] = {};
calc_histogram(&quot;aabacc&quot;, histogram);
// histogram['a'] == 3
// histogram['b'] == 1
// histogram['c'] == 2
// histogram['d'] == 0
</code></pre>
<h2><a class="header" href="#pÅ™evod-textu-na-ÄÃ­slo" id="pÅ™evod-textu-na-ÄÃ­slo">PÅ™evod textu na ÄÃ­slo</a></h2>
<p>VytvoÅ™te funkci, kterÃ¡ pÅ™evede Å™etÄ›zec na ÄÃ­slo v desÃ­tkovÃ© soustavÄ›. Pokud ÄÃ­slo nelze pÅ™evÃ©st,
vraÅ¥te hodnotu <code>0</code>.</p>
<pre><code class="language-c">convert(&quot;5&quot;);   // vrÃ¡tÃ­ int s hodnotou 5
convert(&quot;123&quot;); // vrÃ¡tÃ­ int s hodnotou 123
</code></pre>
<p>Zkuste pÅ™idat i podporu pro zÃ¡pornÃ¡ ÄÃ­sla.</p>
<h2><a class="header" href="#naÄÃ­tÃ¡nÃ­-pinu" id="naÄÃ­tÃ¡nÃ­-pinu">NaÄÃ­tÃ¡nÃ­ PINu</a></h2>
<p>NaÄtÄ›te od uÅ¾ivatele PIN (4 ÄÃ­slice). PotÃ© opakovanÄ› vyzÃ½vejte uÅ¾ivatele k zadÃ¡nÃ­ PINu. Pokud
uÅ¾ivatel zadÃ¡ 3x nesprÃ¡vnÃ½ PIN, vypiÅ¡te chybovou hlÃ¡Å¡ku a ukonÄete program. Pokud uÅ¾ivatel zadÃ¡ PIN sprÃ¡vnÄ›,
tak vypiÅ¡te <code>&quot;Uspesne zadani PINu&quot;</code> a ukonÄete program.</p>
<h2><a class="header" href="#hÃ¡dacÃ­-hra-guessing-game" id="hÃ¡dacÃ­-hra-guessing-game">HÃ¡dacÃ­ hra (<em>guessing game</em>)</a></h2>
<p>Vygenerujte <a href="ulohy/../ruzne/nahodna_cisla.html">nÃ¡hodnÃ© ÄÃ­slo</a>. PotÃ© nechte uÅ¾ivatele hÃ¡dat, jakÃ© ÄÃ­slo
program vygeneroval. Po kaÅ¾dÃ©m tipu uÅ¾ivateli dejte vÄ›dÄ›t, jestli uhÃ¡dl sprÃ¡vnÄ› nebo jestli jeho
tip byl vyÅ¡Å¡Ã­ Äi niÅ¾Å¡Ã­ neÅ¾ ÄÃ­slo, kterÃ© hÃ¡dÃ¡.</p>
<h1><a class="header" href="#kalkulaÄka" id="kalkulaÄka">KalkulaÄka</a></h1>
<p>NaÄtÄ›te ze vstupu programu nebo z <a href="ulohy/../ruzne/funkce_main.html">parametrÅ¯ pÅ™Ã­kazovÃ©ho Å™Ã¡dku</a> matematickÃ½
vÃ½raz, kterÃ½ bude obsahovat celÃ¡ ÄÃ­sla a operÃ¡tory <code>+</code>, <code>-</code>, <code>/</code>, <code>*</code> a vypiÅ¡te vÃ½sledek tohoto
vÃ½razu.</p>
<ul>
<li><em>Varianta 1</em>: PouÅ¾ijte klasickÃ½ zÃ¡pis v <a href="https://cs.wikipedia.org/wiki/Infixov%C3%A1_notace">infixovÃ© notaci</a>.
NemusÃ­te Å™eÅ¡it prioritu operÃ¡torÅ¯.</li>
<li><em>Varianta 2</em>: PÅ™idejte podporu pro prioritu operÃ¡torÅ¯ a zÃ¡vorky <code>(</code>, <code>)</code>. PouÅ¾ijte algoritmus
<a href="https://cs.wikipedia.org/wiki/Algoritmus_shunting-yard">Shunting yard</a>.</li>
<li><em>Varianta 3</em>: PouÅ¾ijte <a href="https://cs.wikipedia.org/wiki/Postfixov%C3%A1_notace">postfixovou notaci</a>.
Zde bude fungovat priorita operÃ¡torÅ¯ a &quot;zÃ¡vorkovÃ¡nÃ­&quot; bez nutnosti sloÅ¾itÃ©ho naÄÃ­tÃ¡nÃ­ vstupu z
varianty 2.</li>
</ul>
<h1><a class="header" href="#stÅ™elba-na-terÄ" id="stÅ™elba-na-terÄ">StÅ™elba na terÄ</a></h1>
<p>VytvoÅ™te program, kterÃ½ naÄte souÅ™adnice terÄÅ¯ a stÅ™el, a vykreslÃ­ je do obrÃ¡zku ve formÃ¡tu
vektorovÃ© grafiky <a href="https://en.wikipedia.org/wiki/Scalable_Vector_Graphics">SVG</a>. Pokud si vygenerovanÃ½ SVG obrÃ¡zek otevÅ™ete v internetovÃ©m prohlÃ­Å¾eÄi, tak by se po najetÃ­
myÅ¡i na terÄ mÄ›lo ukÃ¡zat skÃ³re vybranÃ©ho terÄe.</p>
<p><object data="terc/01_basic.svg"></object></p>
<p>Ze vstupu pÅ™eÄtÄ›te poÄet terÄÅ¯ a nÃ¡slednÄ› si dynamicky alokujte 3 pole typu <code>float</code> pro <code>x</code> souÅ™adnice terÄÅ¯, <code>y</code> souÅ™adnice terÄÅ¯ a polomÄ›ry terÄÅ¯.</p>
<p>PotÃ© pro kaÅ¾dÃ½ terÄ pÅ™eÄtÄ›te jeho <code>x</code> souÅ™adnici, <code>y</code> souÅ™adnici, polomÄ›r a uloÅ¾te je do
odpovÃ­dajÃ­cÃ­ch polÃ­.
NapÅ™Ã­klad nÃ¡sledujÃ­cÃ­ vstup nÃ¡m popisuje 2 terÄe.
PrvnÃ­ terÄ mÃ¡ stÅ™ed na souÅ™adnici \( [50, 70 ] \) a polomÄ›r \( 40 \) a druhÃ½ terÄ leÅ¾Ã­ na stÅ™edu \( [160, 90 ] \) s polomÄ›rem \( 60 \).</p>
<pre><code>2
50 70 40
160 90 60
</code></pre>
<p>Tento vstup nezadÃ¡vejte poÅ™ad dokola z klÃ¡vesnice, ale <a href="ulohy/../c/text/vstupavystup.html#standardn%C3%AD-souborov%C3%A9-deskriptory">pÅ™esmÄ›rujte</a>
si jej do programu ze souboru:</p>
<pre><code>$ ./main &lt; terce.txt
</code></pre>
<p>TerÄe si pomocÃ­ <code>printf</code> vykreslete do vektorovÃ©ho obrÃ¡zku ve formÃ¡tu svg, ve kterÃ©m lze pomocÃ­ tagÅ¯ definovat Ãºtvary.
Ãštvary v obrÃ¡zku obalte tagem <code>svg</code>:</p>
<pre><code class="language-xml">&lt;svg xmlns='http://www.w3.org/2000/svg'&gt;
  &lt;!-- kresleni kruhu --&gt;
&lt;/svg&gt;
</code></pre>
<p>TerÄ se stÅ™edem \( [50, 70] \) a polomÄ›rem \( 40 \) lze vykreslit pomocÃ­:</p>
<pre><code class="language-svg">&lt;circle cx='50' cy='70' r='40' stroke='black' fill='red' /&gt;
</code></pre>
<p>VytvoÅ™enÃ½ SVG obrÃ¡zek si ze standardnÃ­ho vÃ½stupu <a href="ulohy/../c/text/vstupavystup.html#standardn%C3%AD-souborov%C3%A9-deskriptory">pÅ™esmÄ›rujte</a>
do souboru a otevÅ™ete si jej napÅ™Ã­klad v prohlÃ­Å¾eÄi firefox.</p>
<pre><code class="language-shell">$ ./main &lt; terce.txt &gt; obrazek.svg
$ firefox obrazek.svg
</code></pre>
<p>NÃ¡slednÄ› si ze vstupu pÅ™eÄtÄ›te poÄet stÅ™el a alokujte pro nÄ› dvÄ› pole - jedno bude reprezentovat <code>x</code> souÅ™adnice a druhÃ© <code>y</code> souÅ™adnice jednotlivÃ½ch stÅ™el.
SouÅ™adnice si nÃ¡slednÄ› pÅ™eÄtÄ›te do tÄ›chto polÃ­.
Pole si projdÄ›te a vykreslete do obrÃ¡zku jako kruhy napÅ™. s polomÄ›rem \( 4 \).</p>
<p>StÅ™ela zasÃ¡hla terÄ, pokud leÅ¾Ã­ na kruhu.
JinÃ½mi slovy - stÅ™ela zasÃ¡hla terÄ, pokud je vzdÃ¡lenost od stÅ™edu terÄe menÅ¡Ã­ neÅ¾ polomÄ›r terÄe.
VzdÃ¡lenost vypoÄÃ­tÃ¡me jednoduÅ¡e pomocÃ­ Pythagorovy vÄ›ty, kde <code>x</code> odvÄ›sna je rozdÃ­l mezi <code>x</code> souÅ™adnici stÅ™edu terÄe a <code>x</code> souÅ™adnici stÅ™ely. OdvÄ›sna <code>y</code> lze vypoÄÃ­tat obdobnÄ› a potÃ© mÅ¯Å¾eme vypoÄÃ­tat pÅ™eponu, kterÃ¡ reprezentuje vzdÃ¡lenost stÅ™ely od stÅ™edu terÄe.</p>
<svg>
   <circle cx="50" cy="50" r="50" fill="rgb(190, 83, 85)" />
   <circle cx="75" cy="20" r="5" fill="black" />
   <line x1=50 y1=50 x2=75 y2=20 stroke='black'/>
   <line x1=50 y1=50 x2=75 y2=50 stroke='black'/>
   <line x1=75 y1=20 x2=75 y2=50 stroke='black'/>
   <text x=60 y=35 text-anchor="end">dist</text>
</svg>
<p>ProtoÅ¾e mÃ¡me vÃ­ce terÄÅ¯ a vÃ­ce stÅ™el, tak musÃ­me aplikovat vÃ½poÄet vzdÃ¡lenosti mezi kaÅ¾dou stÅ™elou
a kaÅ¾dÃ½m terÄem pomocÃ­ dvou vnoÅ™enÃ½ch <code>for</code> cyklÅ¯.
VnÄ›jÅ¡Ã­ cyklus bude prochÃ¡zet stÅ™ely a vnitÅ™nÃ­ cyklus bude prochÃ¡zet terÄe.
Ve vnitÅ™nÃ­m cyklu vypoÄÃ­tÃ¡me vzdÃ¡lenost mezi stÅ™elou a terÄem a pokud je menÅ¡Ã­ neÅ¾ polomÄ›r,
tak tento konkrÃ©tnÃ­ terÄ byl zasaÅ¾en stÅ™elou z vnÄ›jÅ¡Ã­ho cyklu.
V pÅ™Ã­padÄ›, Å¾e se vÃ­ce kruhÅ¯ pÅ™ekrÃ½vÃ¡, tak stÅ™ela zasÃ¡hla terÄ s menÅ¡Ã­m polomÄ›rem.
Budeme tedy hledat zasÃ¡hnutÃ½ terÄ s nejmenÅ¡Ã­m polomÄ›rem.</p>
<p>SkÃ³re pÅ™i zasaÅ¾enÃ­ stÅ™edu s polomÄ›rem 20 je 10 bodÅ¯ a body postupnÄ› klesajÃ­.
ZdrojovÃ½ kÃ³d SVG ukÃ¡zek si mÅ¯Å¾ete zobrazit.</p>
<details>
<summary>Dva terÄe</summary>
<p><object data="terc/01_basic.svg"></object></p>
<pre><code>2
50 70 40
160 90 60

4
25 70
80 90
150 100
55 140
</code></pre>
</details>
<details>
<summary>PÅ™ekrÃ½vajÃ­cÃ­ se terÄe</summary>
<p><object data="terc/02_overlayed.svg"></object></p>
<pre><code>2
160 90 60
90 70 40

4
125 70 
80 90
150 100
55 140
</code></pre>
</details>
<details>
<summary>PÅ™ekrÃ½vajÃ­cÃ­ se terÄe se stejnÃ½m stÅ™edem</summary>
<p><object data="terc/03_same_c.svg"></object></p>
<pre><code>3
50 70 40
160 90 60
160 90 40
7
25 70
80 90
55 140
125 60
140 130
150 100
215 100
</code></pre>
</details>
<h1><a class="header" href="#ÄŒiÅ¡tÄ›nÃ­-chatu" id="ÄŒiÅ¡tÄ›nÃ­-chatu">ÄŒiÅ¡tÄ›nÃ­ chatu</a></h1>
<p>NapiÅ¡te program, kterÃ½ transformuje cO0l zPrÃ¡Vy<img height="20" src="https://emoji.gg/assets/emoji/GWjiangoOmegaLUL.png"><img height="20" src="https://emoji.gg/assets/emoji/1219_KEKW.png"> z chatu do ÄitelnÃ© podoby.
ZprÃ¡vy jsou do naÅ¡eho programu pÅ™esmÄ›rovÃ¡ny na standardnÃ­ vstup - Ãºkolem bude ÄÃ­st zprÃ¡vy nebo ÄÃ¡sti zprav po Å™Ã¡dcÃ­ch a provÃ¡dÄ›t nÃ¡sledujÃ­cÃ­ Ãºpravy:</p>
<ol>
<li>
<p>Odstranit bÃ­lÃ© znaky (whitespace - mezera, tabulÃ¡tor, ...) ze zaÄÃ¡tku a konce kaÅ¾dÃ©ho Å™Ã¡dku</p>
<p>moÅ¾nÃ© Å™eÅ¡enÃ­:</p>
<ol>
<li>najÃ­t pozici prvnÃ­ho non-whitespace znaku</li>
<li>pÅ™ekopÃ­rovat vÅ¡echny znaky od tÃ©to pozice na zaÄÃ¡tek pomocÃ­ vlastnÃ­ho cyklu nebo <code>strcpy</code>, <code>memcpy</code> Äi <code>memmove</code></li>
<li>cyklem jÃ­t od konce Å™etÄ›zce a najÃ­t prvnÃ­ non-whitespace znak</li>
<li>uloÅ¾it za nÄ›j novÃ½ konec <code>\0</code></li>
</ol>
</li>
<li>
<p>Transformovat cO0L tExT do ÄitelnÃ© podoby</p>
<p>KaÅ¾dÃ¡ vÄ›ta zaÄne velkÃ½m pÃ­smem a vÅ¡echna ostatnÃ­ pÃ­smena ve vÄ›tÄ› budou pÅ™evedena na malÃ¡ pÃ­smena.
VÄ›ta je ukonÄena znakem <code>.</code>, <code>!</code> nebo <code>?</code>.</p>
<p>NapÅ™. si pÅ™ed cyklem vytvoÅ™it promÄ›nnou indikujÃ­cÃ­ start novÃ© vÄ›ty.
Cyklem projÃ­t vÅ¡echny znaky a prvnÃ­ pÃ­smeno vÄ›ty zvÄ›tÅ¡it a zbytek zmenÅ¡ovat.
TeÄka, otaznÃ­k Äi vykÅ™iÄnÃ­k potÃ© nastavÃ­ nastavÃ­ promÄ›nnou indikujÃ­cÃ­ novou vÄ›tu.</p>
</li>
<li>
<p>Nahradit opakujÃ­cÃ­ se znakÅ¯ jednÃ­m vÃ½skytem</p>
<p>NapÅ™. si pamatovat promÄ›nnou s pÅ™edchozÃ­m znakem nebo porovnÃ¡vat pÅ™Ã­mo pÅ™edchozÃ­ znak - pozor abychom nepÅ™istoupili pÅ™ed/za pole.
Na velikosti pÃ­smen nebude zÃ¡leÅ¾et - <code>xXxxXx</code> se takÃ© nahradÃ­ jednÃ­m <code>x</code>.
MÅ¯Å¾eme si udrÅ¾ovat dva indexy - jeden ve vstupnÃ­m stringu a druhÃ½ ve vÃ½stupnÃ­m stringu.
Pokud se znak opakuje, tak jej nepÅ™idÃ¡vÃ¡me do vÃ½stupnÃ­ho stringu.</p>
</li>
<li>
<p>Smazat smajlÃ­ky zapsanÃ© pomocÃ­ <code>:nazev:</code></p>
<p>ProchÃ¡zÃ­me znak po znaku a pamatujeme si, jestli jsme narazili na <code>:</code>.
Pokud ano, tak nepÅ™idÃ¡vÃ¡me znaky do vÃ½stupnÃ­ho stringu.
Pokud nenarazÃ­me na ukonÄovacÃ­ <code>:</code>, tak text musÃ­me do stringu pÅ™idat - viz ukÃ¡zka v testu.</p>
</li>
<li>
<p>Cenzurovat zakÃ¡zanÃ¡ slova pomocÃ­ hvÄ›zdiÄek</p>
<p>KaÅ¾dÃ© slovo z pole blocklistu o velikosti <code>sizeof(blocklist) / sizeof(blocklist[0])</code> zkusÃ­me najÃ­t v Å™etÄ›zci.
Pokud najdeme, tak celÃ© slovo vyhvÄ›zdiÄkujeme a zkusÃ­me hledat dalÅ¡Ã­ vÃ½skyt od konce tohoto vÃ½skytu.
PÅ™i hledÃ¡nÃ­ nebude zÃ¡leÅ¾et na velikosti pÃ­smen.</p>
<pre><code class="language-c">const char *blocklist[] = {
   &quot;windows&quot;,
   &quot;mac&quot;,
   &quot;c#&quot;,
   &quot;fortnite&quot;,
   &quot;php&quot;,
   &quot;javascript&quot;,
   &quot;.net&quot;,
};
// blocklist[0] je &quot;windows&quot;
</code></pre>
</li>
</ol>
<h1><a class="header" href="#pÅ™ekladaÄ-jazyka-brainfuck" id="pÅ™ekladaÄ-jazyka-brainfuck">PÅ™ekladaÄ jazyka Brainfuck</a></h1>
<p>Jazyk <a href="https://esolangs.org/wiki/Brainfuck">Brainfuck</a> je velmi jednoduchÃ½ esoterickÃ½ programovacÃ­
jazyk obsahujÃ­cÃ­ pouze osm instrukcÃ­, lineÃ¡rnÃ­ pamÄ›Å¥ a adresu aktuÃ¡lnÃ­ pamÄ›Å¥ovÃ© buÅˆky. Jedna buÅˆka
odpovÃ­dÃ¡ jednomu bytu.</p>
<ul>
<li>Instrukce <code>+</code> inkrementuje hodnotu aktuÃ¡lnÃ­ buÅˆky.</li>
<li>Instrukce <code>-</code> dekrementuje hodnotu aktuÃ¡lnÃ­ buÅˆky.</li>
<li>Instrukce <code>&gt;</code> inkrementuje adresu buÅˆky (po inkrementaci ukazujeme na nÃ¡sledujÃ­cÃ­ buÅˆku).</li>
<li>Instrukce <code>&lt;</code> dekrementuje adresu buÅˆky (po dekrementaci ukazujeme na pÅ™edchÃ¡zejÃ­cÃ­ buÅˆku).</li>
<li>Instrukce <code>[</code> uvozuje zaÄÃ¡tek cyklu. Cyklus probÃ­hÃ¡, dokud hodnota buÅˆky adresovanÃ© v dobÄ›
vyhodnocovÃ¡nÃ­ podmÃ­nky nenÃ­ nulovÃ¡ (adresovanou buÅˆku mÅ¯Å¾eme mÄ›nit uvnitÅ™ cyklu).</li>
<li>Instrukce <code>]</code> pÅ™edstavuje konec tÄ›la cyklu. Jakmile program narazÃ­ na instrukce <code>]</code>, zkontroluje
hodnotu v aktuÃ¡lnÄ› adresovanÃ© pamÄ›Å¥ovÃ© buÅˆce, a buÄ se vrÃ¡tÃ­ zpÄ›t na odpovÃ­dajÃ­cÃ­ <code>[</code>, nebo je
cyklus ukonÄen a vykonÃ¡vÃ¡nÃ­ programu pokraÄuje provÃ¡dÄ›nÃ­m instrukcÃ­ bezprostÅ™ednÄ› za cyklem.</li>
<li>Instrukce <code>,</code> pÅ™eÄte jeden byte ze vstupu a uloÅ¾Ã­ hodnotu do aktuÃ¡lnÄ› adresovanÃ© buÅˆky.</li>
<li>Instrukce <code>.</code> vypÃ­Å¡e hodnotu aktuÃ¡lnÄ› adresovanÃ© buÅˆky jako ASCII znak na standardnÃ­ vÃ½stup.</li>
</ul>
<p>VÅ¡echny ostatnÃ­ znaky jsou ignorovÃ¡ny.</p>
<p>Program <code>Hello, World!</code> v jazyce Brainfuck mÅ¯Å¾e vypadat napÅ™Ã­klad nÃ¡sledovnÄ›:</p>
<pre><code>++++++++
[
    &gt;++++++++&lt;-
]
&gt;++++++++.&gt;++++++++
[
    &gt;++++++++++++&lt;-
]
&gt;+++++.+++++++..+++.&gt;++++++++
[
    &gt;+++++&lt;-
]
&gt;++++.------------.&lt;&lt;&lt;&lt;+++++++++++++++.&gt;&gt;.+++.------.--------.&gt;&gt;+.
</code></pre>
<p>Naprogramujte interpret jazyka Brainfuck. Interpret (angl. <em>interpreter</em>), je pÅ™ekladaÄ, kterÃ½
zdrojovÃ½ kÃ³d vykonÃ¡vÃ¡ pÅ™i kaÅ¾dÃ©m spuÅ¡tÄ›nÃ­ cÃ­lovÃ©ho programu. Program se tedy nikdy nekompiluje
do spustitelnÃ©ho binÃ¡rnÃ­ho souboru.</p>
<h2><a class="header" href="#implementace-1" id="implementace-1">Implementace</a></h2>
<ul>
<li>Program prochÃ¡zejte znak po znaku a jednotlivÃ© instrukce interpretujte.</li>
<li>Pokud narazÃ­te na konec cyklu (<code>]</code>), staÄÃ­ se vrÃ¡tit v textu zpÄ›t na odpovÃ­dajÃ­cÃ­ <code>[</code>.</li>
<li>NezapomeÅˆte, Å¾e cykly mÅ¯Å¾ou bÃ½t i vnoÅ™enÃ©.</li>
<li>PamÄ›Å¥ lze reprezentovat polem bytÅ¯ fixnÃ­ velikosti.</li>
<li>Adresu lze reprezentovat indexem nebo ukazatelem.</li>
<li>Vstup mÅ¯Å¾eme ÄÃ­st napÅ™Ã­klad pomocÃ­ <code>getc(stdout)</code>.</li>
<li>VÃ½stup mÅ¯Å¾eme realizovat pomocÃ­ funkce <code>putchar</code>.</li>
<li>PÅ™i vstupu a vÃ½stupu pamÄ›Å¥ interpretujte jako ASCII znaky. V opaÄnÃ½ch pÅ™Ã­padech ji lze
interpretovat jako obyÄejnÃ© ÄÃ­slo.</li>
<li>PÅ™i pÅ™Ã­stupu mimo alokovanou pamÄ›Å¥ interpret vypÃ­Å¡e chybu a pÅ™eklad programu skonÄÃ­.</li>
</ul>
<h2><a class="header" href="#ukÃ¡zkovÃ©-programy" id="ukÃ¡zkovÃ©-programy">UkÃ¡zkovÃ© programy</a></h2>
<p>Pro otestovÃ¡nÃ­ svÃ©ho pÅ™ekladaÄe mÅ¯Å¾ete vyuÅ¾Ã­t napÅ™Ã­klad nÃ¡sledujÃ­cÃ­ programy. DalÅ¡Ã­ programy
napsanÃ© v jazyce Brainfuck naleznete na internetu, pÅ™Ã­padnÄ› si mÅ¯Å¾ete zkusit napsat program
vlastnÃ­.</p>
<p>Hello, World:</p>
<pre><code>++++++++[&gt;++++++++&lt;-]&gt;++++++++.&gt;++++++++[&gt;++++++++++++&lt;-]&gt;+++++.+++++++..+++.&gt;++++++++[&gt;+++++&lt;-]&gt;++++.------------.&lt;&lt;&lt;&lt;+++++++++++++++.&gt;&gt;.+++.------.--------.&gt;&gt;+.
</code></pre>
<p>Echo (program opakujÃ­cÃ­ svÅ¯j vstup):</p>
<pre><code>+[&gt;,.&lt;]
</code></pre>
<h2><a class="header" href="#sloÅ¾itÄ›jÅ¡Ã­-varianta-1" id="sloÅ¾itÄ›jÅ¡Ã­-varianta-1">SloÅ¾itÄ›jÅ¡Ã­ varianta</a></h2>
<p>NamÃ­sto pÃ¡sky pevnÄ› danÃ© velikosti naprogramujte pamÄ›Å¥, kterÃ¡ se bude zleva i zprava zvÄ›tÅ¡ovat,
pokud se program pokusÃ­ pÅ™istoupit za hranice pÃ¡sky.</p>
<p>Zkuste mÃ­sto pÅ™Ã­mÃ© interpretace vstupnÃ­ho Å™etÄ›zce nejprve sestavit
<a href="https://en.wikipedia.org/wiki/Abstract_syntax_tree">abstraktnÃ­ syntaktickÃ½ strom (AST)</a>
reprezentujÃ­cÃ­ danÃ½ program. Tvorba AST bude vyÅ¾adovat znalosti z pozdÄ›jÅ¡Ã­ch lekcÃ­. Interpretujte
potÃ© AST, ne pÅ™Ã­mo vstupnÃ­ Å™etÄ›zec.</p>
<p>PÅ™i tvorbÄ› AST proveÄte zÃ¡kladnÃ­ optimalizace - napÅ™Ã­klad sÃ©rii inkrementacÃ­ pÅ™eveÄte na jedno
pÅ™iÄtenÃ­ vÄ›tÅ¡Ã­ho ÄÃ­sla (tedy napÅ™. sÃ©rii osmi inkrementacÃ­ pÅ™evedeme na pÅ™iÄtenÃ­ ÄÃ­sla osm).</p>
<p>Nakonec mÅ¯Å¾ete zkusit namÃ­sto interpretace program zkompilovat. Kompilovat mÅ¯Å¾ete napÅ™Ã­klad
do Assembly, nebo do <a href="https://llvm.org/docs/LangRef.html">LLVM IR kÃ³du</a>. VÃ½stup vaÅ¡eho pÅ™ekladaÄe
nakonec nechÃ¡te pÅ™eloÅ¾it assemblerem nebo LLVM.</p>
<h1><a class="header" href="#struktury-1" id="struktury-1">Struktury</a></h1>
<p>VytvoÅ™te strukturu <code>Student</code>, kterÃ¡ bude obsahovat atributy pro jeho vÄ›k, jmÃ©no, poÄet bodÅ¯ a
nejlepÅ¡Ã­ho pÅ™Ã­tele (to bude takÃ© student). DÃ¡le naimplementujte tyto funkce:</p>
<pre><code class="language-c">/**
 * Nainicializujte studenta se zadanÃ½m vÄ›kem a jmÃ©nem.
 * PoÄet bodÅ¯ i nejlepÅ¡Ã­ pÅ™Ã­tel by mÄ›li bÃ½t nastaveni na nulu.
 */
void student_init(Student* student, int age, const char* name) {}

/**
 * SpoÄÃ­tejte, kolik studentÅ¯ v pÅ™edanÃ©m poli mÃ¡ maximÃ¡lnÄ› zadanÃ½ vÄ›k.
 * PÅ™Ã­klad:
 *   Student students[3];
 *   students[0].age = 18;
 *   students[1].age = 19;
 *   students[2].age = 16;
 *
 *   count_young_students(students, 3, 18); // 2
 */
int count_young_students(Student* students, int count, int maximum_age) {}

/**
 * PÅ™iÅ™aÄte studentÅ¯m body na zÃ¡kladÄ› vÃ½sledkÅ¯ testÅ¯.
 * V poli `points` jsou body pro jednotlivÃ© studenty v poli `students`.
 * Parameter `count` obsahuje poÄet studentÅ¯ a testÅ¯.
 */
void assign_points(Student* students, const int* points, int count) {}

/**
 * VraÅ¥e v parametru `good_students` pole studentÅ¯, kteÅ™Ã­ majÃ­ alespoÅˆ 51 bodÅ¯ a v
 * parametru `good_student_count` jejich poÄet.
 * Budete muset dynamicky naalokovat novÃ© pole s odpovÃ­dajÃ­cÃ­ velikostÃ­.
 */
void filter_good_students(
    const Student* students,
    int count,
    Student** good_students,
    int* good_student_count
);

/**
 * Otestujte, jestli je student Å¡Å¥astnÃ½.
 * Student je Å¡Å¥astnÃ½, pokud:
 * 1) MÃ¡ alespoÅˆ 51 bodÅ¯, a zÃ¡roveÅˆ
 * 2) Jeho nejlepÅ¡Ã­ pÅ™Ã­tel je Å¡Å¥astnÃ½
 *
 * Pokud student nemÃ¡ nejlepÅ¡Ã­ho pÅ™Ã­tele, poklÃ¡dejte podmÃ­nku 2) za splnÄ›nou.
 */
int student_is_happy(Student* student) {}
</code></pre>
<p>K otestovÃ¡nÃ­ vaÅ¡Ã­ implementace mÅ¯Å¾ete pouÅ¾Ã­t nÃ¡sledujÃ­cÃ­ testovacÃ­ program<sup class='margin-toggle sidenote-number'>1</sup>:</p>
<span class='sidenote'><p><sup class='number'>1</sup>Implementace svÃ½ch funkcÃ­ v tomto programu umÃ­stÄ›te nad <code>main</code> a program spusÅ¥te s
<a href="ulohy/../prostredi/ladeni.html#address-sanitizer"><code>Address sanitizerem</code></a>. Pokud program nic nevypÃ­Å¡e, mÃ¡te
implementaci pravdÄ›podobnÄ› sprÃ¡vnÄ›.</p>
</span><details>
<summary>TestovacÃ­ program</summary>
<pre><code class="language-c">#include &lt;assert.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;

// Zde vloÅ¾te implementace funkcÃ­

int main()
{
    Student jirka;
    student_init(&amp;jirka, 18, &quot;Jiri Novak&quot;);
    assert(jirka.age == 18);
    assert(!strcmp(jirka.name, &quot;Jiri Novak&quot;));
    assert(jirka.points == 0);
    assert(jirka.best_friend == NULL);

    Student students[3];
    for (int i = 0; i &lt; 3; i++)
    {
        student_init(students + i, 17 + i, &quot;&quot;);
    }
    assert(count_young_students(students, 3, 18) == 2);

    int points[] = { 10, 15, 3 };
    assign_points(students, points, 3);
    assign_points(students, points, 1);
    assert(students[0].points == 20);
    assert(students[1].points == 15);
    assert(students[2].points == 3);

    Student a = {}, b = {}, c = {};
    a.points = 51;
    b.points = 50;
    c.points = 50;
    assert(student_is_happy(&amp;a));
    a.best_friend = &amp;b;
    assert(!student_is_happy(&amp;a));
    b.points = 51;
    assert(student_is_happy(&amp;a));
    b.best_friend = &amp;c;
    assert(!student_is_happy(&amp;a));
    c.points = 100;
    assert(student_is_happy(&amp;a));

    Student students2[3] = {};
    students2[0].age = 15;
    students2[2].age = 18;
    int points2[] = { 51, 20, 60 };
    assign_points(students2, points2, 3);

    Student* good_students;
    int good_students_count;
    filter_good_students(students2, 3, &amp;good_students, &amp;good_students_count);
    assert(good_students_count == 2);
    assert(good_students[0].age == 15);
    assert(good_students[1].age == 18);

    free(good_students);

    return 0;
}
</code></pre>
</details>
<h1><a class="header" href="#kreslenÃ­-obrazovky-apple-watch" id="kreslenÃ­-obrazovky-apple-watch">KreslenÃ­ obrazovky Apple Watch</a></h1>
<p>Pro tuto Ãºlohu vyuÅ¾ijte stuktury a funkce pro zÃ¡pis obrÃ¡zku formÃ¡tu <a href="ulohy/../c/aplikovane_ulohy/tga.html">TGA</a> do souboru.</p>
<p>VÅ¡e mÃ¡ svÅ¯j pÅ™Ã­bÄ›h a tak tedy zapoÄnÄ›me naÅ¡i cestu napÅ™. ve firmÄ› <a href="https://www.apple.com">Apple</a>â€¦</p>
<p>PÅ™edstavte si, Å¾e jste vÃ½vojÃ¡Å™em/kou ve firmÄ› Apple a <a href="https://en.wikipedia.org/wiki/Steve_Jobs">Steve Jobs</a> VÃ¡s povÄ›Å™Ã­ programÃ¡torskÃ½m Ãºkolem.</p>
<p>Firma aktuÃ¡lnÄ› pracuje na super tajnÃ©m projektu <a href="https://en.wikipedia.org/wiki/Apple_Watch">novÃ½ch smart hodinek</a>, kterÃ© chce uvÃ©st na trh.
VaÅ¡im Ãºkolem je pod pÅ™Ã­mÃ½m vedenÃ­m Steva Jobse (pÅ¯vodnÃ­ho zakladatele firmy) naprogramovat digitÃ¡lnÃ­ cifernÃ­k novÃ½ch hodinek.</p>
<h3><a class="header" href="#technickÃ©-specifikace-displeje" id="technickÃ©-specifikace-displeje">TechnickÃ© specifikace displeje</a></h3>
<p>Displej hodinek mÃ¡ rozliÅ¡enÃ­ <code>368x448</code> px (<a href="https://en.wikipedia.org/wiki/Pixel">pixelÅ¯</a>).</p>
<h3><a class="header" href="#schÃ©ma-pro-zobrazenÃ­-znakÅ¯" id="schÃ©ma-pro-zobrazenÃ­-znakÅ¯">SchÃ©ma pro zobrazenÃ­ znakÅ¯</a></h3>
<p>Na obrÃ¡zku nÃ­Å¾e je rozklesleno, jak by se mÄ›l zobrazovat Äas na hodinkÃ¡ch.</p>
<p><img src="ulohy/../static/img/watches_clock.svg" alt="" /></p>
<p>PrvnÃ­ Å™Ã¡dek slouÅ¾Ã­ pro zobrazeni hodin, druhÃ½ Å™Ã¡dek pro zobrazenÃ­ minut.
TlouÅ¡Å¥ky jednotlivÃ½ch segmentÅ¯ a rozestupy jsou takÃ© zakresleny.
ModÅ™e je znÃ¡zornÄ›na oblast, kde se nevykreslujÃ­ ÄÃ­slice, ale je moÅ¾no kreslit pozadÃ­ cifernÃ­ku.
Jsou znÃ¡zornÄ›na jen ÄtyÅ™i ÄÃ­sla, zbytek si jiÅ¾ odvodÃ­te sami.</p>
<h3><a class="header" href="#funkce-a-struktury-na-implementaci" id="funkce-a-struktury-na-implementaci">Funkce a struktury na implementaci</a></h3>
<p>PostupnÄ› naimplementujte nÃ¡sledujÃ­cÃ­ funkce a struktury.</p>
<h4><a class="header" href="#funkce-pro-vykreslenÃ­-Äasu" id="funkce-pro-vykreslenÃ­-Äasu">Funkce pro vykreslenÃ­ Äasu</a></h4>
<pre><code class="language-c">void watch_draw_time(TGAImage* self, const int hours, const int minutes);
</code></pre>
<p>Funkce nakreslÃ­ do obrÃ¡zku <code>self</code> Äas zadanÃ½ pomocÃ­ Äasu v hodinÃ¡ch (<code>hours</code>) a minutÃ¡ch (<code>minutes</code>).
Barvu ÄÃ­sel si zvolte libovolnÄ›, stejnÄ› jako barvu pozadÃ­.</p>
<h4><a class="header" href="#struktura-pro-reprezentaci-barvy-pixelu-rgba" id="struktura-pro-reprezentaci-barvy-pixelu-rgba">Struktura pro reprezentaci barvy pixelu (<code>RGBA</code>)</a></h4>
<p>Barva se do kaÅ¾dÃ©ho pixelu zapisuje jako ÄtveÅ™ice bajtÅ¯ <code>BGRA</code> (<code>B</code> - Blue, <code>G</code> - Green, <code>R</code> - Red,
<code>A</code> - Alpha). Nadefinujte si strukturu <code>RGBA</code>, kterÃ¡ bude tyto bajty reprezentovat pomocÃ­ ÄtyÅ™
promÄ›nnÃ½ch: <code>r</code>, <code>g</code>, <code>b</code>, <code>a</code> patÅ™iÄnÃ©ho datovÃ©ho typu.</p>
<h4><a class="header" href="#funkce-pro-vykreslenÃ­-Äasu-s-urÄenÃ­m-barev" id="funkce-pro-vykreslenÃ­-Äasu-s-urÄenÃ­m-barev">Funkce pro vykreslenÃ­ Äasu s urÄenÃ­m barev</a></h4>
<pre><code class="language-c">void watch_draw_time_color(
    TGAImage* self,
    const int hours,
    const int minutes,
    const RGBA* fg_color,
    const RGBA* bg_color
);
</code></pre>
<p>Funkce nakreslÃ­ do obrÃ¡zku <code>self</code> Äas zadanÃ½ pomocÃ­ Äasu v hodinÃ¡ch (<code>hours</code>) a minutÃ¡ch (<code>minutes</code>).
Barva ÄÃ­sel je pÅ™edÃ¡na parametrem <code>fg_color</code>, barva pozadÃ­ pak parametrem <code>bg_color</code>.</p>
<h1><a class="header" href="#lÃ©tajÃ­cÃ­-pÃ­smenka" id="lÃ©tajÃ­cÃ­-pÃ­smenka">LÃ©tajÃ­cÃ­ pÃ­smenka</a></h1>
<p>VyuÅ¾ijte znalosti <a href="ulohy/../c/pole/vicerozmerna_pole.html">dvourozmÄ›rnÃ½ch polÃ­</a>, <a href="ulohy/../c/text/retezce.html">Å™etÄ›zcÅ¯</a>
a <a href="ulohy/../ruzne/funkce_main.html#vstupn%C3%AD-parametry-funkce-main">argumentÅ¯ programu</a> pro vytvoÅ™enÃ­ nÃ¡sledujÃ­cÃ­
animace:</p>
<p><asciinema-player src="letters.cast"></asciinema-player></p>
<ol>
<li>
<p>VytvoÅ™Ã­me si strukturu reprezentujÃ­cÃ­ vykreslovacÃ­ plochu</p>
<pre><code class="language-c">typedef struct {
 char *content; // rows x cols &quot;pixelu&quot;
 int rows;
 int cols;
} Board;
</code></pre>
</li>
<li>
<p>Naimplementujeme si funkci pro vytvoÅ™enÃ­ novÃ© vykreslovacÃ­ plochy o pÅ™edanÃ½ch rozmÄ›rech</p>
<pre><code class="language-c">Board* board_new(int rows, int cols) {
 // dynamickÃ¡ alokace pamÄ›ti pro strukturu sloÅ¾enou z pointeru na obsah a dvou promÄ›nnÃ½ch udÃ¡vajÃ­cÃ­ rozmÄ›ry
 // dynamickÃ¡ alokace pamÄ›ti pro rows*cols pixelÅ¯ typu char a uloÅ¾enÃ­ do pointeru content
 // uloÅ¾enÃ­ rows a cols do struktury a vrÃ¡cenÃ­
}
</code></pre>
<p>NesmÃ­me takÃ© zapomenout oÅ¡etÅ™ovat rÅ¯znÃ© chybovÃ© stavy - alokace pamÄ›ti nemusÃ­ bÃ½t vÅ¾dy ÃºspÄ›Å¡nÃ¡ a musÃ­me provÃ©st kontrolu, zda navrÃ¡cenÃ¡ pamÄ›Å¥ nenÃ­ <code>NULL</code>.
K tÃ©to funkci je takÃ© vhodnÃ© doimplementovat funkci pro uvolnÄ›nÃ­ pixelÅ¯ a potÃ© samostatnÃ© struktury:</p>
<pre><code class="language-c">void board_delete(Board* b);
</code></pre>
</li>
<li>
<p>Funkce pro vykreslenÃ­ pixelu / znaku</p>
<p>Pro jednoduÅ¡Ã­ a ÄitelnÄ›jÅ¡Ã­ kÃ³d si naimplementujeme funkci, kterÃ¡ nÃ¡m vykreslÃ­ znak <code>c</code> na Å™Ã¡dek <code>row</code> a sloupec <code>col</code>.
Funkce by takÃ© mÄ›la zkontrolovat, zda souÅ™adnice nenÃ­ pÅ™ed nultÃ½m Äi poslednÃ­m Å™Ã¡dkem a sloupcem, aby nedochÃ¡zelo k pÃ¡du programu nebo k vykreslovÃ¡nÃ­ jinam.</p>
<pre><code class="language-c">void board_draw_pixel(Board *b, int row, int col, char c);
</code></pre>
<p>PÅ™epoÄet 2D souÅ™adnice <code>[row, col]</code> na 1D index mÅ¯Å¾eme podle nÃ¡sledujÃ­cÃ­ho obrÃ¡zku:
<img src="ulohy//static/img/2d_array.svg"></p>
</li>
<li>
<p>VykreslenÃ­ rÃ¡meÄku</p>
<p>Kolem okrajÅ¯ vykreslÃ­me rÃ¡meÄek pomocÃ­ funkce <code>board_draw_pixel</code>.
Pro vykreslovÃ¡nÃ­ rÃ¡meÄku <strong>NENÃ</strong> potÅ™eba prochÃ¡zet vnitÅ™ek - staÄÃ­ dvÄ› smyÄky za sebou.
PrvnÃ­ smyÄka bude prochÃ¡zet vÅ¡echny Å™Ã¡dky a kreslit na nultÃ½ a poslednÃ­ sloupec.
ObdobnÄ› druhÃ¡ smyÄka bude prochÃ¡zet sloupce a kreslit na nultÃ½ a poslednÃ­ Å™Ã¡dek.
ProchÃ¡zenÃ­m vnitÅ™ku plochy se mÅ¯Å¾e znatelnÄ› zpomalit napÅ™. pÅ™i rozliÅ¡enÃ­ 8k.</p>
<pre><code>#################
#               #
#               #
#               #
#               #
#               #
#               #
#################
</code></pre>
</li>
<li>
<p>Reprezentace pÃ­smenka a jeho vykreslovÃ¡nÃ­</p>
<p>PÃ­smenko budeme reprezentovat pomocÃ­ struktury sloÅ¾enÃ© ze znaku, pozice a rychlost pohybu:</p>
<pre><code class="language-c">typedef struct {
 int row;
 int col;
} Coord;

typedef struct {
  char c;
  Coord position;
  Coord speed;
} Letter;
</code></pre>
<p>Rychlost pohybu <code>speed</code> bude nabÃ½vat hodnot <code>-1</code> pro smÄ›r vlevo v pÅ™Ã­padÄ› sloupcovÃ© souÅ™adnice nebo smÄ›r nahoru v pÅ™Ã­padÄ› Å™Ã¡dkovÃ© souÅ™adnice.
Hodnota <code>1</code> pak bude znamenat smÄ›r doprava respektive dolÅ¯.</p>
<p>NÃ¡slednÄ› si vytvoÅ™Ã­me funkci pro jeho vykreslenÃ­ do plochy:</p>
<pre><code>void letter_render(Letter *letter, Board *board);
</code></pre>
</li>
<li>
<p>Pohyb pÃ­smenka s odrÃ¡Å¾enÃ­m od stÄ›n</p>
<p>VytvoÅ™Ã­me si funkci simulujÃ­cÃ­ jeden pohyb pÃ­smenka:</p>
<pre><code>void letter_step(Letter *letter, Board *board);
</code></pre>
<p>K aktuÃ¡lnÃ­ pozici pÃ­smenka v Å™Ã¡dku a sloupci pÅ™iÄteme rychlost <code>speed</code> z odpovÃ­dajÃ­cÃ­ souÅ™adnice.
PotÃ© zkontrolujeme, zda je novÃ¡ pozice na prvnÃ­m Å™Ã¡dku/sloupci Äi pÅ™edposlednÃ­m Å™Ã¡dku/sloupci.
Pokud ano, tak zmÄ›nÃ­me smÄ›r pÃ­smenka a tÃ­m dojde v pÅ™Ã­Å¡tÃ­m kroku k odrazu.</p>
</li>
<li>
<p>HlavnÃ­ smyÄka</p>
<p>Pro otestovÃ¡nÃ­ odrazu je opÄ›t vhodnÃ© si udÄ›lat hlavnÃ­ vykreslovacÃ­ smyÄku:</p>
<pre><code class="language-c">Board *b = board_new(20, 50);
Letter l;
l.c = 'O';
l.position.row = b-&gt;rows / 2;
l.position.col = b-&gt;cols / 2;
l.speed.row = 1;
l.speed.col = -1;

for(;;) {
 // smazani terminalu
 printf(&quot;\e[1;1H\e[2J&quot;);

 // vykresleni ramecku
 board_draw_border(b);

 // jeden krok pismenka
 letter_step(&amp;l, b);

 // vykresleni pismenka
 letter_render(&amp;l, b);

 // uspani na 500 ms
 usleep(500 * 1000);
}
</code></pre>
</li>
<li>
<p>VÃ­ce pÃ­smenek</p>
<p>TextovÃ½ Å™etÄ›zec si pÅ™evedeme na pole lÃ©tajÃ­cÃ­ch pÃ­smenek pomocÃ­ funkce:</p>
<pre><code class="language-c">typedef struct {
 Letter *letters;
 int count;
} Sentence;

Sentence* sentence_new(const char* sentence) {
 // dynamickÃ¡ alokace struktury sentence
 // dynamickÃ¡ alokace pole pro pÃ­smenka letters
 // v cyklu projdeme Å™etÄ›zec sentence a nastavÃ­me pÃ­smenka v letters, tak aby nÃ¡sledovala za sebou a mÄ›la nÃ¡hodnou rychlost
 // vrÃ¡tÃ­me ukazatel na strukturu
}
</code></pre>
<p>VykreslovacÃ­ smyÄku potÃ© upravÃ­me, aby umÄ›la pracovat s celou vÄ›tou a ne jenom s jedinÃ½m pÃ­smenkem - prakticky pÅ¯jde pouze o doplnÄ›nÃ­ cyklu pÅ™es vÅ¡echna pÃ­smenka.</p>
</li>
</ol>
<h1><a class="header" href="#soubory-1" id="soubory-1">Soubory</a></h1>
<p>K vyÅ™eÅ¡enÃ­ tÄ›chto Ãºloh by vÃ¡m mÄ›lo staÄit znÃ¡t <a href="ulohy/../c/soubory/soubory.html">soubory</a> a <a href="ulohy/../c/aplikovane_ulohy/tga.html">TGA</a>
(a samozÅ™ejmÄ› veÅ¡kerÃ© pÅ™edchozÃ­ uÄivo).</p>
<h2><a class="header" href="#spoÄÃ­tÃ¡nÃ­-Å™Ã¡dkÅ¯" id="spoÄÃ­tÃ¡nÃ­-Å™Ã¡dkÅ¯">SpoÄÃ­tÃ¡nÃ­ Å™Ã¡dkÅ¯</a></h2>
<p>Naimplementujte funkci, kterÃ¡ naÄte soubor na zadanÃ© cestÄ› a vrÃ¡tÃ­ poÄet Å™Ã¡dkÅ¯, kterÃ© se v nÄ›m
vyskytujÃ­.</p>
<pre><code class="language-c">int count_lines(const char* path);
</code></pre>
<h2><a class="header" href="#kopÃ­rovÃ¡nÃ­-souboru" id="kopÃ­rovÃ¡nÃ­-souboru">KopÃ­rovÃ¡nÃ­ souboru</a></h2>
<p>Naimplementujte funkci, kterÃ¡ pÅ™ijme cestu ke vstupnÃ­mu a vÃ½stupnÃ­mu souboru a zkopÃ­ruje obsah
vstupnÃ­ho souboru do vÃ½stupnÃ­ho souboru.</p>
<pre><code class="language-c">void copy_file(const char* src, const char* destination);
</code></pre>
<h2><a class="header" href="#Å ifrovÃ¡nÃ­-souboru" id="Å ifrovÃ¡nÃ­-souboru">Å ifrovÃ¡nÃ­ souboru</a></h2>
<p>Naimplementujte funkci, kterÃ¡ pÅ™iÄte ÄÃ­slo <code>key</code> ke vÅ¡em znakÅ¯m v souboru na zadanÃ© cestÄ›.</p>
<pre><code class="language-c">void encrypt_file(const char* path, int key);
</code></pre>
<p>DÃ¡le udÄ›lejte druhou funkci, kterÃ¡ od znakÅ¯ v souboru na zadanÃ© cestÄ› naopak ÄÃ­slo <code>key</code> odeÄte.
Otestujte, Å¾e soubor po zaÅ¡ifrovÃ¡nÃ­ a odÅ¡ifrovÃ¡nÃ­ obsahuje stejnÃ½ obsah. Pro testovÃ¡nÃ­ pouÅ¾Ã­vejte
soubory s ASCII textem.</p>
<pre><code class="language-c">void decrypt_file(const char* path, int key);
</code></pre>
<h1><a class="header" href="#meme-generÃ¡tor" id="meme-generÃ¡tor">Meme generÃ¡tor</a></h1>
<p>VytvoÅ™te generÃ¡tor meme obrÃ¡zkÅ¯ dle instrukcÃ­ na standardnÃ­m vstupu:</p>
<pre><code>blank.tga
meme.tga
2 2
I dont always do
memes
but when i do
i do them in C
</code></pre>
<p><img src="ulohy/meme/meme.png" alt="Image of a meme" /></p>
<p>MoÅ¾nÃ© kroky pro vytvoÅ™enÃ­ generÃ¡toru:</p>
<ol>
<li>NaÄtÄ›te <a href="ulohy/../c/aplikovane_ulohy/tga.html">TGA obrÃ¡zek</a> pozadÃ­ (napÅ™. <a href="ulohy/meme/meme_bg.tga">tento</a>), jehoÅ¾ cesta bude zadÃ¡na na prvnÃ­m Å™Ã¡dku na vstupu
programu. DÃ¡le naÄtÄ›te ze vstupu cestu k vÃ½stupnÃ­mu TGA obrÃ¡zku, a poÄet Å™Ã¡dkÅ¯ v hornÃ­ a spodnÃ­ ÄÃ¡sti obrÃ¡zku, do kterÃ½ch
budete vypisovat text.</li>
<li>NaÄtÄ›te obrÃ¡zek pro kaÅ¾dÃ© pÃ­smeno anglickÃ© abecedy (obrÃ¡zky jsou k dispozici <a href="ulohy/font.zip">zde</a>), a uloÅ¾te si tato pÃ­smena
do pole. </li>
<li>NaÄtÄ›te ze vstupu danÃ½ poÄet Å™Ã¡dkÅ¯ textu a kaÅ¾dÃ½ Å™Ã¡dek vykrselete do naÄtenÃ©ho obrÃ¡zku s pozadÃ­m. Pro vykreslenÃ­ Å™Ã¡dku
v cyklu projdÄ›te vÅ¡echny znaky Å™Ã¡dku, pro kaÅ¾dÃ½ znak naleznÄ›te TGA obrÃ¡zek odpovÃ­dajÃ­cÃ­ danÃ©mu znaku, a pÅ™ekopÃ­rujte jej
na odpovÃ­dajÃ­cÃ­ mÃ­sto v obrÃ¡zku s pozadÃ­m. Po vykreslenÃ­ kaÅ¾dÃ©ho znaku se posuÅˆte na vykreslovanÃ© pozici doprava o Å¡Ã­Å™ku
vykreslenÃ©ho pÃ­smene, po vykreslenÃ­ Å™Ã¡dku se posuÅˆte o vÃ½Å¡ku Å™Ã¡dku nÃ­Å¾e.</li>
<li>ZapiÅ¡te vÃ½slednÃ½ meme obrÃ¡zek na cestu zadanou na druhÃ©m Å™Ã¡dku vstupu programu.</li>
</ol>
<p>Pokud chcete pÅ™idat do vÃ½sledku prÅ¯hlednost, mÅ¯Å¾ete pro vykreslovÃ¡nÃ­ mÅ¯Å¾ete vyuÅ¾Ã­t tzv.
<a href="https://en.wikipedia.org/wiki/Alpha_compositing">alfa blending</a>. PÅ™i zÃ¡pisu pÃ­smenka do pozadÃ­ mÅ¯Å¾ete vÃ½slednou barvu
pixelu pro kaÅ¾dou barevnou sloÅ¾ku vypoÄÃ­tat nÃ¡sledovnÄ›: 
$$ \text{RES} = \frac{\text{LETTER} \cdot \text{LETTER.ALFA} + \text{BG} \cdot (255 - \text{LETTER.ALFA})}{255} $$</p>
<h1><a class="header" href="#sdl-1" id="sdl-1">SDL</a></h1>
<p>Zkuste vytvoÅ™it nÄ›jakou animaci nebo jednoduchou hru pomocÃ­ knihovny <a href="ulohy/../c/aplikovane_ulohy/sdl.html">SDL</a>.</p>
<h2><a class="header" href="#tvorba-animace" id="tvorba-animace">Tvorba animace</a></h2>
<p>PomocÃ­ knihovny pro prÃ¡ci s <a href="ulohy/../c/aplikovane_ulohy/gif.html">GIF animacemi</a> nebo pomocÃ­ <a href="ulohy/../c/aplikovane_ulohy/sdl.html">SDL</a> vytvoÅ™te nÄ›jakou
zajÃ­mavou animaci. NapÅ™Ã­klad se zkuste pÅ™iblÃ­Å¾it tÃ©to animaci z Matrixu:</p>
<p><img src="ulohy/../static/img/matrix-rain.gif" alt="" /></p>
<p>nebo mÅ¯Å¾ete zkusit vytvoÅ™it animaci ohnÄ› z poÄÃ­taÄovÃ© hry <a href="https://fabiensanglard.net/doom_fire_psx/">Doom</a>:</p>
<p><img src="ulohy/doom-fire.gif" alt="" /></p>
<h1><a class="header" href="#had" id="had">Had</a></h1>
<p>Zkuste vytvoÅ™it jednoduchÃ½ klon hry <a href="https://en.wikipedia.org/wiki/Snake_(video_game_genre)">Snake</a> pomocÃ­
<a href="ulohy/snake/../../c/aplikovane_ulohy/sdl.html">SDL</a>.</p>
<p><a href="ulohy/snake/demo/a.html">Demo</a></p>
<ol>
<li>
<p>Vykreslete mÅ™Ã­Å¾ku s polÃ­Äky o rozmÄ›rech 32x32</p>
<ul>
<li>Nekreslete prvnÃ­ dvÄ› a poslednÃ­ dvÄ› polÃ­Äka</li>
<li>Do struktury <code>Game</code> pÅ™idejte rozmÄ›ry vnitÅ™nÃ­ mÅ™Ã­Å¾ky</li>
<li>PresuÅˆte vykreslovÃ¡nÃ­ do vlastnÃ­ funkce</li>
</ul>
<img src="ulohy/snake/grid.png" width="400px">
</li>
<li>
<p>Reprezentace a inicializace hada pomocÃ­ struktury <code>Snake</code></p>
<pre><code class="language-c">typedef struct {
   SDL_Point *parts; // pole souradnic clanku hada
   int tail; // index souradnice ocasu v poli parts
   int head; // index souradnice hlavy v poli parts
} Snake;
</code></pre>
<ul>
<li>
<p>pamatujeme si souÅ™adnice (<code>SDL_Point</code>) vÅ¡ech aktivnÃ­ch ÄlÃ¡nkÅ¯ hada v mÅ™Ã­Å¾ce</p>
<ul>
<li>had mÅ¯Å¾e maximÃ¡lnÄ› zabÃ­rat celou mÅ™Ã­Å¾ku - alokace pole o velikosti ROWS x COLS</li>
<li>pamatujeme si index ocasu a index hlavy, kterÃ© pak budeme posunovat pro pohyb</li>
</ul>
</li>
<li>
<p>vytvoÅ™Ã­me hada o dvou ÄlÃ¡ncÃ­ch uprostÅ™ed mÅ™Ã­Å¾ky</p>
<ul>
<li>uloÅ¾Ã­me souÅ™adnici ÄlÃ¡nku a inkrementujeme indexy hlavy</li>
<li>a jeÅ¡tÄ› jednou pro ten druhÃ½ ÄlÃ¡nek</li>
</ul>
<p><upr-snake></upr-snake></p>
</li>
</ul>
</li>
<li>
<p>VykreslenÃ­ hada</p>
<ul>
<li>projdeme vÅ¡echny ÄlÃ¡nky od ocasu k hlavÄ› a vykreslÃ­me jako Ätverce v mÅ™Ã­Å¾ce</li>
<li>nastavÃ­me si <code>i = tail</code></li>
<li>cyklus dokud <code>i</code> nenÃ­ index hlavy
<ul>
<li>vykreslÃ­me Ätverec se souÅ™adnici <code>i</code> v mÅ™Ã­Å¾ce</li>
<li>posuneme se na dalÅ¡Ã­ ÄlÃ¡nek
<ul>
<li>pokud jsme na konci pole, tak pokraÄujeme od zaÄÃ¡tku pole <code>parts</code> (modulo...)</li>
</ul>
</li>
</ul>
</li>
</ul>
<img src="ulohy/snake/init.png" width="300px">
</li>
<li>
<p>Pohyb hada</p>
<ul>
<li>pokud ubÄ›hlo 200 ms, tak pohnout hada o polÃ­Äko</li>
<li>inkrementace indexu ocasu (opÄ›t s modulem)</li>
<li>vÃ½poÄet novÃ© hlavy jako <code>old_head + direction</code></li>
<li>uloÅ¾enÃ­ novÃ© hlavy do pole parts na index hlavy</li>
<li>inkrementace indexu hlavy (opÄ›t s modulem)</li>
</ul>
</li>
<li>
<p>Pohyb pomocÃ­ Å¡Ã­pek</p>
</li>
<li>
<p>GenerovÃ¡nÃ­ jablek</p>
<ul>
<li>vygenerovat nÃ¡hodnou souÅ™adnici jablka a vykreslovat jako Ätverec</li>
<li>pokud se hlava dostane na pozici jablka, tak neposunovat index ocasu (dojde k zvÄ›tÅ¡eni hada)</li>
</ul>
</li>
<li>
<p>PÅ™i nÃ¡razu do stÄ›ny Äi do sebe vypsat konec hry se skÃ³rem</p>
</li>
<li>
<p>VykreslenÃ­ hada pomoci textur vÄetnÄ› zÃ¡hybÅ¯</p>
<p>Textura obsahuje v mÅ™Ã­Å¾ce polÃ­Äka o velikosti 64x64. 
JednotlivÃ¡ polÃ­Äka lze vybrat pomocÃ­ tÅ™etÃ­ho parametru <code>srcrect</code> v <code>SDL_RenderCopy</code>.
ZÃ¡hyb lze vybrat podle pozice pÅ™edchozÃ­ho a nÃ¡sledujÃ­cÃ­ho ÄlÃ¡nku.</p>
<img src="https://rembound.com/files/creating-a-snake-game-tutorial-with-html5/snake-graphics.png" width="300px" />
</li>
</ol>
<h1><a class="header" href="#ÄŒastÃ©-chyby" id="ÄŒastÃ©-chyby">ÄŒastÃ© chyby</a></h1>
<p>V tÃ©to sekci naleznete Äasto se vyskytujÃ­cÃ­ chyby, na kterÃ© mÅ¯Å¾ete narazit, spolu s nÃ¡vodem, jak je
vyÅ™eÅ¡it.</p>
<h3><a class="header" href="#zÃ¡mÄ›na--a-" id="zÃ¡mÄ›na--a-">ZÃ¡mÄ›na <code>=</code> a <code>==</code></a></h3>
<ul>
<li>OperÃ¡tor <code>=</code> <a href="caste_chyby/../c/promenne/promenne.html#z%C3%A1pis">pÅ™iÅ™azuje</a> hodnotu do svÃ©ho levÃ©ho operandu a vyhodnotÃ­ se s
hodnotou pravÃ©ho operandu.</li>
<li>OperÃ¡tor <code>==</code> <a href="caste_chyby/../c/datove_typy/pravdivostni_typy.html#porovn%C3%A1v%C3%A1n%C3%AD-hodnot">porovnÃ¡vÃ¡</a> dvÄ› hodnoty a vyhodnotÃ­
se jako pravdivostnÃ­ hodnota <code>bool</code>.</li>
</ul>
<p>Je dÅ¯leÅ¾itÃ© tyto operÃ¡tory nezamÄ›Åˆovat! Oba dva operÃ¡tory jsou vÃ½razy, takÅ¾e se v nÄ›co vyhodnotÃ­ a
i kdyÅ¾ je pouÅ¾ijete Å¡patnÄ›, tak Äasto nedostanete chybovou hlÃ¡Å¡ku, coÅ¾ jejich zÃ¡mÄ›nu dÄ›lÃ¡ jeÅ¡tÄ›
nebezpeÄnÄ›jÅ¡Ã­.</p>
<pre><code class="language-c">int a = 0;
a = 5; // nastavÃ­ hodnotu `5` do promÄ›nnÃ© `a`
a == 5; // porovnÃ¡ `a` s hodnotou `5`, vrÃ¡tÃ­ hodnotu `true`, ale nic se neprovede

// podmÃ­nka se provede, pokud se `a` rovnÃ¡ `5`
if (a == 5) {}

// podmÃ­nka se provede vÅ¾dy, vÃ½raz `a = 5` se vyhodnotÃ­ na `5` (`true`)
// zÃ¡roveÅˆ pÅ™i provedenÃ­ podmÃ­nky se pÅ™epÃ­Å¡e hodnota promÄ›nnÃ© `a` na `5`
if (a = 5) {}
</code></pre>
<h3><a class="header" href="#zÃ¡mÄ›na--s--nebo--s-" id="zÃ¡mÄ›na--s--nebo--s-">ZÃ¡mÄ›na <code>&amp;</code> s <code>&amp;&amp;</code> nebo <code>|</code> s <code>||</code></a></h3>
<ul>
<li>OperÃ¡tor <code>&amp;</code> provÃ¡dÃ­ <a href="caste_chyby/../c/datove_typy/celociselne_typy.html#tabulka-aritmetick%C3%BDch-oper%C3%A1tor%C5%AF">bitovÃ½ souÄin</a>,
oÄekÃ¡vÃ¡ jako operandy celÃ¡ ÄÃ­sla (napÅ™. <code>int</code>) a vracÃ­ celÃ© ÄÃ­slo.</li>
<li>OperÃ¡tor <code>&amp;&amp;</code> provÃ¡dÃ­ <a href="caste_chyby/../c/datove_typy/pravdivostni_typy.html#tabulka-logick%C3%BDch-oper%C3%A1tor%C5%AF">logickÃ½ souÄin</a>,
oÄekÃ¡vÃ¡ jako operandy pravdivostnÃ­ hodnoty (<code>bool</code>) a vracÃ­ pravdivostnÃ­ hodnotu.</li>
</ul>
<p>Je dÅ¯leÅ¾itÃ© tyto operÃ¡tory nezamÄ›Åˆovat. JelikoÅ¾ <code>bool</code> lze implicitnÄ› pÅ™evÃ©st na celÃ© ÄÃ­slo a naopak,
zÃ¡mÄ›na tÄ›chto operÃ¡torÅ¯ opÄ›t typicky nepovede k chybÄ› pÅ™i pÅ™ekladu, nicmÃ©nÄ› program nejspÃ­Å¡e pÅ™i
jejich zÃ¡mÄ›nÄ› nebude fungovat tak, jak mÃ¡. OperÃ¡tor <code>&amp;</code> mÃ¡ zÃ¡roveÅˆ vÄ›tÅ¡Ã­
<a href="https://en.cppreference.com/w/c/language/operator_precedence">pÅ™ednost</a> neÅ¾ <code>&amp;&amp;</code>, takÅ¾e se vÃ½raz
s tÃ­mto operÃ¡torem mÅ¯Å¾e vyhodnotit jinak, neÅ¾ oÄekÃ¡vÃ¡te. ObdobnÃ¡ situace platÃ­ i u dvojice
operÃ¡torÅ¯ <code>|</code> (bitovÃ½ souÄet) a <code>||</code> (logickÃ½ souÄet).</p>
<pre><code class="language-c">int a = 3;
a &amp; 4; // `0` 
a &amp;&amp; 4; // `true`

// stejnÃ© jako a &gt; (5 &amp; a) &lt; 6
if (a &gt; 5 &amp; a &lt; 6) {}
</code></pre>
<h3><a class="header" href="#pouÅ¾itÃ­-operÃ¡toru--pro-umocnÄ›nÃ­" id="pouÅ¾itÃ­-operÃ¡toru--pro-umocnÄ›nÃ­">PouÅ¾itÃ­ operÃ¡toru <code>^</code> pro umocnÄ›nÃ­</a></h3>
<p>OperÃ¡tor <code>^</code> provÃ¡dÃ­ v <em>C</em> bitovou operaci <a href="caste_chyby/../c/datove_typy/celociselne_typy.html#operace-s-%C4%8D%C3%ADseln%C3%BDmi-typy">XOR</a>,
nesnaÅ¾te se jej tedy pouÅ¾Ã­t k vÃ½poÄtu mocnin! Pro vÃ½poÄet mocniny pouÅ¾ijte funkci <a href="https://devdocs.io/c/numeric/math/pow"><code>pow</code></a>
(<em>power</em> je anglickÃ© oznaÄenÃ­ pro mocninu).</p>
<pre><code class="language-c editable mainbody">#include &lt;stdio.h&gt;
#include &lt;math.h&gt;

int main() {
    int a = 5 ^ 2;
    printf(&quot;%d\n&quot;, a);

    int b = pow(5, 2);
    printf(&quot;%d\n&quot;, b);

    return 0;
}
</code></pre>
<h3><a class="header" href="#pouÅ¾itÃ­-neexistujÃ­cÃ­ch-negacÃ­-operÃ¡torÅ¯-porovnÃ¡vÃ¡nÃ­" id="pouÅ¾itÃ­-neexistujÃ­cÃ­ch-negacÃ­-operÃ¡torÅ¯-porovnÃ¡vÃ¡nÃ­">PouÅ¾itÃ­ neexistujÃ­cÃ­ch negacÃ­ operÃ¡torÅ¯ porovnÃ¡vÃ¡nÃ­</a></h3>
<p>JedinÃ© existujÃ­cÃ­ operÃ¡tory porovnÃ¡vÃ¡nÃ­ v <em>C</em> jsou <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, <code>&gt;=</code>, <code>==</code> a <code>!=</code>.
OperÃ¡tory jako <code>!&lt;</code>, <code>!&gt;</code>, <code>=&lt;</code> ani <code>=&gt;</code> v <em>C</em> neexistujÃ­! NegacÃ­ operÃ¡toru <code>&lt;</code> je operÃ¡tor <code>&gt;=</code> a negacÃ­ operÃ¡toru
<code>&gt;</code> je operÃ¡tor <code>&lt;=</code>.</p>
<h3><a class="header" href="#porovnÃ¡vÃ¡nÃ­-vÃ½razu-s-vÃ­ce-hodnotami-najednou" id="porovnÃ¡vÃ¡nÃ­-vÃ½razu-s-vÃ­ce-hodnotami-najednou">PorovnÃ¡vÃ¡nÃ­ vÃ½razu s vÃ­ce hodnotami najednou</a></h3>
<p>Pokud budete chtÃ­t zjistit, jestli napÅ™. nÄ›jakÃ¡ promÄ›nnÃ¡ je menÅ¡Ã­ neÅ¾ jedna hodnota a zÃ¡roveÅˆ vÄ›tÅ¡Ã­
neÅ¾ jinÃ¡ hodnota, musÃ­te tyto dvÄ› kontroly provÃ©st separÃ¡tnÄ› a potÃ© jejich vÃ½sledek spojit logickÃ½m
operÃ¡torem <code>&amp;&amp;</code>. Pokud pouÅ¾ijete vÃ½raz jako napÅ™. <code>2 &lt; a &lt; 8</code>, tak se <code>2 &lt; a</code> vyhodnotÃ­ jako hodnota
typu <code>bool</code>, a potÃ© se provede porovnÃ¡nÃ­ <code>true &lt; 8</code>, popÅ™Ã­padÄ› <code>false &lt; 8</code>, coÅ¾ nejspÃ­Å¡e nenÃ­ to, co
zamÃ½Å¡lÃ­te.</p>
<pre><code class="language-c editable mainbody">#include &lt;stdio.h&gt;

int main() {
    int a = 100;

    // Å¡patnÄ›
    if (2 &lt; a &lt; 8) {
        printf(&quot;A: a patri do intervalu (2, 8)\n&quot;);
    }

    // sprÃ¡vnÄ›
    if (2 &lt; a &amp;&amp; a &lt; 8) {
        printf(&quot;B: a patri do intervalu (2, 8)\n&quot;);
    }

    return 0;
}
</code></pre>
<h3><a class="header" href="#stÅ™ednÃ­k-za-for-while-nebo-if" id="stÅ™ednÃ­k-za-for-while-nebo-if">StÅ™ednÃ­k za <code>for</code>, <code>while</code> nebo <code>if</code></a></h3>
<p>PÅ™Ã­kazy <code>for</code>, <code>while</code> nebo <code>if</code> za svou uzavÃ­racÃ­ zÃ¡vorkou <code>)</code> oÄekÃ¡vajÃ­ jeden pÅ™Ã­kaz:</p>
<pre><code class="language-c">if (a &gt; b) printf(&quot;%d&quot;, a);
</code></pre>
<p>nebo blok s pÅ™Ã­kazy:</p>
<pre><code class="language-c">if (a &gt; b) {
    printf(&quot;%d&quot;, a);
    ...
}
</code></pre>
<p>Pokud vÅ¡ak za zÃ¡vorku dÃ¡te rovnou stÅ™ednÃ­k (<code>;</code>), tak to pÅ™ekladaÄ pochopÃ­ jako prÃ¡zdnÃ½ pÅ™Ã­kaz, kterÃ½
nic nedÄ›lÃ¡.</p>
<p>V nÃ¡sledujÃ­cÃ­ ukÃ¡zce se provede 10Ã— prÃ¡zdnÃ© tÄ›lo cyklu <code>for</code> a nÃ¡slednÄ› se jednou vypÃ­Å¡e Å™etÄ›zec <code>&quot;Hello\n&quot;</code>.</p>
<pre><code class="language-c editable mainbody">#include &lt;stdio.h&gt;

int main() {
    for(int i = 0; i &lt; 10; i++); {
        printf(&quot;Hello\n&quot;);
    }
    return 0;
}
</code></pre>
<p>Zde opÄ›t stÅ™ednÃ­k za <code>if</code> reprezentuje prÃ¡zdnÃ½ pÅ™Ã­kaz, takÅ¾e blok kÃ³du s pÅ™Ã­kazem <code>printf</code> se provede
vÅ¾dy, i kdyÅ¾ je tato podmÃ­nka nesplnitelnÃ¡.</p>
<pre><code class="language-c editable mainbody">#include &lt;stdio.h&gt;

int main() {
    if(0); {
        printf(&quot;Hello\n&quot;);
    }

    return 0;
}
</code></pre>
<p>Je to ekvivalentnÃ­, jako byste napsali</p>
<pre><code class="language-c editable mainbody">#include &lt;stdio.h&gt;

int main() {
    if (0) { /* zde nenÃ­ co provÃ©st */ }

    // tento blok se provede vÅ¾dy
    {
      printf(&quot;Hello\n&quot;);
    }

    return 0;
}
</code></pre>
<h3><a class="header" href="#Å patnÃ©-volÃ¡nÃ­-funkce" id="Å patnÃ©-volÃ¡nÃ­-funkce">Å patnÃ© volÃ¡nÃ­ funkce</a></h3>
<p>Abychom zavolali funkci (tj. Å™ekli poÄÃ­taÄi, aby zaÄal vykonÃ¡vat kÃ³d, kterÃ½ v nÃ­ je), napÃ­Å¡eme
nÃ¡zev funkce, zÃ¡vorky a do nich pÅ™Ã­padnÄ› seznam argumentÅ¯. PÅ™i volÃ¡nÃ­ funkce uÅ¾ nezadÃ¡vÃ¡me jejÃ­
nÃ¡vratovÃ½ typ, ten se udÃ¡vÃ¡ pouze u definice funkce.</p>
<pre><code class="language-c">int secti(int a, int b) {
    return a + b;
}
int main() {
    secti(1, 2);        // sprÃ¡vnÄ›
    int secti(1, 2);    // Å¡patnÄ›

    return 0;
}
</code></pre>
<h3><a class="header" href="#zÃ¡mÄ›na--s" id="zÃ¡mÄ›na--s">ZÃ¡mÄ›na <code>'</code> s <code>&quot;</code></a></h3>
<ul>
<li>Apostrof (<code>'</code>) slouÅ¾Ã­ k zapsÃ¡nÃ­ (jednoho) <a href="caste_chyby/../c/text/znaky.html">znaku</a>. NeuklÃ¡dejte do nÄ›j vÃ­ce znakÅ¯ Äi celÃ½ text.</li>
<li>Uvozovky (<code>&quot;</code>) slouÅ¾Ã­ k zapsÃ¡nÃ­ <a href="caste_chyby/../c/text/text.html">Å™etÄ›zce</a>, tj. pole znakÅ¯ ukonÄenÃ©ho hodnotou <code>0</code>.</li>
</ul>
<pre><code class="language-c">char a = 'asd'; // Å¡patnÄ›, vÃ­ce znakÅ¯ v ''
char a = &quot;asd&quot;; // Å¡patnÄ›, uklÃ¡dÃ¡me Å™etÄ›zec do typu `char` (mÄ›lo by bÃ½t `const char*`)

char a = 'x';               // sprÃ¡vnÄ›
const char* str = &quot;hello&quot;;  // sprÃ¡vnÄ›
</code></pre>
<h3><a class="header" href="#porovnÃ¡vÃ¡nÃ­-Å™etÄ›zcÅ¯-pomocÃ­-" id="porovnÃ¡vÃ¡nÃ­-Å™etÄ›zcÅ¯-pomocÃ­-">PorovnÃ¡vÃ¡nÃ­ Å™etÄ›zcÅ¯ pomocÃ­ <code>==</code></a></h3>
<p>Å˜etÄ›zce jsou v jazyce <em>C</em> reprezentovÃ¡ny jako <a href="caste_chyby/../c/text/retezce.html">pole znakÅ¯</a>. KdyÅ¾ pracujete
s Å™etÄ›zcem, tak mÃ¡te obvykle k dispozici <a href="caste_chyby/../c/prace_s_pameti/ukazatele.html">ukazatel</a> na jeho prvnÃ­
<a href="caste_chyby/../c/text/znaky.html">znak</a>.</p>
<p>Pokud k porovnÃ¡nÃ­ dvou Å™etÄ›zcÅ¯ pouÅ¾ijete operÃ¡tor <code>==</code>, tak vlastnÄ› porovnÃ¡te akorÃ¡t hodnotu dvou
ukazatelÅ¯. Pokud budou tyto ukazatele obsahovat stejnou adresu v pamÄ›ti, tak bude vÃ½sledek pravdivÃ½.
Ale dva Å™etÄ›zce se mÅ¯Å¾ou rovnat i v pÅ™Ã­padÄ›, Å¾e leÅ¾Ã­ na rÅ¯znÃ½ch mÃ­stech v pamÄ›ti! Pro porovnÃ¡nÃ­
dvou Å™etÄ›zcÅ¯ tak pouÅ¾ijte funkci <a href="https://devdocs.io/c/string/byte/strcmp"><code>strcmp</code></a>.</p>
<pre><code class="language-c">#include &lt;string.h&gt;

void funkce(const char* a, const char* b) {
    if (a == b) { ... }             // Å¡patnÄ›
    if (strcmp(a, b) == 0) { ... }  // sprÃ¡vnÄ›
}
</code></pre>
<blockquote>
<p>MÅ¯Å¾e vÃ¡m pÅ™ijÃ­t zvlÃ¡Å¡tnÃ­, Å¾e pokud porovnÃ¡vÃ¡te dva <a href="caste_chyby/../c/text/retezce.html#%C5%98et%C4%9Bzcov%C3%BD-liter%C3%A1l">Å™etÄ›zcovÃ© literÃ¡ly</a>,
tak porovnÃ¡nÃ­ dvou stejnÃ½ch Å™etÄ›zcÅ¯ pomocÃ­ <code>==</code> bude fungovat (vrÃ¡tÃ­ pravdivou hodnotu). To je ale
dÃ¡no pouze tÃ­m, Å¾e pÅ™ekladaÄ stejnÃ© Å™etÄ›zcovÃ© literÃ¡ly uklÃ¡dÃ¡ na stejnÃ© mÃ­sto v pamÄ›ti, takÅ¾e majÃ­
stejnou adresu a <code>==</code> zde bude fungovat. Pro porovnÃ¡vÃ¡nÃ­ Å™etÄ›zcÅ¯, kterÃ© ale naÄtete napÅ™. z
terminÃ¡lu nebo ze souboru, to vÅ¡ak fungovat nebude, proto <code>==</code> nikdy pro porovnÃ¡vÃ¡nÃ­ Å™etÄ›zcÅ¯
nepouÅ¾Ã­vejte.</p>
</blockquote>
<h3><a class="header" href="#porovnÃ¡vÃ¡nÃ­-Å™etÄ›zce-naÄtenÃ©ho-funkcÃ­-fgets" id="porovnÃ¡vÃ¡nÃ­-Å™etÄ›zce-naÄtenÃ©ho-funkcÃ­-fgets">PorovnÃ¡vÃ¡nÃ­ Å™etÄ›zce naÄtenÃ©ho funkcÃ­ <code>fgets</code></a></h3>
<p>Funkce <code>fgets</code> umÃ­ naÄÃ­st <a href="caste_chyby/../c/text/vstup.html#na%C4%8Dten%C3%AD-%C5%99%C3%A1dku">Å™Ã¡dek</a> ze vstupnÃ­ho souboru Äi ze
standardnÃ­ho vstupu. Pokud s takto naÄtenÃ½m Å™Ã¡dkem chcete dÃ¡le pracovat, dejte si pozor na to, Å¾e
na konci tohoto Å™etÄ›zce mÅ¯Å¾e bÃ½t znak odÅ™Ã¡dkovÃ¡nÃ­ (<code>'\n'</code>)! Pokud tomu tak bude, tak nebude napÅ™.
fungovat pÅ™Ã­mÃ© porovnÃ¡nÃ­ Å™Ã¡dku s nÄ›jakÃ½m Å™etÄ›zcovÃ½m literÃ¡lem:</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

int main() {
    char buffer[80];
    fgets(buffer, sizeof(buffer), stdin);

    // Pokud uÅ¾ivatel zadÃ¡ v terminÃ¡lu ahoj, tak v promÄ›nnÃ© `buffer` bude
    // Å™etÄ›zec &quot;ahoj\n&quot;, takÅ¾e toto porovnÃ¡nÃ­ nebude fungovat.
    if (strcmp(buffer, &quot;ahoj&quot;) == 0) {
        printf(&quot;Ahoj!\n&quot;);
    }

    return 0;
}
</code></pre>
<p>Pokud tedy chcete takto pracovat s naÄtenÃ½m Å™Ã¡dkem, nejprve byste se mÄ›li podÃ­vat, jestli nekonÄÃ­
znakem odÅ™Ã¡dkovÃ¡nÃ­, a pokud ano, tak tento znak
<a href="caste_chyby/../c/text/retezce.html#k-%C4%8Demu-slou%C5%BE%C3%AD-nulov%C3%BD-znak-na-konci">odstranit</a>.</p>
<p>Znak odÅ™Ã¡dkovÃ¡nÃ­ na konci Å™etÄ›zce bÃ½t nemusÃ­ napÅ™Ã­klad pokud naÄtete poslednÃ­ Å™Ã¡dek ze souboru,
kterÃ½ nenÃ­ ukonÄen znakem odÅ™Ã¡dkovÃ¡nÃ­. PÅ™ed zmÄ›nou Å™etÄ›zce s naÄtenÃ½m Å™Ã¡dkem byste tak vÅ¾dy mÄ›li
nejprve zkontrolovat, Å¾e se na jeho konci znak odÅ™Ã¡dkovÃ¡nÃ­ opravdu nachÃ¡zÃ­.</p>
<h3><a class="header" href="#Å patnÃ¡-prÃ¡ce-s-ukazatelem" id="Å patnÃ¡-prÃ¡ce-s-ukazatelem">Å patnÃ¡ prÃ¡ce s ukazatelem</a></h3>
<p><a href="caste_chyby/../c/prace_s_pameti/ukazatele.html">Ukazatele</a> jsou ÄÃ­sla, kterÃ¡ interpretujeme jako
<a href="caste_chyby/../uvod/pamet.html">adresy v pamÄ›ti</a>. MÅ¯Å¾ete s nimi sice provÃ¡dÄ›t nÄ›kterÃ© aritmetickÃ© operace
(napÅ™Ã­klad sÄÃ­tÃ¡nÃ­ Äi odÄÃ­tÃ¡nÃ­), nicmÃ©nÄ› v takovÃ©m pÅ™Ã­padÄ› provÃ¡dÃ­te vÃ½poÄet s adresou, ne s
hodnotou, kterÃ¡ je na danÃ© adrese uloÅ¾ena.</p>
<p>NapÅ™Ã­klad v tÃ©to funkci, kterÃ¡ by mÄ›la pÅ™iÄÃ­st hodnotu <code>x</code> k pamÄ›ti na adrese <code>ptr</code>, musÃ­te
nejprve pÅ™istoupit k hodnotÄ› na danÃ© adrese (<code>*ptr</code>), a aÅ¾ k tÃ©to hodnotÄ› pak pÅ™iÄÃ­st <code>x</code>:</p>
<pre><code class="language-c">void pricti_hodnotu(int* ptr, int x) {
    ptr += x;   // Å¡patnÄ›, pÅ™iÄteme `x` k adrese `ptr`
    *ptr += x;  // sprÃ¡vnÄ›, pÅ™iÄteme `x` k hodnotÄ› na adrese `ptr` 
}
</code></pre>
<h3><a class="header" href="#vytvÃ¡Å™enÃ­-spousty-promÄ›nnÃ½ch-mÃ­sto-pouÅ¾itÃ­-pole" id="vytvÃ¡Å™enÃ­-spousty-promÄ›nnÃ½ch-mÃ­sto-pouÅ¾itÃ­-pole">VytvÃ¡Å™enÃ­ spousty promÄ›nnÃ½ch mÃ­sto pouÅ¾itÃ­ pole</a></h3>
<p>Pokud potÅ™ebujete jednotnÄ› pracovat s vÄ›tÅ¡Ã­m poÄtem hodnot v pamÄ›ti, pouÅ¾ijte <a href="caste_chyby/../c/pole/pole.html">pole</a>.
SignÃ¡lem, Å¾e jste mÄ›li pouÅ¾Ã­t pole, mÅ¯Å¾e bÃ½t to, Å¾e mÃ¡te ve funkci spoustu promÄ›nnÃ½ch a pro rozliÅ¡enÃ­
kaÅ¾dÃ© promÄ›nnÃ© musÃ­te pÅ™idat novÃ½ Å™Ã¡dek kÃ³du:</p>
<pre><code class="language-c">for (a0 = 0, a1 = 0, a2 = 0, a3 = 0, a4 = 0, a5 = 0; i &lt; pocet; i++)
{
    if (hodnota == 1)
    {
        a0++;
    }
    else if (hodnota == 2)
    {
        a1++;
    }
    else if (hodnota == 3)
    {
        a2++;
    }
    ...
}
</code></pre>
<h3><a class="header" href="#pouÅ¾itÃ­-operÃ¡toru-sizeof-na-ukazatel" id="pouÅ¾itÃ­-operÃ¡toru-sizeof-na-ukazatel">PouÅ¾itÃ­ operÃ¡toru <code>sizeof</code> na ukazatel</a></h3>
<p>OperÃ¡tor <code>sizeof</code> se Äasto hodÃ­ ke zjiÅ¡tÄ›nÃ­ velikosti pole. Pokud jej ovÅ¡em pouÅ¾ijete na ukazatel
(i kdyby v danÃ©m ukazateli byla adresa pole!), tak vÃ¡m vrÃ¡tÃ­ pouze velikost ukazatele, tedy
pravdÄ›podobnÄ› hodnotu <code>8</code> na 64-bitovÃ©m systÃ©mu.</p>
<pre><code class="language-c">char pole[3];
char* ptr = pole;

sizeof(pole); // 3
sizeof(ptr);  // 8
</code></pre>
<p>Pozor na to, Å¾e pokud pouÅ¾ijete datovÃ½ typ pole pro parametr funkce, tak pro pÅ™ekladaÄ se takovÃ½
parametr chovÃ¡ jako ukazatel! Pole se do funkcÃ­ vÅ¾dy pÅ™edÃ¡vajÃ­ jako adresa prvnÃ­ho prvku pole.</p>
<pre><code class="language-c">void print_size(char pole[3]) {
    sizeof(pole); // 8
}
</code></pre>
<p>PodobnÃ½ problÃ©m mÅ¯Å¾e vzniknout i tÅ™eba pÅ™i alokaci pamÄ›ti. NapÅ™Ã­klad zde:</p>
<pre><code class="language-c">typedef struct {
    int vek;
    const char* jmeno;
} Osoba;

int main() {
    Osoba* osoby = (Osoba*) malloc(sizeof(Osoba*) * 5);

    return 0;
}
</code></pre>
<p>DochÃ¡zÃ­ k alokaci pamÄ›ti pro 5 ukazatelÅ¯ na datovÃ½ typ <code>Osoba</code>, mÃ­sto alokace pamÄ›ti pro pÄ›t hodnot typu <code>Osoba</code>!
SprÃ¡vnÃ© pouÅ¾itÃ­ by bylo <code>malloc(sizeof(Osoba) * 5)</code>;</p>
<h3><a class="header" href="#undefined-reference-to-nazev" id="undefined-reference-to-nazev"><code>undefined reference to 'NAZEV'</code></a></h3>
<p>SnaÅ¾Ã­te se zavolat funkci <code>NAZEV</code>, kterÃ¡ nebyla nalezena v Å¾Ã¡dnÃ©m
<a href="caste_chyby/../c/modularizace/linker.html">objektovÃ©m souboru</a>, kterÃ½ jste pÅ™edali pro pÅ™eklad. OvÄ›Å™te si, Å¾e
mÃ¡te nÃ¡zev volanÃ© funkce sprÃ¡vnÄ›.</p>
<h1><a class="header" href="#pamÄ›Å¥ovÃ©-chyby" id="pamÄ›Å¥ovÃ©-chyby">PamÄ›Å¥ovÃ© chyby</a></h1>
<p>V <em>C</em> lze s pamÄ›tÃ­ programu pracovat <a href="caste_chyby/../c/prace_s_pameti/dynamicka_pamet.html">manuÃ¡lnÄ›</a>, coÅ¾ velmi Äasto vede
k rÅ¯znÃ½m pamÄ›Å¥ovÃ½m chybÃ¡m, kterÃ© mÅ¯Å¾ou zpÅ¯sobit Å¡patnÃ© chovÃ¡nÃ­ Äi pÃ¡d programu. Jsou takÃ©
nejÄastÄ›jÅ¡Ã­m zdrojem rÅ¯znÃ½ch
<a href="https://owasp.org/www-community/attacks/Buffer_overflow_attack">zranitelnostÃ­</a>, kterÃ© umoÅ¾ÅˆujÃ­
ÃºtoÄnÃ­kÅ¯m pÅ™evzÃ­t kontrolu nad programem nebo celÃ½m poÄÃ­taÄem.</p>
<p>Pro ÄÃ¡steÄnou prevenci pamÄ›Å¥ovÃ½ch chyb silnÄ› doporuÄujeme pÅ™i vÃ½voji <em>C</em> programÅ¯ pouÅ¾Ã­vat
nÃ¡stroj <a href="caste_chyby/../prostredi/ladeni.html#address-sanitizer">Address sanitizer</a>.</p>
<h2><a class="header" href="#stack-overflow" id="stack-overflow">Stack overflow</a></h2>
<p>Pokud bychom vytvoÅ™ili v zÃ¡sobnÃ­kovÃ©m rÃ¡mci moc promÄ›nnÃ½ch, promÄ›nnÃ©, kterÃ© jsou
<a href="caste_chyby/../c/pole/pole.html">moc velkÃ©</a>, anebo bychom mÄ›li v jednu chvÃ­li aktivnÃ­ch moc zÃ¡sobnÃ­kovÃ½ch rÃ¡mcÅ¯
(napÅ™Ã­klad pÅ™i moc hlubokÃ© <a href="caste_chyby/../c/funkce/rekurze.html">rekurzi</a>), tak mÅ¯Å¾e dojÃ­t pamÄ›Å¥ urÄenÃ¡ pro zÃ¡sobnÃ­k.
Tato situce se nazÃ½vÃ¡ <strong>pÅ™eteÄenÃ­ zÃ¡sobnÃ­ku</strong> (<em>stack overflow</em>):</p>
<pre><code class="language-c">int funkce(int x) {
    return funkce(x + 1);
}
int main() {
    funkce(0);
    return 0;
}
</code></pre>
<h2><a class="header" href="#segmentation-fault" id="segmentation-fault">Segmentation fault</a></h2>
<p>Tato chyba je zpÅ¯sobena pokusem o zapsÃ¡nÃ­ nebo ÄtenÃ­ neplatnÃ© adresy v pamÄ›ti. K tÃ©to chybÄ› Äasto
dochÃ¡zÃ­ zejmÃ©na pÅ™i tÄ›chto situacÃ­ch:</p>
<ul>
<li>
<p>ZapÃ­sujeme nebo Äteme z pamÄ›ti pole mimo jeho rozsah (tj. &quot;pÅ™ed&quot; nebo &quot;za&quot; pamÄ›tÃ­ pole).
Tato situace se nazÃ½vÃ¡ <a href="https://owasp.org/www-community/vulnerabilities/Buffer_Overflow"><em>buffer overflow</em></a>.
Tato chyba uÅ¾ zpÅ¯sobila nespoÄet bezpeÄnostnÃ­ch chyb v rÅ¯znÃ½ch softwarech.</p>
<pre><code class="language-c">#include &lt;stdlib.h&gt;

int main() {
    int* p = (int*) malloc(sizeof(int));
    p[1] = 5;
    return 0;
}
</code></pre>
</li>
<li>
<p>PokouÅ¡Ã­me se pÅ™eÄÃ­st hodnotu na adrese 0 (<code>NULL</code>), kterÃ¡ je pouÅ¾Ã­vÃ¡na pro inicializaci
ukazatelÅ¯. Tato situace se nazÃ½vÃ¡
<a href="https://owasp.org/www-community/vulnerabilities/Null_Dereference"><em>null pointer dereference</em></a>.</p>
<pre><code class="language-c">int main() {
    int* p = (void*) 0;
    int a = *p;

    return 0;
}
</code></pre>
</li>
<li>
<p>SnaÅ¾Ã­me se pÅ™istoupit k pamÄ›ti, kterÃ¡ jiÅ¾ byla <a href="caste_chyby/../c/prace_s_pameti/dynamicka_pamet.html#uvoln%C4%9Bn%C3%AD-pam%C4%9Bti">uvolnÄ›na</a>.
Tato situace se nazÃ½vÃ¡
<a href="https://owasp.org/www-community/vulnerabilities/Using_freed_memory"><em>use-after-free</em></a>.</p>
<pre><code class="language-c">#include &lt;stdlib.h&gt;

int main() {
    int* p = (int*) malloc(sizeof(int));
    free(p);

    *p = 1;
    return 0;
}
</code></pre>
<p>PÅ™Ã­stup k jiÅ¾ uvolnÄ›nÃ© pamÄ›ti mÅ¯Å¾e nastat i bez pouÅ¾itÃ­
<a href="caste_chyby/../c/prace_s_pameti/dynamicka_pamet.html">dynamickÃ© pamÄ›ti</a>. NapÅ™Ã­klad tento kÃ³d nenÃ­ sprÃ¡vnÄ›:</p>
<pre><code class="language-c">#include &lt;stdlib.h&gt;

int* vrat_ukazatel(int x) {
    int y = x + 1;
    return &amp;y;
}

int main() {
    int* p = vrat_ukazatel(1);
    *p = 1;
    return 0;
}
</code></pre>
<p>Jakmile totiÅ¾ vykonÃ¡vÃ¡nÃ­ funkce <code>vrat_ukazatel</code> skonÄÃ­, tak se
<a href="caste_chyby/../c/prace_s_pameti/automaticka_pamet.html">uvolnÃ­</a> pamÄ›Å¥ jejich lokÃ¡lnÃ­ch promÄ›nnÃ½ch. Adresa
uloÅ¾enÃ¡ v <code>p</code> tak obsahuje nevalidnÃ­ pamÄ›Å¥ a je chybou k nÃ­ pÅ™istupovat (aÅ¥ uÅ¾ ÄÃ­st, tak
zapisovat).</p>
</li>
<li>
<p>SnaÅ¾Ã­me se uvolnit pamÄ›t, kterÃ¡ jiÅ¾ byla uvolnÄ›na. Tato situace se nazÃ½vÃ¡
<a href="https://owasp.org/www-community/vulnerabilities/Doubly_freeing_memory"><em>double free</em></a>.</p>
<pre><code class="language-c">#include &lt;stdlib.h&gt;

int main() {
    int* p = (int*) malloc(sizeof(int));
    free(p);
    free(p);
    return 0;
}
</code></pre>
</li>
</ul>
<blockquote>
<p>Zkuste si programy vÃ½Å¡e spustit nejprve bez Address sanitizeru a potÃ© s nÃ­m. DokÃ¡zal sanitizer
detekovat nÄ›kterÃ© z popsanÃ½ch pamÄ›Å¥ovÃ½ch chyb?</p>
</blockquote>
<h2><a class="header" href="#memory-leak" id="memory-leak">Memory leak</a></h2>
<p>Pokud (opakovanÄ›) alokujeme <a href="caste_chyby/../c/prace_s_pameti/dynamicka_pamet.html">dynamickou pamÄ›Å¥</a> a neuvolÅˆujeme ji, tak
dochÃ¡zÃ­ k tzv. <a href="https://owasp.org/www-community/vulnerabilities/Memory_leak"><em>memory leaku</em></a>
(Ãºniku pamÄ›ti). Pokud pamÄ›Å¥ programu stÃ¡le roste a nenÃ­ nijak uvolÅˆovÃ¡na, tak postupem Äasu poÄÃ­taÄi
nutnÄ› dojde pamÄ›Å¥ a program tak bude nÃ¡silnÄ› ukonÄen.</p>
<pre><code class="language-c">void leak() {
    // adresa alokovanÃ© pamÄ›ti je zahozena, nelze ji tedy uvolnit
    malloc(sizeof(int));
}
</code></pre>
<p>Tato chyba je celkem zÃ¡keÅ™nÃ¡, protoÅ¾e pokud pamÄ›Å¥ roste pomalu, tak mÅ¯Å¾e trvat dost dlouho, neÅ¾
pamÄ›Å¥ programu dojde a vy se tak dozvÃ­te o problÃ©mu. K nalezenÃ­ chyby doporuÄujeme opÄ›t pouÅ¾Ã­t Address
sanitizer, kterÃ½ na konci programu zkontroluje, jestli vÅ¡echny dynamicky naalokovanÃ© bloky byly
korektnÄ› uvolnÄ›ny.</p>
<blockquote>
<p>NemusÃ­te se vÅ¡ak bÃ¡t, Å¾e by neuvolnÄ›nÃ¡ pamÄ›Å¥ ve vaÅ¡em programu nÄ›jak naruÅ¡ovala chod operaÄnÃ­ho
systÃ©mu. I kdyÅ¾ pamÄ›Å¥ manuÃ¡lnÄ› neuvolnÃ­te, tak modernÃ­ operaÄnÃ­ systÃ©my veÅ¡kerou pamÄ›Å¥ vaÅ¡eho
spuÅ¡tÄ›nÃ©ho programu uvolnÃ­, jakmile program skonÄÃ­. Dokud vÅ¡ak program bÄ›Å¾Ã­, tak bude neuvolnÄ›nÃ¡
pamÄ›Å¥ zabÃ­rat mÃ­sto, coÅ¾ mÅ¯Å¾e zpÅ¯sobovat problÃ©my.</p>
</blockquote>
<h1><a class="header" href="#galerie-projektÅ¯" id="galerie-projektÅ¯">Galerie projektÅ¯</a></h1>
<p>Zde naleznete vybranÃ© projekty od studentÅ¯ minulÃ½ch roÄnÃ­kÅ¯ <code>UPR</code>:</p>
<ul>
<li><a href="galerie_projektu/2020.html">RoÄnÃ­k 2020/2021</a></li>
</ul>
<h1><a class="header" href="#galerie-projektÅ¯-20202021" id="galerie-projektÅ¯-20202021">Galerie projektÅ¯ 2020/2021</a></h1>
<p>Galerie vybranÃ½ch projektÅ¯ od studentÅ¯ z roÄnÃ­ku <code>2020/2021</code>.</p>
<h2><a class="header" href="#fruit-ninja" id="fruit-ninja">Fruit Ninja</a></h2>
<p><a href="galerie_projektu/../c/aplikovane_ulohy/sdl.html">SDL</a> + <a href="galerie_projektu/../c/aplikovane_ulohy/chipmunk.html">Chipmunk</a></p>
<p><video width="500" src="../static/projekty_2020/projekt1.webm" controls></video></p>
<h2><a class="header" href="#angry-birds" id="angry-birds">Angry Birds</a></h2>
<p><a href="galerie_projektu/../c/aplikovane_ulohy/sdl.html">SDL</a> + <a href="galerie_projektu/../c/aplikovane_ulohy/chipmunk.html">Chipmunk</a></p>
<p><video width="500" src="../static/projekty_2020/projekt2.webm" controls></video></p>
<h2><a class="header" href="#pacman" id="pacman">PacMan</a></h2>
<p><a href="galerie_projektu/../c/aplikovane_ulohy/sdl.html">SDL</a></p>
<p><video width="500" src="../static/projekty_2020/projekt3.webm" controls></video></p>
<h2><a class="header" href="#space-invaders" id="space-invaders">Space Invaders</a></h2>
<p><a href="galerie_projektu/../c/aplikovane_ulohy/sdl.html">SDL</a></p>
<p><video width="500" src="../static/projekty_2020/projekt4.webm" controls></video></p>
<h2><a class="header" href="#tetris" id="tetris">Tetris</a></h2>
<p><a href="galerie_projektu/../c/aplikovane_ulohy/sdl.html">SDL</a></p>
<p><video width="500" src="../static/projekty_2020/projekt5.webm" controls></video></p>
<p><video width="500" src="../static/projekty_2020/projekt6.webm" controls></video></p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        
        <!-- Google Analytics Tag -->
        <script type="text/javascript">
            var localAddrs = ["localhost", "127.0.0.1", ""];

            // make sure we don't activate google analytics if the developer is
            // inspecting the book locally...
            if (localAddrs.indexOf(document.location.hostname) === -1) {
                (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
                (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
                m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
                })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

                ga('create', 'UA-177556287-1', 'auto');
                ga('send', 'pageview');
            }
        </script>
        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        
        <script src="ace.js" type="text/javascript" charset="utf-8"></script>
        <script src="editor.js" type="text/javascript" charset="utf-8"></script>
        <script src="mode-rust.js" type="text/javascript" charset="utf-8"></script>
        <script src="theme-dawn.js" type="text/javascript" charset="utf-8"></script>
        <script src="theme-tomorrow_night.js" type="text/javascript" charset="utf-8"></script>
        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        
        <script type="text/javascript" src="theme/mode-c_cpp.min.js"></script>
        
        <script type="text/javascript" src="theme/asciinema-player.js"></script>
        
        <script type="text/javascript" src="src/wasm/xterm.min.js"></script>
        
        <script type="text/javascript" src="src/wasm/fit.min.js"></script>
        
        <script type="text/javascript" src="src/wasm/shared.js"></script>
        
        <script type="text/javascript" src="src/wasm/web.js"></script>
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>
        
        

    </body>
</html>
