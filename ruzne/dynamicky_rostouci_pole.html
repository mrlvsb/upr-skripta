<!DOCTYPE HTML>
<html lang="cs" class="sidebar-visible no-js rust">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Dynamicky rostoucí pole - Úvod do programování</title>
        
        


        <!-- Custom HTML head -->
        <style>
.xterm {
  margin-top: 10px;
}
.content {
  overflow-y: visible !important;
}
video {
    max-width: 100%;
}
</style>
<script src="https://kelvin.cs.vsb.cz/upr/animations.js"></script>


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="../favicon.svg">
        
        
        <link rel="shortcut icon" href="../favicon.png">
        
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="../fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        
        <link rel="stylesheet" href="../theme/css/tufte.css">
        
        <link rel="stylesheet" href="../theme/asciinema-player.css">
        
        <link rel="stylesheet" href="../src/wasm/xterm.min.css">
        

        
        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "rust" : "rust";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('rust')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item "><a href="../uvod/uvod.html"><strong aria-hidden="true">1.</strong> Úvod</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../uvod/programovani.html"><strong aria-hidden="true">1.1.</strong> Programování</a></li><li class="chapter-item "><a href="../uvod/programovaci_jazyky.html"><strong aria-hidden="true">1.2.</strong> Programovací jazyky</a></li><li class="chapter-item "><a href="../uvod/jazyk_c.html"><strong aria-hidden="true">1.3.</strong> Jazyk C</a></li><li class="chapter-item "><a href="../uvod/pamet.html"><strong aria-hidden="true">1.4.</strong> Paměť</a></li></ol></li><li class="chapter-item "><a href="../prostredi/nastaveni_prostredi.html"><strong aria-hidden="true">2.</strong> Nastavení prostředí</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../prostredi/os/os.html"><strong aria-hidden="true">2.1.</strong> Operační systém</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../prostredi/os/linux.html"><strong aria-hidden="true">2.1.1.</strong> Linux</a></li><li class="chapter-item "><a href="../prostredi/os/macos.html"><strong aria-hidden="true">2.1.2.</strong> macOS</a></li></ol></li><li class="chapter-item "><a href="../prostredi/editor/editor.html"><strong aria-hidden="true">2.2.</strong> Editor</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../prostredi/editor/vscode.html"><strong aria-hidden="true">2.2.1.</strong> VS Code</a></li><li class="chapter-item "><a href="../prostredi/editor/clion.html"><strong aria-hidden="true">2.2.2.</strong> CLion</a></li></ol></li><li class="chapter-item "><a href="../prostredi/preklad_programu.html"><strong aria-hidden="true">2.3.</strong> Překlad</a></li><li class="chapter-item "><a href="../prostredi/ladeni.html"><strong aria-hidden="true">2.4.</strong> Ladění</a></li></ol></li><li class="chapter-item "><a href="../ai.html"><strong aria-hidden="true">3.</strong> Použití AI</a></li><li class="chapter-item "><a href="../c/programovani.html"><strong aria-hidden="true">4.</strong> Programování v C</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../c/syntaxe.html"><strong aria-hidden="true">4.1.</strong> Syntaxe</a></li><li class="chapter-item "><a href="../c/prikazy_vyrazy.html"><strong aria-hidden="true">4.2.</strong> Příkazy a výrazy</a></li><li class="chapter-item "><a href="../c/promenne/promenne.html"><strong aria-hidden="true">4.3.</strong> Proměnné</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../c/promenne/globalni_promenne.html"><strong aria-hidden="true">4.3.1.</strong> Globální proměnné</a></li><li class="chapter-item "><a href="../c/promenne/konstanty.html"><strong aria-hidden="true">4.3.2.</strong> Konstanty</a></li><li class="chapter-item "><a href="../c/promenne/slozeny_zapis.html"><strong aria-hidden="true">4.3.3.</strong> Složený zápis</a></li><li class="chapter-item "><a href="../c/promenne/pojmenovavani.html"><strong aria-hidden="true">4.3.4.</strong> Pojmenovávání proměnných</a></li></ol></li><li class="chapter-item "><a href="../c/datove_typy/datove_typy.html"><strong aria-hidden="true">4.4.</strong> Datové typy</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../c/datove_typy/celociselne_typy.html"><strong aria-hidden="true">4.4.1.</strong> Celočíselné typy</a></li><li class="chapter-item "><a href="../c/datove_typy/desetinne_typy.html"><strong aria-hidden="true">4.4.2.</strong> Desetinné číselné typy</a></li><li class="chapter-item "><a href="../c/datove_typy/pravdivostni_typy.html"><strong aria-hidden="true">4.4.3.</strong> Pravdivostní typy</a></li><li class="chapter-item "><a href="../c/datove_typy/konverze.html"><strong aria-hidden="true">4.4.4.</strong> Konverze</a></li></ol></li><li class="chapter-item "><a href="../c/rizeni_toku/rizeni_toku.html"><strong aria-hidden="true">4.5.</strong> Řízení toku</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../c/rizeni_toku/podminky.html"><strong aria-hidden="true">4.5.1.</strong> Podmínky</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../c/rizeni_toku/if.html"><strong aria-hidden="true">4.5.1.1.</strong> Příkaz if</a></li><li class="chapter-item "><a href="../c/rizeni_toku/switch.html"><strong aria-hidden="true">4.5.1.2.</strong> Příkaz switch</a></li><li class="chapter-item "><a href="../c/rizeni_toku/ternarni_operator.html"><strong aria-hidden="true">4.5.1.3.</strong> Ternární operátor</a></li></ol></li><li class="chapter-item "><a href="../c/rizeni_toku/cykly.html"><strong aria-hidden="true">4.5.2.</strong> Cykly</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../c/rizeni_toku/while.html"><strong aria-hidden="true">4.5.2.1.</strong> Cyklus while</a></li><li class="chapter-item "><a href="../c/rizeni_toku/for.html"><strong aria-hidden="true">4.5.2.2.</strong> Cyklus for</a></li></ol></li></ol></li><li class="chapter-item "><a href="../c/funkce/funkce.html"><strong aria-hidden="true">4.6.</strong> Funkce</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../c/funkce/rekurze.html"><strong aria-hidden="true">4.6.1.</strong> Rekurze</a></li><li class="chapter-item "><a href="../c/funkce/stdlib.html"><strong aria-hidden="true">4.6.2.</strong> Funkce standardní knihovny</a></li></ol></li><li class="chapter-item "><a href="../c/preprocesor/preprocesor.html"><strong aria-hidden="true">4.7.</strong> Preprocesor</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../c/preprocesor/vkladani_souboru.html"><strong aria-hidden="true">4.7.1.</strong> Vkládání souborů</a></li><li class="chapter-item "><a href="../c/preprocesor/makra.html"><strong aria-hidden="true">4.7.2.</strong> Makra</a></li></ol></li><li class="chapter-item "><a href="../c/prace_s_pameti/prace_s_pameti.html"><strong aria-hidden="true">4.8.</strong> Práce s pamětí</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../c/prace_s_pameti/automaticka_pamet.html"><strong aria-hidden="true">4.8.1.</strong> Automatická paměť</a></li><li class="chapter-item "><a href="../c/prace_s_pameti/ukazatele.html"><strong aria-hidden="true">4.8.2.</strong> Ukazatele</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../c/prace_s_pameti/ukazatele_na_funkce.html"><strong aria-hidden="true">4.8.2.1.</strong> Ukazatele na funkce</a></li></ol></li><li class="chapter-item "><a href="../c/prace_s_pameti/dynamicka_pamet.html"><strong aria-hidden="true">4.8.3.</strong> Dynamická paměť</a></li><li class="chapter-item "><a href="../c/prace_s_pameti/globalni_pamet.html"><strong aria-hidden="true">4.8.4.</strong> Globální paměť</a></li></ol></li><li class="chapter-item "><a href="../c/pole/pole.html"><strong aria-hidden="true">4.9.</strong> Pole</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../c/pole/staticka_pole.html"><strong aria-hidden="true">4.9.1.</strong> Statické pole</a></li><li class="chapter-item "><a href="../c/pole/dynamicka_pole.html"><strong aria-hidden="true">4.9.2.</strong> Dynamické pole</a></li><li class="chapter-item "><a href="../c/pole/vicerozmerna_pole.html"><strong aria-hidden="true">4.9.3.</strong> Vícerozměrné pole</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../c/pole/zubata_pole.html"><strong aria-hidden="true">4.9.3.1.</strong> Zubatá pole</a></li></ol></li></ol></li><li class="chapter-item "><a href="../c/text/text.html"><strong aria-hidden="true">4.10.</strong> Text</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../c/text/znaky.html"><strong aria-hidden="true">4.10.1.</strong> Znaky</a></li><li class="chapter-item "><a href="../c/text/retezce.html"><strong aria-hidden="true">4.10.2.</strong> Řetězce</a></li><li class="chapter-item "><a href="../c/text/vstupavystup.html"><strong aria-hidden="true">4.10.3.</strong> Vstup a výstup</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../c/text/vstup.html"><strong aria-hidden="true">4.10.3.1.</strong> Vstup</a></li><li class="chapter-item "><a href="../c/text/vystup.html"><strong aria-hidden="true">4.10.3.2.</strong> Výstup</a></li></ol></li></ol></li><li class="chapter-item "><a href="../c/struktury/vlastni_datove_typy.html"><strong aria-hidden="true">4.11.</strong> Vlastní datové typy</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../c/struktury/struktury.html"><strong aria-hidden="true">4.11.1.</strong> Struktury</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../c/struktury/pametova_reprezentace.html"><strong aria-hidden="true">4.11.1.1.</strong> Reprezentace v paměti</a></li></ol></li><li class="chapter-item "><a href="../c/struktury/struktury_funkce.html"><strong aria-hidden="true">4.11.2.</strong> Struktury a funkce</a></li></ol></li><li class="chapter-item "><a href="../c/soubory/soubory.html"><strong aria-hidden="true">4.12.</strong> Soubory</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../c/soubory/otevirani_souboru.html"><strong aria-hidden="true">4.12.1.</strong> Otevření souborů</a></li><li class="chapter-item "><a href="../c/soubory/prace_se_soubory.html"><strong aria-hidden="true">4.12.2.</strong> Práce se soubory</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../c/soubory/zapis_do_souboru.html"><strong aria-hidden="true">4.12.2.1.</strong> Zápis do souboru</a></li><li class="chapter-item "><a href="../c/soubory/cteni_ze_souboru.html"><strong aria-hidden="true">4.12.2.2.</strong> Čtení ze souboru</a></li></ol></li></ol></li><li class="chapter-item "><a href="../c/modularizace/modularizace.html"><strong aria-hidden="true">4.13.</strong> Modularizace</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../c/modularizace/linker.html"><strong aria-hidden="true">4.13.1.</strong> Linker</a></li><li class="chapter-item "><a href="../c/modularizace/pouzivani_kodu_z_jinych_souboru.html"><strong aria-hidden="true">4.13.2.</strong> Používání kódu z jiných souborů</a></li><li class="chapter-item "><a href="../c/modularizace/hlavickove_soubory.html"><strong aria-hidden="true">4.13.3.</strong> Hlavičkové soubory</a></li><li class="chapter-item "><a href="../c/modularizace/knihovny.html"><strong aria-hidden="true">4.13.4.</strong> Knihovny</a></li></ol></li><li class="chapter-item "><a href="../c/automatizace_prekladu.html"><strong aria-hidden="true">4.14.</strong> Automatizace překladu</a></li><li class="chapter-item "><a href="../c/aplikovane_ulohy/ulohy.html"><strong aria-hidden="true">4.15.</strong> Aplikované úlohy</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../c/aplikovane_ulohy/tga.html"><strong aria-hidden="true">4.15.1.</strong> TGA</a></li><li class="chapter-item "><a href="../c/aplikovane_ulohy/gif.html"><strong aria-hidden="true">4.15.2.</strong> GIF</a></li><li class="chapter-item "><a href="../c/aplikovane_ulohy/sdl.html"><strong aria-hidden="true">4.15.3.</strong> SDL</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../c/aplikovane_ulohy/sdl/herni_smycka.html"><strong aria-hidden="true">4.15.3.1.</strong> Herní smyčka</a></li><li class="chapter-item "><a href="../c/aplikovane_ulohy/sdl/kresleni.html"><strong aria-hidden="true">4.15.3.2.</strong> Kreslení</a></li><li class="chapter-item "><a href="../c/aplikovane_ulohy/sdl/vstup.html"><strong aria-hidden="true">4.15.3.3.</strong> Vstup</a></li></ol></li><li class="chapter-item "><a href="../c/aplikovane_ulohy/chipmunk.html"><strong aria-hidden="true">4.15.4.</strong> Chipmunk</a></li></ol></li><li class="chapter-item "><a href="../c/co_dal.html"><strong aria-hidden="true">4.16.</strong> Co dál?</a></li></ol></li><li class="chapter-item expanded "><a href="../ruzne/ruzne.html"><strong aria-hidden="true">5.</strong> Různé</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../ruzne/rozklad_problemu.html"><strong aria-hidden="true">5.1.</strong> Rozklad problému</a></li><li class="chapter-item "><a href="../ruzne/vyhodnocovani_vyrazu.html"><strong aria-hidden="true">5.2.</strong> Vyhodnocování výrazů</a></li><li class="chapter-item "><a href="../ruzne/nahodna_cisla.html"><strong aria-hidden="true">5.3.</strong> Generování náhodných čísel</a></li><li class="chapter-item expanded "><a href="../ruzne/dynamicky_rostouci_pole.html" class="active"><strong aria-hidden="true">5.4.</strong> Dynamicky rostoucí pole</a></li><li class="chapter-item "><a href="../ruzne/funkce_main.html"><strong aria-hidden="true">5.5.</strong> Funkce main</a></li><li class="chapter-item "><a href="../ruzne/parametry_prekladace.html"><strong aria-hidden="true">5.6.</strong> Parametry překladače</a></li><li class="chapter-item "><a href="../ruzne/nedefinovane_chovani.html"><strong aria-hidden="true">5.7.</strong> Nedefinované chování</a></li><li class="chapter-item "><a href="../ruzne/tahak.html"><strong aria-hidden="true">5.8.</strong> Tahák</a></li></ol></li><li class="chapter-item "><a href="../ulohy/ulohy.html"><strong aria-hidden="true">6.</strong> Úlohy</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../ulohy/promenne.html"><strong aria-hidden="true">6.1.</strong> Proměnné</a></li><li class="chapter-item "><a href="../ulohy/podminky_a_cykly.html"><strong aria-hidden="true">6.2.</strong> Podmínky a cykly</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../ulohy/kulicka.html"><strong aria-hidden="true">6.2.1.</strong> Odrážející se kulička</a></li><li class="chapter-item "><a href="../ulohy/grafy.html"><strong aria-hidden="true">6.2.2.</strong> Vykreslování grafů funkcí</a></li></ol></li><li class="chapter-item "><a href="../ulohy/funkce.html"><strong aria-hidden="true">6.3.</strong> Funkce</a></li><li class="chapter-item "><a href="../ulohy/ukazatele.html"><strong aria-hidden="true">6.4.</strong> Ukazatele</a></li><li class="chapter-item "><a href="../ulohy/pole.html"><strong aria-hidden="true">6.5.</strong> Pole</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../ulohy/pvp.html"><strong aria-hidden="true">6.5.1.</strong> PvP bitevní hra</a></li><li class="chapter-item "><a href="../ulohy/dvourozmerne_pole.html"><strong aria-hidden="true">6.5.2.</strong> Dvourozměrné pole</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../ulohy/digitalni_hodiny.html"><strong aria-hidden="true">6.5.2.1.</strong> Digitální hodiny</a></li></ol></li></ol></li><li class="chapter-item "><a href="../ulohy/text.html"><strong aria-hidden="true">6.6.</strong> Text</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../ulohy/kalkulacka.html"><strong aria-hidden="true">6.6.1.</strong> Kalkulačka</a></li><li class="chapter-item "><a href="../ulohy/strelba_na_terc.html"><strong aria-hidden="true">6.6.2.</strong> Střelba na terč</a></li><li class="chapter-item "><a href="../ulohy/cisteni_chatu.html"><strong aria-hidden="true">6.6.3.</strong> Čištění chatu</a></li><li class="chapter-item "><a href="../ulohy/brainfuck.html"><strong aria-hidden="true">6.6.4.</strong> Překladač jazyka Brainfuck</a></li></ol></li><li class="chapter-item "><a href="../ulohy/struktury.html"><strong aria-hidden="true">6.7.</strong> Struktury</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../ulohy/tga_watch.html"><strong aria-hidden="true">6.7.1.</strong> TGA hodiny</a></li><li class="chapter-item "><a href="../ulohy/letters.html"><strong aria-hidden="true">6.7.2.</strong> Létající písmenka</a></li></ol></li><li class="chapter-item "><a href="../ulohy/soubory.html"><strong aria-hidden="true">6.8.</strong> Soubory</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../ulohy/meme.html"><strong aria-hidden="true">6.8.1.</strong> Meme generátor</a></li></ol></li><li class="chapter-item "><a href="../ulohy/sdl.html"><strong aria-hidden="true">6.9.</strong> SDL</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../ulohy/snake/snake.html"><strong aria-hidden="true">6.9.1.</strong> Had</a></li></ol></li></ol></li><li class="chapter-item "><a href="../caste_chyby/caste_chyby.html"><strong aria-hidden="true">7.</strong> Časté chyby</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../caste_chyby/pametove_chyby.html"><strong aria-hidden="true">7.1.</strong> Paměťové chyby</a></li></ol></li><li class="chapter-item "><a href="../galerie_projektu/galerie_projektu.html"><strong aria-hidden="true">8.</strong> Galerie projektů</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../galerie_projektu/2020.html"><strong aria-hidden="true">8.1.</strong> 2020/2021</a></li><li class="chapter-item "><a href="../galerie_projektu/2023.html"><strong aria-hidden="true">8.2.</strong> 2023/2024</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">Úvod do programování</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        <a href="https://github.com/mrlvsb/upr-skripta" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#dynamicky-rostoucí-pole" id="dynamicky-rostoucí-pole">Dynamicky rostoucí pole</a></h1>
<p>V kapitolách o <a href="../c/pole/staticka_pole.html">statických</a> a <a href="../c/pole/dynamicka_pole.html">dynamických</a>
polích jsme si ukázali, jak můžeme vytvořit paměť pro více proměnných uložených sekvenčně za sebou
v paměti. Tato pole však měla vždy jedno omezení, protože jejich velikost se po jejich vytvoření nedala
měnit. Jakmile však naše programy začnou být složitější, budeme si určitě chtít pamatovat více hodnot
bez toho, abychom museli nutně dopředu vědět, kolik těchto hodnot bude. Například:</p>
<ul>
<li>Čteme řádky z textového souboru, a nevíme dopředu, kolik těch řádků bude.</li>
<li>Chceme projít existující pole a vytáhnout z něj pouze ty prvky, které splňují nějakou vlastnost.</li>
<li>Uživatel v naší <a href="../c/aplikovane_ulohy/sdl.html">SDL</a> aplikaci kliká na obrazovku a my chceme na každém
bodu kliknutí něco vykreslit.</li>
</ul>
<p>Proto je vhodné naučit se vytvořit pole, které můžeme postupně naplňovat, a jehož velikost se může
v čase zvětšovat. Takovému poli budeme říkat <strong>dynamicky rostoucí pole</strong> (dále pouze <em>rostoucí pole</em>).
Tato datová struktura je tak užitečná a často využívaná, že se ve spoustě programovacích jazycích
vyskytuje jako vestavěný stavební blok<sup class='margin-toggle sidenote-number'>1</sup>.</p>
<span class='sidenote'><p><sup class='number'>1</sup>C++: <a href="https://en.cppreference.com/w/cpp/container/vector">std::vector</a>, Java: <a href="https://docs.oracle.com/javase/8/docs/api/java/util/ArrayList.html">ArrayList</a>, C#: <a href="https://learn.microsoft.com/en-us/dotnet/api/system.collections.generic.list-1">List</a>, JavaScript: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array">Array</a></p>
</span>
<h2><a class="header" href="#implementace" id="implementace">Implementace</a></h2>
<p>Rostoucí pole bude muset být naalokované na haldě, protože na zásobníku bychom nebyli
schopni jeho velikost měnit, a museli bychom ji znát v době překladu, což by nám nepomohlo. Rostoucí
pole bude fungovat zhruba takto:</p>
<ol>
<li>Naalokujeme na haldě dynamické pole s nějakou počáteční velikostí.
<ul>
<li>Pole bude na začátku &quot;prázdné&quot;, tj. nebudou v něm uloženy žádné validní hodnoty, ale bude
obsahovat dostatečnou kapacitu na uložení nějakého počtu hodnot.</li>
</ul>
</li>
<li>Budeme do něj postupně přidávat prvky.</li>
<li>Jakmile bude pole zcela zaplněné, tak jej zvětšíme, abychom udělali místo pro další prvky.</li>
</ol>
<p>Zde je ukázka struktury, která bude implementovat rostoucí pole celých čísel (<code>int</code>ů):</p>
<pre><code class="language-c">typedef struct {
    int* data;
    int pocet;
    int kapacita;
} PoleIntu;
</code></pre>
<p>Pro implementaci budeme potřebovat minimálně tyto tři údaje:</p>
<ul>
<li><code>data</code> - ukazatel na data na haldě, která budou naalokovaná funkcí <a href="https://devdocs.io/c/memory/malloc"><code>malloc</code></a>.</li>
<li><code>pocet</code> - současný počet prvků v poli. Při práci s jakýmkoliv polem potřebujeme vždy vědět, kolik
prvků v něm je. Abychom si tuto informaci nemuseli pamatovat někde bokem, dáme ji přímo do struktury
rostoucího pole.</li>
<li><code>kapacita</code> - maximální počet prvků, které pole může obsahovat. Tato hodnota odpovídá tomu, pro kolik
prvků jsme vyalokovali paměť funkcí <code>malloc</code>.</li>
</ul>
<p>Nyní si ukážeme jak naimplementovat funkce, které budou s tímto polem pracovat.</p>
<h3><a class="header" href="#vytvoření-pole" id="vytvoření-pole">Vytvoření pole</a></h3>
<p>Pro vytvoření pole potřebujeme naalokovat paměť na haldě s nějakou úvodní <code>kapacitou</code>, kterou si můžeme
do funkce na vytvoření pole poslat jako argument:</p>
<pre><code class="language-c">void poleintu_vytvor(PoleIntu* pole, int kapacita) {
    // Naalokujeme pamet na halde
    pole-&gt;data = (int*) malloc(sizeof(int) * kapacita);
    // Na zacatku je pole prazdne, takze je pocet prvku 0
    pole-&gt;pocet = 0;
    // Kapacita odpovida tomu, kolik je pole schopne udrzet prvku, nez mu dojde misto
    pole-&gt;kapacita = kapacita;
}
</code></pre>
<h3><a class="header" href="#přidání-prvku-do-pole" id="přidání-prvku-do-pole">Přidání prvku do pole</a></h3>
<p>Při přidávání prvku do pole musíme daný prvek zapsat na první &quot;volné&quot; místo v poli. Na jaký index
musíme prvek zapsat?</p>
<ul>
<li>Když je pole prázdné (<code>pocet = 0</code>), tak zapíšeme nový prvek na index <code>0</code>:
<pre><code>[?, ?, ?, ?]
 ^
</code></pre>
</li>
<li>Když má pole jeden prvek (<code>pocet = 1</code>), tak zapíšeme nový prvek na index <code>1</code>:
<pre><code>[8, ?, ?, ?]
    ^
</code></pre>
</li>
<li>Když má pole dva prvky (<code>pocet = 2</code>), tak zapíšeme nový prvek na index <code>2</code>:
<pre><code>[8, 4, ?, ?]
       ^
</code></pre>
</li>
</ul>
<p>Počet prvků v poli tedy vždy přímo odpovídá indexu, na který bychom měli zapsat příští prvek.</p>
<p>Dejme tomu, že máme pole s kapacitou <code>4</code>, s dvěma prvky (<code>pocet</code> je <code>2</code>) a chceme do něj uložit
novou hodnotu <code>8</code>. Tuto hodnotu musíme zapsat na index <code>2</code>. A po zápisu prvku musíme také zvýšit
počet prvků v poli, protože jsme do pole vložili nový prvek!</p>
<pre><code>[5, 4, ?, ?]
       ^
       (pocet = 2)

[5, 4, 8, ?]
          ^
          (pocet = 3)
</code></pre>
<p>V kódu by to mohlo vypadat takto:</p>
<pre><code class="language-c">void poleintu_pridej(PoleIntu* pole, int hodnota) {
    // Zapiseme novy prvek na index dany soucasnemu poctu prvku
    pole-&gt;data[pole-&gt;pocet] = hodnota;
    // Zvysime pocet prvku o jednicku
    pole-&gt;pocet += 1;
}
</code></pre>
<h3><a class="header" href="#zvětšení-velikosti-pole" id="zvětšení-velikosti-pole">Zvětšení velikosti pole</a></h3>
<p>Nicméně to samo o sobě nestačí. Co když je totiž pole už plné? V tom případě nesmíme zapsat hodnotu
do paměti na indexu <code>pocet</code>, protože bychom zapsali data mimo validní paměť a došlo by tak k
<a href="../caste_chyby/pametove_chyby.html#segmentation-fault">paměťové chybě</a> 💣!</p>
<p>Pokud tedy dojde k situaci, že už je naše pole plné, tak jej nejprve musíme zvětšit. To můžeme udělat
následujícím postupem:</p>
<ol>
<li>Naalokujeme nové, větší pole na haldě.
<ul>
<li>Jakou velikost (kapacitu) zvolit pro nové pole? Pokud bychom zvyšovali velikost o <code>1</code>, tak budeme
muset pole zvětšovat při přidání každého prvku, což by bylo velmi neefektivní. Obvykle se kapacita
rostoucích polí zdvojnásobí, díky čehož bude velikost růst exponenciálně a my tak nebudeme muset
často velikost zvětšovat.</li>
</ul>
</li>
<li>Překopírujeme původní data ze starého pole do nového pole.</li>
<li>Uvolníme paměť starého pole.</li>
<li>Nastavíme ukazatel (<code>data</code>) na nové pole na haldě.</li>
</ol>
<p>V kódu by to mohlo vypadat např. takto:</p>
<pre><code class="language-c">// Pokud je pole plne
if (pole-&gt;pocet == pole-&gt;kapacita) {
    // Zdvojnasobime kapacitu
    pole-&gt;kapacita = pole-&gt;kapacita * 2;
    // Naalokujeme nove pole s dvojnasobnou kapacitou
    int* nove_pole = (int*) malloc(sizeof(int) * pole-&gt;kapacita);
    // Prekopirujeme hodnoty ze stareho pole do noveho
    for (int i = 0; i &lt; pole-&gt;pocet; i++) {
        nove_pole[i] = pole-&gt;data[i];
    }
    // Uvolnime pamet stareho pole
    free(pole-&gt;data);
    // Nastavime ukazatel na nove pole
    pole-&gt;data = nove_pole;
}
</code></pre>
<p>Jelikož je tato funkcionalita v jazyce <em>C</em> relativně často používaná, standardní knihovna <em>C</em> obsahuje
funkci <a href="https://devdocs.io/c/memory/realloc"><code>realloc</code></a>, která toto zvětšení pole umí udělat za nás.
Kód výše tak lze zjednodušit:</p>
<pre><code class="language-c">if (pole-&gt;pocet == pole-&gt;kapacita) {
    pole-&gt;kapacita = pole-&gt;kapacita * 2;
    pole-&gt;data = (int*) realloc(pole-&gt;data, sizeof(int) * pole-&gt;kapacita);
}
</code></pre>
<p>Kompletní kód funkce na přidání prvku do rostoucího pole naleznete níže. </p>
<h3><a class="header" href="#smazání-pole" id="smazání-pole">Smazání pole</a></h3>
<p>Nesmíme samozřejmě zapomenout ani na to po sobě uklidit. Po skončení práce s polem bychom tedy měli
jeho paměť smazat:</p>
<pre><code class="language-c">void poleintu_smaz(PoleIntu* pole) {
    free(pole-&gt;data);
}
</code></pre>
<p>Celý kód dynamicky rostoucího pole <code>int</code>ů můžete naleznout zde:</p>
<details>
<summary>Dynamicky rostoucí pole intů</summary>
<pre><code class="language-c">typedef struct {
    // Ukazatel na data na haldě
    int* data;
    // Soucasny pocet prvku v poli
    int pocet;
    // Pocet prvku, ktery lze v poli maximalne mit.
    // Maximalni hodnota, ktere muze nabyvat `pocet`.
    int kapacita;
} PoleIntu;

void poleintu_vytvor(PoleIntu* pole, int kapacita) {
    // Naalokujeme pamet na halde
    pole-&gt;data = (int*) malloc(sizeof(int) * kapacita);
    // Na zacatku je pole prazdne, takze je pocet prvku 0
    pole-&gt;pocet = 0;
    // Kapacita odpovida tomu, kolik je pole schopne udrzet prvku, nez mu dojde misto
    pole-&gt;kapacita = kapacita;
}

void poleintu_pridej(PoleIntu* pole, int hodnota) {
    // Pokud je pole plne
    if (pole-&gt;pocet == pole-&gt;kapacita) {
        // Zdvojnasobime kapacitu
        pole-&gt;kapacita = pole-&gt;kapacita * 2;
        // Naalokujeme nove pole s dvojnasobnou kapacitou a nastavime ukazatel na nove pole
        pole-&gt;data = (int*) realloc(pole-&gt;data, sizeof(int) * pole-&gt;kapacita);
    }

    // Zapiseme novy prvek na index dany soucasnemu poctu prvku
    pole-&gt;data[pole-&gt;pocet] = hodnota;
    // Zvysime pocet prvku o jednicku
    pole-&gt;pocet += 1;
}

void poleintu_smaz(PoleIntu* pole) {
    // Smazeme dynamicke pole
    free(pole-&gt;data);
}
</code></pre>
</details>
<h2><a class="header" href="#zobecnění-pro-více-datových-typů" id="zobecnění-pro-více-datových-typů">Zobecnění pro více datových typů</a></h2>
<p>Výše popsané pole je velmi užitečné, nicméně můžeme jej použít pouze s jedním datovým typem (<code>int</code>).
V našich programech si určitě budeme chtít ukládat do rostoucího pole více datových typů. Jak toho
můžeme dosáhnout?</p>
<h3><a class="header" href="#separátní-kód-pro-každý-datový-typ" id="separátní-kód-pro-každý-datový-typ">Separátní kód pro každý datový typ</a></h3>
<p>Asi nejjednodušší způsob je prostě vzít kód tohoto pole a zkopírovat jej pro každý datový typ, který
budeme chtít do pole ukládat. Takže nám vzniknou struktury <code>PoleIntu</code>, <code>PoleCharu</code>, <code>PoleBoolu</code> atd.</p>
<p>I když je tento způsob relativně jednoduchý na provedení (<code>Ctrl + C</code>, <code>Ctrl + V</code> a přejmenování názvů),
tak asi tušíte, že má řadu nevýhod. V našem programu by vznikla spousta kódu, který by byl silně
zduplikovaný a pokud bychom narazili na nějakou chybu, tak bychom ji museli opravit na více místech.
Tento opakující se kód by také pravděpodobně byl dost nepřehledný.</p>
<p>Můžeme si trochu pomoct využitím <a href="../c/preprocesor/makra.html">maker</a>:</p>
<pre><code class="language-c">#define VYTVOR_LIST(nazev, typ)\
typedef struct {\
   typ* data;\
   int pocet;\
   int kapacita;\
} nazev;

VYTVOR_LIST(PoleIntu, int)
VYTVOR_LIST(PoleFloatu, float)
</code></pre>
<p>Nicméně to má také své nevýhody (upravovat kód makra je relativně namáhavé) a pořád budeme mít separátní
datovou strukturu pro každý datový typ.</p>
<h3><a class="header" href="#pole-ukazatelů" id="pole-ukazatelů">Pole ukazatelů</a></h3>
<p>Pokud se zamyslíme nad tím, proč nemůžeme použít <code>PoleIntu</code> pro libovolný datový typ, je to způsobeno
tím, že každý prvek v tomto poli má fixní velikost (<code>sizeof(int)</code>, tedy pravděpodobně <code>4</code> byty). Do
tohoto pole tedy nemůžeme jednoduše ukládat prvky, které mají jinou velikost, což je problém.</p>
<p>Abychom tento problém obešli, můžeme vytvořit pole, jehož prvky budou mít také fixní velikost, ale
zároveň budou schopny poskytovat přístup k libovolné hodnotě libovolného datového typu. Toho můžeme
dosáhnout tak, že do pole nebudeme ukládat přímo hodnoty, které si chceme zapamatovat, ale pouze jejich
adresy. Vytvoříme tedy pole ukazatelů! Jelikož nevíme, s jakým datovým typem bude chtít uživatel toto
pole použít, tak nezvolíme pro typ ukazatele <code>int*</code> nebo např. <code>float*</code>, ale použijeme datový typ
&quot;obecného&quot; ukazatele, který prostě obsahuje adresu, ale neříká, co na dané adrese leží. Tím je typ
<code>void*</code>.</p>
<p>Strukturu pole bychom tedy mohli upravit takto:</p>
<pre><code class="language-c">typedef struct {
    void** data;
    int pocet;
    int kapacita;
} RostouciPole;
</code></pre>
<p>Předtím jsme uchovávali ukazatel, v němž byla adresa, na které ležel datový typ <code>int</code>, proto byl typ
atributu <code>data</code> <code>int*</code>. Nyní uchováváme ukazatel, v němž bude adrese, na které bude ležet datový typ
<code>void*</code>, proto bude typ atributu <code>data</code> <code>void**</code>.</p>
<p>V paměti bude tedy pole vypadat cca takto:</p>
<pre><code>// Predtim
[5, 8, 6, 4]

// Ted
 5
 ^   6
 |   ^
[|,|,|,|]
   |   |
   |   v
   |   4
   |
   ╰-&gt; 8
</code></pre>
<p>Každý prvek pole bude mít fixní velikost (<code>sizeof(void*)</code>, tedy pravděpodobně <code>8</code> bytů), a bude obsahovat
pouze adresu nějakého prvku (libovolného datového typu).</p>
<p>Když si tedy pole pamatuje adresy, odkud je vzít? Pokud bychom do pole dávali adresy např. lokálních
proměnných, tak pravděpodobně brzy narazíme na problémy:</p>
<pre><code class="language-c">RostouciPole pole;
pole_vytvor(&amp;pole, 10);
for (int i = 0; i &lt; 10; i++) {
    // Vloz do pole adresu promenne i
    pole_pridej(&amp;pole, &amp;i);
}
</code></pre>
<ol>
<li>Lokální proměnná může zaniknout dříve, než pole. V ten moment bude adresa v poli neplatná a dojde
k <a href="nedefinovane_chovani.html">nedefinovanému chování</a> 💣.</li>
<li>V případě výše si ukládáme do pole adresu té stejné proměnné, takže všechny prvky v poli budou mít
stejnou hodnotu.</li>
<li>I pokud lokální proměnná bude existovat dostatečně dlouho, a budeme do pole ukládat adresy různých
proměnných, tak pořád budeme mít problém v tom, že si budeme muset tuto proměnnou ukládat &quot;někde bokem&quot;,
protože v poli bude pouze její adresa. Tím nevyřešíme náš původní problém s pole rostoucí velikosti,
pouze jej přesuneme jinam.</li>
</ol>
<p>Z toho důvodu se nám vyplatí ukládat do pole takové adresy, jejichž životnost bude neomezená, a nebudeme
se tak muset starat o to, jestli náhodou nejsou dealokovány moc brzy. Jinak řečeno, můžeme do pole
ukládat paměť alokovanou na <a href="../c/prace_s_pameti/dynamicka_pamet.html">haldě</a>.</p>
<p>Takovéto pole by pak šlo používat např. takto:</p>
<pre><code class="language-c">RostouciPole pole;
pole_vytvor(&amp;pole, 10);

for (int i = 0; i &lt; 10; i++) {
    int* pamet = malloc(sizeof(int));
    *pamet = i + 1;
    pole_pridej(&amp;pole, pamet);
}

for (int i = 0; i &lt; 10; i++) {
    int* pamet = (int*) pole-&gt;data[i];
    printf(&quot;Prvek cislo %d: %d\n&quot;, i, *pamet);
}

pole_smaz(pole);
</code></pre>
<p>Při mazání pole bychom neměli zapomenout na uvolnění všech adres, které jsou v něm uloženy:</p>
<pre><code class="language-c">void pole_smaz(RostouciPole* pole) {
    for (int i = 0; i &lt; pole-&gt;pocet; i++) {
        free(pole-&gt;data[i]);
    }
    free(pole-&gt;data);
}
</code></pre>
<blockquote>
<p>V současné podobě lze funkci <code>pole_vloz</code> špatně použít. Pokud do ní dáme adresu, která nepochází
z funkce <code>malloc</code>, tak dojde k nedefinovanému chování při mazání pole. Zkuste navrhnout jinou verzi
funkce <code>pole_vloz</code>, která nepůjde použít špatně, a která zajistí, že paměť bude vždy vytvořena na
haldě. Můžete (musíte!) pro to změnit signaturu funkce.</p>
</blockquote>
<h4><a class="header" href="#typová-kontrola" id="typová-kontrola">Typová kontrola</a></h4>
<p>U obecného rostoucího pole je třeba dávat si velký pozor na to, že do něj budeme vkládat a poté z něj
vybírat stejné datové typy! Tím, že používáme typ <code>void*</code>, tak nás překladač nebude upozorňovat na
práci s nekompatibilními datovými typy. Pokud do pole nejprve vložíte adresu <code>int</code>u, a poté se k této
adrese budete chovat, jako by to byla adresa např. <code>float</code>u (<code>float*</code>), tak se váš program nebude
chovat správně!</p>
<p>Celý kód dynamicky rostoucího pole <code>int</code>ů můžete naleznout zde:</p>
<details>
<summary>Dynamicky rostoucí pole adres</summary>
<pre><code class="language-c">typedef struct {
    // Ukazatel na data na haldě
    void** data;
    // Soucasny pocet prvku v poli
    int pocet;
    // Pocet prvku, ktery lze v poli maximalne mit.
    // Maximalni hodnota, ktere muze nabyvat `pocet`.
    int kapacita;
} RostouciPole;

void pole_vytvor(RostouciPole* pole, int kapacita) {
    // Naalokujeme pamet na halde
    pole-&gt;data = (void**) malloc(sizeof(void*) * kapacita);
    // Na zacatku je pole prazdne, takze je pocet prvku 0
    pole-&gt;pocet = 0;
    // Kapacita odpovida tomu, kolik je pole schopne udrzet prvku, nez mu dojde misto
    pole-&gt;kapacita = kapacita;
}

void pole_pridej(RostouciPole* pole, void* adresa) {
    // Pokud je pole plne
    if (pole-&gt;pocet == pole-&gt;kapacita) {
        // Zdvojnasobime kapacitu
        pole-&gt;kapacita = pole-&gt;kapacita * 2;
        // Naalokujeme nove pole s dvojnasobnou kapacitou a nastavime ukazatel na nove pole
        pole-&gt;data = (void**) realloc(pole-&gt;data, sizeof(void*) * pole-&gt;kapacita);
    }

    // Zapiseme novy prvek na index dany soucasnemu poctu prvku
    pole-&gt;data[pole-&gt;pocet] = adresa;
    // Zvysime pocet prvku o jednicku
    pole-&gt;pocet += 1;
}

void pole_smaz(RostouciPole* pole) {
    for (int i = 0; i &lt; pole-&gt;pocet; i++) {
        free(pole-&gt;data[i]);
    }
    free(pole-&gt;data);
}
</code></pre>
</details>
<h3><a class="header" href="#pole-bytů" id="pole-bytů">Pole bytů</a></h3>
<p>Pole ukazatelů je relativně jednoduché na použití, ale má také nevýhody, hlavně co se týče plýtvání
pamětí, protože musíme všechny hodnoty alokovat na haldě, a také s tím související neefektivitou.</p>
<p>Rostoucí pole můžeme navrhnout ještě jinak, pokud se k němu budeme chovat v podstatě jako k poli bytů,
do kterých budeme byte po bytu kopírovat hodnoty, které v něm chceme ukládat. V této variantě bychom
si ve struktuře ukládali pole bytů (znaků), a také velikost datového typu, který chceme do pole ukládat.</p>
<pre><code class="language-c">typedef struct {
    // Pole bytů/znaků
    char* data;
    // Velikost datového typu
    int velikost_prvku;
    int pocet;
    int kapacita;
} RostouciPole;
</code></pre>
<p>Při vkládání nového prvku pak stačí jeho byty nakopírovat do našeho pole, a při získávání prvku zase
byty zpět vykopírovat na adresu, kterou poskytne uživatel:</p>
<pre><code class="language-c">void pole_pridej(RostouciPole* pole, void* adresa) {
    if (pole-&gt;pocet == pole-&gt;kapacita) { /* zvetseni pole */ }

    // Vypocteme cilovou adresu, která bude na &quot;indexu&quot; `pocet` * `velikost_prvku`
    void* cil = pole-&gt;data + (pole-&gt;pocet * pole-&gt;velikost_prvku);
    // Zapiseme na danou adresu vsechny byty nasi vkladane hodnoty
    memcpy(cil, adresa, pole-&gt;velikost_prvku);
}

void pole_vrat(RostouciPole* pole, int index, void* adresa) {
    // Vypocteme cilovou adresu, která bude na &quot;indexu&quot; `index` * `velikost_prvku`
    void* zdroj = pole-&gt;data + (indexu * pole-&gt;velikost_prvku);
    // Zapiseme na predanou adresu vsechny byty nasi ziskavane hodnoty
    memcpy(adresa, zdroj, pole-&gt;velikost_prvku);
}
</code></pre>
<p>Aby toto řešení bylo plně korektní, museli bychom implementaci ještě rozšířit tak, aby brala v potaz
<a href="../c/struktury/pametova_reprezentace.html#zarovn%C3%A1n%C3%AD">zarovnání</a> daného datového typu, jinak by se mohlo
stát, že bude vložená hodnota v poli ležet na nezarovnané adrese.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                            <a rel="prev" href="../ruzne/nahodna_cisla.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        

                        
                            <a rel="next" href="../ruzne/funkce_main.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                    <a rel="prev" href="../ruzne/nahodna_cisla.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a rel="next" href="../ruzne/funkce_main.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                
            </nav>

        </div>

        

        
        <!-- Google Analytics Tag -->
        <script type="text/javascript">
            var localAddrs = ["localhost", "127.0.0.1", ""];

            // make sure we don't activate google analytics if the developer is
            // inspecting the book locally...
            if (localAddrs.indexOf(document.location.hostname) === -1) {
                (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
                (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
                m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
                })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

                ga('create', 'UA-177556287-1', 'auto');
                ga('send', 'pageview');
            }
        </script>
        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        
        <script src="../ace.js" type="text/javascript" charset="utf-8"></script>
        <script src="../editor.js" type="text/javascript" charset="utf-8"></script>
        <script src="../mode-rust.js" type="text/javascript" charset="utf-8"></script>
        <script src="../theme-dawn.js" type="text/javascript" charset="utf-8"></script>
        <script src="../theme-tomorrow_night.js" type="text/javascript" charset="utf-8"></script>
        

        
        <script src="../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        
        <script type="text/javascript" src="../theme/mode-c_cpp.min.js"></script>
        
        <script type="text/javascript" src="../theme/asciinema-player.js"></script>
        
        <script type="text/javascript" src="../src/wasm/xterm.min.js"></script>
        
        <script type="text/javascript" src="../src/wasm/fit.min.js"></script>
        
        <script type="text/javascript" src="../src/wasm/shared.js"></script>
        
        <script type="text/javascript" src="../src/wasm/web.js"></script>
        

        

    </body>
</html>
